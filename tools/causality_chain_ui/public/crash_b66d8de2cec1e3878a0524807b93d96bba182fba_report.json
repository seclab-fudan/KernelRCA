{
    "report": "https://syzkaller.appspot.com/bug?id=b66d8de2cec1e3878a0524807b93d96bba182fba",
    "title": "general protection fault in j1939_netdev_notify (2)",
    "call": {
        "4226": {
            "name": "+0x1c",
            "parent_idx": 4224,
            "source_line": [
                {
                    "file": "net/can/j1939/main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/can/j1939/main.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n219",
                    "code": [
                        "/* get pointer to priv without increasing ref counter */",
                        "static inline struct j1939_priv *j1939_ndev_to_priv(struct net_device *ndev)",
                        "{",
                        "\tstruct can_ml_priv *can_ml_priv = ndev->ml_priv;",
                        "",
                        "\tif (!can_ml_priv)",
                        "\t\treturn NULL;",
                        "",
                        "\treturn can_ml_priv->j1939_priv;",
                        "}"
                    ],
                    "start": 211,
                    "highlight": 219
                },
                {
                    "file": "net/can/j1939/main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/can/j1939/main.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n231",
                    "code": [
                        "static struct j1939_priv *j1939_priv_get_by_ndev_locked(struct net_device *ndev)",
                        "{",
                        "\tstruct j1939_priv *priv;",
                        "",
                        "\tlockdep_assert_held(&j1939_netdev_lock);",
                        "",
                        "\tif (ndev->type != ARPHRD_CAN)",
                        "\t\treturn NULL;",
                        "",
                        "\tpriv = j1939_ndev_to_priv(ndev);",
                        "\tif (priv)",
                        "\t\tj1939_priv_get(priv);",
                        "",
                        "\treturn priv;",
                        "}"
                    ],
                    "start": 222,
                    "highlight": 231
                }
            ],
            "ins_idx": 41,
            "addr": "0xffffffff81a080ac"
        },
        "4224": {
            "name": "j1939_priv_get_by_ndev_locked",
            "parent_idx": 4221,
            "source_line": [
                {
                    "file": "net/can/j1939/main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/can/j1939/main.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n243",
                    "code": [
                        "static struct j1939_priv *j1939_priv_get_by_ndev(struct net_device *ndev)",
                        "{",
                        "\tstruct j1939_priv *priv;",
                        "",
                        "\tspin_lock(&j1939_netdev_lock);",
                        "\tpriv = j1939_priv_get_by_ndev_locked(ndev);",
                        "\tspin_unlock(&j1939_netdev_lock);",
                        "",
                        "\treturn priv;",
                        "}"
                    ],
                    "start": 238,
                    "highlight": 243
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81a080e3"
        },
        "4221": {
            "name": "j1939_priv_get_by_ndev",
            "parent_idx": 4218,
            "source_line": [
                {
                    "file": "net/can/j1939/main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/can/j1939/main.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n353",
                    "code": [
                        "static int j1939_netdev_notify(struct notifier_block *nb,",
                        "\t\t\t       unsigned long msg, void *data)",
                        "{",
                        "\tstruct net_device *ndev = netdev_notifier_info_to_dev(data);",
                        "\tstruct j1939_priv *priv;",
                        "",
                        "\tpriv = j1939_priv_get_by_ndev(ndev);",
                        "\tif (!priv)",
                        "\t\tgoto notify_done;",
                        "",
                        "\tif (ndev->type != ARPHRD_CAN)",
                        "\t\tgoto notify_put;",
                        "",
                        "\tswitch (msg) {",
                        "\tcase NETDEV_DOWN:",
                        "\t\tj1939_cancel_active_session(priv, NULL);",
                        "\t\tj1939_sk_netdev_event_netdown(priv);",
                        "\t\tj1939_ecu_unmap_all(priv);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "notify_put:",
                        "\tj1939_priv_put(priv);",
                        "",
                        "notify_done:",
                        "\treturn NOTIFY_DONE;",
                        "}"
                    ],
                    "start": 347,
                    "highlight": 353
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81a0810d"
        },
        "4218": {
            "name": "j1939_netdev_notify(indirect)",
            "parent_idx": 3068,
            "source_line": [
                {
                    "file": "kernel/notifier.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/notifier.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n83",
                    "code": [
                        "/**",
                        " * notifier_call_chain - Informs the registered notifiers about an event.",
                        " *\t@nl:\t\tPointer to head of the blocking notifier chain",
                        " *\t@val:\t\tValue passed unmodified to notifier function",
                        " *\t@v:\t\tPointer passed unmodified to notifier function",
                        " *\t@nr_to_call:\tNumber of notifier functions to be called. Don't care",
                        " *\t\t\tvalue of this parameter is -1.",
                        " *\t@nr_calls:\tRecords the number of notifications sent. Don't care",
                        " *\t\t\tvalue of this field is NULL.",
                        " *\t@returns:\tnotifier_call_chain returns the value returned by the",
                        " *\t\t\tlast notifier function called.",
                        " */",
                        "static int notifier_call_chain(struct notifier_block **nl,",
                        "\t\t\t       unsigned long val, void *v,",
                        "\t\t\t       int nr_to_call, int *nr_calls)",
                        "{",
                        "\tint ret = NOTIFY_DONE;",
                        "\tstruct notifier_block *nb, *next_nb;",
                        "",
                        "\tnb = rcu_dereference_raw(*nl);",
                        "",
                        "\twhile (nb && nr_to_call) {",
                        "\t\tnext_nb = rcu_dereference_raw(nb->next);",
                        "",
                        "#ifdef CONFIG_DEBUG_NOTIFIERS",
                        "\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {",
                        "\t\t\tWARN(1, \"Invalid notifier called!\");",
                        "\t\t\tnb = next_nb;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "#endif",
                        "\t\tret = nb->notifier_call(nb, val, v);",
                        "",
                        "\t\tif (nr_calls)",
                        "\t\t\t(*nr_calls)++;",
                        "",
                        "\t\tif (ret & NOTIFY_STOP_MASK)",
                        "\t\t\tbreak;",
                        "\t\tnb = next_nb;",
                        "\t\tnr_to_call--;",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 52,
                    "highlight": 83
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8108693d"
        },
        "3068": {
            "name": "call_netdevice_notifiers_info",
            "parent_idx": 3064,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n2034",
                    "code": [
                        "static int call_netdevice_notifiers_extack(unsigned long val,",
                        "\t\t\t\t\t   struct net_device *dev,",
                        "\t\t\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct netdev_notifier_info info = {",
                        "\t\t.dev = dev,",
                        "\t\t.extack = extack,",
                        "\t};",
                        "",
                        "\treturn call_netdevice_notifiers_info(val, &info);",
                        "}"
                    ],
                    "start": 2025,
                    "highlight": 2034
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81889ed0"
        },
        "3064": {
            "name": "call_netdevice_notifiers",
            "parent_idx": 3040,
            "source_line": [
                {
                    "file": "drivers/net/tun.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/tun.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n3093",
                    "code": [
                        "static long __tun_chr_ioctl(struct file *file, unsigned int cmd,",
                        "\t\t\t    unsigned long arg, int ifreq_len)",
                        "{",
                        "\tstruct tun_file *tfile = file->private_data;",
                        "\tstruct net *net = sock_net(&tfile->sk);",
                        "\tstruct tun_struct *tun;",
                        "\tvoid __user* argp = (void __user*)arg;",
                        "\tunsigned int ifindex, carrier;",
                        "\tstruct ifreq ifr;",
                        "\tkuid_t owner;",
                        "\tkgid_t group;",
                        "\tint sndbuf;",
                        "\tint vnet_hdr_sz;",
                        "\tint le;",
                        "\tint ret;",
                        "\tbool do_notify = false;",
                        "",
                        "\tif (cmd == TUNSETIFF || cmd == TUNSETQUEUE ||",
                        "\t    (_IOC_TYPE(cmd) == SOCK_IOC_TYPE && cmd != SIOCGSKNS)) {",
                        "\t\tif (copy_from_user(&ifr, argp, ifreq_len))",
                        "\t\t\treturn -EFAULT;",
                        "\t} else {",
                        "\t\tmemset(&ifr, 0, sizeof(ifr));",
                        "\t}",
                        "\tif (cmd == TUNGETFEATURES) {",
                        "\t\t/* Currently this just means: \"what IFF flags are valid?\".",
                        "\t\t * This is needed because we never checked for invalid flags on",
                        "\t\t * TUNSETIFF.",
                        "\t\t */",
                        "\t\treturn put_user(IFF_TUN | IFF_TAP | TUN_FEATURES,",
                        "\t\t\t\t(unsigned int __user*)argp);",
                        "\t} else if (cmd == TUNSETQUEUE) {",
                        "\t\treturn tun_set_queue(file, &ifr);",
                        "\t} else if (cmd == SIOCGSKNS) {",
                        "\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))",
                        "\t\t\treturn -EPERM;",
                        "\t\treturn open_related_ns(&net->ns, get_net_ns);",
                        "\t}",
                        "",
                        "\tret = 0;",
                        "\trtnl_lock();",
                        "",
                        "\ttun = tun_get(tfile);",
                        "\tif (cmd == TUNSETIFF) {",
                        "\t\tret = -EEXIST;",
                        "\t\tif (tun)",
                        "\t\t\tgoto unlock;",
                        "",
                        "\t\tifr.ifr_name[IFNAMSIZ-1] = '\\0';",
                        "",
                        "\t\tret = tun_set_iff(net, file, &ifr);",
                        "",
                        "\t\tif (ret)",
                        "\t\t\tgoto unlock;",
                        "",
                        "\t\tif (copy_to_user(argp, &ifr, ifreq_len))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tgoto unlock;",
                        "\t}",
                        "\tif (cmd == TUNSETIFINDEX) {",
                        "\t\tret = -EPERM;",
                        "\t\tif (tun)",
                        "\t\t\tgoto unlock;",
                        "",
                        "\t\tret = -EFAULT;",
                        "\t\tif (copy_from_user(&ifindex, argp, sizeof(ifindex)))",
                        "\t\t\tgoto unlock;",
                        "",
                        "\t\tret = 0;",
                        "\t\ttfile->ifindex = ifindex;",
                        "\t\tgoto unlock;",
                        "\t}",
                        "",
                        "\tret = -EBADFD;",
                        "\tif (!tun)",
                        "\t\tgoto unlock;",
                        "",
                        "\tnetif_info(tun, drv, tun->dev, \"tun_chr_ioctl cmd %u\\n\", cmd);",
                        "",
                        "\tnet = dev_net(tun->dev);",
                        "\tret = 0;",
                        "\tswitch (cmd) {",
                        "\tcase TUNGETIFF:",
                        "\t\ttun_get_iff(tun, &ifr);",
                        "",
                        "\t\tif (tfile->detached)",
                        "\t\t\tifr.ifr_flags |= IFF_DETACH_QUEUE;",
                        "\t\tif (!tfile->socket.sk->sk_filter)",
                        "\t\t\tifr.ifr_flags |= IFF_NOFILTER;",
                        "",
                        "\t\tif (copy_to_user(argp, &ifr, ifreq_len))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETNOCSUM:",
                        "\t\t/* Disable/Enable checksum */",
                        "",
                        "\t\t/* [unimplemented] */",
                        "\t\tnetif_info(tun, drv, tun->dev, \"ignored: set checksum %s\\n\",",
                        "\t\t\t   arg ? \"disabled\" : \"enabled\");",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETPERSIST:",
                        "\t\t/* Disable/Enable persist mode. Keep an extra reference to the",
                        "\t\t * module to prevent the module being unprobed.",
                        "\t\t */",
                        "\t\tif (arg && !(tun->flags & IFF_PERSIST)) {",
                        "\t\t\ttun->flags |= IFF_PERSIST;",
                        "\t\t\t__module_get(THIS_MODULE);",
                        "\t\t\tdo_notify = true;",
                        "\t\t}",
                        "\t\tif (!arg && (tun->flags & IFF_PERSIST)) {",
                        "\t\t\ttun->flags &= ~IFF_PERSIST;",
                        "\t\t\tmodule_put(THIS_MODULE);",
                        "\t\t\tdo_notify = true;",
                        "\t\t}",
                        "",
                        "\t\tnetif_info(tun, drv, tun->dev, \"persist %s\\n\",",
                        "\t\t\t   arg ? \"enabled\" : \"disabled\");",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETOWNER:",
                        "\t\t/* Set owner of the device */",
                        "\t\towner = make_kuid(current_user_ns(), arg);",
                        "\t\tif (!uid_valid(owner)) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\ttun->owner = owner;",
                        "\t\tdo_notify = true;",
                        "\t\tnetif_info(tun, drv, tun->dev, \"owner set to %u\\n\",",
                        "\t\t\t   from_kuid(&init_user_ns, tun->owner));",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETGROUP:",
                        "\t\t/* Set group of the device */",
                        "\t\tgroup = make_kgid(current_user_ns(), arg);",
                        "\t\tif (!gid_valid(group)) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\ttun->group = group;",
                        "\t\tdo_notify = true;",
                        "\t\tnetif_info(tun, drv, tun->dev, \"group set to %u\\n\",",
                        "\t\t\t   from_kgid(&init_user_ns, tun->group));",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETLINK:",
                        "\t\t/* Only allow setting the type when the interface is down */",
                        "\t\tif (tun->dev->flags & IFF_UP) {",
                        "\t\t\tnetif_info(tun, drv, tun->dev,",
                        "\t\t\t\t   \"Linktype set failed because interface is up\\n\");",
                        "\t\t\tret = -EBUSY;",
                        "\t\t} else {",
                        "\t\t\tret = call_netdevice_notifiers(NETDEV_PRE_TYPE_CHANGE,",
                        "\t\t\t\t\t\t       tun->dev);",
                        "\t\t\tret = notifier_to_errno(ret);",
                        "\t\t\tif (ret) {",
                        "\t\t\t\tnetif_info(tun, drv, tun->dev,",
                        "\t\t\t\t\t   \"Refused to change device type\\n\");",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\ttun->dev->type = (int) arg;",
                        "\t\t\tnetif_info(tun, drv, tun->dev, \"linktype set to %d\\n\",",
                        "\t\t\t\t   tun->dev->type);",
                        "\t\t\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE,",
                        "\t\t\t\t\t\t tun->dev);",
                        "\t\t}",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETDEBUG:",
                        "\t\ttun->msg_enable = (u32)arg;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETOFFLOAD:",
                        "\t\tret = set_offload(tun, arg);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETTXFILTER:",
                        "\t\t/* Can be set only for TAPs */",
                        "\t\tret = -EINVAL;",
                        "\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)",
                        "\t\t\tbreak;",
                        "\t\tret = update_filter(&tun->txflt, (void __user *)arg);",
                        "\t\tbreak;",
                        "",
                        "\tcase SIOCGIFHWADDR:",
                        "\t\t/* Get hw address */",
                        "\t\tmemcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);",
                        "\t\tifr.ifr_hwaddr.sa_family = tun->dev->type;",
                        "\t\tif (copy_to_user(argp, &ifr, ifreq_len))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "",
                        "\tcase SIOCSIFHWADDR:",
                        "\t\t/* Set hw address */",
                        "\t\tret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr, NULL);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETSNDBUF:",
                        "\t\tsndbuf = tfile->socket.sk->sk_sndbuf;",
                        "\t\tif (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETSNDBUF:",
                        "\t\tif (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {",
                        "\t\t\tret = -EFAULT;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (sndbuf <= 0) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\ttun->sndbuf = sndbuf;",
                        "\t\ttun_set_sndbuf(tun);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETVNETHDRSZ:",
                        "\t\tvnet_hdr_sz = tun->vnet_hdr_sz;",
                        "\t\tif (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETVNETHDRSZ:",
                        "\t\tif (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {",
                        "\t\t\tret = -EFAULT;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\ttun->vnet_hdr_sz = vnet_hdr_sz;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETVNETLE:",
                        "\t\tle = !!(tun->flags & TUN_VNET_LE);",
                        "\t\tif (put_user(le, (int __user *)argp))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETVNETLE:",
                        "\t\tif (get_user(le, (int __user *)argp)) {",
                        "\t\t\tret = -EFAULT;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (le)",
                        "\t\t\ttun->flags |= TUN_VNET_LE;",
                        "\t\telse",
                        "\t\t\ttun->flags &= ~TUN_VNET_LE;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETVNETBE:",
                        "\t\tret = tun_get_vnet_be(tun, argp);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETVNETBE:",
                        "\t\tret = tun_set_vnet_be(tun, argp);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNATTACHFILTER:",
                        "\t\t/* Can be set only for TAPs */",
                        "\t\tret = -EINVAL;",
                        "\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)",
                        "\t\t\tbreak;",
                        "\t\tret = -EFAULT;",
                        "\t\tif (copy_from_user(&tun->fprog, argp, sizeof(tun->fprog)))",
                        "\t\t\tbreak;",
                        "",
                        "\t\tret = tun_attach_filter(tun);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNDETACHFILTER:",
                        "\t\t/* Can be set only for TAPs */",
                        "\t\tret = -EINVAL;",
                        "\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)",
                        "\t\t\tbreak;",
                        "\t\tret = 0;",
                        "\t\ttun_detach_filter(tun, tun->numqueues);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETFILTER:",
                        "\t\tret = -EINVAL;",
                        "\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)",
                        "\t\t\tbreak;",
                        "\t\tret = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &tun->fprog, sizeof(tun->fprog)))",
                        "\t\t\tbreak;",
                        "\t\tret = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETSTEERINGEBPF:",
                        "\t\tret = tun_set_ebpf(tun, &tun->steering_prog, argp);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETFILTEREBPF:",
                        "\t\tret = tun_set_ebpf(tun, &tun->filter_prog, argp);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETCARRIER:",
                        "\t\tret = -EFAULT;",
                        "\t\tif (copy_from_user(&carrier, argp, sizeof(carrier)))",
                        "\t\t\tgoto unlock;",
                        "",
                        "\t\tret = tun_net_change_carrier(tun->dev, (bool)carrier);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETDEVNETNS:",
                        "\t\tret = -EPERM;",
                        "\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))",
                        "\t\t\tgoto unlock;",
                        "\t\tret = open_related_ns(&net->ns, get_net_ns);",
                        "\t\tbreak;",
                        "",
                        "\tdefault:",
                        "\t\tret = -EINVAL;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tif (do_notify)",
                        "\t\tnetdev_state_change(tun->dev);",
                        "",
                        "unlock:",
                        "\trtnl_unlock();",
                        "\tif (tun)",
                        "\t\ttun_put(tun);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2928,
                    "highlight": 3093
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816c3502"
        },
        "3040": {
            "name": "tun_chr_ioctl(indirect)",
            "parent_idx": 3039,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n48",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 30,
                    "highlight": 48
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811ea2ad"
        },
        "3039": {
            "name": "vfs_ioctl",
            "parent_idx": 3020,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n753",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 739,
                    "highlight": 753
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n739",
                    "code": [
                        "/*",
                        " * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.",
                        " * It's just a simple helper for sys_ioctl and compat_sys_ioctl.",
                        " *",
                        " * When you add any new common ioctls to the switches above and below,",
                        " * please ensure they have compatible arguments in compat mode.",
                        " */",
                        "static int do_vfs_ioctl(struct file *filp, unsigned int fd,",
                        "\t\t\tunsigned int cmd, unsigned long arg)",
                        "{",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tstruct inode *inode = file_inode(filp);",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIOCLEX:",
                        "\t\tset_close_on_exec(fd, 1);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONCLEX:",
                        "\t\tset_close_on_exec(fd, 0);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONBIO:",
                        "\t\treturn ioctl_fionbio(filp, argp);",
                        "",
                        "\tcase FIOASYNC:",
                        "\t\treturn ioctl_fioasync(fd, filp, argp);",
                        "",
                        "\tcase FIOQSIZE:",
                        "\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||",
                        "\t\t    S_ISLNK(inode->i_mode)) {",
                        "\t\t\tloff_t res = inode_get_bytes(inode);",
                        "\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?",
                        "\t\t\t\t\t    -EFAULT : 0;",
                        "\t\t}",
                        "",
                        "\t\treturn -ENOTTY;",
                        "",
                        "\tcase FIFREEZE:",
                        "\t\treturn ioctl_fsfreeze(filp);",
                        "",
                        "\tcase FITHAW:",
                        "\t\treturn ioctl_fsthaw(filp);",
                        "",
                        "\tcase FS_IOC_FIEMAP:",
                        "\t\treturn ioctl_fiemap(filp, argp);",
                        "",
                        "\tcase FIGETBSZ:",
                        "\t\t/* anon_bdev filesystems may not have a block size */",
                        "\t\tif (!inode->i_sb->s_blocksize)",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
                        "",
                        "\tcase FICLONE:",
                        "\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);",
                        "",
                        "\tcase FICLONERANGE:",
                        "\t\treturn ioctl_file_clone_range(filp, argp);",
                        "",
                        "\tcase FIDEDUPERANGE:",
                        "\t\treturn ioctl_file_dedupe_range(filp, argp);",
                        "",
                        "\tcase FIONREAD:",
                        "\t\tif (!S_ISREG(inode->i_mode))",
                        "\t\t\treturn vfs_ioctl(filp, cmd, arg);",
                        "",
                        "\t\treturn put_user(i_size_read(inode) - filp->f_pos,",
                        "\t\t\t\t(int __user *)argp);",
                        "",
                        "\tdefault:",
                        "\t\tif (S_ISREG(inode->i_mode))",
                        "\t\t\treturn file_ioctl(filp, cmd, argp);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn -ENOIOCTLCMD;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 660,
                    "highlight": 739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811eb1ae"
        },
        "3020": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 3017,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b73ede"
        },
        "3017": {
            "name": "do_syscall_64",
            "parent_idx": 3010,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=d635a69dd4981cc51f90293f5f64268620ed1565#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "3010": {
            "name": "177_syscall_7",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "4225": {
            "name": "+0x10",
            "parent_idx": 4224,
            "source_line": [
                {
                    "file": "net/can/j1939/main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/can/j1939/main.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n214",
                    "code": [
                        "/* get pointer to priv without increasing ref counter */",
                        "static inline struct j1939_priv *j1939_ndev_to_priv(struct net_device *ndev)",
                        "{",
                        "\tstruct can_ml_priv *can_ml_priv = ndev->ml_priv;",
                        "",
                        "\tif (!can_ml_priv)",
                        "\t\treturn NULL;",
                        "",
                        "\treturn can_ml_priv->j1939_priv;",
                        "}"
                    ],
                    "start": 211,
                    "highlight": 214
                },
                {
                    "file": "net/can/j1939/main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/can/j1939/main.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n231",
                    "code": [
                        "static struct j1939_priv *j1939_priv_get_by_ndev_locked(struct net_device *ndev)",
                        "{",
                        "\tstruct j1939_priv *priv;",
                        "",
                        "\tlockdep_assert_held(&j1939_netdev_lock);",
                        "",
                        "\tif (ndev->type != ARPHRD_CAN)",
                        "\t\treturn NULL;",
                        "",
                        "\tpriv = j1939_ndev_to_priv(ndev);",
                        "\tif (priv)",
                        "\t\tj1939_priv_get(priv);",
                        "",
                        "\treturn priv;",
                        "}"
                    ],
                    "start": 222,
                    "highlight": 231
                }
            ],
            "ins_idx": 85,
            "addr": "0xffffffff81a080a0"
        },
        "564": {
            "name": "+0x35a",
            "parent_idx": 510,
            "source_line": [
                {
                    "file": "drivers/net/tun.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/tun.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n2709",
                    "code": [
                        "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)",
                        "{",
                        "\tstruct tun_struct *tun;",
                        "\tstruct tun_file *tfile = file->private_data;",
                        "\tstruct net_device *dev;",
                        "\tint err;",
                        "",
                        "\tif (tfile->detached)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif ((ifr->ifr_flags & IFF_NAPI_FRAGS)) {",
                        "\t\tif (!capable(CAP_NET_ADMIN))",
                        "\t\t\treturn -EPERM;",
                        "",
                        "\t\tif (!(ifr->ifr_flags & IFF_NAPI) ||",
                        "\t\t    (ifr->ifr_flags & TUN_TYPE_MASK) != IFF_TAP)",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tdev = __dev_get_by_name(net, ifr->ifr_name);",
                        "\tif (dev) {",
                        "\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)",
                        "\t\t\treturn -EBUSY;",
                        "\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)",
                        "\t\t\ttun = netdev_priv(dev);",
                        "\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)",
                        "\t\t\ttun = netdev_priv(dev);",
                        "\t\telse",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=",
                        "\t\t    !!(tun->flags & IFF_MULTI_QUEUE))",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\tif (tun_not_capable(tun))",
                        "\t\t\treturn -EPERM;",
                        "\t\terr = security_tun_dev_open(tun->security);",
                        "\t\tif (err < 0)",
                        "\t\t\treturn err;",
                        "",
                        "\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER,",
                        "\t\t\t\t ifr->ifr_flags & IFF_NAPI,",
                        "\t\t\t\t ifr->ifr_flags & IFF_NAPI_FRAGS, true);",
                        "\t\tif (err < 0)",
                        "\t\t\treturn err;",
                        "",
                        "\t\tif (tun->flags & IFF_MULTI_QUEUE &&",
                        "\t\t    (tun->numqueues + tun->numdisabled > 1)) {",
                        "\t\t\t/* One or more queue has already been attached, no need",
                        "\t\t\t * to initialize the device again.",
                        "\t\t\t */",
                        "\t\t\tnetdev_state_change(dev);",
                        "\t\t\treturn 0;",
                        "\t\t}",
                        "",
                        "\t\ttun->flags = (tun->flags & ~TUN_FEATURES) |",
                        "\t\t\t      (ifr->ifr_flags & TUN_FEATURES);",
                        "",
                        "\t\tnetdev_state_change(dev);",
                        "\t} else {",
                        "\t\tchar *name;",
                        "\t\tunsigned long flags = 0;",
                        "\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?",
                        "\t\t\t     MAX_TAP_QUEUES : 1;",
                        "",
                        "\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))",
                        "\t\t\treturn -EPERM;",
                        "\t\terr = security_tun_dev_create();",
                        "\t\tif (err < 0)",
                        "\t\t\treturn err;",
                        "",
                        "\t\t/* Set dev type */",
                        "\t\tif (ifr->ifr_flags & IFF_TUN) {",
                        "\t\t\t/* TUN device */",
                        "\t\t\tflags |= IFF_TUN;",
                        "\t\t\tname = \"tun%d\";",
                        "\t\t} else if (ifr->ifr_flags & IFF_TAP) {",
                        "\t\t\t/* TAP device */",
                        "\t\t\tflags |= IFF_TAP;",
                        "\t\t\tname = \"tap%d\";",
                        "\t\t} else",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\tif (*ifr->ifr_name)",
                        "\t\t\tname = ifr->ifr_name;",
                        "",
                        "\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,",
                        "\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,",
                        "\t\t\t\t       queues);",
                        "",
                        "\t\tif (!dev)",
                        "\t\t\treturn -ENOMEM;",
                        "",
                        "\t\tdev_net_set(dev, net);",
                        "\t\tdev->rtnl_link_ops = &tun_link_ops;",
                        "\t\tdev->ifindex = tfile->ifindex;",
                        "\t\tdev->sysfs_groups[0] = &tun_attr_group;",
                        "",
                        "\t\ttun = netdev_priv(dev);",
                        "\t\ttun->dev = dev;",
                        "\t\ttun->flags = flags;",
                        "\t\ttun->txflt.count = 0;",
                        "\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);",
                        "",
                        "\t\ttun->align = NET_SKB_PAD;",
                        "\t\ttun->filter_attached = false;",
                        "\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;",
                        "\t\ttun->rx_batched = 0;",
                        "\t\tRCU_INIT_POINTER(tun->steering_prog, NULL);",
                        "",
                        "\t\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);",
                        "\t\tif (!dev->tstats) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto err_free_dev;",
                        "\t\t}",
                        "",
                        "\t\tspin_lock_init(&tun->lock);",
                        "",
                        "\t\terr = security_tun_dev_alloc_security(&tun->security);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err_free_stat;",
                        "",
                        "\t\ttun_net_init(dev);",
                        "\t\ttun_flow_init(tun);",
                        "",
                        "\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |",
                        "\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |",
                        "\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;",
                        "\t\tdev->features = dev->hw_features | NETIF_F_LLTX;",
                        "\t\tdev->vlan_features = dev->features &",
                        "\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |",
                        "\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);",
                        "",
                        "\t\ttun->flags = (tun->flags & ~TUN_FEATURES) |",
                        "\t\t\t      (ifr->ifr_flags & TUN_FEATURES);",
                        "",
                        "\t\tINIT_LIST_HEAD(&tun->disabled);",
                        "\t\terr = tun_attach(tun, file, false, ifr->ifr_flags & IFF_NAPI,",
                        "\t\t\t\t ifr->ifr_flags & IFF_NAPI_FRAGS, false);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err_free_flow;",
                        "",
                        "\t\terr = register_netdevice(tun->dev);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err_detach;",
                        "\t\t/* free_netdev() won't check refcnt, to aovid race",
                        "\t\t * with dev_put() we need publish tun after registration.",
                        "\t\t */",
                        "\t\trcu_assign_pointer(tfile->tun, tun);",
                        "\t}",
                        "",
                        "\tnetif_carrier_on(tun->dev);",
                        "",
                        "\t/* Make sure persistent devices do not get stuck in",
                        "\t * xoff state.",
                        "\t */",
                        "\tif (netif_running(tun->dev))",
                        "\t\tnetif_tx_wake_all_queues(tun->dev);",
                        "",
                        "\tstrcpy(ifr->ifr_name, tun->dev->name);",
                        "\treturn 0;",
                        "",
                        "err_detach:",
                        "\ttun_detach_all(dev);",
                        "\t/* We are here because register_netdevice() has failed.",
                        "\t * If register_netdevice() already called tun_free_netdev()",
                        "\t * while dealing with the error, dev->stats has been cleared.",
                        "\t */",
                        "\tif (!dev->tstats)",
                        "\t\tgoto err_free_dev;",
                        "",
                        "err_free_flow:",
                        "\ttun_flow_uninit(tun);",
                        "\tsecurity_tun_dev_free_security(tun->security);",
                        "err_free_stat:",
                        "\tfree_percpu(dev->tstats);",
                        "err_free_dev:",
                        "\tfree_netdev(dev);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2599,
                    "highlight": 2709
                }
            ],
            "ins_idx": 130,
            "addr": "0xffffffff816c1a9a"
        },
        "510": {
            "name": "tun_set_iff",
            "parent_idx": 495,
            "source_line": [
                {
                    "file": "drivers/net/tun.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/tun.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n2978",
                    "code": [
                        "static long __tun_chr_ioctl(struct file *file, unsigned int cmd,",
                        "\t\t\t    unsigned long arg, int ifreq_len)",
                        "{",
                        "\tstruct tun_file *tfile = file->private_data;",
                        "\tstruct net *net = sock_net(&tfile->sk);",
                        "\tstruct tun_struct *tun;",
                        "\tvoid __user* argp = (void __user*)arg;",
                        "\tunsigned int ifindex, carrier;",
                        "\tstruct ifreq ifr;",
                        "\tkuid_t owner;",
                        "\tkgid_t group;",
                        "\tint sndbuf;",
                        "\tint vnet_hdr_sz;",
                        "\tint le;",
                        "\tint ret;",
                        "\tbool do_notify = false;",
                        "",
                        "\tif (cmd == TUNSETIFF || cmd == TUNSETQUEUE ||",
                        "\t    (_IOC_TYPE(cmd) == SOCK_IOC_TYPE && cmd != SIOCGSKNS)) {",
                        "\t\tif (copy_from_user(&ifr, argp, ifreq_len))",
                        "\t\t\treturn -EFAULT;",
                        "\t} else {",
                        "\t\tmemset(&ifr, 0, sizeof(ifr));",
                        "\t}",
                        "\tif (cmd == TUNGETFEATURES) {",
                        "\t\t/* Currently this just means: \"what IFF flags are valid?\".",
                        "\t\t * This is needed because we never checked for invalid flags on",
                        "\t\t * TUNSETIFF.",
                        "\t\t */",
                        "\t\treturn put_user(IFF_TUN | IFF_TAP | TUN_FEATURES,",
                        "\t\t\t\t(unsigned int __user*)argp);",
                        "\t} else if (cmd == TUNSETQUEUE) {",
                        "\t\treturn tun_set_queue(file, &ifr);",
                        "\t} else if (cmd == SIOCGSKNS) {",
                        "\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))",
                        "\t\t\treturn -EPERM;",
                        "\t\treturn open_related_ns(&net->ns, get_net_ns);",
                        "\t}",
                        "",
                        "\tret = 0;",
                        "\trtnl_lock();",
                        "",
                        "\ttun = tun_get(tfile);",
                        "\tif (cmd == TUNSETIFF) {",
                        "\t\tret = -EEXIST;",
                        "\t\tif (tun)",
                        "\t\t\tgoto unlock;",
                        "",
                        "\t\tifr.ifr_name[IFNAMSIZ-1] = '\\0';",
                        "",
                        "\t\tret = tun_set_iff(net, file, &ifr);",
                        "",
                        "\t\tif (ret)",
                        "\t\t\tgoto unlock;",
                        "",
                        "\t\tif (copy_to_user(argp, &ifr, ifreq_len))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tgoto unlock;",
                        "\t}",
                        "\tif (cmd == TUNSETIFINDEX) {",
                        "\t\tret = -EPERM;",
                        "\t\tif (tun)",
                        "\t\t\tgoto unlock;",
                        "",
                        "\t\tret = -EFAULT;",
                        "\t\tif (copy_from_user(&ifindex, argp, sizeof(ifindex)))",
                        "\t\t\tgoto unlock;",
                        "",
                        "\t\tret = 0;",
                        "\t\ttfile->ifindex = ifindex;",
                        "\t\tgoto unlock;",
                        "\t}",
                        "",
                        "\tret = -EBADFD;",
                        "\tif (!tun)",
                        "\t\tgoto unlock;",
                        "",
                        "\tnetif_info(tun, drv, tun->dev, \"tun_chr_ioctl cmd %u\\n\", cmd);",
                        "",
                        "\tnet = dev_net(tun->dev);",
                        "\tret = 0;",
                        "\tswitch (cmd) {",
                        "\tcase TUNGETIFF:",
                        "\t\ttun_get_iff(tun, &ifr);",
                        "",
                        "\t\tif (tfile->detached)",
                        "\t\t\tifr.ifr_flags |= IFF_DETACH_QUEUE;",
                        "\t\tif (!tfile->socket.sk->sk_filter)",
                        "\t\t\tifr.ifr_flags |= IFF_NOFILTER;",
                        "",
                        "\t\tif (copy_to_user(argp, &ifr, ifreq_len))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETNOCSUM:",
                        "\t\t/* Disable/Enable checksum */",
                        "",
                        "\t\t/* [unimplemented] */",
                        "\t\tnetif_info(tun, drv, tun->dev, \"ignored: set checksum %s\\n\",",
                        "\t\t\t   arg ? \"disabled\" : \"enabled\");",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETPERSIST:",
                        "\t\t/* Disable/Enable persist mode. Keep an extra reference to the",
                        "\t\t * module to prevent the module being unprobed.",
                        "\t\t */",
                        "\t\tif (arg && !(tun->flags & IFF_PERSIST)) {",
                        "\t\t\ttun->flags |= IFF_PERSIST;",
                        "\t\t\t__module_get(THIS_MODULE);",
                        "\t\t\tdo_notify = true;",
                        "\t\t}",
                        "\t\tif (!arg && (tun->flags & IFF_PERSIST)) {",
                        "\t\t\ttun->flags &= ~IFF_PERSIST;",
                        "\t\t\tmodule_put(THIS_MODULE);",
                        "\t\t\tdo_notify = true;",
                        "\t\t}",
                        "",
                        "\t\tnetif_info(tun, drv, tun->dev, \"persist %s\\n\",",
                        "\t\t\t   arg ? \"enabled\" : \"disabled\");",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETOWNER:",
                        "\t\t/* Set owner of the device */",
                        "\t\towner = make_kuid(current_user_ns(), arg);",
                        "\t\tif (!uid_valid(owner)) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\ttun->owner = owner;",
                        "\t\tdo_notify = true;",
                        "\t\tnetif_info(tun, drv, tun->dev, \"owner set to %u\\n\",",
                        "\t\t\t   from_kuid(&init_user_ns, tun->owner));",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETGROUP:",
                        "\t\t/* Set group of the device */",
                        "\t\tgroup = make_kgid(current_user_ns(), arg);",
                        "\t\tif (!gid_valid(group)) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\ttun->group = group;",
                        "\t\tdo_notify = true;",
                        "\t\tnetif_info(tun, drv, tun->dev, \"group set to %u\\n\",",
                        "\t\t\t   from_kgid(&init_user_ns, tun->group));",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETLINK:",
                        "\t\t/* Only allow setting the type when the interface is down */",
                        "\t\tif (tun->dev->flags & IFF_UP) {",
                        "\t\t\tnetif_info(tun, drv, tun->dev,",
                        "\t\t\t\t   \"Linktype set failed because interface is up\\n\");",
                        "\t\t\tret = -EBUSY;",
                        "\t\t} else {",
                        "\t\t\tret = call_netdevice_notifiers(NETDEV_PRE_TYPE_CHANGE,",
                        "\t\t\t\t\t\t       tun->dev);",
                        "\t\t\tret = notifier_to_errno(ret);",
                        "\t\t\tif (ret) {",
                        "\t\t\t\tnetif_info(tun, drv, tun->dev,",
                        "\t\t\t\t\t   \"Refused to change device type\\n\");",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\ttun->dev->type = (int) arg;",
                        "\t\t\tnetif_info(tun, drv, tun->dev, \"linktype set to %d\\n\",",
                        "\t\t\t\t   tun->dev->type);",
                        "\t\t\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE,",
                        "\t\t\t\t\t\t tun->dev);",
                        "\t\t}",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETDEBUG:",
                        "\t\ttun->msg_enable = (u32)arg;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETOFFLOAD:",
                        "\t\tret = set_offload(tun, arg);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETTXFILTER:",
                        "\t\t/* Can be set only for TAPs */",
                        "\t\tret = -EINVAL;",
                        "\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)",
                        "\t\t\tbreak;",
                        "\t\tret = update_filter(&tun->txflt, (void __user *)arg);",
                        "\t\tbreak;",
                        "",
                        "\tcase SIOCGIFHWADDR:",
                        "\t\t/* Get hw address */",
                        "\t\tmemcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);",
                        "\t\tifr.ifr_hwaddr.sa_family = tun->dev->type;",
                        "\t\tif (copy_to_user(argp, &ifr, ifreq_len))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "",
                        "\tcase SIOCSIFHWADDR:",
                        "\t\t/* Set hw address */",
                        "\t\tret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr, NULL);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETSNDBUF:",
                        "\t\tsndbuf = tfile->socket.sk->sk_sndbuf;",
                        "\t\tif (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETSNDBUF:",
                        "\t\tif (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {",
                        "\t\t\tret = -EFAULT;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (sndbuf <= 0) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\ttun->sndbuf = sndbuf;",
                        "\t\ttun_set_sndbuf(tun);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETVNETHDRSZ:",
                        "\t\tvnet_hdr_sz = tun->vnet_hdr_sz;",
                        "\t\tif (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETVNETHDRSZ:",
                        "\t\tif (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {",
                        "\t\t\tret = -EFAULT;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\ttun->vnet_hdr_sz = vnet_hdr_sz;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETVNETLE:",
                        "\t\tle = !!(tun->flags & TUN_VNET_LE);",
                        "\t\tif (put_user(le, (int __user *)argp))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETVNETLE:",
                        "\t\tif (get_user(le, (int __user *)argp)) {",
                        "\t\t\tret = -EFAULT;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (le)",
                        "\t\t\ttun->flags |= TUN_VNET_LE;",
                        "\t\telse",
                        "\t\t\ttun->flags &= ~TUN_VNET_LE;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETVNETBE:",
                        "\t\tret = tun_get_vnet_be(tun, argp);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETVNETBE:",
                        "\t\tret = tun_set_vnet_be(tun, argp);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNATTACHFILTER:",
                        "\t\t/* Can be set only for TAPs */",
                        "\t\tret = -EINVAL;",
                        "\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)",
                        "\t\t\tbreak;",
                        "\t\tret = -EFAULT;",
                        "\t\tif (copy_from_user(&tun->fprog, argp, sizeof(tun->fprog)))",
                        "\t\t\tbreak;",
                        "",
                        "\t\tret = tun_attach_filter(tun);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNDETACHFILTER:",
                        "\t\t/* Can be set only for TAPs */",
                        "\t\tret = -EINVAL;",
                        "\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)",
                        "\t\t\tbreak;",
                        "\t\tret = 0;",
                        "\t\ttun_detach_filter(tun, tun->numqueues);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETFILTER:",
                        "\t\tret = -EINVAL;",
                        "\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)",
                        "\t\t\tbreak;",
                        "\t\tret = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &tun->fprog, sizeof(tun->fprog)))",
                        "\t\t\tbreak;",
                        "\t\tret = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETSTEERINGEBPF:",
                        "\t\tret = tun_set_ebpf(tun, &tun->steering_prog, argp);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETFILTEREBPF:",
                        "\t\tret = tun_set_ebpf(tun, &tun->filter_prog, argp);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNSETCARRIER:",
                        "\t\tret = -EFAULT;",
                        "\t\tif (copy_from_user(&carrier, argp, sizeof(carrier)))",
                        "\t\t\tgoto unlock;",
                        "",
                        "\t\tret = tun_net_change_carrier(tun->dev, (bool)carrier);",
                        "\t\tbreak;",
                        "",
                        "\tcase TUNGETDEVNETNS:",
                        "\t\tret = -EPERM;",
                        "\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))",
                        "\t\t\tgoto unlock;",
                        "\t\tret = open_related_ns(&net->ns, get_net_ns);",
                        "\t\tbreak;",
                        "",
                        "\tdefault:",
                        "\t\tret = -EINVAL;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tif (do_notify)",
                        "\t\tnetdev_state_change(tun->dev);",
                        "",
                        "unlock:",
                        "\trtnl_unlock();",
                        "\tif (tun)",
                        "\t\ttun_put(tun);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2928,
                    "highlight": 2978
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816c3265"
        },
        "495": {
            "name": "tun_chr_ioctl(indirect)",
            "parent_idx": 494,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n48",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 30,
                    "highlight": 48
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811ea2ad"
        },
        "494": {
            "name": "vfs_ioctl",
            "parent_idx": 475,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n753",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 739,
                    "highlight": 753
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n739",
                    "code": [
                        "/*",
                        " * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.",
                        " * It's just a simple helper for sys_ioctl and compat_sys_ioctl.",
                        " *",
                        " * When you add any new common ioctls to the switches above and below,",
                        " * please ensure they have compatible arguments in compat mode.",
                        " */",
                        "static int do_vfs_ioctl(struct file *filp, unsigned int fd,",
                        "\t\t\tunsigned int cmd, unsigned long arg)",
                        "{",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tstruct inode *inode = file_inode(filp);",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIOCLEX:",
                        "\t\tset_close_on_exec(fd, 1);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONCLEX:",
                        "\t\tset_close_on_exec(fd, 0);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONBIO:",
                        "\t\treturn ioctl_fionbio(filp, argp);",
                        "",
                        "\tcase FIOASYNC:",
                        "\t\treturn ioctl_fioasync(fd, filp, argp);",
                        "",
                        "\tcase FIOQSIZE:",
                        "\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||",
                        "\t\t    S_ISLNK(inode->i_mode)) {",
                        "\t\t\tloff_t res = inode_get_bytes(inode);",
                        "\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?",
                        "\t\t\t\t\t    -EFAULT : 0;",
                        "\t\t}",
                        "",
                        "\t\treturn -ENOTTY;",
                        "",
                        "\tcase FIFREEZE:",
                        "\t\treturn ioctl_fsfreeze(filp);",
                        "",
                        "\tcase FITHAW:",
                        "\t\treturn ioctl_fsthaw(filp);",
                        "",
                        "\tcase FS_IOC_FIEMAP:",
                        "\t\treturn ioctl_fiemap(filp, argp);",
                        "",
                        "\tcase FIGETBSZ:",
                        "\t\t/* anon_bdev filesystems may not have a block size */",
                        "\t\tif (!inode->i_sb->s_blocksize)",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
                        "",
                        "\tcase FICLONE:",
                        "\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);",
                        "",
                        "\tcase FICLONERANGE:",
                        "\t\treturn ioctl_file_clone_range(filp, argp);",
                        "",
                        "\tcase FIDEDUPERANGE:",
                        "\t\treturn ioctl_file_dedupe_range(filp, argp);",
                        "",
                        "\tcase FIONREAD:",
                        "\t\tif (!S_ISREG(inode->i_mode))",
                        "\t\t\treturn vfs_ioctl(filp, cmd, arg);",
                        "",
                        "\t\treturn put_user(i_size_read(inode) - filp->f_pos,",
                        "\t\t\t\t(int __user *)argp);",
                        "",
                        "\tdefault:",
                        "\t\tif (S_ISREG(inode->i_mode))",
                        "\t\t\treturn file_ioctl(filp, cmd, argp);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn -ENOIOCTLCMD;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 660,
                    "highlight": 739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811eb1ae"
        },
        "475": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 472,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b73ede"
        },
        "472": {
            "name": "do_syscall_64",
            "parent_idx": 465,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=d635a69dd4981cc51f90293f5f64268620ed1565#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "465": {
            "name": "103_syscall_6",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "563": {
            "name": "+0x338",
            "parent_idx": 510,
            "source_line": [
                {
                    "file": "drivers/net/tun.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/tun.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n2709",
                    "code": [
                        "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)",
                        "{",
                        "\tstruct tun_struct *tun;",
                        "\tstruct tun_file *tfile = file->private_data;",
                        "\tstruct net_device *dev;",
                        "\tint err;",
                        "",
                        "\tif (tfile->detached)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif ((ifr->ifr_flags & IFF_NAPI_FRAGS)) {",
                        "\t\tif (!capable(CAP_NET_ADMIN))",
                        "\t\t\treturn -EPERM;",
                        "",
                        "\t\tif (!(ifr->ifr_flags & IFF_NAPI) ||",
                        "\t\t    (ifr->ifr_flags & TUN_TYPE_MASK) != IFF_TAP)",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tdev = __dev_get_by_name(net, ifr->ifr_name);",
                        "\tif (dev) {",
                        "\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)",
                        "\t\t\treturn -EBUSY;",
                        "\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)",
                        "\t\t\ttun = netdev_priv(dev);",
                        "\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)",
                        "\t\t\ttun = netdev_priv(dev);",
                        "\t\telse",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=",
                        "\t\t    !!(tun->flags & IFF_MULTI_QUEUE))",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\tif (tun_not_capable(tun))",
                        "\t\t\treturn -EPERM;",
                        "\t\terr = security_tun_dev_open(tun->security);",
                        "\t\tif (err < 0)",
                        "\t\t\treturn err;",
                        "",
                        "\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER,",
                        "\t\t\t\t ifr->ifr_flags & IFF_NAPI,",
                        "\t\t\t\t ifr->ifr_flags & IFF_NAPI_FRAGS, true);",
                        "\t\tif (err < 0)",
                        "\t\t\treturn err;",
                        "",
                        "\t\tif (tun->flags & IFF_MULTI_QUEUE &&",
                        "\t\t    (tun->numqueues + tun->numdisabled > 1)) {",
                        "\t\t\t/* One or more queue has already been attached, no need",
                        "\t\t\t * to initialize the device again.",
                        "\t\t\t */",
                        "\t\t\tnetdev_state_change(dev);",
                        "\t\t\treturn 0;",
                        "\t\t}",
                        "",
                        "\t\ttun->flags = (tun->flags & ~TUN_FEATURES) |",
                        "\t\t\t      (ifr->ifr_flags & TUN_FEATURES);",
                        "",
                        "\t\tnetdev_state_change(dev);",
                        "\t} else {",
                        "\t\tchar *name;",
                        "\t\tunsigned long flags = 0;",
                        "\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?",
                        "\t\t\t     MAX_TAP_QUEUES : 1;",
                        "",
                        "\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))",
                        "\t\t\treturn -EPERM;",
                        "\t\terr = security_tun_dev_create();",
                        "\t\tif (err < 0)",
                        "\t\t\treturn err;",
                        "",
                        "\t\t/* Set dev type */",
                        "\t\tif (ifr->ifr_flags & IFF_TUN) {",
                        "\t\t\t/* TUN device */",
                        "\t\t\tflags |= IFF_TUN;",
                        "\t\t\tname = \"tun%d\";",
                        "\t\t} else if (ifr->ifr_flags & IFF_TAP) {",
                        "\t\t\t/* TAP device */",
                        "\t\t\tflags |= IFF_TAP;",
                        "\t\t\tname = \"tap%d\";",
                        "\t\t} else",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\tif (*ifr->ifr_name)",
                        "\t\t\tname = ifr->ifr_name;",
                        "",
                        "\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,",
                        "\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,",
                        "\t\t\t\t       queues);",
                        "",
                        "\t\tif (!dev)",
                        "\t\t\treturn -ENOMEM;",
                        "",
                        "\t\tdev_net_set(dev, net);",
                        "\t\tdev->rtnl_link_ops = &tun_link_ops;",
                        "\t\tdev->ifindex = tfile->ifindex;",
                        "\t\tdev->sysfs_groups[0] = &tun_attr_group;",
                        "",
                        "\t\ttun = netdev_priv(dev);",
                        "\t\ttun->dev = dev;",
                        "\t\ttun->flags = flags;",
                        "\t\ttun->txflt.count = 0;",
                        "\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);",
                        "",
                        "\t\ttun->align = NET_SKB_PAD;",
                        "\t\ttun->filter_attached = false;",
                        "\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;",
                        "\t\ttun->rx_batched = 0;",
                        "\t\tRCU_INIT_POINTER(tun->steering_prog, NULL);",
                        "",
                        "\t\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);",
                        "\t\tif (!dev->tstats) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto err_free_dev;",
                        "\t\t}",
                        "",
                        "\t\tspin_lock_init(&tun->lock);",
                        "",
                        "\t\terr = security_tun_dev_alloc_security(&tun->security);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err_free_stat;",
                        "",
                        "\t\ttun_net_init(dev);",
                        "\t\ttun_flow_init(tun);",
                        "",
                        "\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |",
                        "\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |",
                        "\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;",
                        "\t\tdev->features = dev->hw_features | NETIF_F_LLTX;",
                        "\t\tdev->vlan_features = dev->features &",
                        "\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |",
                        "\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);",
                        "",
                        "\t\ttun->flags = (tun->flags & ~TUN_FEATURES) |",
                        "\t\t\t      (ifr->ifr_flags & TUN_FEATURES);",
                        "",
                        "\t\tINIT_LIST_HEAD(&tun->disabled);",
                        "\t\terr = tun_attach(tun, file, false, ifr->ifr_flags & IFF_NAPI,",
                        "\t\t\t\t ifr->ifr_flags & IFF_NAPI_FRAGS, false);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err_free_flow;",
                        "",
                        "\t\terr = register_netdevice(tun->dev);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err_detach;",
                        "\t\t/* free_netdev() won't check refcnt, to aovid race",
                        "\t\t * with dev_put() we need publish tun after registration.",
                        "\t\t */",
                        "\t\trcu_assign_pointer(tfile->tun, tun);",
                        "\t}",
                        "",
                        "\tnetif_carrier_on(tun->dev);",
                        "",
                        "\t/* Make sure persistent devices do not get stuck in",
                        "\t * xoff state.",
                        "\t */",
                        "\tif (netif_running(tun->dev))",
                        "\t\tnetif_tx_wake_all_queues(tun->dev);",
                        "",
                        "\tstrcpy(ifr->ifr_name, tun->dev->name);",
                        "\treturn 0;",
                        "",
                        "err_detach:",
                        "\ttun_detach_all(dev);",
                        "\t/* We are here because register_netdevice() has failed.",
                        "\t * If register_netdevice() already called tun_free_netdev()",
                        "\t * while dealing with the error, dev->stats has been cleared.",
                        "\t */",
                        "\tif (!dev->tstats)",
                        "\t\tgoto err_free_dev;",
                        "",
                        "err_free_flow:",
                        "\ttun_flow_uninit(tun);",
                        "\tsecurity_tun_dev_free_security(tun->security);",
                        "err_free_stat:",
                        "\tfree_percpu(dev->tstats);",
                        "err_free_dev:",
                        "\tfree_netdev(dev);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2599,
                    "highlight": 2709
                }
            ],
            "ins_idx": 191,
            "addr": "0xffffffff816c1a78"
        },
        "562": {
            "name": "+0x95",
            "parent_idx": 561,
            "source_line": [
                {
                    "file": "mm/percpu.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/percpu.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n1874",
                    "code": [
                        "/**",
                        " * pcpu_alloc - the percpu allocator",
                        " * @size: size of area to allocate in bytes",
                        " * @align: alignment of area (max PAGE_SIZE)",
                        " * @reserved: allocate from the reserved chunk if available",
                        " * @gfp: allocation flags",
                        " *",
                        " * Allocate percpu area of @size bytes aligned at @align.  If @gfp doesn't",
                        " * contain %GFP_KERNEL, the allocation is atomic. If @gfp has __GFP_NOWARN",
                        " * then no warning will be triggered on invalid or failed allocation",
                        " * requests.",
                        " *",
                        " * RETURNS:",
                        " * Percpu pointer to the allocated area on success, NULL on failure.",
                        " */",
                        "static void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved,",
                        "\t\t\t\t gfp_t gfp)",
                        "{",
                        "\tgfp_t pcpu_gfp;",
                        "\tbool is_atomic;",
                        "\tbool do_warn;",
                        "\tenum pcpu_chunk_type type;",
                        "\tstruct list_head *pcpu_slot;",
                        "\tstruct obj_cgroup *objcg = NULL;",
                        "\tstatic int warn_limit = 10;",
                        "\tstruct pcpu_chunk *chunk, *next;",
                        "\tconst char *err;",
                        "\tint slot, off, cpu, ret;",
                        "\tunsigned long flags;",
                        "\tvoid __percpu *ptr;",
                        "\tsize_t bits, bit_align;",
                        "",
                        "\tgfp = current_gfp_context(gfp);",
                        "\t/* whitelisted flags that can be passed to the backing allocators */",
                        "\tpcpu_gfp = gfp & (GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);",
                        "\tis_atomic = (gfp & GFP_KERNEL) != GFP_KERNEL;",
                        "\tdo_warn = !(gfp & __GFP_NOWARN);",
                        "",
                        "\t/*",
                        "\t * There is now a minimum allocation size of PCPU_MIN_ALLOC_SIZE,",
                        "\t * therefore alignment must be a minimum of that many bytes.",
                        "\t * An allocation may have internal fragmentation from rounding up",
                        "\t * of up to PCPU_MIN_ALLOC_SIZE - 1 bytes.",
                        "\t */",
                        "\tif (unlikely(align < PCPU_MIN_ALLOC_SIZE))",
                        "\t\talign = PCPU_MIN_ALLOC_SIZE;",
                        "",
                        "\tsize = ALIGN(size, PCPU_MIN_ALLOC_SIZE);",
                        "\tbits = size >> PCPU_MIN_ALLOC_SHIFT;",
                        "\tbit_align = align >> PCPU_MIN_ALLOC_SHIFT;",
                        "",
                        "\tif (unlikely(!size || size > PCPU_MIN_UNIT_SIZE || align > PAGE_SIZE ||",
                        "\t\t     !is_power_of_2(align))) {",
                        "\t\tWARN(do_warn, \"illegal size (%zu) or align (%zu) for percpu allocation\\n\",",
                        "\t\t     size, align);",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\ttype = pcpu_memcg_pre_alloc_hook(size, gfp, &objcg);",
                        "\tif (unlikely(type == PCPU_FAIL_ALLOC))",
                        "\t\treturn NULL;",
                        "\tpcpu_slot = pcpu_chunk_list(type);",
                        "",
                        "\tif (!is_atomic) {",
                        "\t\t/*",
                        "\t\t * pcpu_balance_workfn() allocates memory under this mutex,",
                        "\t\t * and it may wait for memory reclaim. Allow current task",
                        "\t\t * to become OOM victim, in case of memory pressure.",
                        "\t\t */",
                        "\t\tif (gfp & __GFP_NOFAIL) {",
                        "\t\t\tmutex_lock(&pcpu_alloc_mutex);",
                        "\t\t} else if (mutex_lock_killable(&pcpu_alloc_mutex)) {",
                        "\t\t\tpcpu_memcg_post_alloc_hook(objcg, NULL, 0, size);",
                        "\t\t\treturn NULL;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tspin_lock_irqsave(&pcpu_lock, flags);",
                        "",
                        "\t/* serve reserved allocations from the reserved chunk if available */",
                        "\tif (reserved && pcpu_reserved_chunk) {",
                        "\t\tchunk = pcpu_reserved_chunk;",
                        "",
                        "\t\toff = pcpu_find_block_fit(chunk, bits, bit_align, is_atomic);",
                        "\t\tif (off < 0) {",
                        "\t\t\terr = \"alloc from reserved chunk failed\";",
                        "\t\t\tgoto fail_unlock;",
                        "\t\t}",
                        "",
                        "\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);",
                        "\t\tif (off >= 0)",
                        "\t\t\tgoto area_found;",
                        "",
                        "\t\terr = \"alloc from reserved chunk failed\";",
                        "\t\tgoto fail_unlock;",
                        "\t}",
                        "",
                        "restart:",
                        "\t/* search through normal chunks */",
                        "\tfor (slot = pcpu_size_to_slot(size); slot < pcpu_nr_slots; slot++) {",
                        "\t\tlist_for_each_entry_safe(chunk, next, &pcpu_slot[slot], list) {",
                        "\t\t\toff = pcpu_find_block_fit(chunk, bits, bit_align,",
                        "\t\t\t\t\t\t  is_atomic);",
                        "\t\t\tif (off < 0) {",
                        "\t\t\t\tif (slot < PCPU_SLOT_FAIL_THRESHOLD)",
                        "\t\t\t\t\tpcpu_chunk_move(chunk, 0);",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "",
                        "\t\t\toff = pcpu_alloc_area(chunk, bits, bit_align, off);",
                        "\t\t\tif (off >= 0)",
                        "\t\t\t\tgoto area_found;",
                        "",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tspin_unlock_irqrestore(&pcpu_lock, flags);",
                        "",
                        "\t/*",
                        "\t * No space left.  Create a new chunk.  We don't want multiple",
                        "\t * tasks to create chunks simultaneously.  Serialize and create iff",
                        "\t * there's still no empty chunk after grabbing the mutex.",
                        "\t */",
                        "\tif (is_atomic) {",
                        "\t\terr = \"atomic alloc failed, no space left\";",
                        "\t\tgoto fail;",
                        "\t}",
                        "",
                        "\tif (list_empty(&pcpu_slot[pcpu_nr_slots - 1])) {",
                        "\t\tchunk = pcpu_create_chunk(type, pcpu_gfp);",
                        "\t\tif (!chunk) {",
                        "\t\t\terr = \"failed to allocate new chunk\";",
                        "\t\t\tgoto fail;",
                        "\t\t}",
                        "",
                        "\t\tspin_lock_irqsave(&pcpu_lock, flags);",
                        "\t\tpcpu_chunk_relocate(chunk, -1);",
                        "\t} else {",
                        "\t\tspin_lock_irqsave(&pcpu_lock, flags);",
                        "\t}",
                        "",
                        "\tgoto restart;",
                        "",
                        "area_found:",
                        "\tpcpu_stats_area_alloc(chunk, size);",
                        "\tspin_unlock_irqrestore(&pcpu_lock, flags);",
                        "",
                        "\t/* populate if not all pages are already there */",
                        "\tif (!is_atomic) {",
                        "\t\tunsigned int page_start, page_end, rs, re;",
                        "",
                        "\t\tpage_start = PFN_DOWN(off);",
                        "\t\tpage_end = PFN_UP(off + size);",
                        "",
                        "\t\tbitmap_for_each_clear_region(chunk->populated, rs, re,",
                        "\t\t\t\t\t     page_start, page_end) {",
                        "\t\t\tWARN_ON(chunk->immutable);",
                        "",
                        "\t\t\tret = pcpu_populate_chunk(chunk, rs, re, pcpu_gfp);",
                        "",
                        "\t\t\tspin_lock_irqsave(&pcpu_lock, flags);",
                        "\t\t\tif (ret) {",
                        "\t\t\t\tpcpu_free_area(chunk, off);",
                        "\t\t\t\terr = \"failed to populate\";",
                        "\t\t\t\tgoto fail_unlock;",
                        "\t\t\t}",
                        "\t\t\tpcpu_chunk_populated(chunk, rs, re);",
                        "\t\t\tspin_unlock_irqrestore(&pcpu_lock, flags);",
                        "\t\t}",
                        "",
                        "\t\tmutex_unlock(&pcpu_alloc_mutex);",
                        "\t}",
                        "",
                        "\tif (pcpu_nr_empty_pop_pages < PCPU_EMPTY_POP_PAGES_LOW)",
                        "\t\tpcpu_schedule_balance_work();",
                        "",
                        "\t/* clear the areas and return address relative to base address */",
                        "\tfor_each_possible_cpu(cpu)",
                        "\t\tmemset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);",
                        "",
                        "\tptr = __addr_to_pcpu_ptr(chunk->base_addr + off);",
                        "\tkmemleak_alloc_percpu(ptr, size, gfp);",
                        "",
                        "\ttrace_percpu_alloc_percpu(reserved, is_atomic, size, align,",
                        "\t\t\tchunk->base_addr, off, ptr);",
                        "",
                        "\tpcpu_memcg_post_alloc_hook(objcg, chunk, off, size);",
                        "",
                        "\treturn ptr;",
                        "",
                        "fail_unlock:",
                        "\tspin_unlock_irqrestore(&pcpu_lock, flags);",
                        "fail:",
                        "\ttrace_percpu_alloc_percpu_fail(reserved, is_atomic, size, align);",
                        "",
                        "\tif (!is_atomic && do_warn && warn_limit) {",
                        "\t\tpr_warn(\"allocation failed, size=%zu align=%zu atomic=%d, %s\\n\",",
                        "\t\t\tsize, align, is_atomic, err);",
                        "\t\tdump_stack();",
                        "\t\tif (!--warn_limit)",
                        "\t\t\tpr_info(\"limit reached, disable warning\\n\");",
                        "\t}",
                        "\tif (is_atomic) {",
                        "\t\t/* see the flag handling in pcpu_blance_workfn() */",
                        "\t\tpcpu_atomic_alloc_failed = true;",
                        "\t\tpcpu_schedule_balance_work();",
                        "\t} else {",
                        "\t\tmutex_unlock(&pcpu_alloc_mutex);",
                        "\t}",
                        "",
                        "\tpcpu_memcg_post_alloc_hook(objcg, NULL, 0, size);",
                        "",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 1661,
                    "highlight": 1874
                }
            ],
            "ins_idx": 263,
            "addr": "0xffffffff81183c05"
        },
        "561": {
            "name": "__alloc_percpu_gfp",
            "parent_idx": 510,
            "source_line": [
                {
                    "file": "drivers/net/tun.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/tun.c?id=d635a69dd4981cc51f90293f5f64268620ed1565#n2709",
                    "code": [
                        "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)",
                        "{",
                        "\tstruct tun_struct *tun;",
                        "\tstruct tun_file *tfile = file->private_data;",
                        "\tstruct net_device *dev;",
                        "\tint err;",
                        "",
                        "\tif (tfile->detached)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif ((ifr->ifr_flags & IFF_NAPI_FRAGS)) {",
                        "\t\tif (!capable(CAP_NET_ADMIN))",
                        "\t\t\treturn -EPERM;",
                        "",
                        "\t\tif (!(ifr->ifr_flags & IFF_NAPI) ||",
                        "\t\t    (ifr->ifr_flags & TUN_TYPE_MASK) != IFF_TAP)",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tdev = __dev_get_by_name(net, ifr->ifr_name);",
                        "\tif (dev) {",
                        "\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)",
                        "\t\t\treturn -EBUSY;",
                        "\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)",
                        "\t\t\ttun = netdev_priv(dev);",
                        "\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)",
                        "\t\t\ttun = netdev_priv(dev);",
                        "\t\telse",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=",
                        "\t\t    !!(tun->flags & IFF_MULTI_QUEUE))",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\tif (tun_not_capable(tun))",
                        "\t\t\treturn -EPERM;",
                        "\t\terr = security_tun_dev_open(tun->security);",
                        "\t\tif (err < 0)",
                        "\t\t\treturn err;",
                        "",
                        "\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER,",
                        "\t\t\t\t ifr->ifr_flags & IFF_NAPI,",
                        "\t\t\t\t ifr->ifr_flags & IFF_NAPI_FRAGS, true);",
                        "\t\tif (err < 0)",
                        "\t\t\treturn err;",
                        "",
                        "\t\tif (tun->flags & IFF_MULTI_QUEUE &&",
                        "\t\t    (tun->numqueues + tun->numdisabled > 1)) {",
                        "\t\t\t/* One or more queue has already been attached, no need",
                        "\t\t\t * to initialize the device again.",
                        "\t\t\t */",
                        "\t\t\tnetdev_state_change(dev);",
                        "\t\t\treturn 0;",
                        "\t\t}",
                        "",
                        "\t\ttun->flags = (tun->flags & ~TUN_FEATURES) |",
                        "\t\t\t      (ifr->ifr_flags & TUN_FEATURES);",
                        "",
                        "\t\tnetdev_state_change(dev);",
                        "\t} else {",
                        "\t\tchar *name;",
                        "\t\tunsigned long flags = 0;",
                        "\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?",
                        "\t\t\t     MAX_TAP_QUEUES : 1;",
                        "",
                        "\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))",
                        "\t\t\treturn -EPERM;",
                        "\t\terr = security_tun_dev_create();",
                        "\t\tif (err < 0)",
                        "\t\t\treturn err;",
                        "",
                        "\t\t/* Set dev type */",
                        "\t\tif (ifr->ifr_flags & IFF_TUN) {",
                        "\t\t\t/* TUN device */",
                        "\t\t\tflags |= IFF_TUN;",
                        "\t\t\tname = \"tun%d\";",
                        "\t\t} else if (ifr->ifr_flags & IFF_TAP) {",
                        "\t\t\t/* TAP device */",
                        "\t\t\tflags |= IFF_TAP;",
                        "\t\t\tname = \"tap%d\";",
                        "\t\t} else",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\tif (*ifr->ifr_name)",
                        "\t\t\tname = ifr->ifr_name;",
                        "",
                        "\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,",
                        "\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,",
                        "\t\t\t\t       queues);",
                        "",
                        "\t\tif (!dev)",
                        "\t\t\treturn -ENOMEM;",
                        "",
                        "\t\tdev_net_set(dev, net);",
                        "\t\tdev->rtnl_link_ops = &tun_link_ops;",
                        "\t\tdev->ifindex = tfile->ifindex;",
                        "\t\tdev->sysfs_groups[0] = &tun_attr_group;",
                        "",
                        "\t\ttun = netdev_priv(dev);",
                        "\t\ttun->dev = dev;",
                        "\t\ttun->flags = flags;",
                        "\t\ttun->txflt.count = 0;",
                        "\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);",
                        "",
                        "\t\ttun->align = NET_SKB_PAD;",
                        "\t\ttun->filter_attached = false;",
                        "\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;",
                        "\t\ttun->rx_batched = 0;",
                        "\t\tRCU_INIT_POINTER(tun->steering_prog, NULL);",
                        "",
                        "\t\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);",
                        "\t\tif (!dev->tstats) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto err_free_dev;",
                        "\t\t}",
                        "",
                        "\t\tspin_lock_init(&tun->lock);",
                        "",
                        "\t\terr = security_tun_dev_alloc_security(&tun->security);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err_free_stat;",
                        "",
                        "\t\ttun_net_init(dev);",
                        "\t\ttun_flow_init(tun);",
                        "",
                        "\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |",
                        "\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |",
                        "\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;",
                        "\t\tdev->features = dev->hw_features | NETIF_F_LLTX;",
                        "\t\tdev->vlan_features = dev->features &",
                        "\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |",
                        "\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);",
                        "",
                        "\t\ttun->flags = (tun->flags & ~TUN_FEATURES) |",
                        "\t\t\t      (ifr->ifr_flags & TUN_FEATURES);",
                        "",
                        "\t\tINIT_LIST_HEAD(&tun->disabled);",
                        "\t\terr = tun_attach(tun, file, false, ifr->ifr_flags & IFF_NAPI,",
                        "\t\t\t\t ifr->ifr_flags & IFF_NAPI_FRAGS, false);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err_free_flow;",
                        "",
                        "\t\terr = register_netdevice(tun->dev);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err_detach;",
                        "\t\t/* free_netdev() won't check refcnt, to aovid race",
                        "\t\t * with dev_put() we need publish tun after registration.",
                        "\t\t */",
                        "\t\trcu_assign_pointer(tfile->tun, tun);",
                        "\t}",
                        "",
                        "\tnetif_carrier_on(tun->dev);",
                        "",
                        "\t/* Make sure persistent devices do not get stuck in",
                        "\t * xoff state.",
                        "\t */",
                        "\tif (netif_running(tun->dev))",
                        "\t\tnetif_tx_wake_all_queues(tun->dev);",
                        "",
                        "\tstrcpy(ifr->ifr_name, tun->dev->name);",
                        "\treturn 0;",
                        "",
                        "err_detach:",
                        "\ttun_detach_all(dev);",
                        "\t/* We are here because register_netdevice() has failed.",
                        "\t * If register_netdevice() already called tun_free_netdev()",
                        "\t * while dealing with the error, dev->stats has been cleared.",
                        "\t */",
                        "\tif (!dev->tstats)",
                        "\t\tgoto err_free_dev;",
                        "",
                        "err_free_flow:",
                        "\ttun_flow_uninit(tun);",
                        "\tsecurity_tun_dev_free_security(tun->security);",
                        "err_free_stat:",
                        "\tfree_percpu(dev->tstats);",
                        "err_free_dev:",
                        "\tfree_netdev(dev);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2599,
                    "highlight": 2709
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816c1a6e"
        }
    },
    "ins": {
        "41": {
            "name": "mov r12, qword ptr [r12 + 0x6028]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x607dc8006308",
            "call_idx": 4226,
            "inputs": [
                7090,
                7091
            ],
            "outputs": [
                7092
            ]
        },
        "85": {
            "name": "mov r12, qword ptr [rdi + 0x4b8]",
            "desc": "Type Confusion Read as * can_ml_priv.",
            "call_idx": 4225,
            "inputs": [
                7087,
                7088
            ],
            "outputs": [
                7089
            ]
        },
        "130": {
            "name": "mov qword ptr [r14 + 0x4b8], rbx",
            "desc": "Write as * pcpu_sw_netstats.",
            "call_idx": 564,
            "inputs": [
                943,
                944
            ],
            "outputs": [
                945
            ]
        },
        "191": {
            "name": "mov rbx, rax",
            "desc": "",
            "call_idx": 563,
            "inputs": [
                941
            ],
            "outputs": [
                942
            ]
        },
        "263": {
            "name": "ret ",
            "desc": "Source of base address MEMALLOC 0x607dc80002e0",
            "call_idx": 562,
            "inputs": [],
            "outputs": [
                940
            ]
        }
    },
    "data": {
        "7090": {
            "name": "R12",
            "ins_idx": 41,
            "value": "0x607dc80002e0",
            "sources": []
        },
        "7091": {
            "name": "[0x607dc8006308]",
            "ins_idx": 41,
            "value": "0x0",
            "sources": []
        },
        "7092": {
            "name": "R12",
            "ins_idx": 41,
            "value": "0x0",
            "sources": []
        },
        "7087": {
            "name": "RDI",
            "ins_idx": 85,
            "value": "0xffff888101900000",
            "sources": []
        },
        "7088": {
            "name": "[0xffff8881019004b8]",
            "ins_idx": 85,
            "value": "0x607dc80002e0",
            "sources": []
        },
        "7089": {
            "name": "R12",
            "ins_idx": 85,
            "value": "0x607dc80002e0",
            "sources": [
                7090
            ]
        },
        "943": {
            "name": "R14",
            "ins_idx": 130,
            "value": "0xffff888101900000",
            "sources": []
        },
        "944": {
            "name": "RBX",
            "ins_idx": 130,
            "value": "0x607dc80002e0",
            "sources": []
        },
        "945": {
            "name": "[0xffff8881019004b8]",
            "ins_idx": 130,
            "value": "0x607dc80002e0",
            "sources": [
                7088
            ]
        },
        "941": {
            "name": "RAX",
            "ins_idx": 191,
            "value": "0x607dc80002e0",
            "sources": []
        },
        "942": {
            "name": "RBX",
            "ins_idx": 191,
            "value": "0x607dc80002e0",
            "sources": [
                944
            ]
        },
        "940": {
            "name": "RAX",
            "ins_idx": 263,
            "value": "0x607dc80002e0",
            "sources": [
                941
            ]
        }
    },
    "chain": {
        "41": [
            85
        ],
        "85": [
            130
        ],
        "130": [
            191
        ],
        "191": [
            263
        ]
    }
}