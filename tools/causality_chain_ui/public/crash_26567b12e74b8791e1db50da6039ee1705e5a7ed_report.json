{
    "report": "https://syzkaller.appspot.com/bug?id=26567b12e74b8791e1db50da6039ee1705e5a7ed",
    "title": "BUG: unable to handle kernel NULL pointer dereference in fbcon_cursor",
    "call": {
        "1008": {
            "name": "+0x3",
            "parent_idx": 996,
            "source_line": [
                {
                    "file": "./arch/x86/include/asm/GEN-for-each-reg.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./arch/x86/include/asm/GEN-for-each-reg.h?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n2",
                    "code": [
                        "#ifdef CONFIG_64BIT",
                        "GEN(rax)",
                        "GEN(rbx)",
                        "GEN(rcx)",
                        "GEN(rdx)",
                        "GEN(rsi)",
                        "GEN(rdi)",
                        "GEN(rbp)",
                        "GEN(r8)",
                        "GEN(r9)",
                        "GEN(r10)",
                        "GEN(r11)",
                        "GEN(r12)",
                        "GEN(r13)",
                        "GEN(r14)",
                        "GEN(r15)",
                        "#else",
                        "GEN(eax)",
                        "GEN(ebx)",
                        "GEN(ecx)",
                        "GEN(edx)",
                        "GEN(esi)",
                        "GEN(edi)",
                        "GEN(ebp)",
                        "#endif"
                    ],
                    "start": 1,
                    "highlight": 2
                }
            ],
            "ins_idx": 8,
            "addr": "0xffffffff81e03863"
        },
        "996": {
            "name": "fbcon_cursor(indirect)",
            "parent_idx": 993,
            "source_line": [
                {
                    "file": "drivers/tty/vt/vt.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/vt/vt.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n907",
                    "code": [
                        "static void hide_cursor(struct vc_data *vc)",
                        "{",
                        "\tif (vc_is_sel(vc))",
                        "\t\tclear_selection();",
                        "",
                        "\tvc->vc_sw->con_cursor(vc, CM_ERASE);",
                        "\thide_softcursor(vc);",
                        "}"
                    ],
                    "start": 902,
                    "highlight": 907
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff814e90d0"
        },
        "993": {
            "name": "hide_cursor",
            "parent_idx": 990,
            "source_line": [
                {
                    "file": "drivers/tty/vt/vt.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/vt/vt.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n1012",
                    "code": [
                        "void redraw_screen(struct vc_data *vc, int is_switch)",
                        "{",
                        "\tint redraw = 0;",
                        "",
                        "\tWARN_CONSOLE_UNLOCKED();",
                        "",
                        "\tif (!vc) {",
                        "\t\t/* strange ... */",
                        "\t\t/* printk(\"redraw_screen: tty %d not allocated ??\\n\", new_console+1); */",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\tif (is_switch) {",
                        "\t\tstruct vc_data *old_vc = vc_cons[fg_console].d;",
                        "\t\tif (old_vc == vc)",
                        "\t\t\treturn;",
                        "\t\tif (!con_is_visible(vc))",
                        "\t\t\tredraw = 1;",
                        "\t\t*vc->vc_display_fg = vc;",
                        "\t\tfg_console = vc->vc_num;",
                        "\t\thide_cursor(old_vc);",
                        "\t\tif (!con_is_visible(old_vc)) {",
                        "\t\t\tsave_screen(old_vc);",
                        "\t\t\tset_origin(old_vc);",
                        "\t\t}",
                        "\t\tif (tty0dev)",
                        "\t\t\tsysfs_notify(&tty0dev->kobj, NULL, \"active\");",
                        "\t} else {",
                        "\t\thide_cursor(vc);",
                        "\t\tredraw = 1;",
                        "\t}",
                        "",
                        "\tif (redraw) {",
                        "\t\tint update;",
                        "\t\tint old_was_color = vc->vc_can_do_color;",
                        "",
                        "\t\tset_origin(vc);",
                        "\t\tupdate = vc->vc_sw->con_switch(vc);",
                        "\t\tset_palette(vc);",
                        "\t\t/*",
                        "\t\t * If console changed from mono<->color, the best we can do",
                        "\t\t * is to clear the buffer attributes. As it currently stands,",
                        "\t\t * rebuilding new attributes from the old buffer is not doable",
                        "\t\t * without overly complex code.",
                        "\t\t */",
                        "\t\tif (old_was_color != vc->vc_can_do_color) {",
                        "\t\t\tupdate_attr(vc);",
                        "\t\t\tclear_buffer_attributes(vc);",
                        "\t\t}",
                        "",
                        "\t\tif (update && vc->vc_mode != KD_GRAPHICS)",
                        "\t\t\tdo_update_region(vc, vc->vc_origin, vc->vc_screenbuf_size / 2);",
                        "\t}",
                        "\tset_cursor(vc);",
                        "\tif (is_switch) {",
                        "\t\tset_leds();",
                        "\t\tcompute_shiftstate();",
                        "\t\tnotify_update(vc);",
                        "\t}",
                        "}"
                    ],
                    "start": 984,
                    "highlight": 1012
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff814ea231"
        },
        "990": {
            "name": "redraw_screen",
            "parent_idx": 944,
            "source_line": [
                {
                    "file": "drivers/tty/vt/vt.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/vt/vt.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n1326",
                    "code": [
                        "static int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,",
                        "\t\t\t\tunsigned int cols, unsigned int lines)",
                        "{",
                        "\tunsigned long old_origin, new_origin, new_scr_end, rlth, rrem, err = 0;",
                        "\tunsigned long end;",
                        "\tunsigned int old_rows, old_row_size, first_copied_row;",
                        "\tunsigned int new_cols, new_rows, new_row_size, new_screen_size;",
                        "\tunsigned int user;",
                        "\tunsigned short *oldscreen, *newscreen;",
                        "\tstruct uni_screen *new_uniscr = NULL;",
                        "",
                        "\tWARN_CONSOLE_UNLOCKED();",
                        "",
                        "\tif (!vc)",
                        "\t\treturn -ENXIO;",
                        "",
                        "\tuser = vc->vc_resize_user;",
                        "\tvc->vc_resize_user = 0;",
                        "",
                        "\tif (cols > VC_MAXCOL || lines > VC_MAXROW)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tnew_cols = (cols ? cols : vc->vc_cols);",
                        "\tnew_rows = (lines ? lines : vc->vc_rows);",
                        "\tnew_row_size = new_cols << 1;",
                        "\tnew_screen_size = new_row_size * new_rows;",
                        "",
                        "\tif (new_cols == vc->vc_cols && new_rows == vc->vc_rows)",
                        "\t\treturn 0;",
                        "",
                        "\tif (new_screen_size > KMALLOC_MAX_SIZE || !new_screen_size)",
                        "\t\treturn -EINVAL;",
                        "\tnewscreen = kzalloc(new_screen_size, GFP_USER);",
                        "\tif (!newscreen)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tif (get_vc_uniscr(vc)) {",
                        "\t\tnew_uniscr = vc_uniscr_alloc(new_cols, new_rows);",
                        "\t\tif (!new_uniscr) {",
                        "\t\t\tkfree(newscreen);",
                        "\t\t\treturn -ENOMEM;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (vc_is_sel(vc))",
                        "\t\tclear_selection();",
                        "",
                        "\told_rows = vc->vc_rows;",
                        "\told_row_size = vc->vc_size_row;",
                        "",
                        "\terr = resize_screen(vc, new_cols, new_rows, user);",
                        "\tif (err) {",
                        "\t\tkfree(newscreen);",
                        "\t\tvc_uniscr_free(new_uniscr);",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\tvc->vc_rows = new_rows;",
                        "\tvc->vc_cols = new_cols;",
                        "\tvc->vc_size_row = new_row_size;",
                        "\tvc->vc_screenbuf_size = new_screen_size;",
                        "",
                        "\trlth = min(old_row_size, new_row_size);",
                        "\trrem = new_row_size - rlth;",
                        "\told_origin = vc->vc_origin;",
                        "\tnew_origin = (long) newscreen;",
                        "\tnew_scr_end = new_origin + new_screen_size;",
                        "",
                        "\tif (vc->state.y > new_rows) {",
                        "\t\tif (old_rows - vc->state.y < new_rows) {",
                        "\t\t\t/*",
                        "\t\t\t * Cursor near the bottom, copy contents from the",
                        "\t\t\t * bottom of buffer",
                        "\t\t\t */",
                        "\t\t\tfirst_copied_row = (old_rows - new_rows);",
                        "\t\t} else {",
                        "\t\t\t/*",
                        "\t\t\t * Cursor is in no man's land, copy 1/2 screenful",
                        "\t\t\t * from the top and bottom of cursor position",
                        "\t\t\t */",
                        "\t\t\tfirst_copied_row = (vc->state.y - new_rows/2);",
                        "\t\t}",
                        "\t\told_origin += first_copied_row * old_row_size;",
                        "\t} else",
                        "\t\tfirst_copied_row = 0;",
                        "\tend = old_origin + old_row_size * min(old_rows, new_rows);",
                        "",
                        "\tvc_uniscr_copy_area(new_uniscr, new_cols, new_rows,",
                        "\t\t\t    get_vc_uniscr(vc), rlth/2, first_copied_row,",
                        "\t\t\t    min(old_rows, new_rows));",
                        "\tvc_uniscr_set(vc, new_uniscr);",
                        "",
                        "\tupdate_attr(vc);",
                        "",
                        "\twhile (old_origin < end) {",
                        "\t\tscr_memcpyw((unsigned short *) new_origin,",
                        "\t\t\t    (unsigned short *) old_origin, rlth);",
                        "\t\tif (rrem)",
                        "\t\t\tscr_memsetw((void *)(new_origin + rlth),",
                        "\t\t\t\t    vc->vc_video_erase_char, rrem);",
                        "\t\told_origin += old_row_size;",
                        "\t\tnew_origin += new_row_size;",
                        "\t}",
                        "\tif (new_scr_end > new_origin)",
                        "\t\tscr_memsetw((void *)new_origin, vc->vc_video_erase_char,",
                        "\t\t\t    new_scr_end - new_origin);",
                        "\toldscreen = vc->vc_screenbuf;",
                        "\tvc->vc_screenbuf = newscreen;",
                        "\tvc->vc_screenbuf_size = new_screen_size;",
                        "\tset_origin(vc);",
                        "\tkfree(oldscreen);",
                        "",
                        "\t/* do part of a reset_terminal() */",
                        "\tvc->vc_top = 0;",
                        "\tvc->vc_bottom = vc->vc_rows;",
                        "\tgotoxy(vc, vc->state.x, vc->state.y);",
                        "\tsave_cur(vc);",
                        "",
                        "\tif (tty) {",
                        "\t\t/* Rewrite the requested winsize data with the actual",
                        "\t\t   resulting sizes */",
                        "\t\tstruct winsize ws;",
                        "\t\tmemset(&ws, 0, sizeof(ws));",
                        "\t\tws.ws_row = vc->vc_rows;",
                        "\t\tws.ws_col = vc->vc_cols;",
                        "\t\tws.ws_ypixel = vc->vc_scan_lines;",
                        "\t\ttty_do_resize(tty, &ws);",
                        "\t}",
                        "",
                        "\tif (con_is_visible(vc))",
                        "\t\tupdate_screen(vc);",
                        "\tvt_event_post(VT_EVENT_RESIZE, vc->vc_num, vc->vc_num);",
                        "\tnotify_update(vc);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1196,
                    "highlight": 1326
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff814ea98b"
        },
        "944": {
            "name": "vc_resize",
            "parent_idx": 934,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n1410",
                    "code": [
                        "static void fbcon_set_disp(struct fb_info *info, struct fb_var_screeninfo *var,",
                        "\t\t\t   int unit)",
                        "{",
                        "\tstruct fbcon_display *p, *t;",
                        "\tstruct vc_data **default_mode, *vc;",
                        "\tstruct vc_data *svc;",
                        "\tstruct fbcon_ops *ops = info->fbcon_par;",
                        "\tint rows, cols;",
                        "",
                        "\tp = &fb_display[unit];",
                        "",
                        "\tif (var_to_display(p, var, info))",
                        "\t\treturn;",
                        "",
                        "\tvc = vc_cons[unit].d;",
                        "",
                        "\tif (!vc)",
                        "\t\treturn;",
                        "",
                        "\tdefault_mode = vc->vc_display_fg;",
                        "\tsvc = *default_mode;",
                        "\tt = &fb_display[svc->vc_num];",
                        "",
                        "\tif (!vc->vc_font.data) {",
                        "\t\tvc->vc_font.data = (void *)(p->fontdata = t->fontdata);",
                        "\t\tvc->vc_font.width = (*default_mode)->vc_font.width;",
                        "\t\tvc->vc_font.height = (*default_mode)->vc_font.height;",
                        "\t\tvc->vc_font.charcount = (*default_mode)->vc_font.charcount;",
                        "\t\tp->userfont = t->userfont;",
                        "\t\tif (p->userfont)",
                        "\t\t\tREFCOUNT(p->fontdata)++;",
                        "\t}",
                        "",
                        "\tvar->activate = FB_ACTIVATE_NOW;",
                        "\tinfo->var.activate = var->activate;",
                        "\tvar->yoffset = info->var.yoffset;",
                        "\tvar->xoffset = info->var.xoffset;",
                        "\tfb_set_var(info, var);",
                        "\tops->var = info->var;",
                        "\tvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);",
                        "\tvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;",
                        "\tif (vc->vc_font.charcount == 256) {",
                        "\t\tvc->vc_hi_font_mask = 0;",
                        "\t} else {",
                        "\t\tvc->vc_hi_font_mask = 0x100;",
                        "\t\tif (vc->vc_can_do_color)",
                        "\t\t\tvc->vc_complement_mask <<= 1;",
                        "\t}",
                        "",
                        "\tif (!*svc->vc_uni_pagedir_loc)",
                        "\t\tcon_set_default_unimap(svc);",
                        "\tif (!*vc->vc_uni_pagedir_loc)",
                        "\t\tcon_copy_unimap(vc, svc);",
                        "",
                        "\tcols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);",
                        "\trows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);",
                        "\tcols /= vc->vc_font.width;",
                        "\trows /= vc->vc_font.height;",
                        "\tvc_resize(vc, cols, rows);",
                        "",
                        "\tif (con_is_visible(vc)) {",
                        "\t\tupdate_screen(vc);",
                        "\t}",
                        "}"
                    ],
                    "start": 1352,
                    "highlight": 1410
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8146ec16"
        },
        "934": {
            "name": "fbcon_set_disp",
            "parent_idx": 920,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n816",
                    "code": [
                        "static void con2fb_init_display(struct vc_data *vc, struct fb_info *info,",
                        "\t\t\t\tint unit, int show_logo)",
                        "{",
                        "\tstruct fbcon_ops *ops = info->fbcon_par;",
                        "\tint ret;",
                        "",
                        "\tops->currcon = fg_console;",
                        "",
                        "\tif (info->fbops->fb_set_par && !(ops->flags & FBCON_FLAGS_INIT)) {",
                        "\t\tret = info->fbops->fb_set_par(info);",
                        "",
                        "\t\tif (ret)",
                        "\t\t\tprintk(KERN_ERR \"con2fb_init_display: detected \"",
                        "\t\t\t\t\"unhandled fb_set_par error, \"",
                        "\t\t\t\t\"error code %d\\n\", ret);",
                        "\t}",
                        "",
                        "\tops->flags |= FBCON_FLAGS_INIT;",
                        "\tops->graphics = 0;",
                        "\tfbcon_set_disp(info, &info->var, unit);",
                        "",
                        "\tif (show_logo) {",
                        "\t\tstruct vc_data *fg_vc = vc_cons[fg_console].d;",
                        "\t\tstruct fb_info *fg_info =",
                        "\t\t\tregistered_fb[con2fb_map[fg_console]];",
                        "",
                        "\t\tfbcon_prepare_logo(fg_vc, fg_info, fg_vc->vc_cols,",
                        "\t\t\t\t   fg_vc->vc_rows, fg_vc->vc_cols,",
                        "\t\t\t\t   fg_vc->vc_rows);",
                        "\t}",
                        "",
                        "\tupdate_screen(vc_cons[fg_console].d);",
                        "}"
                    ],
                    "start": 797,
                    "highlight": 816
                },
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n887",
                    "code": [
                        "/**",
                        " *\tset_con2fb_map - map console to frame buffer device",
                        " *\t@unit: virtual console number to map",
                        " *\t@newidx: frame buffer index to map virtual console to",
                        " *      @user: user request",
                        " *",
                        " *\tMaps a virtual console @unit to a frame buffer device",
                        " *\t@newidx.",
                        " *",
                        " *\tThis should be called with the console lock held.",
                        " */",
                        "static int set_con2fb_map(int unit, int newidx, int user)",
                        "{",
                        "\tstruct vc_data *vc = vc_cons[unit].d;",
                        "\tint oldidx = con2fb_map[unit];",
                        "\tstruct fb_info *info = registered_fb[newidx];",
                        "\tstruct fb_info *oldinfo = NULL;",
                        "\tint found, err = 0;",
                        "",
                        "\tWARN_CONSOLE_UNLOCKED();",
                        "",
                        "\tif (oldidx == newidx)",
                        "\t\treturn 0;",
                        "",
                        "\tif (!info)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (!search_for_mapped_con() || !con_is_bound(&fb_con)) {",
                        "\t\tinfo_idx = newidx;",
                        "\t\treturn do_fbcon_takeover(0);",
                        "\t}",
                        "",
                        "\tif (oldidx != -1)",
                        "\t\toldinfo = registered_fb[oldidx];",
                        "",
                        "\tfound = search_fb_in_map(newidx);",
                        "",
                        "\tcon2fb_map[unit] = newidx;",
                        "\tif (!err && !found)",
                        "\t\terr = con2fb_acquire_newinfo(vc, info, unit, oldidx);",
                        "",
                        "\t/*",
                        "\t * If old fb is not mapped to any of the consoles,",
                        "\t * fbcon should release it.",
                        "\t */",
                        "\tif (!err && oldinfo && !search_fb_in_map(oldidx))",
                        "\t\terr = con2fb_release_oldinfo(vc, oldinfo, info, unit, oldidx,",
                        "\t\t\t\t\t     found);",
                        "",
                        "\tif (!err) {",
                        "\t\tint show_logo = (fg_console == 0 && !user &&",
                        "\t\t\t\t logo_shown != FBCON_LOGO_DONTSHOW);",
                        "",
                        "\t\tif (!found)",
                        "\t\t\tfbcon_add_cursor_timer(info);",
                        "\t\tcon2fb_map_boot[unit] = newidx;",
                        "\t\tcon2fb_init_display(vc, info, unit, show_logo);",
                        "\t}",
                        "",
                        "\tif (!search_fb_in_map(info_idx))",
                        "\t\tinfo_idx = newidx;",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 831,
                    "highlight": 887
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81470dd5"
        },
        "920": {
            "name": "set_con2fb_map",
            "parent_idx": 905,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n3018",
                    "code": [
                        "int fbcon_set_con2fb_map_ioctl(void __user *argp)",
                        "{",
                        "\tstruct fb_con2fbmap con2fb;",
                        "\tint ret;",
                        "",
                        "\tif (copy_from_user(&con2fb, argp, sizeof(con2fb)))",
                        "\t\treturn -EFAULT;",
                        "\tif (con2fb.console < 1 || con2fb.console > MAX_NR_CONSOLES)",
                        "\t\treturn -EINVAL;",
                        "\tif (con2fb.framebuffer >= FB_MAX)",
                        "\t\treturn -EINVAL;",
                        "\tif (!registered_fb[con2fb.framebuffer])",
                        "\t\trequest_module(\"fb%d\", con2fb.framebuffer);",
                        "\tif (!registered_fb[con2fb.framebuffer]) {",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tconsole_lock();",
                        "\tret = set_con2fb_map(con2fb.console - 1,",
                        "\t\t\t     con2fb.framebuffer, 1);",
                        "\tconsole_unlock();",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3000,
                    "highlight": 3018
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81472ac4"
        },
        "905": {
            "name": "fbcon_set_con2fb_map_ioctl",
            "parent_idx": 903,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbmem.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbmem.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n1156",
                    "code": [
                        "static long do_fb_ioctl(struct fb_info *info, unsigned int cmd,",
                        "\t\t\tunsigned long arg)",
                        "{",
                        "\tconst struct fb_ops *fb;",
                        "\tstruct fb_var_screeninfo var;",
                        "\tstruct fb_fix_screeninfo fix;",
                        "\tstruct fb_cmap cmap_from;",
                        "\tstruct fb_cmap_user cmap;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tlong ret = 0;",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FBIOGET_VSCREENINFO:",
                        "\t\tlock_fb_info(info);",
                        "\t\tvar = info->var;",
                        "\t\tunlock_fb_info(info);",
                        "",
                        "\t\tret = copy_to_user(argp, &var, sizeof(var)) ? -EFAULT : 0;",
                        "\t\tbreak;",
                        "\tcase FBIOPUT_VSCREENINFO:",
                        "\t\tif (copy_from_user(&var, argp, sizeof(var)))",
                        "\t\t\treturn -EFAULT;",
                        "\t\tconsole_lock();",
                        "\t\tlock_fb_info(info);",
                        "\t\tret = fb_set_var(info, &var);",
                        "\t\tif (!ret)",
                        "\t\t\tfbcon_update_vcs(info, var.activate & FB_ACTIVATE_ALL);",
                        "\t\tunlock_fb_info(info);",
                        "\t\tconsole_unlock();",
                        "\t\tif (!ret && copy_to_user(argp, &var, sizeof(var)))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "\tcase FBIOGET_FSCREENINFO:",
                        "\t\tlock_fb_info(info);",
                        "\t\tmemcpy(&fix, &info->fix, sizeof(fix));",
                        "\t\tif (info->flags & FBINFO_HIDE_SMEM_START)",
                        "\t\t\tfix.smem_start = 0;",
                        "\t\tunlock_fb_info(info);",
                        "",
                        "\t\tret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0;",
                        "\t\tbreak;",
                        "\tcase FBIOPUTCMAP:",
                        "\t\tif (copy_from_user(&cmap, argp, sizeof(cmap)))",
                        "\t\t\treturn -EFAULT;",
                        "\t\tret = fb_set_user_cmap(&cmap, info);",
                        "\t\tbreak;",
                        "\tcase FBIOGETCMAP:",
                        "\t\tif (copy_from_user(&cmap, argp, sizeof(cmap)))",
                        "\t\t\treturn -EFAULT;",
                        "\t\tlock_fb_info(info);",
                        "\t\tcmap_from = info->cmap;",
                        "\t\tunlock_fb_info(info);",
                        "\t\tret = fb_cmap_to_user(&cmap_from, &cmap);",
                        "\t\tbreak;",
                        "\tcase FBIOPAN_DISPLAY:",
                        "\t\tif (copy_from_user(&var, argp, sizeof(var)))",
                        "\t\t\treturn -EFAULT;",
                        "\t\tconsole_lock();",
                        "\t\tlock_fb_info(info);",
                        "\t\tret = fb_pan_display(info, &var);",
                        "\t\tunlock_fb_info(info);",
                        "\t\tconsole_unlock();",
                        "\t\tif (ret == 0 && copy_to_user(argp, &var, sizeof(var)))",
                        "\t\t\treturn -EFAULT;",
                        "\t\tbreak;",
                        "\tcase FBIO_CURSOR:",
                        "\t\tret = -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FBIOGET_CON2FBMAP:",
                        "\t\tret = fbcon_get_con2fb_map_ioctl(argp);",
                        "\t\tbreak;",
                        "\tcase FBIOPUT_CON2FBMAP:",
                        "\t\tret = fbcon_set_con2fb_map_ioctl(argp);",
                        "\t\tbreak;",
                        "\tcase FBIOBLANK:",
                        "\t\tconsole_lock();",
                        "\t\tlock_fb_info(info);",
                        "\t\tret = fb_blank(info, arg);",
                        "\t\t/* might again call into fb_blank */",
                        "\t\tfbcon_fb_blanked(info, arg);",
                        "\t\tunlock_fb_info(info);",
                        "\t\tconsole_unlock();",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tlock_fb_info(info);",
                        "\t\tfb = info->fbops;",
                        "\t\tif (fb->fb_ioctl)",
                        "\t\t\tret = fb->fb_ioctl(info, cmd, arg);",
                        "\t\telse",
                        "\t\t\tret = -ENOTTY;",
                        "\t\tunlock_fb_info(info);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1084,
                    "highlight": 1156
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81466bb1"
        },
        "903": {
            "name": "do_fb_ioctl(indirect)",
            "parent_idx": 890,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n48",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 30,
                    "highlight": 48
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n753",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 739,
                    "highlight": 753
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n739",
                    "code": [
                        "/*",
                        " * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.",
                        " * It's just a simple helper for sys_ioctl and compat_sys_ioctl.",
                        " *",
                        " * When you add any new common ioctls to the switches above and below,",
                        " * please ensure they have compatible arguments in compat mode.",
                        " */",
                        "static int do_vfs_ioctl(struct file *filp, unsigned int fd,",
                        "\t\t\tunsigned int cmd, unsigned long arg)",
                        "{",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tstruct inode *inode = file_inode(filp);",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIOCLEX:",
                        "\t\tset_close_on_exec(fd, 1);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONCLEX:",
                        "\t\tset_close_on_exec(fd, 0);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONBIO:",
                        "\t\treturn ioctl_fionbio(filp, argp);",
                        "",
                        "\tcase FIOASYNC:",
                        "\t\treturn ioctl_fioasync(fd, filp, argp);",
                        "",
                        "\tcase FIOQSIZE:",
                        "\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||",
                        "\t\t    S_ISLNK(inode->i_mode)) {",
                        "\t\t\tloff_t res = inode_get_bytes(inode);",
                        "\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?",
                        "\t\t\t\t\t    -EFAULT : 0;",
                        "\t\t}",
                        "",
                        "\t\treturn -ENOTTY;",
                        "",
                        "\tcase FIFREEZE:",
                        "\t\treturn ioctl_fsfreeze(filp);",
                        "",
                        "\tcase FITHAW:",
                        "\t\treturn ioctl_fsthaw(filp);",
                        "",
                        "\tcase FS_IOC_FIEMAP:",
                        "\t\treturn ioctl_fiemap(filp, argp);",
                        "",
                        "\tcase FIGETBSZ:",
                        "\t\t/* anon_bdev filesystems may not have a block size */",
                        "\t\tif (!inode->i_sb->s_blocksize)",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
                        "",
                        "\tcase FICLONE:",
                        "\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);",
                        "",
                        "\tcase FICLONERANGE:",
                        "\t\treturn ioctl_file_clone_range(filp, argp);",
                        "",
                        "\tcase FIDEDUPERANGE:",
                        "\t\treturn ioctl_file_dedupe_range(filp, argp);",
                        "",
                        "\tcase FIONREAD:",
                        "\t\tif (!S_ISREG(inode->i_mode))",
                        "\t\t\treturn vfs_ioctl(filp, cmd, arg);",
                        "",
                        "\t\treturn put_user(i_size_read(inode) - filp->f_pos,",
                        "\t\t\t\t(int __user *)argp);",
                        "",
                        "\tdefault:",
                        "\t\tif (S_ISREG(inode->i_mode))",
                        "\t\t\treturn file_ioctl(filp, cmd, argp);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn -ENOIOCTLCMD;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 660,
                    "highlight": 739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811fb2e9"
        },
        "890": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 887,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b9939e"
        },
        "887": {
            "name": "do_syscall_64",
            "parent_idx": 881,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "881": {
            "name": "44_syscall_7",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1007": {
            "name": "+0x10e",
            "parent_idx": 996,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n1344",
                    "code": [
                        "static void fbcon_cursor(struct vc_data *vc, int mode)",
                        "{",
                        "\tstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];",
                        "\tstruct fbcon_ops *ops = info->fbcon_par;",
                        " \tint c = scr_readw((u16 *) vc->vc_pos);",
                        "",
                        "\tops->cur_blink_jiffies = msecs_to_jiffies(vc->vc_cur_blink_ms);",
                        "",
                        "\tif (fbcon_is_inactive(vc, info) || vc->vc_deccm != 1)",
                        "\t\treturn;",
                        "",
                        "\tif (vc->vc_cursor_type & CUR_SW)",
                        "\t\tfbcon_del_cursor_timer(info);",
                        "\telse",
                        "\t\tfbcon_add_cursor_timer(info);",
                        "",
                        "\tops->cursor_flash = (mode == CM_ERASE) ? 0 : 1;",
                        "",
                        "\tops->cursor(vc, info, mode, get_color(vc, info, c, 1),",
                        "\t\t    get_color(vc, info, c, 0));",
                        "}"
                    ],
                    "start": 1326,
                    "highlight": 1344
                }
            ],
            "ins_idx": 26,
            "addr": "0xffffffff8146f9fe"
        },
        "1006": {
            "name": "+0xdb",
            "parent_idx": 996,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n1344",
                    "code": [
                        "static void fbcon_cursor(struct vc_data *vc, int mode)",
                        "{",
                        "\tstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];",
                        "\tstruct fbcon_ops *ops = info->fbcon_par;",
                        " \tint c = scr_readw((u16 *) vc->vc_pos);",
                        "",
                        "\tops->cur_blink_jiffies = msecs_to_jiffies(vc->vc_cur_blink_ms);",
                        "",
                        "\tif (fbcon_is_inactive(vc, info) || vc->vc_deccm != 1)",
                        "\t\treturn;",
                        "",
                        "\tif (vc->vc_cursor_type & CUR_SW)",
                        "\t\tfbcon_del_cursor_timer(info);",
                        "\telse",
                        "\t\tfbcon_add_cursor_timer(info);",
                        "",
                        "\tops->cursor_flash = (mode == CM_ERASE) ? 0 : 1;",
                        "",
                        "\tops->cursor(vc, info, mode, get_color(vc, info, c, 1),",
                        "\t\t    get_color(vc, info, c, 0));",
                        "}"
                    ],
                    "start": 1326,
                    "highlight": 1344
                }
            ],
            "ins_idx": 44,
            "addr": "0xffffffff8146f9cb"
        },
        "120": {
            "name": "+0x0",
            "parent_idx": 119,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n2925",
                    "code": [
                        "#ifdef CONFIG_TRACING",
                        "void *kmem_cache_alloc_trace(struct kmem_cache *s, gfp_t gfpflags, size_t size)",
                        "{",
                        "\tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_);",
                        "\ttrace_kmalloc(_RET_IP_, ret, size, s->size, gfpflags);",
                        "\tret = kasan_kmalloc(s, ret, size, gfpflags);",
                        "\treturn ret;",
                        "}",
                        "EXPORT_SYMBOL(kmem_cache_alloc_trace);",
                        "#endif",
                        "",
                        "#ifdef CONFIG_NUMA",
                        "void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)",
                        "{",
                        "\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);",
                        "",
                        "\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,",
                        "\t\t\t\t    s->object_size, s->size, gfpflags, node);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2913,
                    "highlight": 2925
                }
            ],
            "ins_idx": 63,
            "addr": "0xffffffff811d9a70"
        },
        "119": {
            "name": "kmem_cache_alloc_trace",
            "parent_idx": 116,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n552",
                    "code": [
                        "/**",
                        " * kmalloc - allocate memory",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate.",
                        " *",
                        " * kmalloc is the normal method of allocating memory",
                        " * for objects smaller than page size in the kernel.",
                        " *",
                        " * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN",
                        " * bytes. For @size of power of two bytes, the alignment is also guaranteed",
                        " * to be at least to the size.",
                        " *",
                        " * The @flags argument may be one of the GFP flags defined at",
                        " * include/linux/gfp.h and described at",
                        " * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`",
                        " *",
                        " * The recommended usage of the @flags is described at",
                        " * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`",
                        " *",
                        " * Below is a brief outline of the most useful GFP flags",
                        " *",
                        " * %GFP_KERNEL",
                        " *\tAllocate normal kernel ram. May sleep.",
                        " *",
                        " * %GFP_NOWAIT",
                        " *\tAllocation will not sleep.",
                        " *",
                        " * %GFP_ATOMIC",
                        " *\tAllocation will not sleep.  May use emergency pools.",
                        " *",
                        " * %GFP_HIGHUSER",
                        " *\tAllocate memory from high memory on behalf of user.",
                        " *",
                        " * Also it is possible to set different flags by OR'ing",
                        " * in one or more of the following additional @flags:",
                        " *",
                        " * %__GFP_HIGH",
                        " *\tThis allocation has high priority and may use emergency pools.",
                        " *",
                        " * %__GFP_NOFAIL",
                        " *\tIndicate that this allocation is in no way allowed to fail",
                        " *\t(think twice before using).",
                        " *",
                        " * %__GFP_NORETRY",
                        " *\tIf memory is not immediately available,",
                        " *\tthen give up at once.",
                        " *",
                        " * %__GFP_NOWARN",
                        " *\tIf allocation fails, don't issue any warnings.",
                        " *",
                        " * %__GFP_RETRY_MAYFAIL",
                        " *\tTry really hard to succeed the allocation but fail",
                        " *\teventually.",
                        " */",
                        "static __always_inline void *kmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\tif (__builtin_constant_p(size)) {",
                        "#ifndef CONFIG_SLOB",
                        "\t\tunsigned int index;",
                        "#endif",
                        "\t\tif (size > KMALLOC_MAX_CACHE_SIZE)",
                        "\t\t\treturn kmalloc_large(size, flags);",
                        "#ifndef CONFIG_SLOB",
                        "\t\tindex = kmalloc_index(size);",
                        "",
                        "\t\tif (!index)",
                        "\t\t\treturn ZERO_SIZE_PTR;",
                        "",
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 484,
                    "highlight": 552
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n682",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 675,
                    "highlight": 682
                },
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n729",
                    "code": [
                        "static int con2fb_acquire_newinfo(struct vc_data *vc, struct fb_info *info,",
                        "\t\t\t\t  int unit, int oldidx)",
                        "{",
                        "\tstruct fbcon_ops *ops = NULL;",
                        "\tint err = 0;",
                        "",
                        "\tif (!try_module_get(info->fbops->owner))",
                        "\t\terr = -ENODEV;",
                        "",
                        "\tif (!err && info->fbops->fb_open &&",
                        "\t    info->fbops->fb_open(info, 0))",
                        "\t\terr = -ENODEV;",
                        "",
                        "\tif (!err) {",
                        "\t\tops = kzalloc(sizeof(struct fbcon_ops), GFP_KERNEL);",
                        "\t\tif (!ops)",
                        "\t\t\terr = -ENOMEM;",
                        "\t}",
                        "",
                        "\tif (!err) {",
                        "\t\tops->cur_blink_jiffies = HZ / 5;",
                        "\t\tops->info = info;",
                        "\t\tinfo->fbcon_par = ops;",
                        "",
                        "\t\tif (vc)",
                        "\t\t\tset_blitting_type(vc, info);",
                        "\t}",
                        "",
                        "\tif (err) {",
                        "\t\tcon2fb_map[unit] = oldidx;",
                        "\t\tmodule_put(info->fbops->owner);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 715,
                    "highlight": 729
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81470ade"
        },
        "116": {
            "name": "con2fb_acquire_newinfo",
            "parent_idx": 112,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n870",
                    "code": [
                        "/**",
                        " *\tset_con2fb_map - map console to frame buffer device",
                        " *\t@unit: virtual console number to map",
                        " *\t@newidx: frame buffer index to map virtual console to",
                        " *      @user: user request",
                        " *",
                        " *\tMaps a virtual console @unit to a frame buffer device",
                        " *\t@newidx.",
                        " *",
                        " *\tThis should be called with the console lock held.",
                        " */",
                        "static int set_con2fb_map(int unit, int newidx, int user)",
                        "{",
                        "\tstruct vc_data *vc = vc_cons[unit].d;",
                        "\tint oldidx = con2fb_map[unit];",
                        "\tstruct fb_info *info = registered_fb[newidx];",
                        "\tstruct fb_info *oldinfo = NULL;",
                        "\tint found, err = 0;",
                        "",
                        "\tWARN_CONSOLE_UNLOCKED();",
                        "",
                        "\tif (oldidx == newidx)",
                        "\t\treturn 0;",
                        "",
                        "\tif (!info)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (!search_for_mapped_con() || !con_is_bound(&fb_con)) {",
                        "\t\tinfo_idx = newidx;",
                        "\t\treturn do_fbcon_takeover(0);",
                        "\t}",
                        "",
                        "\tif (oldidx != -1)",
                        "\t\toldinfo = registered_fb[oldidx];",
                        "",
                        "\tfound = search_fb_in_map(newidx);",
                        "",
                        "\tcon2fb_map[unit] = newidx;",
                        "\tif (!err && !found)",
                        "\t\terr = con2fb_acquire_newinfo(vc, info, unit, oldidx);",
                        "",
                        "\t/*",
                        "\t * If old fb is not mapped to any of the consoles,",
                        "\t * fbcon should release it.",
                        "\t */",
                        "\tif (!err && oldinfo && !search_fb_in_map(oldidx))",
                        "\t\terr = con2fb_release_oldinfo(vc, oldinfo, info, unit, oldidx,",
                        "\t\t\t\t\t     found);",
                        "",
                        "\tif (!err) {",
                        "\t\tint show_logo = (fg_console == 0 && !user &&",
                        "\t\t\t\t logo_shown != FBCON_LOGO_DONTSHOW);",
                        "",
                        "\t\tif (!found)",
                        "\t\t\tfbcon_add_cursor_timer(info);",
                        "\t\tcon2fb_map_boot[unit] = newidx;",
                        "\t\tcon2fb_init_display(vc, info, unit, show_logo);",
                        "\t}",
                        "",
                        "\tif (!search_fb_in_map(info_idx))",
                        "\t\tinfo_idx = newidx;",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 831,
                    "highlight": 870
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81470e5f"
        },
        "112": {
            "name": "set_con2fb_map",
            "parent_idx": 99,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n3018",
                    "code": [
                        "int fbcon_set_con2fb_map_ioctl(void __user *argp)",
                        "{",
                        "\tstruct fb_con2fbmap con2fb;",
                        "\tint ret;",
                        "",
                        "\tif (copy_from_user(&con2fb, argp, sizeof(con2fb)))",
                        "\t\treturn -EFAULT;",
                        "\tif (con2fb.console < 1 || con2fb.console > MAX_NR_CONSOLES)",
                        "\t\treturn -EINVAL;",
                        "\tif (con2fb.framebuffer >= FB_MAX)",
                        "\t\treturn -EINVAL;",
                        "\tif (!registered_fb[con2fb.framebuffer])",
                        "\t\trequest_module(\"fb%d\", con2fb.framebuffer);",
                        "\tif (!registered_fb[con2fb.framebuffer]) {",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tconsole_lock();",
                        "\tret = set_con2fb_map(con2fb.console - 1,",
                        "\t\t\t     con2fb.framebuffer, 1);",
                        "\tconsole_unlock();",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3000,
                    "highlight": 3018
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81472ac4"
        },
        "99": {
            "name": "fbcon_set_con2fb_map_ioctl",
            "parent_idx": 97,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbmem.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbmem.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n1156",
                    "code": [
                        "static long do_fb_ioctl(struct fb_info *info, unsigned int cmd,",
                        "\t\t\tunsigned long arg)",
                        "{",
                        "\tconst struct fb_ops *fb;",
                        "\tstruct fb_var_screeninfo var;",
                        "\tstruct fb_fix_screeninfo fix;",
                        "\tstruct fb_cmap cmap_from;",
                        "\tstruct fb_cmap_user cmap;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tlong ret = 0;",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FBIOGET_VSCREENINFO:",
                        "\t\tlock_fb_info(info);",
                        "\t\tvar = info->var;",
                        "\t\tunlock_fb_info(info);",
                        "",
                        "\t\tret = copy_to_user(argp, &var, sizeof(var)) ? -EFAULT : 0;",
                        "\t\tbreak;",
                        "\tcase FBIOPUT_VSCREENINFO:",
                        "\t\tif (copy_from_user(&var, argp, sizeof(var)))",
                        "\t\t\treturn -EFAULT;",
                        "\t\tconsole_lock();",
                        "\t\tlock_fb_info(info);",
                        "\t\tret = fb_set_var(info, &var);",
                        "\t\tif (!ret)",
                        "\t\t\tfbcon_update_vcs(info, var.activate & FB_ACTIVATE_ALL);",
                        "\t\tunlock_fb_info(info);",
                        "\t\tconsole_unlock();",
                        "\t\tif (!ret && copy_to_user(argp, &var, sizeof(var)))",
                        "\t\t\tret = -EFAULT;",
                        "\t\tbreak;",
                        "\tcase FBIOGET_FSCREENINFO:",
                        "\t\tlock_fb_info(info);",
                        "\t\tmemcpy(&fix, &info->fix, sizeof(fix));",
                        "\t\tif (info->flags & FBINFO_HIDE_SMEM_START)",
                        "\t\t\tfix.smem_start = 0;",
                        "\t\tunlock_fb_info(info);",
                        "",
                        "\t\tret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0;",
                        "\t\tbreak;",
                        "\tcase FBIOPUTCMAP:",
                        "\t\tif (copy_from_user(&cmap, argp, sizeof(cmap)))",
                        "\t\t\treturn -EFAULT;",
                        "\t\tret = fb_set_user_cmap(&cmap, info);",
                        "\t\tbreak;",
                        "\tcase FBIOGETCMAP:",
                        "\t\tif (copy_from_user(&cmap, argp, sizeof(cmap)))",
                        "\t\t\treturn -EFAULT;",
                        "\t\tlock_fb_info(info);",
                        "\t\tcmap_from = info->cmap;",
                        "\t\tunlock_fb_info(info);",
                        "\t\tret = fb_cmap_to_user(&cmap_from, &cmap);",
                        "\t\tbreak;",
                        "\tcase FBIOPAN_DISPLAY:",
                        "\t\tif (copy_from_user(&var, argp, sizeof(var)))",
                        "\t\t\treturn -EFAULT;",
                        "\t\tconsole_lock();",
                        "\t\tlock_fb_info(info);",
                        "\t\tret = fb_pan_display(info, &var);",
                        "\t\tunlock_fb_info(info);",
                        "\t\tconsole_unlock();",
                        "\t\tif (ret == 0 && copy_to_user(argp, &var, sizeof(var)))",
                        "\t\t\treturn -EFAULT;",
                        "\t\tbreak;",
                        "\tcase FBIO_CURSOR:",
                        "\t\tret = -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FBIOGET_CON2FBMAP:",
                        "\t\tret = fbcon_get_con2fb_map_ioctl(argp);",
                        "\t\tbreak;",
                        "\tcase FBIOPUT_CON2FBMAP:",
                        "\t\tret = fbcon_set_con2fb_map_ioctl(argp);",
                        "\t\tbreak;",
                        "\tcase FBIOBLANK:",
                        "\t\tconsole_lock();",
                        "\t\tlock_fb_info(info);",
                        "\t\tret = fb_blank(info, arg);",
                        "\t\t/* might again call into fb_blank */",
                        "\t\tfbcon_fb_blanked(info, arg);",
                        "\t\tunlock_fb_info(info);",
                        "\t\tconsole_unlock();",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tlock_fb_info(info);",
                        "\t\tfb = info->fbops;",
                        "\t\tif (fb->fb_ioctl)",
                        "\t\t\tret = fb->fb_ioctl(info, cmd, arg);",
                        "\t\telse",
                        "\t\t\tret = -ENOTTY;",
                        "\t\tunlock_fb_info(info);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1084,
                    "highlight": 1156
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81466bb1"
        },
        "97": {
            "name": "do_fb_ioctl(indirect)",
            "parent_idx": 84,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n48",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 30,
                    "highlight": 48
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n753",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 739,
                    "highlight": 753
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n739",
                    "code": [
                        "/*",
                        " * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.",
                        " * It's just a simple helper for sys_ioctl and compat_sys_ioctl.",
                        " *",
                        " * When you add any new common ioctls to the switches above and below,",
                        " * please ensure they have compatible arguments in compat mode.",
                        " */",
                        "static int do_vfs_ioctl(struct file *filp, unsigned int fd,",
                        "\t\t\tunsigned int cmd, unsigned long arg)",
                        "{",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tstruct inode *inode = file_inode(filp);",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIOCLEX:",
                        "\t\tset_close_on_exec(fd, 1);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONCLEX:",
                        "\t\tset_close_on_exec(fd, 0);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONBIO:",
                        "\t\treturn ioctl_fionbio(filp, argp);",
                        "",
                        "\tcase FIOASYNC:",
                        "\t\treturn ioctl_fioasync(fd, filp, argp);",
                        "",
                        "\tcase FIOQSIZE:",
                        "\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||",
                        "\t\t    S_ISLNK(inode->i_mode)) {",
                        "\t\t\tloff_t res = inode_get_bytes(inode);",
                        "\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?",
                        "\t\t\t\t\t    -EFAULT : 0;",
                        "\t\t}",
                        "",
                        "\t\treturn -ENOTTY;",
                        "",
                        "\tcase FIFREEZE:",
                        "\t\treturn ioctl_fsfreeze(filp);",
                        "",
                        "\tcase FITHAW:",
                        "\t\treturn ioctl_fsthaw(filp);",
                        "",
                        "\tcase FS_IOC_FIEMAP:",
                        "\t\treturn ioctl_fiemap(filp, argp);",
                        "",
                        "\tcase FIGETBSZ:",
                        "\t\t/* anon_bdev filesystems may not have a block size */",
                        "\t\tif (!inode->i_sb->s_blocksize)",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
                        "",
                        "\tcase FICLONE:",
                        "\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);",
                        "",
                        "\tcase FICLONERANGE:",
                        "\t\treturn ioctl_file_clone_range(filp, argp);",
                        "",
                        "\tcase FIDEDUPERANGE:",
                        "\t\treturn ioctl_file_dedupe_range(filp, argp);",
                        "",
                        "\tcase FIONREAD:",
                        "\t\tif (!S_ISREG(inode->i_mode))",
                        "\t\t\treturn vfs_ioctl(filp, cmd, arg);",
                        "",
                        "\t\treturn put_user(i_size_read(inode) - filp->f_pos,",
                        "\t\t\t\t(int __user *)argp);",
                        "",
                        "\tdefault:",
                        "\t\tif (S_ISREG(inode->i_mode))",
                        "\t\t\treturn file_ioctl(filp, cmd, argp);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn -ENOIOCTLCMD;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 660,
                    "highlight": 739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811fb2e9"
        },
        "84": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 81,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b9939e"
        },
        "81": {
            "name": "do_syscall_64",
            "parent_idx": 75,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "75": {
            "name": "31_syscall_5",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1005": {
            "name": "+0x71",
            "parent_idx": 1001,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n423",
                    "code": [
                        "static void fbcon_add_cursor_timer(struct fb_info *info)",
                        "{",
                        "\tstruct fbcon_ops *ops = info->fbcon_par;",
                        "",
                        "\tif ((!info->queue.func || info->queue.func == fb_flashcursor) &&",
                        "\t    !(ops->flags & FBCON_FLAGS_CURSOR_TIMER) &&",
                        "\t    !fbcon_cursor_noblink) {",
                        "\t\tif (!info->queue.func)",
                        "\t\t\tINIT_WORK(&info->queue, fb_flashcursor);",
                        "",
                        "\t\ttimer_setup(&ops->cursor_timer, cursor_timer_handler, 0);",
                        "\t\tmod_timer(&ops->cursor_timer, jiffies + ops->cur_blink_jiffies);",
                        "\t\tops->flags |= FBCON_FLAGS_CURSOR_TIMER;",
                        "\t}",
                        "}"
                    ],
                    "start": 409,
                    "highlight": 423
                }
            ],
            "ins_idx": 62,
            "addr": "0xffffffff8146da21"
        },
        "1001": {
            "name": "fbcon_add_cursor_timer",
            "parent_idx": 996,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n1340",
                    "code": [
                        "static void fbcon_cursor(struct vc_data *vc, int mode)",
                        "{",
                        "\tstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];",
                        "\tstruct fbcon_ops *ops = info->fbcon_par;",
                        " \tint c = scr_readw((u16 *) vc->vc_pos);",
                        "",
                        "\tops->cur_blink_jiffies = msecs_to_jiffies(vc->vc_cur_blink_ms);",
                        "",
                        "\tif (fbcon_is_inactive(vc, info) || vc->vc_deccm != 1)",
                        "\t\treturn;",
                        "",
                        "\tif (vc->vc_cursor_type & CUR_SW)",
                        "\t\tfbcon_del_cursor_timer(info);",
                        "\telse",
                        "\t\tfbcon_add_cursor_timer(info);",
                        "",
                        "\tops->cursor_flash = (mode == CM_ERASE) ? 0 : 1;",
                        "",
                        "\tops->cursor(vc, info, mode, get_color(vc, info, c, 1),",
                        "\t\t    get_color(vc, info, c, 0));",
                        "}"
                    ],
                    "start": 1326,
                    "highlight": 1340
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8146f9b2"
        },
        "1003": {
            "name": "+0x16",
            "parent_idx": 1001,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n410",
                    "code": [
                        "static void fbcon_add_cursor_timer(struct fb_info *info)",
                        "{",
                        "\tstruct fbcon_ops *ops = info->fbcon_par;",
                        "",
                        "\tif ((!info->queue.func || info->queue.func == fb_flashcursor) &&",
                        "\t    !(ops->flags & FBCON_FLAGS_CURSOR_TIMER) &&",
                        "\t    !fbcon_cursor_noblink) {",
                        "\t\tif (!info->queue.func)",
                        "\t\t\tINIT_WORK(&info->queue, fb_flashcursor);",
                        "",
                        "\t\ttimer_setup(&ops->cursor_timer, cursor_timer_handler, 0);",
                        "\t\tmod_timer(&ops->cursor_timer, jiffies + ops->cur_blink_jiffies);",
                        "\t\tops->flags |= FBCON_FLAGS_CURSOR_TIMER;",
                        "\t}",
                        "}"
                    ],
                    "start": 409,
                    "highlight": 410
                }
            ],
            "ins_idx": 86,
            "addr": "0xffffffff8146d9c6"
        },
        "1000": {
            "name": "+0x35",
            "parent_idx": 996,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n1329",
                    "code": [
                        "static void fbcon_cursor(struct vc_data *vc, int mode)",
                        "{",
                        "\tstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];",
                        "\tstruct fbcon_ops *ops = info->fbcon_par;",
                        " \tint c = scr_readw((u16 *) vc->vc_pos);",
                        "",
                        "\tops->cur_blink_jiffies = msecs_to_jiffies(vc->vc_cur_blink_ms);",
                        "",
                        "\tif (fbcon_is_inactive(vc, info) || vc->vc_deccm != 1)",
                        "\t\treturn;",
                        "",
                        "\tif (vc->vc_cursor_type & CUR_SW)",
                        "\t\tfbcon_del_cursor_timer(info);",
                        "\telse",
                        "\t\tfbcon_add_cursor_timer(info);",
                        "",
                        "\tops->cursor_flash = (mode == CM_ERASE) ? 0 : 1;",
                        "",
                        "\tops->cursor(vc, info, mode, get_color(vc, info, c, 1),",
                        "\t\t    get_color(vc, info, c, 0));",
                        "}"
                    ],
                    "start": 1326,
                    "highlight": 1329
                }
            ],
            "ins_idx": 118,
            "addr": "0xffffffff8146f925"
        },
        "121": {
            "name": "+0x9f",
            "parent_idx": 116,
            "source_line": [
                {
                    "file": "drivers/video/fbdev/core/fbcon.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/video/fbdev/core/fbcon.c?id=0da0a8a0a0e1845f495431c3d8d733d2bbf9e9e5#n737",
                    "code": [
                        "static int con2fb_acquire_newinfo(struct vc_data *vc, struct fb_info *info,",
                        "\t\t\t\t  int unit, int oldidx)",
                        "{",
                        "\tstruct fbcon_ops *ops = NULL;",
                        "\tint err = 0;",
                        "",
                        "\tif (!try_module_get(info->fbops->owner))",
                        "\t\terr = -ENODEV;",
                        "",
                        "\tif (!err && info->fbops->fb_open &&",
                        "\t    info->fbops->fb_open(info, 0))",
                        "\t\terr = -ENODEV;",
                        "",
                        "\tif (!err) {",
                        "\t\tops = kzalloc(sizeof(struct fbcon_ops), GFP_KERNEL);",
                        "\t\tif (!ops)",
                        "\t\t\terr = -ENOMEM;",
                        "\t}",
                        "",
                        "\tif (!err) {",
                        "\t\tops->cur_blink_jiffies = HZ / 5;",
                        "\t\tops->info = info;",
                        "\t\tinfo->fbcon_par = ops;",
                        "",
                        "\t\tif (vc)",
                        "\t\t\tset_blitting_type(vc, info);",
                        "\t}",
                        "",
                        "\tif (err) {",
                        "\t\tcon2fb_map[unit] = oldidx;",
                        "\t\tmodule_put(info->fbops->owner);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 715,
                    "highlight": 737
                }
            ],
            "ins_idx": 162,
            "addr": "0xffffffff81470aff"
        }
    },
    "ins": {
        "8": {
            "name": "jmp rax",
            "desc": "Invalid Code Pointer",
            "call_idx": 1008,
            "inputs": [
                1755
            ],
            "outputs": [
                1756
            ]
        },
        "26": {
            "name": "mov rax, r15",
            "desc": "",
            "call_idx": 1007,
            "inputs": [
                1753
            ],
            "outputs": [
                1754
            ]
        },
        "44": {
            "name": "mov r15, qword ptr [rbx + 0x20]",
            "desc": "Heap Use Before Initialization",
            "call_idx": 1006,
            "inputs": [
                1750,
                1751
            ],
            "outputs": [
                1752
            ]
        },
        "63": {
            "name": "push r15",
            "desc": "Code pointer source MEMALLOC 0x0",
            "call_idx": 120,
            "inputs": [],
            "outputs": [
                175
            ]
        },
        "62": {
            "name": "pop rbx",
            "desc": "",
            "call_idx": 1005,
            "inputs": [
                1747,
                1748
            ],
            "outputs": [
                1749
            ]
        },
        "86": {
            "name": "push rbx",
            "desc": "",
            "call_idx": 1003,
            "inputs": [
                1743,
                1744
            ],
            "outputs": [
                1745
            ]
        },
        "118": {
            "name": "mov rbx, qword ptr [r12 + 0x348]",
            "desc": "",
            "call_idx": 1000,
            "inputs": [
                1739,
                1740
            ],
            "outputs": [
                1741
            ]
        },
        "162": {
            "name": "mov qword ptr [rbp + 0x348], rax",
            "desc": "",
            "call_idx": 121,
            "inputs": [
                176,
                177
            ],
            "outputs": [
                178
            ]
        }
    },
    "data": {
        "1755": {
            "name": "RAX",
            "ins_idx": 8,
            "value": "0x0",
            "sources": []
        },
        "1756": {
            "name": "RIP",
            "ins_idx": 8,
            "value": "0x0",
            "sources": []
        },
        "1753": {
            "name": "R15",
            "ins_idx": 26,
            "value": "0x0",
            "sources": []
        },
        "1754": {
            "name": "RAX",
            "ins_idx": 26,
            "value": "0x0",
            "sources": [
                1755
            ]
        },
        "1750": {
            "name": "RBX",
            "ins_idx": 44,
            "value": "0xffff888102556600",
            "sources": []
        },
        "1751": {
            "name": "[0xffff888102556620]",
            "ins_idx": 44,
            "value": "0x0",
            "sources": []
        },
        "1752": {
            "name": "R15",
            "ins_idx": 44,
            "value": "0x0",
            "sources": [
                1753
            ]
        },
        "175": {
            "name": "RAX",
            "ins_idx": 63,
            "value": "0xffff888102556600",
            "sources": [
                177
            ]
        },
        "1747": {
            "name": "RSP",
            "ins_idx": 62,
            "value": "0xffffc9000054fbd0",
            "sources": []
        },
        "1748": {
            "name": "[0xffffc9000054fbd0]",
            "ins_idx": 62,
            "value": "0xffff888102556600",
            "sources": []
        },
        "1749": {
            "name": "RBX",
            "ins_idx": 62,
            "value": "0xffff888102556600",
            "sources": [
                1750
            ]
        },
        "1743": {
            "name": "RSP",
            "ins_idx": 86,
            "value": "0xffffc9000054fbd8",
            "sources": []
        },
        "1744": {
            "name": "RBX",
            "ins_idx": 86,
            "value": "0xffff888102556600",
            "sources": []
        },
        "1745": {
            "name": "[0xffffc9000054fbd0]",
            "ins_idx": 86,
            "value": "0xffff888102556600",
            "sources": [
                1748
            ]
        },
        "1739": {
            "name": "R12",
            "ins_idx": 118,
            "value": "0xffff888101ba1800",
            "sources": []
        },
        "1740": {
            "name": "[0xffff888101ba1b48]",
            "ins_idx": 118,
            "value": "0xffff888102556600",
            "sources": []
        },
        "1741": {
            "name": "RBX",
            "ins_idx": 118,
            "value": "0xffff888102556600",
            "sources": [
                1744
            ]
        },
        "176": {
            "name": "RBP",
            "ins_idx": 162,
            "value": "0xffff888101ba1800",
            "sources": []
        },
        "177": {
            "name": "RAX",
            "ins_idx": 162,
            "value": "0xffff888102556600",
            "sources": []
        },
        "178": {
            "name": "[0xffff888101ba1b48]",
            "ins_idx": 162,
            "value": "0xffff888102556600",
            "sources": [
                1740
            ]
        }
    },
    "chain": {
        "8": [
            26
        ],
        "26": [
            44
        ],
        "44": [
            63,
            62
        ],
        "62": [
            86
        ],
        "86": [
            118
        ],
        "118": [
            162
        ],
        "162": [
            63
        ]
    }
}