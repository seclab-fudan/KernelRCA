{
    "report": "https://syzkaller.appspot.com/bug?id=7b960555c96033c67abee42d6eb6a95f24df8e99",
    "title": "general protection fault in ethnl_parse_header",
    "call": {
        "3201": {
            "name": "+0x1ea",
            "parent_idx": 3194,
            "source_line": [
                {
                    "file": "./include/linux/netlink.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/netlink.h?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n127",
                    "code": [
                        "static inline void nl_set_extack_cookie_u32(struct netlink_ext_ack *extack,",
                        "\t\t\t\t\t    u32 cookie)",
                        "{",
                        "\tu32 __cookie = cookie;",
                        "",
                        "\tmemcpy(extack->cookie, &__cookie, sizeof(__cookie));",
                        "\textack->cookie_len = sizeof(__cookie);",
                        "}"
                    ],
                    "start": 122,
                    "highlight": 127
                },
                {
                    "file": "net/ethtool/netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ethtool/netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n59",
                    "code": [
                        "/**",
                        " * ethnl_parse_header() - parse request header",
                        " * @req_info:    structure to put results into",
                        " * @header:      nest attribute with request header",
                        " * @net:         request netns",
                        " * @extack:      netlink extack for error reporting",
                        " * @require_dev: fail if no device identified in header",
                        " *",
                        " * Parse request header in nested attribute @nest and puts results into",
                        " * the structure pointed to by @req_info. Extack from @info is used for error",
                        " * reporting. If req_info->dev is not null on return, reference to it has",
                        " * been taken. If error is returned, *req_info is null initialized and no",
                        " * reference is held.",
                        " *",
                        " * Return: 0 on success or negative error code",
                        " */",
                        "int ethnl_parse_header(struct ethnl_req_info *req_info,",
                        "\t\t       const struct nlattr *header, struct net *net,",
                        "\t\t       struct netlink_ext_ack *extack, bool require_dev)",
                        "{",
                        "\tstruct nlattr *tb[ETHTOOL_A_HEADER_MAX + 1];",
                        "\tconst struct nlattr *devname_attr;",
                        "\tstruct net_device *dev = NULL;",
                        "\tu32 flags = 0;",
                        "\tint ret;",
                        "",
                        "\tif (!header) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"request header missing\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "\tret = nla_parse_nested(tb, ETHTOOL_A_HEADER_MAX, header,",
                        "\t\t\t       ethnl_header_policy, extack);",
                        "\tif (ret < 0)",
                        "\t\treturn ret;",
                        "\tif (tb[ETHTOOL_A_HEADER_FLAGS]) {",
                        "\t\tflags = nla_get_u32(tb[ETHTOOL_A_HEADER_FLAGS]);",
                        "\t\tif (flags & ~ETHTOOL_FLAG_ALL) {",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_HEADER_FLAGS],",
                        "\t\t\t\t\t    \"unrecognized request flags\");",
                        "\t\t\tnl_set_extack_cookie_u32(extack, ETHTOOL_FLAG_ALL);",
                        "\t\t\treturn -EOPNOTSUPP;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tdevname_attr = tb[ETHTOOL_A_HEADER_DEV_NAME];",
                        "\tif (tb[ETHTOOL_A_HEADER_DEV_INDEX]) {",
                        "\t\tu32 ifindex = nla_get_u32(tb[ETHTOOL_A_HEADER_DEV_INDEX]);",
                        "",
                        "\t\tdev = dev_get_by_index(net, ifindex);",
                        "\t\tif (!dev) {",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(extack,",
                        "\t\t\t\t\t    tb[ETHTOOL_A_HEADER_DEV_INDEX],",
                        "\t\t\t\t\t    \"no device matches ifindex\");",
                        "\t\t\treturn -ENODEV;",
                        "\t\t}",
                        "\t\t/* if both ifindex and ifname are passed, they must match */",
                        "\t\tif (devname_attr &&",
                        "\t\t    strncmp(dev->name, nla_data(devname_attr), IFNAMSIZ)) {",
                        "\t\t\tdev_put(dev);",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(extack, header,",
                        "\t\t\t\t\t    \"ifindex and name do not match\");",
                        "\t\t\treturn -ENODEV;",
                        "\t\t}",
                        "\t} else if (devname_attr) {",
                        "\t\tdev = dev_get_by_name(net, nla_data(devname_attr));",
                        "\t\tif (!dev) {",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(extack, devname_attr,",
                        "\t\t\t\t\t    \"no device matches name\");",
                        "\t\t\treturn -ENODEV;",
                        "\t\t}",
                        "\t} else if (require_dev) {",
                        "\t\tNL_SET_ERR_MSG_ATTR(extack, header,",
                        "\t\t\t\t    \"neither ifindex nor name specified\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (dev && !netif_device_present(dev)) {",
                        "\t\tdev_put(dev);",
                        "\t\tNL_SET_ERR_MSG(extack, \"device not present\");",
                        "\t\treturn -ENODEV;",
                        "\t}",
                        "",
                        "\treq_info->dev = dev;",
                        "\treq_info->flags = flags;",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 20,
                    "highlight": 59
                }
            ],
            "ins_idx": 1,
            "addr": "0xffffffff818f0fca"
        },
        "3194": {
            "name": "ethnl_parse_header",
            "parent_idx": 3186,
            "source_line": [
                {
                    "file": "net/ethtool/netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ethtool/netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n264",
                    "code": [
                        "/**",
                        " * ethnl_default_parse() - Parse request message",
                        " * @req_info:    pointer to structure to put data into",
                        " * @nlhdr:       pointer to request message header",
                        " * @net:         request netns",
                        " * @request_ops: struct request_ops for request type",
                        " * @extack:      netlink extack for error reporting",
                        " * @require_dev: fail if no device identified in header",
                        " *",
                        " * Parse universal request header and call request specific ->parse_request()",
                        " * callback (if defined) to parse the rest of the message.",
                        " *",
                        " * Return: 0 on success or negative error code",
                        " */",
                        "static int ethnl_default_parse(struct ethnl_req_info *req_info,",
                        "\t\t\t       const struct nlmsghdr *nlhdr, struct net *net,",
                        "\t\t\t       const struct ethnl_request_ops *request_ops,",
                        "\t\t\t       struct netlink_ext_ack *extack, bool require_dev)",
                        "{",
                        "\tstruct nlattr **tb;",
                        "\tint ret;",
                        "",
                        "\ttb = kmalloc_array(request_ops->max_attr + 1, sizeof(tb[0]),",
                        "\t\t\t   GFP_KERNEL);",
                        "\tif (!tb)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tret = nlmsg_parse(nlhdr, GENL_HDRLEN, tb, request_ops->max_attr,",
                        "\t\t\t  request_ops->request_policy, extack);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "\tret = ethnl_parse_header(req_info, tb[request_ops->hdr_attr], net,",
                        "\t\t\t\t extack, require_dev);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tif (request_ops->parse_request) {",
                        "\t\tret = request_ops->parse_request(req_info, tb, extack);",
                        "\t\tif (ret < 0)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tret = 0;",
                        "out:",
                        "\tkfree(tb);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 233,
                    "highlight": 264
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818f10bc"
        },
        "3186": {
            "name": "ethnl_default_parse",
            "parent_idx": 3183,
            "source_line": [
                {
                    "file": "net/ethtool/netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ethtool/netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n492",
                    "code": [
                        "/* generic ->start() handler for GET requests */",
                        "static int ethnl_default_start(struct netlink_callback *cb)",
                        "{",
                        "\tstruct ethnl_dump_ctx *ctx = ethnl_dump_context(cb);",
                        "\tstruct ethnl_reply_data *reply_data;",
                        "\tconst struct ethnl_request_ops *ops;",
                        "\tstruct ethnl_req_info *req_info;",
                        "\tstruct genlmsghdr *ghdr;",
                        "\tint ret;",
                        "",
                        "\tBUILD_BUG_ON(sizeof(*ctx) > sizeof(cb->ctx));",
                        "",
                        "\tghdr = nlmsg_data(cb->nlh);",
                        "\tops = ethnl_default_requests[ghdr->cmd];",
                        "\tif (WARN_ONCE(!ops, \"cmd %u has no ethnl_request_ops\\n\", ghdr->cmd))",
                        "\t\treturn -EOPNOTSUPP;",
                        "\treq_info = kzalloc(ops->req_info_size, GFP_KERNEL);",
                        "\tif (!req_info)",
                        "\t\treturn -ENOMEM;",
                        "\treply_data = kmalloc(ops->reply_data_size, GFP_KERNEL);",
                        "\tif (!reply_data) {",
                        "\t\tret = -ENOMEM;",
                        "\t\tgoto free_req_info;",
                        "\t}",
                        "",
                        "\tret = ethnl_default_parse(req_info, cb->nlh, sock_net(cb->skb->sk), ops,",
                        "\t\t\t\t  cb->extack, false);",
                        "\tif (req_info->dev) {",
                        "\t\t/* We ignore device specification in dump requests but as the",
                        "\t\t * same parser as for non-dump (doit) requests is used, it",
                        "\t\t * would take reference to the device if it finds one",
                        "\t\t */",
                        "\t\tdev_put(req_info->dev);",
                        "\t\treq_info->dev = NULL;",
                        "\t}",
                        "\tif (ret < 0)",
                        "\t\tgoto free_reply_data;",
                        "",
                        "\tctx->ops = ops;",
                        "\tctx->req_info = req_info;",
                        "\tctx->reply_data = reply_data;",
                        "\tctx->pos_hash = 0;",
                        "\tctx->pos_idx = 0;",
                        "",
                        "\treturn 0;",
                        "",
                        "free_reply_data:",
                        "\tkfree(reply_data);",
                        "free_req_info:",
                        "\tkfree(req_info);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 467,
                    "highlight": 492
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818f1198"
        },
        "3183": {
            "name": "ethnl_default_start(indirect)",
            "parent_idx": 3093,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n2343",
                    "code": [
                        "int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,",
                        "\t\t\t const struct nlmsghdr *nlh,",
                        "\t\t\t struct netlink_dump_control *control)",
                        "{",
                        "\tstruct netlink_sock *nlk, *nlk2;",
                        "\tstruct netlink_callback *cb;",
                        "\tstruct sock *sk;",
                        "\tint ret;",
                        "",
                        "\trefcount_inc(&skb->users);",
                        "",
                        "\tsk = netlink_lookup(sock_net(ssk), ssk->sk_protocol, NETLINK_CB(skb).portid);",
                        "\tif (sk == NULL) {",
                        "\t\tret = -ECONNREFUSED;",
                        "\t\tgoto error_free;",
                        "\t}",
                        "",
                        "\tnlk = nlk_sk(sk);",
                        "\tmutex_lock(nlk->cb_mutex);",
                        "\t/* A dump is in progress... */",
                        "\tif (nlk->cb_running) {",
                        "\t\tret = -EBUSY;",
                        "\t\tgoto error_unlock;",
                        "\t}",
                        "\t/* add reference of module which cb->dump belongs to */",
                        "\tif (!try_module_get(control->module)) {",
                        "\t\tret = -EPROTONOSUPPORT;",
                        "\t\tgoto error_unlock;",
                        "\t}",
                        "",
                        "\tcb = &nlk->cb;",
                        "\tmemset(cb, 0, sizeof(*cb));",
                        "\tcb->dump = control->dump;",
                        "\tcb->done = control->done;",
                        "\tcb->nlh = nlh;",
                        "\tcb->data = control->data;",
                        "\tcb->module = control->module;",
                        "\tcb->min_dump_alloc = control->min_dump_alloc;",
                        "\tcb->skb = skb;",
                        "",
                        "\tnlk2 = nlk_sk(NETLINK_CB(skb).sk);",
                        "\tcb->strict_check = !!(nlk2->flags & NETLINK_F_STRICT_CHK);",
                        "",
                        "\tif (control->start) {",
                        "\t\tret = control->start(cb);",
                        "\t\tif (ret)",
                        "\t\t\tgoto error_put;",
                        "\t}",
                        "",
                        "\tnlk->cb_running = true;",
                        "\tnlk->dump_done_errno = INT_MAX;",
                        "",
                        "\tmutex_unlock(nlk->cb_mutex);",
                        "",
                        "\tret = netlink_dump(sk);",
                        "",
                        "\tsock_put(sk);",
                        "",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\t/* We successfully started a dump, by returning -EINTR we",
                        "\t * signal not to send ACK even if it was requested.",
                        "\t */",
                        "\treturn -EINTR;",
                        "",
                        "error_put:",
                        "\tmodule_put(control->module);",
                        "error_unlock:",
                        "\tsock_put(sk);",
                        "\tmutex_unlock(nlk->cb_mutex);",
                        "error_free:",
                        "\tkfree_skb(skb);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2299,
                    "highlight": 2343
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818e6d33"
        },
        "3093": {
            "name": "__netlink_dump_start",
            "parent_idx": 3077,
            "source_line": [
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n630",
                    "code": [
                        "static int genl_family_rcv_msg_dumpit(const struct genl_family *family,",
                        "\t\t\t\t      struct sk_buff *skb,",
                        "\t\t\t\t      struct nlmsghdr *nlh,",
                        "\t\t\t\t      struct netlink_ext_ack *extack,",
                        "\t\t\t\t      const struct genl_ops *ops,",
                        "\t\t\t\t      int hdrlen, struct net *net)",
                        "{",
                        "\tstruct genl_dumpit_info *info;",
                        "\tstruct nlattr **attrs = NULL;",
                        "\tint err;",
                        "",
                        "\tif (!ops->dumpit)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tif (ops->validate & GENL_DONT_VALIDATE_DUMP)",
                        "\t\tgoto no_attrs;",
                        "",
                        "\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tattrs = genl_family_rcv_msg_attrs_parse(family, nlh, extack,",
                        "\t\t\t\t\t\tops, hdrlen,",
                        "\t\t\t\t\t\tGENL_DONT_VALIDATE_DUMP_STRICT,",
                        "\t\t\t\t\t\ttrue);",
                        "\tif (IS_ERR(attrs))",
                        "\t\treturn PTR_ERR(attrs);",
                        "",
                        "no_attrs:",
                        "\t/* Allocate dumpit info. It is going to be freed by done() callback. */",
                        "\tinfo = genl_dumpit_info_alloc();",
                        "\tif (!info) {",
                        "\t\tgenl_family_rcv_msg_attrs_free(family, attrs, true);",
                        "\t\treturn -ENOMEM;",
                        "\t}",
                        "",
                        "\tinfo->family = family;",
                        "\tinfo->ops = ops;",
                        "\tinfo->attrs = attrs;",
                        "",
                        "\tif (!family->parallel_ops) {",
                        "\t\tstruct netlink_dump_control c = {",
                        "\t\t\t.module = family->module,",
                        "\t\t\t.data = info,",
                        "\t\t\t.start = genl_lock_start,",
                        "\t\t\t.dump = genl_lock_dumpit,",
                        "\t\t\t.done = genl_lock_done,",
                        "\t\t};",
                        "",
                        "\t\tgenl_unlock();",
                        "\t\terr = __netlink_dump_start(net->genl_sock, skb, nlh, &c);",
                        "\t\tgenl_lock();",
                        "",
                        "\t} else {",
                        "\t\tstruct netlink_dump_control c = {",
                        "\t\t\t.module = family->module,",
                        "\t\t\t.data = info,",
                        "\t\t\t.start = ops->start,",
                        "\t\t\t.dump = ops->dumpit,",
                        "\t\t\t.done = genl_parallel_done,",
                        "\t\t};",
                        "",
                        "\t\terr = __netlink_dump_start(net->genl_sock, skb, nlh, &c);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 569,
                    "highlight": 630
                },
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n715",
                    "code": [
                        "static int genl_family_rcv_msg(const struct genl_family *family,",
                        "\t\t\t       struct sk_buff *skb,",
                        "\t\t\t       struct nlmsghdr *nlh,",
                        "\t\t\t       struct netlink_ext_ack *extack)",
                        "{",
                        "\tconst struct genl_ops *ops;",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct genlmsghdr *hdr = nlmsg_data(nlh);",
                        "\tint hdrlen;",
                        "",
                        "\t/* this family doesn't exist in this netns */",
                        "\tif (!family->netnsok && !net_eq(net, &init_net))",
                        "\t\treturn -ENOENT;",
                        "",
                        "\thdrlen = GENL_HDRLEN + family->hdrsize;",
                        "\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tops = genl_get_cmd(hdr->cmd, family);",
                        "\tif (ops == NULL)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tif ((ops->flags & GENL_ADMIN_PERM) &&",
                        "\t    !netlink_capable(skb, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\tif ((ops->flags & GENL_UNS_ADMIN_PERM) &&",
                        "\t    !netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\tif ((nlh->nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP)",
                        "\t\treturn genl_family_rcv_msg_dumpit(family, skb, nlh, extack,",
                        "\t\t\t\t\t\t  ops, hdrlen, net);",
                        "\telse",
                        "\t\treturn genl_family_rcv_msg_doit(family, skb, nlh, extack,",
                        "\t\t\t\t\t\tops, hdrlen, net);",
                        "}"
                    ],
                    "start": 684,
                    "highlight": 715
                },
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n735",
                    "code": [
                        "static int genl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\tstruct netlink_ext_ack *extack)",
                        "{",
                        "\tconst struct genl_family *family;",
                        "\tint err;",
                        "",
                        "\tfamily = genl_family_find_byid(nlh->nlmsg_type);",
                        "\tif (family == NULL)",
                        "\t\treturn -ENOENT;",
                        "",
                        "\tif (!family->parallel_ops)",
                        "\t\tgenl_lock();",
                        "",
                        "\terr = genl_family_rcv_msg(family, skb, nlh, extack);",
                        "",
                        "\tif (!family->parallel_ops)",
                        "\t\tgenl_unlock();",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 722,
                    "highlight": 735
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818eb0e2"
        },
        "3077": {
            "name": "genl_rcv_msg(indirect)",
            "parent_idx": 3074,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n2469",
                    "code": [
                        "int netlink_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *,",
                        "\t\t\t\t\t\t   struct nlmsghdr *,",
                        "\t\t\t\t\t\t   struct netlink_ext_ack *))",
                        "{",
                        "\tstruct netlink_ext_ack extack;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tint err;",
                        "",
                        "\twhile (skb->len >= nlmsg_total_size(0)) {",
                        "\t\tint msglen;",
                        "",
                        "\t\tmemset(&extack, 0, sizeof(extack));",
                        "\t\tnlh = nlmsg_hdr(skb);",
                        "\t\terr = 0;",
                        "",
                        "\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len)",
                        "\t\t\treturn 0;",
                        "",
                        "\t\t/* Only requests are handled by the kernel */",
                        "\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST))",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\t/* Skip control messages */",
                        "\t\tif (nlh->nlmsg_type < NLMSG_MIN_TYPE)",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\terr = cb(skb, nlh, &extack);",
                        "\t\tif (err == -EINTR)",
                        "\t\t\tgoto skip;",
                        "",
                        "ack:",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err)",
                        "\t\t\tnetlink_ack(skb, nlh, err, &extack);",
                        "",
                        "skip:",
                        "\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);",
                        "\t\tif (msglen > skb->len)",
                        "\t\t\tmsglen = skb->len;",
                        "\t\tskb_pull(skb, msglen);",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 2443,
                    "highlight": 2469
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818e8f3d"
        },
        "3074": {
            "name": "netlink_rcv_skb",
            "parent_idx": 3065,
            "source_line": [
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n746",
                    "code": [
                        "static void genl_rcv(struct sk_buff *skb)",
                        "{",
                        "\tdown_read(&cb_lock);",
                        "\tnetlink_rcv_skb(skb, &genl_rcv_msg);",
                        "\tup_read(&cb_lock);",
                        "}"
                    ],
                    "start": 743,
                    "highlight": 746
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818e976a"
        },
        "3065": {
            "name": "genl_rcv(indirect)",
            "parent_idx": 2963,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n1303",
                    "code": [
                        "static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,",
                        "\t\t\t\t  struct sock *ssk)",
                        "{",
                        "\tint ret;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "",
                        "\tret = -ECONNREFUSED;",
                        "\tif (nlk->netlink_rcv != NULL) {",
                        "\t\tret = skb->len;",
                        "\t\tnetlink_skb_set_owner_r(skb, sk);",
                        "\t\tNETLINK_CB(skb).sk = ssk;",
                        "\t\tnetlink_deliver_tap_kernel(sk, ssk, skb);",
                        "\t\tnlk->netlink_rcv(skb);",
                        "\t\tconsume_skb(skb);",
                        "\t} else {",
                        "\t\tkfree_skb(skb);",
                        "\t}",
                        "\tsock_put(sk);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1291,
                    "highlight": 1303
                },
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n1329",
                    "code": [
                        "int netlink_unicast(struct sock *ssk, struct sk_buff *skb,",
                        "\t\t    u32 portid, int nonblock)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tint err;",
                        "\tlong timeo;",
                        "",
                        "\tskb = netlink_trim(skb, gfp_any());",
                        "",
                        "\ttimeo = sock_sndtimeo(ssk, nonblock);",
                        "retry:",
                        "\tsk = netlink_getsockbyportid(ssk, portid);",
                        "\tif (IS_ERR(sk)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn PTR_ERR(sk);",
                        "\t}",
                        "\tif (netlink_is_kernel(sk))",
                        "\t\treturn netlink_unicast_kernel(sk, skb, ssk);",
                        "",
                        "\tif (sk_filter(sk, skb)) {",
                        "\t\terr = skb->len;",
                        "\t\tkfree_skb(skb);",
                        "\t\tsock_put(sk);",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = netlink_attachskb(sk, skb, &timeo, ssk);",
                        "\tif (err == 1)",
                        "\t\tgoto retry;",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\treturn netlink_sendskb(sk, skb);",
                        "}"
                    ],
                    "start": 1312,
                    "highlight": 1329
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818e86cf"
        },
        "2963": {
            "name": "netlink_unicast",
            "parent_idx": 2815,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n1918",
                    "code": [
                        "static int netlink_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "\tDECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);",
                        "\tu32 dst_portid;",
                        "\tu32 dst_group;",
                        "\tstruct sk_buff *skb;",
                        "\tint err;",
                        "\tstruct scm_cookie scm;",
                        "\tu32 netlink_skb_flags = 0;",
                        "",
                        "\tif (msg->msg_flags&MSG_OOB)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\terr = scm_send(sock, msg, &scm, true);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tif (msg->msg_namelen) {",
                        "\t\terr = -EINVAL;",
                        "\t\tif (msg->msg_namelen < sizeof(struct sockaddr_nl))",
                        "\t\t\tgoto out;",
                        "\t\tif (addr->nl_family != AF_NETLINK)",
                        "\t\t\tgoto out;",
                        "\t\tdst_portid = addr->nl_pid;",
                        "\t\tdst_group = ffs(addr->nl_groups);",
                        "\t\terr =  -EPERM;",
                        "\t\tif ((dst_group || dst_portid) &&",
                        "\t\t    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))",
                        "\t\t\tgoto out;",
                        "\t\tnetlink_skb_flags |= NETLINK_SKB_DST;",
                        "\t} else {",
                        "\t\tdst_portid = nlk->dst_portid;",
                        "\t\tdst_group = nlk->dst_group;",
                        "\t}",
                        "",
                        "\tif (!nlk->bound) {",
                        "\t\terr = netlink_autobind(sock);",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t} else {",
                        "\t\t/* Ensure nlk is hashed and visible. */",
                        "\t\tsmp_rmb();",
                        "\t}",
                        "",
                        "\terr = -EMSGSIZE;",
                        "\tif (len > sk->sk_sndbuf - 32)",
                        "\t\tgoto out;",
                        "\terr = -ENOBUFS;",
                        "\tskb = netlink_alloc_large_skb(len, dst_group);",
                        "\tif (skb == NULL)",
                        "\t\tgoto out;",
                        "",
                        "\tNETLINK_CB(skb).portid\t= nlk->portid;",
                        "\tNETLINK_CB(skb).dst_group = dst_group;",
                        "\tNETLINK_CB(skb).creds\t= scm.creds;",
                        "\tNETLINK_CB(skb).flags\t= netlink_skb_flags;",
                        "",
                        "\terr = -EFAULT;",
                        "\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\terr = security_netlink_send(sk, skb);",
                        "\tif (err) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (dst_group) {",
                        "\t\trefcount_inc(&skb->users);",
                        "\t\tnetlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);",
                        "\t}",
                        "\terr = netlink_unicast(sk, skb, dst_portid, msg->msg_flags&MSG_DONTWAIT);",
                        "",
                        "out:",
                        "\tscm_destroy(&scm);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1843,
                    "highlight": 1918
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818e89bb"
        },
        "2815": {
            "name": "netlink_sendmsg(indirect)",
            "parent_idx": 2807,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n652",
                    "code": [
                        "INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t   size_t));",
                        "INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t    size_t));",
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,",
                        "\t\t\t\t     inet_sendmsg, sock, msg,",
                        "\t\t\t\t     msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 646,
                    "highlight": 652
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n672",
                    "code": [
                        "/**",
                        " *\tsock_sendmsg - send a message through @sock",
                        " *\t@sock: socket",
                        " *\t@msg: message to send",
                        " *",
                        " *\tSends @msg through @sock, passing through LSM.",
                        " *\tReturns the number of bytes sent, or an error code.",
                        " */",
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 659,
                    "highlight": 672
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818782b4"
        },
        "2807": {
            "name": "sock_sendmsg",
            "parent_idx": 2804,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n2343",
                    "code": [
                        "static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,",
                        "\t\t\t   unsigned int flags, struct used_address *used_address,",
                        "\t\t\t   unsigned int allowed_msghdr_flags)",
                        "{",
                        "\tunsigned char ctl[sizeof(struct cmsghdr) + 20]",
                        "\t\t\t\t__aligned(sizeof(__kernel_size_t));",
                        "\t/* 20 is size of ipv6_pktinfo */",
                        "\tunsigned char *ctl_buf = ctl;",
                        "\tint ctl_len;",
                        "\tssize_t err;",
                        "",
                        "\terr = -ENOBUFS;",
                        "",
                        "\tif (msg_sys->msg_controllen > INT_MAX)",
                        "\t\tgoto out;",
                        "\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);",
                        "\tctl_len = msg_sys->msg_controllen;",
                        "\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
                        "\t\terr =",
                        "\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,",
                        "\t\t\t\t\t\t     sizeof(ctl));",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t\tctl_buf = msg_sys->msg_control;",
                        "\t\tctl_len = msg_sys->msg_controllen;",
                        "\t} else if (ctl_len) {",
                        "\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=",
                        "\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));",
                        "\t\tif (ctl_len > sizeof(ctl)) {",
                        "\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);",
                        "\t\t\tif (ctl_buf == NULL)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\terr = -EFAULT;",
                        "\t\t/*",
                        "\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.",
                        "\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted",
                        "\t\t * checking falls down on this.",
                        "\t\t */",
                        "\t\tif (copy_from_user(ctl_buf,",
                        "\t\t\t\t   (void __user __force *)msg_sys->msg_control,",
                        "\t\t\t\t   ctl_len))",
                        "\t\t\tgoto out_freectl;",
                        "\t\tmsg_sys->msg_control = ctl_buf;",
                        "\t}",
                        "\tmsg_sys->msg_flags = flags;",
                        "",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;",
                        "\t/*",
                        "\t * If this is sendmmsg() and current destination address is same as",
                        "\t * previously succeeded address, omit asking LSM's decision.",
                        "\t * used_address->name_len is initialized to UINT_MAX so that the first",
                        "\t * destination address never matches.",
                        "\t */",
                        "\tif (used_address && msg_sys->msg_name &&",
                        "\t    used_address->name_len == msg_sys->msg_namelen &&",
                        "\t    !memcmp(&used_address->name, msg_sys->msg_name,",
                        "\t\t    used_address->name_len)) {",
                        "\t\terr = sock_sendmsg_nosec(sock, msg_sys);",
                        "\t\tgoto out_freectl;",
                        "\t}",
                        "\terr = sock_sendmsg(sock, msg_sys);",
                        "\t/*",
                        "\t * If this is sendmmsg() and sending to current destination address was",
                        "\t * successful, remember it.",
                        "\t */",
                        "\tif (used_address && err >= 0) {",
                        "\t\tused_address->name_len = msg_sys->msg_namelen;",
                        "\t\tif (msg_sys->msg_name)",
                        "\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,",
                        "\t\t\t       used_address->name_len);",
                        "\t}",
                        "",
                        "out_freectl:",
                        "\tif (ctl_buf != ctl)",
                        "\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2281,
                    "highlight": 2343
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818785c9"
        },
        "2804": {
            "name": "____sys_sendmsg",
            "parent_idx": 2795,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n2397",
                    "code": [
                        "\terr = ____sys_sendmsg(sock, msg_sys, flags, used_address,",
                        "\t\t\t\tallowed_msghdr_flags);",
                        "\tkfree(iov);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2397,
                    "highlight": 2397
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81878f52"
        },
        "2795": {
            "name": "___sys_sendmsg",
            "parent_idx": 2773,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n2430",
                    "code": [
                        "\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);",
                        "",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2430,
                    "highlight": 2430
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8187b01f"
        },
        "2773": {
            "name": "__x64_sys_sendmsg(indirect)",
            "parent_idx": 2770,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n294",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 281,
                    "highlight": 294
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81002829"
        },
        "2770": {
            "name": "do_syscall_64",
            "parent_idx": 2762,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "2762": {
            "name": "75_syscall_7",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "3195": {
            "name": "+0x8",
            "parent_idx": 3194,
            "source_line": [
                {
                    "file": "net/ethtool/netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ethtool/netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n39",
                    "code": [
                        "/**",
                        " * ethnl_parse_header() - parse request header",
                        " * @req_info:    structure to put results into",
                        " * @header:      nest attribute with request header",
                        " * @net:         request netns",
                        " * @extack:      netlink extack for error reporting",
                        " * @require_dev: fail if no device identified in header",
                        " *",
                        " * Parse request header in nested attribute @nest and puts results into",
                        " * the structure pointed to by @req_info. Extack from @info is used for error",
                        " * reporting. If req_info->dev is not null on return, reference to it has",
                        " * been taken. If error is returned, *req_info is null initialized and no",
                        " * reference is held.",
                        " *",
                        " * Return: 0 on success or negative error code",
                        " */",
                        "int ethnl_parse_header(struct ethnl_req_info *req_info,",
                        "\t\t       const struct nlattr *header, struct net *net,",
                        "\t\t       struct netlink_ext_ack *extack, bool require_dev)",
                        "{",
                        "\tstruct nlattr *tb[ETHTOOL_A_HEADER_MAX + 1];",
                        "\tconst struct nlattr *devname_attr;",
                        "\tstruct net_device *dev = NULL;",
                        "\tu32 flags = 0;",
                        "\tint ret;",
                        "",
                        "\tif (!header) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"request header missing\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "\tret = nla_parse_nested(tb, ETHTOOL_A_HEADER_MAX, header,",
                        "\t\t\t       ethnl_header_policy, extack);",
                        "\tif (ret < 0)",
                        "\t\treturn ret;",
                        "\tif (tb[ETHTOOL_A_HEADER_FLAGS]) {",
                        "\t\tflags = nla_get_u32(tb[ETHTOOL_A_HEADER_FLAGS]);",
                        "\t\tif (flags & ~ETHTOOL_FLAG_ALL) {",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[ETHTOOL_A_HEADER_FLAGS],",
                        "\t\t\t\t\t    \"unrecognized request flags\");",
                        "\t\t\tnl_set_extack_cookie_u32(extack, ETHTOOL_FLAG_ALL);",
                        "\t\t\treturn -EOPNOTSUPP;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tdevname_attr = tb[ETHTOOL_A_HEADER_DEV_NAME];",
                        "\tif (tb[ETHTOOL_A_HEADER_DEV_INDEX]) {",
                        "\t\tu32 ifindex = nla_get_u32(tb[ETHTOOL_A_HEADER_DEV_INDEX]);",
                        "",
                        "\t\tdev = dev_get_by_index(net, ifindex);",
                        "\t\tif (!dev) {",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(extack,",
                        "\t\t\t\t\t    tb[ETHTOOL_A_HEADER_DEV_INDEX],",
                        "\t\t\t\t\t    \"no device matches ifindex\");",
                        "\t\t\treturn -ENODEV;",
                        "\t\t}",
                        "\t\t/* if both ifindex and ifname are passed, they must match */",
                        "\t\tif (devname_attr &&",
                        "\t\t    strncmp(dev->name, nla_data(devname_attr), IFNAMSIZ)) {",
                        "\t\t\tdev_put(dev);",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(extack, header,",
                        "\t\t\t\t\t    \"ifindex and name do not match\");",
                        "\t\t\treturn -ENODEV;",
                        "\t\t}",
                        "\t} else if (devname_attr) {",
                        "\t\tdev = dev_get_by_name(net, nla_data(devname_attr));",
                        "\t\tif (!dev) {",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(extack, devname_attr,",
                        "\t\t\t\t\t    \"no device matches name\");",
                        "\t\t\treturn -ENODEV;",
                        "\t\t}",
                        "\t} else if (require_dev) {",
                        "\t\tNL_SET_ERR_MSG_ATTR(extack, header,",
                        "\t\t\t\t    \"neither ifindex nor name specified\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (dev && !netif_device_present(dev)) {",
                        "\t\tdev_put(dev);",
                        "\t\tNL_SET_ERR_MSG(extack, \"device not present\");",
                        "\t\treturn -ENODEV;",
                        "\t}",
                        "",
                        "\treq_info->dev = dev;",
                        "\treq_info->flags = flags;",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 20,
                    "highlight": 39
                }
            ],
            "ins_idx": 62,
            "addr": "0xffffffff818f0de8"
        },
        "3193": {
            "name": "+0x79",
            "parent_idx": 3186,
            "source_line": [
                {
                    "file": "net/ethtool/netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ethtool/netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n264",
                    "code": [
                        "/**",
                        " * ethnl_default_parse() - Parse request message",
                        " * @req_info:    pointer to structure to put data into",
                        " * @nlhdr:       pointer to request message header",
                        " * @net:         request netns",
                        " * @request_ops: struct request_ops for request type",
                        " * @extack:      netlink extack for error reporting",
                        " * @require_dev: fail if no device identified in header",
                        " *",
                        " * Parse universal request header and call request specific ->parse_request()",
                        " * callback (if defined) to parse the rest of the message.",
                        " *",
                        " * Return: 0 on success or negative error code",
                        " */",
                        "static int ethnl_default_parse(struct ethnl_req_info *req_info,",
                        "\t\t\t       const struct nlmsghdr *nlhdr, struct net *net,",
                        "\t\t\t       const struct ethnl_request_ops *request_ops,",
                        "\t\t\t       struct netlink_ext_ack *extack, bool require_dev)",
                        "{",
                        "\tstruct nlattr **tb;",
                        "\tint ret;",
                        "",
                        "\ttb = kmalloc_array(request_ops->max_attr + 1, sizeof(tb[0]),",
                        "\t\t\t   GFP_KERNEL);",
                        "\tif (!tb)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tret = nlmsg_parse(nlhdr, GENL_HDRLEN, tb, request_ops->max_attr,",
                        "\t\t\t  request_ops->request_policy, extack);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "\tret = ethnl_parse_header(req_info, tb[request_ops->hdr_attr], net,",
                        "\t\t\t\t extack, require_dev);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tif (request_ops->parse_request) {",
                        "\t\tret = request_ops->parse_request(req_info, tb, extack);",
                        "\t\tif (ret < 0)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tret = 0;",
                        "out:",
                        "\tkfree(tb);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 233,
                    "highlight": 264
                }
            ],
            "ins_idx": 90,
            "addr": "0xffffffff818f10a9"
        },
        "3187": {
            "name": "+0x9",
            "parent_idx": 3186,
            "source_line": [
                {
                    "file": "net/ethtool/netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ethtool/netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n251",
                    "code": [
                        "/**",
                        " * ethnl_default_parse() - Parse request message",
                        " * @req_info:    pointer to structure to put data into",
                        " * @nlhdr:       pointer to request message header",
                        " * @net:         request netns",
                        " * @request_ops: struct request_ops for request type",
                        " * @extack:      netlink extack for error reporting",
                        " * @require_dev: fail if no device identified in header",
                        " *",
                        " * Parse universal request header and call request specific ->parse_request()",
                        " * callback (if defined) to parse the rest of the message.",
                        " *",
                        " * Return: 0 on success or negative error code",
                        " */",
                        "static int ethnl_default_parse(struct ethnl_req_info *req_info,",
                        "\t\t\t       const struct nlmsghdr *nlhdr, struct net *net,",
                        "\t\t\t       const struct ethnl_request_ops *request_ops,",
                        "\t\t\t       struct netlink_ext_ack *extack, bool require_dev)",
                        "{",
                        "\tstruct nlattr **tb;",
                        "\tint ret;",
                        "",
                        "\ttb = kmalloc_array(request_ops->max_attr + 1, sizeof(tb[0]),",
                        "\t\t\t   GFP_KERNEL);",
                        "\tif (!tb)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tret = nlmsg_parse(nlhdr, GENL_HDRLEN, tb, request_ops->max_attr,",
                        "\t\t\t  request_ops->request_policy, extack);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "\tret = ethnl_parse_header(req_info, tb[request_ops->hdr_attr], net,",
                        "\t\t\t\t extack, require_dev);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tif (request_ops->parse_request) {",
                        "\t\tret = request_ops->parse_request(req_info, tb, extack);",
                        "\t\tif (ret < 0)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tret = 0;",
                        "out:",
                        "\tkfree(tb);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 233,
                    "highlight": 251
                }
            ],
            "ins_idx": 186,
            "addr": "0xffffffff818f1039"
        },
        "3185": {
            "name": "+0x69",
            "parent_idx": 3183,
            "source_line": [
                {
                    "file": "net/ethtool/netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ethtool/netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n492",
                    "code": [
                        "/* generic ->start() handler for GET requests */",
                        "static int ethnl_default_start(struct netlink_callback *cb)",
                        "{",
                        "\tstruct ethnl_dump_ctx *ctx = ethnl_dump_context(cb);",
                        "\tstruct ethnl_reply_data *reply_data;",
                        "\tconst struct ethnl_request_ops *ops;",
                        "\tstruct ethnl_req_info *req_info;",
                        "\tstruct genlmsghdr *ghdr;",
                        "\tint ret;",
                        "",
                        "\tBUILD_BUG_ON(sizeof(*ctx) > sizeof(cb->ctx));",
                        "",
                        "\tghdr = nlmsg_data(cb->nlh);",
                        "\tops = ethnl_default_requests[ghdr->cmd];",
                        "\tif (WARN_ONCE(!ops, \"cmd %u has no ethnl_request_ops\\n\", ghdr->cmd))",
                        "\t\treturn -EOPNOTSUPP;",
                        "\treq_info = kzalloc(ops->req_info_size, GFP_KERNEL);",
                        "\tif (!req_info)",
                        "\t\treturn -ENOMEM;",
                        "\treply_data = kmalloc(ops->reply_data_size, GFP_KERNEL);",
                        "\tif (!reply_data) {",
                        "\t\tret = -ENOMEM;",
                        "\t\tgoto free_req_info;",
                        "\t}",
                        "",
                        "\tret = ethnl_default_parse(req_info, cb->nlh, sock_net(cb->skb->sk), ops,",
                        "\t\t\t\t  cb->extack, false);",
                        "\tif (req_info->dev) {",
                        "\t\t/* We ignore device specification in dump requests but as the",
                        "\t\t * same parser as for non-dump (doit) requests is used, it",
                        "\t\t * would take reference to the device if it finds one",
                        "\t\t */",
                        "\t\tdev_put(req_info->dev);",
                        "\t\treq_info->dev = NULL;",
                        "\t}",
                        "\tif (ret < 0)",
                        "\t\tgoto free_reply_data;",
                        "",
                        "\tctx->ops = ops;",
                        "\tctx->req_info = req_info;",
                        "\tctx->reply_data = reply_data;",
                        "\tctx->pos_hash = 0;",
                        "\tctx->pos_idx = 0;",
                        "",
                        "\treturn 0;",
                        "",
                        "free_reply_data:",
                        "\tkfree(reply_data);",
                        "free_req_info:",
                        "\tkfree(req_info);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 467,
                    "highlight": 492
                }
            ],
            "ins_idx": 211,
            "addr": "0xffffffff818f1189"
        },
        "3181": {
            "name": "+0x14c",
            "parent_idx": 3093,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n2330",
                    "code": [
                        "int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,",
                        "\t\t\t const struct nlmsghdr *nlh,",
                        "\t\t\t struct netlink_dump_control *control)",
                        "{",
                        "\tstruct netlink_sock *nlk, *nlk2;",
                        "\tstruct netlink_callback *cb;",
                        "\tstruct sock *sk;",
                        "\tint ret;",
                        "",
                        "\trefcount_inc(&skb->users);",
                        "",
                        "\tsk = netlink_lookup(sock_net(ssk), ssk->sk_protocol, NETLINK_CB(skb).portid);",
                        "\tif (sk == NULL) {",
                        "\t\tret = -ECONNREFUSED;",
                        "\t\tgoto error_free;",
                        "\t}",
                        "",
                        "\tnlk = nlk_sk(sk);",
                        "\tmutex_lock(nlk->cb_mutex);",
                        "\t/* A dump is in progress... */",
                        "\tif (nlk->cb_running) {",
                        "\t\tret = -EBUSY;",
                        "\t\tgoto error_unlock;",
                        "\t}",
                        "\t/* add reference of module which cb->dump belongs to */",
                        "\tif (!try_module_get(control->module)) {",
                        "\t\tret = -EPROTONOSUPPORT;",
                        "\t\tgoto error_unlock;",
                        "\t}",
                        "",
                        "\tcb = &nlk->cb;",
                        "\tmemset(cb, 0, sizeof(*cb));",
                        "\tcb->dump = control->dump;",
                        "\tcb->done = control->done;",
                        "\tcb->nlh = nlh;",
                        "\tcb->data = control->data;",
                        "\tcb->module = control->module;",
                        "\tcb->min_dump_alloc = control->min_dump_alloc;",
                        "\tcb->skb = skb;",
                        "",
                        "\tnlk2 = nlk_sk(NETLINK_CB(skb).sk);",
                        "\tcb->strict_check = !!(nlk2->flags & NETLINK_F_STRICT_CHK);",
                        "",
                        "\tif (control->start) {",
                        "\t\tret = control->start(cb);",
                        "\t\tif (ret)",
                        "\t\t\tgoto error_put;",
                        "\t}",
                        "",
                        "\tnlk->cb_running = true;",
                        "\tnlk->dump_done_errno = INT_MAX;",
                        "",
                        "\tmutex_unlock(nlk->cb_mutex);",
                        "",
                        "\tret = netlink_dump(sk);",
                        "",
                        "\tsock_put(sk);",
                        "",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\t/* We successfully started a dump, by returning -EINTR we",
                        "\t * signal not to send ACK even if it was requested.",
                        "\t */",
                        "\treturn -EINTR;",
                        "",
                        "error_put:",
                        "\tmodule_put(control->module);",
                        "error_unlock:",
                        "\tsock_put(sk);",
                        "\tmutex_unlock(nlk->cb_mutex);",
                        "error_free:",
                        "\tkfree_skb(skb);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2299,
                    "highlight": 2330
                }
            ],
            "ins_idx": 237,
            "addr": "0xffffffff818e6ccc"
        },
        "3173": {
            "name": "+0x11d",
            "parent_idx": 3093,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=2363d73a2f3e92787f336721c40918ba2eb0c74c#n2330",
                    "code": [
                        "int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,",
                        "\t\t\t const struct nlmsghdr *nlh,",
                        "\t\t\t struct netlink_dump_control *control)",
                        "{",
                        "\tstruct netlink_sock *nlk, *nlk2;",
                        "\tstruct netlink_callback *cb;",
                        "\tstruct sock *sk;",
                        "\tint ret;",
                        "",
                        "\trefcount_inc(&skb->users);",
                        "",
                        "\tsk = netlink_lookup(sock_net(ssk), ssk->sk_protocol, NETLINK_CB(skb).portid);",
                        "\tif (sk == NULL) {",
                        "\t\tret = -ECONNREFUSED;",
                        "\t\tgoto error_free;",
                        "\t}",
                        "",
                        "\tnlk = nlk_sk(sk);",
                        "\tmutex_lock(nlk->cb_mutex);",
                        "\t/* A dump is in progress... */",
                        "\tif (nlk->cb_running) {",
                        "\t\tret = -EBUSY;",
                        "\t\tgoto error_unlock;",
                        "\t}",
                        "\t/* add reference of module which cb->dump belongs to */",
                        "\tif (!try_module_get(control->module)) {",
                        "\t\tret = -EPROTONOSUPPORT;",
                        "\t\tgoto error_unlock;",
                        "\t}",
                        "",
                        "\tcb = &nlk->cb;",
                        "\tmemset(cb, 0, sizeof(*cb));",
                        "\tcb->dump = control->dump;",
                        "\tcb->done = control->done;",
                        "\tcb->nlh = nlh;",
                        "\tcb->data = control->data;",
                        "\tcb->module = control->module;",
                        "\tcb->min_dump_alloc = control->min_dump_alloc;",
                        "\tcb->skb = skb;",
                        "",
                        "\tnlk2 = nlk_sk(NETLINK_CB(skb).sk);",
                        "\tcb->strict_check = !!(nlk2->flags & NETLINK_F_STRICT_CHK);",
                        "",
                        "\tif (control->start) {",
                        "\t\tret = control->start(cb);",
                        "\t\tif (ret)",
                        "\t\t\tgoto error_put;",
                        "\t}",
                        "",
                        "\tnlk->cb_running = true;",
                        "\tnlk->dump_done_errno = INT_MAX;",
                        "",
                        "\tmutex_unlock(nlk->cb_mutex);",
                        "",
                        "\tret = netlink_dump(sk);",
                        "",
                        "\tsock_put(sk);",
                        "",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\t/* We successfully started a dump, by returning -EINTR we",
                        "\t * signal not to send ACK even if it was requested.",
                        "\t */",
                        "\treturn -EINTR;",
                        "",
                        "error_put:",
                        "\tmodule_put(control->module);",
                        "error_unlock:",
                        "\tsock_put(sk);",
                        "\tmutex_unlock(nlk->cb_mutex);",
                        "error_free:",
                        "\tkfree_skb(skb);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2299,
                    "highlight": 2330
                }
            ],
            "ins_idx": 268,
            "addr": "0xffffffff818e6c9d"
        }
    },
    "ins": {
        "1": {
            "name": "mov dword ptr [r12 + 0x10], 3",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x10",
            "call_idx": 3201,
            "inputs": [
                6219
            ],
            "outputs": [
                6220
            ]
        },
        "62": {
            "name": "mov r12, rcx",
            "desc": "",
            "call_idx": 3195,
            "inputs": [
                6209
            ],
            "outputs": [
                6210
            ]
        },
        "90": {
            "name": "mov rcx, r13",
            "desc": "",
            "call_idx": 3193,
            "inputs": [
                6207
            ],
            "outputs": [
                6208
            ]
        },
        "186": {
            "name": "mov r13, r8",
            "desc": "",
            "call_idx": 3187,
            "inputs": [
                6197
            ],
            "outputs": [
                6198
            ]
        },
        "211": {
            "name": "mov r8, qword ptr [rbx + 0x30]",
            "desc": "",
            "call_idx": 3185,
            "inputs": [
                6194,
                6195
            ],
            "outputs": [
                6196
            ]
        },
        "237": {
            "name": "rep stosq qword ptr [rdi], rax",
            "desc": "",
            "call_idx": 3181,
            "inputs": [
                6187,
                6188
            ],
            "outputs": [
                6189
            ]
        },
        "268": {
            "name": "xor eax, eax",
            "desc": "Source of base address CONST 0x0",
            "call_idx": 3173,
            "inputs": [
                6165,
                6166
            ],
            "outputs": [
                6167
            ]
        }
    },
    "data": {
        "6219": {
            "name": "R12",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "6220": {
            "name": "[0x10]",
            "ins_idx": 1,
            "value": "0x3",
            "sources": []
        },
        "6209": {
            "name": "RCX",
            "ins_idx": 62,
            "value": "0x0",
            "sources": []
        },
        "6210": {
            "name": "R12",
            "ins_idx": 62,
            "value": "0x0",
            "sources": [
                6219
            ]
        },
        "6207": {
            "name": "R13",
            "ins_idx": 90,
            "value": "0x0",
            "sources": []
        },
        "6208": {
            "name": "RCX",
            "ins_idx": 90,
            "value": "0x0",
            "sources": [
                6209
            ]
        },
        "6197": {
            "name": "R8",
            "ins_idx": 186,
            "value": "0x0",
            "sources": []
        },
        "6198": {
            "name": "R13",
            "ins_idx": 186,
            "value": "0x0",
            "sources": [
                6207
            ]
        },
        "6194": {
            "name": "RBX",
            "ins_idx": 211,
            "value": "0xffff88823541e330",
            "sources": []
        },
        "6195": {
            "name": "[0xffff88823541e360]",
            "ins_idx": 211,
            "value": "0x0",
            "sources": []
        },
        "6196": {
            "name": "R8",
            "ins_idx": 211,
            "value": "0x0",
            "sources": [
                6197
            ]
        },
        "6187": {
            "name": "RAX",
            "ins_idx": 237,
            "value": "0x0",
            "sources": []
        },
        "6188": {
            "name": "RDI",
            "ins_idx": 237,
            "value": "0xffff88823541e360",
            "sources": []
        },
        "6189": {
            "name": "[0xffff88823541e360]",
            "ins_idx": 237,
            "value": "0x0",
            "sources": [
                6195
            ]
        },
        "6165": {
            "name": "RAX",
            "ins_idx": 268,
            "value": "0x0",
            "sources": []
        },
        "6166": {
            "name": "RAX",
            "ins_idx": 268,
            "value": "0x0",
            "sources": []
        },
        "6167": {
            "name": "RAX",
            "ins_idx": 268,
            "value": "0x0",
            "sources": [
                6187
            ]
        }
    },
    "chain": {
        "1": [
            62
        ],
        "62": [
            90
        ],
        "90": [
            186
        ],
        "186": [
            211
        ],
        "211": [
            237
        ],
        "237": [
            268
        ]
    }
}