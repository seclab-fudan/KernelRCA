{
    "report": "https://syzkaller.appspot.com/bug?id=3f6daa8df2d01d0560d3944fe06728c8c9ba5eff",
    "title": "KASAN: slab-out-of-bounds Read in f2fs_build_segment_manager",
    "call": {
        "4389": {
            "name": "+0x2e02",
            "parent_idx": 3331,
            "source_line": [
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4710",
                    "code": [
                        "/*",
                        " * Update min, max modified time for cost-benefit GC algorithm",
                        " */",
                        "static void init_min_max_mtime(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct sit_info *sit_i = SIT_I(sbi);",
                        "\tunsigned int segno;",
                        "",
                        "\tdown_write(&sit_i->sentry_lock);",
                        "",
                        "\tsit_i->min_mtime = ULLONG_MAX;",
                        "",
                        "\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {",
                        "\t\tunsigned int i;",
                        "\t\tunsigned long long mtime = 0;",
                        "",
                        "\t\tfor (i = 0; i < sbi->segs_per_sec; i++)",
                        "\t\t\tmtime += get_seg_entry(sbi, segno + i)->mtime;",
                        "",
                        "\t\tmtime = div_u64(mtime, sbi->segs_per_sec);",
                        "",
                        "\t\tif (sit_i->min_mtime > mtime)",
                        "\t\t\tsit_i->min_mtime = mtime;",
                        "\t}",
                        "\tsit_i->max_mtime = get_mtime(sbi, false);",
                        "\tup_write(&sit_i->sentry_lock);",
                        "}"
                    ],
                    "start": 4693,
                    "highlight": 4710
                },
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4792",
                    "code": [
                        "int f2fs_build_segment_manager(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);",
                        "\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);",
                        "\tstruct f2fs_sm_info *sm_info;",
                        "\tint err;",
                        "",
                        "\tsm_info = f2fs_kzalloc(sbi, sizeof(struct f2fs_sm_info), GFP_KERNEL);",
                        "\tif (!sm_info)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\t/* init sm info */",
                        "\tsbi->sm_info = sm_info;",
                        "\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);",
                        "\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);",
                        "\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);",
                        "\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);",
                        "\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);",
                        "\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);",
                        "\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);",
                        "\tsm_info->rec_prefree_segments = sm_info->main_segments *",
                        "\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;",
                        "\tif (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)",
                        "\t\tsm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;",
                        "",
                        "\tif (!f2fs_lfs_mode(sbi))",
                        "\t\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;",
                        "\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;",
                        "\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;",
                        "\tsm_info->min_seq_blocks = sbi->blocks_per_seg * sbi->segs_per_sec;",
                        "\tsm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;",
                        "\tsm_info->min_ssr_sections = reserved_sections(sbi);",
                        "",
                        "\tINIT_LIST_HEAD(&sm_info->sit_entry_set);",
                        "",
                        "\tinit_rwsem(&sm_info->curseg_lock);",
                        "",
                        "\tif (!f2fs_readonly(sbi->sb)) {",
                        "\t\terr = f2fs_create_flush_cmd_control(sbi);",
                        "\t\tif (err)",
                        "\t\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = create_discard_cmd_control(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = build_sit_info(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_free_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\t/* reinit free segmap based on SIT */",
                        "\terr = build_sit_entries(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_free_segmap(sbi);",
                        "\terr = build_dirty_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = sanity_check_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_min_max_mtime(sbi);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 4721,
                    "highlight": 4792
                }
            ],
            "ins_idx": 33,
            "addr": "0xffffffff8161ec92"
        },
        "3331": {
            "name": "f2fs_build_segment_manager",
            "parent_idx": 2889,
            "source_line": [
                {
                    "file": "fs/f2fs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/super.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n3633",
                    "code": [
                        "static int f2fs_fill_super(struct super_block *sb, void *data, int silent)",
                        "{",
                        "\tstruct f2fs_sb_info *sbi;",
                        "\tstruct f2fs_super_block *raw_super;",
                        "\tstruct inode *root;",
                        "\tint err;",
                        "\tbool skip_recovery = false, need_fsck = false;",
                        "\tchar *options = NULL;",
                        "\tint recovery, i, valid_super_block;",
                        "\tstruct curseg_info *seg_i;",
                        "\tint retry_cnt = 1;",
                        "",
                        "try_onemore:",
                        "\terr = -EINVAL;",
                        "\traw_super = NULL;",
                        "\tvalid_super_block = -1;",
                        "\trecovery = 0;",
                        "",
                        "\t/* allocate memory for f2fs-specific super block info */",
                        "\tsbi = kzalloc(sizeof(struct f2fs_sb_info), GFP_KERNEL);",
                        "\tif (!sbi)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tsbi->sb = sb;",
                        "",
                        "\t/* Load the checksum driver */",
                        "\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32\", 0, 0);",
                        "\tif (IS_ERR(sbi->s_chksum_driver)) {",
                        "\t\tf2fs_err(sbi, \"Cannot load crc32 driver.\");",
                        "\t\terr = PTR_ERR(sbi->s_chksum_driver);",
                        "\t\tsbi->s_chksum_driver = NULL;",
                        "\t\tgoto free_sbi;",
                        "\t}",
                        "",
                        "\t/* set a block size */",
                        "\tif (unlikely(!sb_set_blocksize(sb, F2FS_BLKSIZE))) {",
                        "\t\tf2fs_err(sbi, \"unable to set blocksize\");",
                        "\t\tgoto free_sbi;",
                        "\t}",
                        "",
                        "\terr = read_raw_super_block(sbi, &raw_super, &valid_super_block,",
                        "\t\t\t\t\t\t\t\t&recovery);",
                        "\tif (err)",
                        "\t\tgoto free_sbi;",
                        "",
                        "\tsb->s_fs_info = sbi;",
                        "\tsbi->raw_super = raw_super;",
                        "",
                        "\t/* precompute checksum seed for metadata */",
                        "\tif (f2fs_sb_has_inode_chksum(sbi))",
                        "\t\tsbi->s_chksum_seed = f2fs_chksum(sbi, ~0, raw_super->uuid,",
                        "\t\t\t\t\t\tsizeof(raw_super->uuid));",
                        "",
                        "\t/*",
                        "\t * The BLKZONED feature indicates that the drive was formatted with",
                        "\t * zone alignment optimization. This is optional for host-aware",
                        "\t * devices, but mandatory for host-managed zoned block devices.",
                        "\t */",
                        "#ifndef CONFIG_BLK_DEV_ZONED",
                        "\tif (f2fs_sb_has_blkzoned(sbi)) {",
                        "\t\tf2fs_err(sbi, \"Zoned block device support is not enabled\");",
                        "\t\terr = -EOPNOTSUPP;",
                        "\t\tgoto free_sb_buf;",
                        "\t}",
                        "#endif",
                        "\tdefault_options(sbi);",
                        "\t/* parse mount options */",
                        "\toptions = kstrdup((const char *)data, GFP_KERNEL);",
                        "\tif (data && !options) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto free_sb_buf;",
                        "\t}",
                        "",
                        "\terr = parse_options(sb, options, false);",
                        "\tif (err)",
                        "\t\tgoto free_options;",
                        "",
                        "\tsbi->max_file_blocks = max_file_blocks();",
                        "\tsb->s_maxbytes = sbi->max_file_blocks <<",
                        "\t\t\t\tle32_to_cpu(raw_super->log_blocksize);",
                        "\tsb->s_max_links = F2FS_LINK_MAX;",
                        "",
                        "\terr = f2fs_setup_casefold(sbi);",
                        "\tif (err)",
                        "\t\tgoto free_options;",
                        "",
                        "#ifdef CONFIG_QUOTA",
                        "\tsb->dq_op = &f2fs_quota_operations;",
                        "\tsb->s_qcop = &f2fs_quotactl_ops;",
                        "\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;",
                        "",
                        "\tif (f2fs_sb_has_quota_ino(sbi)) {",
                        "\t\tfor (i = 0; i < MAXQUOTAS; i++) {",
                        "\t\t\tif (f2fs_qf_ino(sbi->sb, i))",
                        "\t\t\t\tsbi->nquota_files++;",
                        "\t\t}",
                        "\t}",
                        "#endif",
                        "",
                        "\tsb->s_op = &f2fs_sops;",
                        "#ifdef CONFIG_FS_ENCRYPTION",
                        "\tsb->s_cop = &f2fs_cryptops;",
                        "#endif",
                        "#ifdef CONFIG_FS_VERITY",
                        "\tsb->s_vop = &f2fs_verityops;",
                        "#endif",
                        "\tsb->s_xattr = f2fs_xattr_handlers;",
                        "\tsb->s_export_op = &f2fs_export_ops;",
                        "\tsb->s_magic = F2FS_SUPER_MAGIC;",
                        "\tsb->s_time_gran = 1;",
                        "\tsb->s_flags = (sb->s_flags & ~SB_POSIXACL) |",
                        "\t\t(test_opt(sbi, POSIX_ACL) ? SB_POSIXACL : 0);",
                        "\tmemcpy(&sb->s_uuid, raw_super->uuid, sizeof(raw_super->uuid));",
                        "\tsb->s_iflags |= SB_I_CGROUPWB;",
                        "",
                        "\t/* init f2fs-specific super block info */",
                        "\tsbi->valid_super_block = valid_super_block;",
                        "\tinit_rwsem(&sbi->gc_lock);",
                        "\tmutex_init(&sbi->writepages);",
                        "\tmutex_init(&sbi->cp_mutex);",
                        "\tinit_rwsem(&sbi->node_write);",
                        "\tinit_rwsem(&sbi->node_change);",
                        "",
                        "\t/* disallow all the data/node/meta page writes */",
                        "\tset_sbi_flag(sbi, SBI_POR_DOING);",
                        "\tspin_lock_init(&sbi->stat_lock);",
                        "",
                        "\t/* init iostat info */",
                        "\tspin_lock_init(&sbi->iostat_lock);",
                        "\tsbi->iostat_enable = false;",
                        "\tsbi->iostat_period_ms = DEFAULT_IOSTAT_PERIOD_MS;",
                        "",
                        "\tfor (i = 0; i < NR_PAGE_TYPE; i++) {",
                        "\t\tint n = (i == META) ? 1: NR_TEMP_TYPE;",
                        "\t\tint j;",
                        "",
                        "\t\tsbi->write_io[i] =",
                        "\t\t\tf2fs_kmalloc(sbi,",
                        "\t\t\t\t     array_size(n,",
                        "\t\t\t\t\t\tsizeof(struct f2fs_bio_info)),",
                        "\t\t\t\t     GFP_KERNEL);",
                        "\t\tif (!sbi->write_io[i]) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto free_bio_info;",
                        "\t\t}",
                        "",
                        "\t\tfor (j = HOT; j < n; j++) {",
                        "\t\t\tinit_rwsem(&sbi->write_io[i][j].io_rwsem);",
                        "\t\t\tsbi->write_io[i][j].sbi = sbi;",
                        "\t\t\tsbi->write_io[i][j].bio = NULL;",
                        "\t\t\tspin_lock_init(&sbi->write_io[i][j].io_lock);",
                        "\t\t\tINIT_LIST_HEAD(&sbi->write_io[i][j].io_list);",
                        "\t\t\tINIT_LIST_HEAD(&sbi->write_io[i][j].bio_list);",
                        "\t\t\tinit_rwsem(&sbi->write_io[i][j].bio_list_lock);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tinit_rwsem(&sbi->cp_rwsem);",
                        "\tinit_rwsem(&sbi->quota_sem);",
                        "\tinit_waitqueue_head(&sbi->cp_wait);",
                        "\tinit_sb_info(sbi);",
                        "",
                        "\terr = init_percpu_info(sbi);",
                        "\tif (err)",
                        "\t\tgoto free_bio_info;",
                        "",
                        "\tif (F2FS_IO_ALIGNED(sbi)) {",
                        "\t\tsbi->write_io_dummy =",
                        "\t\t\tmempool_create_page_pool(2 * (F2FS_IO_SIZE(sbi) - 1), 0);",
                        "\t\tif (!sbi->write_io_dummy) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto free_percpu;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* init per sbi slab cache */",
                        "\terr = f2fs_init_xattr_caches(sbi);",
                        "\tif (err)",
                        "\t\tgoto free_io_dummy;",
                        "",
                        "\t/* get an inode for meta space */",
                        "\tsbi->meta_inode = f2fs_iget(sb, F2FS_META_INO(sbi));",
                        "\tif (IS_ERR(sbi->meta_inode)) {",
                        "\t\tf2fs_err(sbi, \"Failed to read F2FS meta data inode\");",
                        "\t\terr = PTR_ERR(sbi->meta_inode);",
                        "\t\tgoto free_xattr_cache;",
                        "\t}",
                        "",
                        "\terr = f2fs_get_valid_checkpoint(sbi);",
                        "\tif (err) {",
                        "\t\tf2fs_err(sbi, \"Failed to get valid F2FS checkpoint\");",
                        "\t\tgoto free_meta_inode;",
                        "\t}",
                        "",
                        "\tif (__is_set_ckpt_flags(F2FS_CKPT(sbi), CP_QUOTA_NEED_FSCK_FLAG))",
                        "\t\tset_sbi_flag(sbi, SBI_QUOTA_NEED_REPAIR);",
                        "\tif (__is_set_ckpt_flags(F2FS_CKPT(sbi), CP_DISABLED_QUICK_FLAG)) {",
                        "\t\tset_sbi_flag(sbi, SBI_CP_DISABLED_QUICK);",
                        "\t\tsbi->interval_time[DISABLE_TIME] = DEF_DISABLE_QUICK_INTERVAL;",
                        "\t}",
                        "",
                        "\tif (__is_set_ckpt_flags(F2FS_CKPT(sbi), CP_FSCK_FLAG))",
                        "\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);",
                        "",
                        "\t/* Initialize device list */",
                        "\terr = f2fs_scan_devices(sbi);",
                        "\tif (err) {",
                        "\t\tf2fs_err(sbi, \"Failed to find devices\");",
                        "\t\tgoto free_devices;",
                        "\t}",
                        "",
                        "\terr = f2fs_init_post_read_wq(sbi);",
                        "\tif (err) {",
                        "\t\tf2fs_err(sbi, \"Failed to initialize post read workqueue\");",
                        "\t\tgoto free_devices;",
                        "\t}",
                        "",
                        "\tsbi->total_valid_node_count =",
                        "\t\t\t\tle32_to_cpu(sbi->ckpt->valid_node_count);",
                        "\tpercpu_counter_set(&sbi->total_valid_inode_count,",
                        "\t\t\t\tle32_to_cpu(sbi->ckpt->valid_inode_count));",
                        "\tsbi->user_block_count = le64_to_cpu(sbi->ckpt->user_block_count);",
                        "\tsbi->total_valid_block_count =",
                        "\t\t\t\tle64_to_cpu(sbi->ckpt->valid_block_count);",
                        "\tsbi->last_valid_block_count = sbi->total_valid_block_count;",
                        "\tsbi->reserved_blocks = 0;",
                        "\tsbi->current_reserved_blocks = 0;",
                        "\tlimit_reserve_root(sbi);",
                        "\tadjust_unusable_cap_perc(sbi);",
                        "",
                        "\tfor (i = 0; i < NR_INODE_TYPE; i++) {",
                        "\t\tINIT_LIST_HEAD(&sbi->inode_list[i]);",
                        "\t\tspin_lock_init(&sbi->inode_lock[i]);",
                        "\t}",
                        "\tmutex_init(&sbi->flush_lock);",
                        "",
                        "\tf2fs_init_extent_cache_info(sbi);",
                        "",
                        "\tf2fs_init_ino_entry_info(sbi);",
                        "",
                        "\tf2fs_init_fsync_node_info(sbi);",
                        "",
                        "\t/* setup f2fs internal modules */",
                        "\terr = f2fs_build_segment_manager(sbi);",
                        "\tif (err) {",
                        "\t\tf2fs_err(sbi, \"Failed to initialize F2FS segment manager (%d)\",",
                        "\t\t\t err);",
                        "\t\tgoto free_sm;",
                        "\t}",
                        "\terr = f2fs_build_node_manager(sbi);",
                        "\tif (err) {",
                        "\t\tf2fs_err(sbi, \"Failed to initialize F2FS node manager (%d)\",",
                        "\t\t\t err);",
                        "\t\tgoto free_nm;",
                        "\t}",
                        "",
                        "\t/* For write statistics */",
                        "\tif (sb->s_bdev->bd_part)",
                        "\t\tsbi->sectors_written_start =",
                        "\t\t\t(u64)part_stat_read(sb->s_bdev->bd_part,",
                        "\t\t\t\t\t    sectors[STAT_WRITE]);",
                        "",
                        "\t/* Read accumulated write IO statistics if exists */",
                        "\tseg_i = CURSEG_I(sbi, CURSEG_HOT_NODE);",
                        "\tif (__exist_node_summaries(sbi))",
                        "\t\tsbi->kbytes_written =",
                        "\t\t\tle64_to_cpu(seg_i->journal->info.kbytes_written);",
                        "",
                        "\tf2fs_build_gc_manager(sbi);",
                        "",
                        "\terr = f2fs_build_stats(sbi);",
                        "\tif (err)",
                        "\t\tgoto free_nm;",
                        "",
                        "\t/* get an inode for node space */",
                        "\tsbi->node_inode = f2fs_iget(sb, F2FS_NODE_INO(sbi));",
                        "\tif (IS_ERR(sbi->node_inode)) {",
                        "\t\tf2fs_err(sbi, \"Failed to read node inode\");",
                        "\t\terr = PTR_ERR(sbi->node_inode);",
                        "\t\tgoto free_stats;",
                        "\t}",
                        "",
                        "\t/* read root inode and dentry */",
                        "\troot = f2fs_iget(sb, F2FS_ROOT_INO(sbi));",
                        "\tif (IS_ERR(root)) {",
                        "\t\tf2fs_err(sbi, \"Failed to read root inode\");",
                        "\t\terr = PTR_ERR(root);",
                        "\t\tgoto free_node_inode;",
                        "\t}",
                        "\tif (!S_ISDIR(root->i_mode) || !root->i_blocks ||",
                        "\t\t\t!root->i_size || !root->i_nlink) {",
                        "\t\tiput(root);",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto free_node_inode;",
                        "\t}",
                        "",
                        "\tsb->s_root = d_make_root(root); /* allocate root dentry */",
                        "\tif (!sb->s_root) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto free_node_inode;",
                        "\t}",
                        "",
                        "\terr = f2fs_register_sysfs(sbi);",
                        "\tif (err)",
                        "\t\tgoto free_root_inode;",
                        "",
                        "#ifdef CONFIG_QUOTA",
                        "\t/* Enable quota usage during mount */",
                        "\tif (f2fs_sb_has_quota_ino(sbi) && !f2fs_readonly(sb)) {",
                        "\t\terr = f2fs_enable_quotas(sb);",
                        "\t\tif (err)",
                        "\t\t\tf2fs_err(sbi, \"Cannot turn on quotas: error %d\", err);",
                        "\t}",
                        "#endif",
                        "\t/* if there are any orphan inodes, free them */",
                        "\terr = f2fs_recover_orphan_inodes(sbi);",
                        "\tif (err)",
                        "\t\tgoto free_meta;",
                        "",
                        "\tif (unlikely(is_set_ckpt_flags(sbi, CP_DISABLED_FLAG)))",
                        "\t\tgoto reset_checkpoint;",
                        "",
                        "\t/* recover fsynced data */",
                        "\tif (!test_opt(sbi, DISABLE_ROLL_FORWARD) &&",
                        "\t\t\t!test_opt(sbi, NORECOVERY)) {",
                        "\t\t/*",
                        "\t\t * mount should be failed, when device has readonly mode, and",
                        "\t\t * previous checkpoint was not done by clean system shutdown.",
                        "\t\t */",
                        "\t\tif (f2fs_hw_is_readonly(sbi)) {",
                        "\t\t\tif (!is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG)) {",
                        "\t\t\t\terr = -EROFS;",
                        "\t\t\t\tf2fs_err(sbi, \"Need to recover fsync data, but write access unavailable\");",
                        "\t\t\t\tgoto free_meta;",
                        "\t\t\t}",
                        "\t\t\tf2fs_info(sbi, \"write access unavailable, skipping recovery\");",
                        "\t\t\tgoto reset_checkpoint;",
                        "\t\t}",
                        "",
                        "\t\tif (need_fsck)",
                        "\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);",
                        "",
                        "\t\tif (skip_recovery)",
                        "\t\t\tgoto reset_checkpoint;",
                        "",
                        "\t\terr = f2fs_recover_fsync_data(sbi, false);",
                        "\t\tif (err < 0) {",
                        "\t\t\tif (err != -ENOMEM)",
                        "\t\t\t\tskip_recovery = true;",
                        "\t\t\tneed_fsck = true;",
                        "\t\t\tf2fs_err(sbi, \"Cannot recover all fsync data errno=%d\",",
                        "\t\t\t\t err);",
                        "\t\t\tgoto free_meta;",
                        "\t\t}",
                        "\t} else {",
                        "\t\terr = f2fs_recover_fsync_data(sbi, true);",
                        "",
                        "\t\tif (!f2fs_readonly(sb) && err > 0) {",
                        "\t\t\terr = -EINVAL;",
                        "\t\t\tf2fs_err(sbi, \"Need to recover fsync data\");",
                        "\t\t\tgoto free_meta;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * If the f2fs is not readonly and fsync data recovery succeeds,",
                        "\t * check zoned block devices' write pointer consistency.",
                        "\t */",
                        "\tif (!err && !f2fs_readonly(sb) && f2fs_sb_has_blkzoned(sbi)) {",
                        "\t\terr = f2fs_check_write_pointer(sbi);",
                        "\t\tif (err)",
                        "\t\t\tgoto free_meta;",
                        "\t}",
                        "",
                        "reset_checkpoint:",
                        "\t/* f2fs_recover_fsync_data() cleared this already */",
                        "\tclear_sbi_flag(sbi, SBI_POR_DOING);",
                        "",
                        "\tif (test_opt(sbi, DISABLE_CHECKPOINT)) {",
                        "\t\terr = f2fs_disable_checkpoint(sbi);",
                        "\t\tif (err)",
                        "\t\t\tgoto sync_free_meta;",
                        "\t} else if (is_set_ckpt_flags(sbi, CP_DISABLED_FLAG)) {",
                        "\t\tf2fs_enable_checkpoint(sbi);",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * If filesystem is not mounted as read-only then",
                        "\t * do start the gc_thread.",
                        "\t */",
                        "\tif (F2FS_OPTION(sbi).bggc_mode != BGGC_MODE_OFF && !f2fs_readonly(sb)) {",
                        "\t\t/* After POR, we can run background GC thread.*/",
                        "\t\terr = f2fs_start_gc_thread(sbi);",
                        "\t\tif (err)",
                        "\t\t\tgoto sync_free_meta;",
                        "\t}",
                        "\tkvfree(options);",
                        "",
                        "\t/* recover broken superblock */",
                        "\tif (recovery) {",
                        "\t\terr = f2fs_commit_super(sbi, true);",
                        "\t\tf2fs_info(sbi, \"Try to recover %dth superblock, ret: %d\",",
                        "\t\t\t  sbi->valid_super_block ? 1 : 2, err);",
                        "\t}",
                        "",
                        "\tf2fs_join_shrinker(sbi);",
                        "",
                        "\tf2fs_tuning_parameters(sbi);",
                        "",
                        "\tf2fs_notice(sbi, \"Mounted with checkpoint version = %llx\",",
                        "\t\t    cur_cp_version(F2FS_CKPT(sbi)));",
                        "\tf2fs_update_time(sbi, CP_TIME);",
                        "\tf2fs_update_time(sbi, REQ_TIME);",
                        "\tclear_sbi_flag(sbi, SBI_CP_DISABLED_QUICK);",
                        "\treturn 0;",
                        "",
                        "sync_free_meta:",
                        "\t/* safe to flush all the data */",
                        "\tsync_filesystem(sbi->sb);",
                        "\tretry_cnt = 0;",
                        "",
                        "free_meta:",
                        "#ifdef CONFIG_QUOTA",
                        "\tf2fs_truncate_quota_inode_pages(sb);",
                        "\tif (f2fs_sb_has_quota_ino(sbi) && !f2fs_readonly(sb))",
                        "\t\tf2fs_quota_off_umount(sbi->sb);",
                        "#endif",
                        "\t/*",
                        "\t * Some dirty meta pages can be produced by f2fs_recover_orphan_inodes()",
                        "\t * failed by EIO. Then, iput(node_inode) can trigger balance_fs_bg()",
                        "\t * followed by f2fs_write_checkpoint() through f2fs_write_node_pages(), which",
                        "\t * falls into an infinite loop in f2fs_sync_meta_pages().",
                        "\t */",
                        "\ttruncate_inode_pages_final(META_MAPPING(sbi));",
                        "\t/* evict some inodes being cached by GC */",
                        "\tevict_inodes(sb);",
                        "\tf2fs_unregister_sysfs(sbi);",
                        "free_root_inode:",
                        "\tdput(sb->s_root);",
                        "\tsb->s_root = NULL;",
                        "free_node_inode:",
                        "\tf2fs_release_ino_entry(sbi, true);",
                        "\ttruncate_inode_pages_final(NODE_MAPPING(sbi));",
                        "\tiput(sbi->node_inode);",
                        "\tsbi->node_inode = NULL;",
                        "free_stats:",
                        "\tf2fs_destroy_stats(sbi);",
                        "free_nm:",
                        "\tf2fs_destroy_node_manager(sbi);",
                        "free_sm:",
                        "\tf2fs_destroy_segment_manager(sbi);",
                        "\tf2fs_destroy_post_read_wq(sbi);",
                        "free_devices:",
                        "\tdestroy_device_list(sbi);",
                        "\tkvfree(sbi->ckpt);",
                        "free_meta_inode:",
                        "\tmake_bad_inode(sbi->meta_inode);",
                        "\tiput(sbi->meta_inode);",
                        "\tsbi->meta_inode = NULL;",
                        "free_xattr_cache:",
                        "\tf2fs_destroy_xattr_caches(sbi);",
                        "free_io_dummy:",
                        "\tmempool_destroy(sbi->write_io_dummy);",
                        "free_percpu:",
                        "\tdestroy_percpu_info(sbi);",
                        "free_bio_info:",
                        "\tfor (i = 0; i < NR_PAGE_TYPE; i++)",
                        "\t\tkvfree(sbi->write_io[i]);",
                        "",
                        "#ifdef CONFIG_UNICODE",
                        "\tutf8_unload(sbi->s_encoding);",
                        "#endif",
                        "free_options:",
                        "#ifdef CONFIG_QUOTA",
                        "\tfor (i = 0; i < MAXQUOTAS; i++)",
                        "\t\tkfree(F2FS_OPTION(sbi).s_qf_names[i]);",
                        "#endif",
                        "\tfscrypt_free_dummy_context(&F2FS_OPTION(sbi).dummy_enc_ctx);",
                        "\tkvfree(options);",
                        "free_sb_buf:",
                        "\tkfree(raw_super);",
                        "free_sbi:",
                        "\tif (sbi->s_chksum_driver)",
                        "\t\tcrypto_free_shash(sbi->s_chksum_driver);",
                        "\tkfree(sbi);",
                        "",
                        "\t/* give only one another chance */",
                        "\tif (retry_cnt > 0 && skip_recovery) {",
                        "\t\tretry_cnt--;",
                        "\t\tshrink_dcache_sb(sb);",
                        "\t\tgoto try_onemore;",
                        "\t}",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 3390,
                    "highlight": 3633
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff815da646"
        },
        "2889": {
            "name": "f2fs_fill_super(indirect)",
            "parent_idx": 2343,
            "source_line": [
                {
                    "file": "fs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/super.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n1417",
                    "code": [
                        "struct dentry *mount_bdev(struct file_system_type *fs_type,",
                        "\tint flags, const char *dev_name, void *data,",
                        "\tint (*fill_super)(struct super_block *, void *, int))",
                        "{",
                        "\tstruct block_device *bdev;",
                        "\tstruct super_block *s;",
                        "\tfmode_t mode = FMODE_READ | FMODE_EXCL;",
                        "\tint error = 0;",
                        "",
                        "\tif (!(flags & SB_RDONLY))",
                        "\t\tmode |= FMODE_WRITE;",
                        "",
                        "\tbdev = blkdev_get_by_path(dev_name, mode, fs_type);",
                        "\tif (IS_ERR(bdev))",
                        "\t\treturn ERR_CAST(bdev);",
                        "",
                        "\t/*",
                        "\t * once the super is inserted into the list by sget, s_umount",
                        "\t * will protect the lockfs code from trying to start a snapshot",
                        "\t * while we are mounting",
                        "\t */",
                        "\tmutex_lock(&bdev->bd_fsfreeze_mutex);",
                        "\tif (bdev->bd_fsfreeze_count > 0) {",
                        "\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);",
                        "\t\terror = -EBUSY;",
                        "\t\tgoto error_bdev;",
                        "\t}",
                        "\ts = sget(fs_type, test_bdev_super, set_bdev_super, flags | SB_NOSEC,",
                        "\t\t bdev);",
                        "\tmutex_unlock(&bdev->bd_fsfreeze_mutex);",
                        "\tif (IS_ERR(s))",
                        "\t\tgoto error_s;",
                        "",
                        "\tif (s->s_root) {",
                        "\t\tif ((flags ^ s->s_flags) & SB_RDONLY) {",
                        "\t\t\tdeactivate_locked_super(s);",
                        "\t\t\terror = -EBUSY;",
                        "\t\t\tgoto error_bdev;",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * s_umount nests inside bd_mutex during",
                        "\t\t * __invalidate_device().  blkdev_put() acquires",
                        "\t\t * bd_mutex and can't be called under s_umount.  Drop",
                        "\t\t * s_umount temporarily.  This is safe as we're",
                        "\t\t * holding an active reference.",
                        "\t\t */",
                        "\t\tup_write(&s->s_umount);",
                        "\t\tblkdev_put(bdev, mode);",
                        "\t\tdown_write(&s->s_umount);",
                        "\t} else {",
                        "\t\ts->s_mode = mode;",
                        "\t\tsnprintf(s->s_id, sizeof(s->s_id), \"%pg\", bdev);",
                        "\t\tsb_set_blocksize(s, block_size(bdev));",
                        "\t\terror = fill_super(s, data, flags & SB_SILENT ? 1 : 0);",
                        "\t\tif (error) {",
                        "\t\t\tdeactivate_locked_super(s);",
                        "\t\t\tgoto error;",
                        "\t\t}",
                        "",
                        "\t\ts->s_flags |= SB_ACTIVE;",
                        "\t\tbdev->bd_super = s;",
                        "\t}",
                        "",
                        "\treturn dget(s->s_root);",
                        "",
                        "error_s:",
                        "\terror = PTR_ERR(s);",
                        "error_bdev:",
                        "\tblkdev_put(bdev, mode);",
                        "error:",
                        "\treturn ERR_PTR(error);",
                        "}"
                    ],
                    "start": 1363,
                    "highlight": 1417
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81324554"
        },
        "2343": {
            "name": "mount_bdev(indirect)",
            "parent_idx": 2339,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n592",
                    "code": [
                        "/*",
                        " * Get a mountable root with the legacy mount command.",
                        " */",
                        "static int legacy_get_tree(struct fs_context *fc)",
                        "{",
                        "\tstruct legacy_fs_context *ctx = fc->fs_private;",
                        "\tstruct super_block *sb;",
                        "\tstruct dentry *root;",
                        "",
                        "\troot = fc->fs_type->mount(fc->fs_type, fc->sb_flags,",
                        "\t\t\t\t      fc->source, ctx->legacy_data);",
                        "\tif (IS_ERR(root))",
                        "\t\treturn PTR_ERR(root);",
                        "",
                        "\tsb = root->d_sb;",
                        "\tBUG_ON(!sb);",
                        "",
                        "\tfc->root = root;",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 583,
                    "highlight": 592
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8137f326"
        },
        "2339": {
            "name": "legacy_get_tree(indirect)",
            "parent_idx": 2336,
            "source_line": [
                {
                    "file": "fs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/super.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n1547",
                    "code": [
                        "/**",
                        " * vfs_get_tree - Get the mountable root",
                        " * @fc: The superblock configuration context.",
                        " *",
                        " * The filesystem is invoked to get or create a superblock which can then later",
                        " * be used for mounting.  The filesystem places a pointer to the root to be",
                        " * used for mounting in @fc->root.",
                        " */",
                        "int vfs_get_tree(struct fs_context *fc)",
                        "{",
                        "\tstruct super_block *sb;",
                        "\tint error;",
                        "",
                        "\tif (fc->root)",
                        "\t\treturn -EBUSY;",
                        "",
                        "\t/* Get the mountable root in fc->root, with a ref on the root and a ref",
                        "\t * on the superblock.",
                        "\t */",
                        "\terror = fc->ops->get_tree(fc);",
                        "\tif (error < 0)",
                        "\t\treturn error;",
                        "",
                        "\tif (!fc->root) {",
                        "\t\tpr_err(\"Filesystem %s get_tree() didn't set fc->root\\n\",",
                        "\t\t       fc->fs_type->name);",
                        "\t\t/* We don't know what the locking state of the superblock is -",
                        "\t\t * if there is a superblock.",
                        "\t\t */",
                        "\t\tBUG();",
                        "\t}",
                        "",
                        "\tsb = fc->root->d_sb;",
                        "\tWARN_ON(!sb->s_bdi);",
                        "",
                        "\t/*",
                        "\t * Write barrier is for super_cache_count(). We place it before setting",
                        "\t * SB_BORN as the data dependency between the two functions is the",
                        "\t * superblock structure contents that we just set up, not the SB_BORN",
                        "\t * flag.",
                        "\t */",
                        "\tsmp_wmb();",
                        "\tsb->s_flags |= SB_BORN;",
                        "",
                        "\terror = security_sb_set_mnt_opts(sb, fc->security, 0, NULL);",
                        "\tif (unlikely(error)) {",
                        "\t\tfc_drop_locked(fc);",
                        "\t\treturn error;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * filesystems should never set s_maxbytes larger than MAX_LFS_FILESIZE",
                        "\t * but s_maxbytes was an unsigned long long for many releases. Throw",
                        "\t * this warning for a little while to try and catch filesystems that",
                        "\t * violate this rule.",
                        "\t */",
                        "\tWARN((sb->s_maxbytes < 0), \"%s set sb->s_maxbytes to \"",
                        "\t\t\"negative value (%lld)\\n\", fc->fs_type->name, sb->s_maxbytes);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1528,
                    "highlight": 1547
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8132218c"
        },
        "2336": {
            "name": "vfs_get_tree",
            "parent_idx": 2185,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n2875",
                    "code": [
                        "/*",
                        " * create a new mount for userspace and request it to be added into the",
                        " * namespace's tree",
                        " */",
                        "static int do_new_mount(struct path *path, const char *fstype, int sb_flags,",
                        "\t\t\tint mnt_flags, const char *name, void *data)",
                        "{",
                        "\tstruct file_system_type *type;",
                        "\tstruct fs_context *fc;",
                        "\tconst char *subtype = NULL;",
                        "\tint err = 0;",
                        "",
                        "\tif (!fstype)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\ttype = get_fs_type(fstype);",
                        "\tif (!type)",
                        "\t\treturn -ENODEV;",
                        "",
                        "\tif (type->fs_flags & FS_HAS_SUBTYPE) {",
                        "\t\tsubtype = strchr(fstype, '.');",
                        "\t\tif (subtype) {",
                        "\t\t\tsubtype++;",
                        "\t\t\tif (!*subtype) {",
                        "\t\t\t\tput_filesystem(type);",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tfc = fs_context_for_mount(type, sb_flags);",
                        "\tput_filesystem(type);",
                        "\tif (IS_ERR(fc))",
                        "\t\treturn PTR_ERR(fc);",
                        "",
                        "\tif (subtype)",
                        "\t\terr = vfs_parse_fs_string(fc, \"subtype\",",
                        "\t\t\t\t\t  subtype, strlen(subtype));",
                        "\tif (!err && name)",
                        "\t\terr = vfs_parse_fs_string(fc, \"source\", name, strlen(name));",
                        "\tif (!err)",
                        "\t\terr = parse_monolithic_mount_data(fc, data);",
                        "\tif (!err && !mount_capable(fc))",
                        "\t\terr = -EPERM;",
                        "\tif (!err)",
                        "\t\terr = vfs_get_tree(fc);",
                        "\tif (!err)",
                        "\t\terr = do_new_mount_fc(fc, path, mnt_flags);",
                        "",
                        "\tput_fs_context(fc);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2830,
                    "highlight": 2875
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n3192",
                    "code": [
                        "/*",
                        " * Flags is a 32-bit value that allows up to 31 non-fs dependent flags to",
                        " * be given to the mount() call (ie: read-only, no-dev, no-suid etc).",
                        " *",
                        " * data is a (void *) that can point to any structure up to",
                        " * PAGE_SIZE-1 bytes, which can contain arbitrary fs-dependent",
                        " * information (or be NULL).",
                        " *",
                        " * Pre-0.97 versions of mount() didn't have a flags word.",
                        " * When the flags word was introduced its top half was required",
                        " * to have the magic value 0xC0ED, and this remained so until 2.4.0-test9.",
                        " * Therefore, if this magic number is present, it carries no information",
                        " * and must be discarded.",
                        " */",
                        "int path_mount(const char *dev_name, struct path *path,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tunsigned int mnt_flags = 0, sb_flags;",
                        "\tint ret;",
                        "",
                        "\t/* Discard magic */",
                        "\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)",
                        "\t\tflags &= ~MS_MGC_MSK;",
                        "",
                        "\t/* Basic sanity checks */",
                        "\tif (data_page)",
                        "\t\t((char *)data_page)[PAGE_SIZE - 1] = 0;",
                        "",
                        "\tif (flags & MS_NOUSER)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tret = security_sb_mount(dev_name, path, type_page, flags, data_page);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tif (!may_mount())",
                        "\t\treturn -EPERM;",
                        "\tif ((flags & SB_MANDLOCK) && !may_mandlock())",
                        "\t\treturn -EPERM;",
                        "",
                        "\t/* Default to relatime unless overriden */",
                        "\tif (!(flags & MS_NOATIME))",
                        "\t\tmnt_flags |= MNT_RELATIME;",
                        "",
                        "\t/* Separate the per-mountpoint flags */",
                        "\tif (flags & MS_NOSUID)",
                        "\t\tmnt_flags |= MNT_NOSUID;",
                        "\tif (flags & MS_NODEV)",
                        "\t\tmnt_flags |= MNT_NODEV;",
                        "\tif (flags & MS_NOEXEC)",
                        "\t\tmnt_flags |= MNT_NOEXEC;",
                        "\tif (flags & MS_NOATIME)",
                        "\t\tmnt_flags |= MNT_NOATIME;",
                        "\tif (flags & MS_NODIRATIME)",
                        "\t\tmnt_flags |= MNT_NODIRATIME;",
                        "\tif (flags & MS_STRICTATIME)",
                        "\t\tmnt_flags &= ~(MNT_RELATIME | MNT_NOATIME);",
                        "\tif (flags & MS_RDONLY)",
                        "\t\tmnt_flags |= MNT_READONLY;",
                        "",
                        "\t/* The default atime for remount is preservation */",
                        "\tif ((flags & MS_REMOUNT) &&",
                        "\t    ((flags & (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |",
                        "\t\t       MS_STRICTATIME)) == 0)) {",
                        "\t\tmnt_flags &= ~MNT_ATIME_MASK;",
                        "\t\tmnt_flags |= path->mnt->mnt_flags & MNT_ATIME_MASK;",
                        "\t}",
                        "",
                        "\tsb_flags = flags & (SB_RDONLY |",
                        "\t\t\t    SB_SYNCHRONOUS |",
                        "\t\t\t    SB_MANDLOCK |",
                        "\t\t\t    SB_DIRSYNC |",
                        "\t\t\t    SB_SILENT |",
                        "\t\t\t    SB_POSIXACL |",
                        "\t\t\t    SB_LAZYTIME |",
                        "\t\t\t    SB_I_VERSION);",
                        "",
                        "\tif ((flags & (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND))",
                        "\t\treturn do_reconfigure_mnt(path, mnt_flags);",
                        "\tif (flags & MS_REMOUNT)",
                        "\t\treturn do_remount(path, flags, sb_flags, mnt_flags, data_page);",
                        "\tif (flags & MS_BIND)",
                        "\t\treturn do_loopback(path, dev_name, flags & MS_REC);",
                        "\tif (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))",
                        "\t\treturn do_change_type(path, flags);",
                        "\tif (flags & MS_MOVE)",
                        "\t\treturn do_move_mount_old(path, dev_name);",
                        "",
                        "\treturn do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,",
                        "\t\t\t    data_page);",
                        "}"
                    ],
                    "start": 3105,
                    "highlight": 3192
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8135da21"
        },
        "2185": {
            "name": "path_mount",
            "parent_idx": 2063,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n3205",
                    "code": [
                        "long do_mount(const char *dev_name, const char __user *dir_name,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tstruct path path;",
                        "\tint ret;",
                        "",
                        "\tret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &path);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tret = path_mount(dev_name, &path, type_page, flags, data_page);",
                        "\tpath_put(&path);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3196,
                    "highlight": 3205
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n3413",
                    "code": [
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3390,
                    "highlight": 3413
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n3390",
                    "code": [
                        "struct dentry *mount_subtree(struct vfsmount *m, const char *name)",
                        "{",
                        "\tstruct mount *mnt = real_mount(m);",
                        "\tstruct mnt_namespace *ns;",
                        "\tstruct super_block *s;",
                        "\tstruct path path;",
                        "\tint err;",
                        "",
                        "\tns = alloc_mnt_ns(&init_user_ns, true);",
                        "\tif (IS_ERR(ns)) {",
                        "\t\tmntput(m);",
                        "\t\treturn ERR_CAST(ns);",
                        "\t}",
                        "\tmnt->mnt_ns = ns;",
                        "\tns->root = mnt;",
                        "\tns->mounts++;",
                        "\tlist_add(&mnt->mnt_list, &ns->list);",
                        "",
                        "\terr = vfs_path_lookup(m->mnt_root, m,",
                        "\t\t\tname, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);",
                        "",
                        "\tput_mnt_ns(ns);",
                        "",
                        "\tif (err)",
                        "\t\treturn ERR_PTR(err);",
                        "",
                        "\t/* trade a vfsmount reference for active sb one */",
                        "\ts = path.mnt->mnt_sb;",
                        "\tatomic_inc(&s->s_active);",
                        "\tmntput(path.mnt);",
                        "\t/* lock the sucker */",
                        "\tdown_write(&s->s_umount);",
                        "\t/* ... and return the root of (sub)tree on it */",
                        "\treturn path.dentry;",
                        "}",
                        "EXPORT_SYMBOL(mount_subtree);",
                        "",
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3353,
                    "highlight": 3390
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8135e5f6"
        },
        "2063": {
            "name": "__x64_sys_mount(indirect)",
            "parent_idx": 2060,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8235575e"
        },
        "2060": {
            "name": "do_syscall_64",
            "parent_idx": 2053,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n118",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 118
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "2053": {
            "name": "257_syscall_17",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "4388": {
            "name": "+0x2df3",
            "parent_idx": 3331,
            "source_line": [
                {
                    "file": "fs/f2fs/segment.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.h?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n317",
                    "code": [
                        "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,",
                        "\t\t\t\t\t\tunsigned int segno)",
                        "{",
                        "\tstruct sit_info *sit_i = SIT_I(sbi);",
                        "\treturn &sit_i->sentries[segno];",
                        "}"
                    ],
                    "start": 313,
                    "highlight": 317
                },
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4710",
                    "code": [
                        "/*",
                        " * Update min, max modified time for cost-benefit GC algorithm",
                        " */",
                        "static void init_min_max_mtime(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct sit_info *sit_i = SIT_I(sbi);",
                        "\tunsigned int segno;",
                        "",
                        "\tdown_write(&sit_i->sentry_lock);",
                        "",
                        "\tsit_i->min_mtime = ULLONG_MAX;",
                        "",
                        "\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {",
                        "\t\tunsigned int i;",
                        "\t\tunsigned long long mtime = 0;",
                        "",
                        "\t\tfor (i = 0; i < sbi->segs_per_sec; i++)",
                        "\t\t\tmtime += get_seg_entry(sbi, segno + i)->mtime;",
                        "",
                        "\t\tmtime = div_u64(mtime, sbi->segs_per_sec);",
                        "",
                        "\t\tif (sit_i->min_mtime > mtime)",
                        "\t\t\tsit_i->min_mtime = mtime;",
                        "\t}",
                        "\tsit_i->max_mtime = get_mtime(sbi, false);",
                        "\tup_write(&sit_i->sentry_lock);",
                        "}"
                    ],
                    "start": 4693,
                    "highlight": 4710
                },
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4792",
                    "code": [
                        "int f2fs_build_segment_manager(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);",
                        "\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);",
                        "\tstruct f2fs_sm_info *sm_info;",
                        "\tint err;",
                        "",
                        "\tsm_info = f2fs_kzalloc(sbi, sizeof(struct f2fs_sm_info), GFP_KERNEL);",
                        "\tif (!sm_info)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\t/* init sm info */",
                        "\tsbi->sm_info = sm_info;",
                        "\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);",
                        "\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);",
                        "\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);",
                        "\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);",
                        "\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);",
                        "\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);",
                        "\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);",
                        "\tsm_info->rec_prefree_segments = sm_info->main_segments *",
                        "\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;",
                        "\tif (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)",
                        "\t\tsm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;",
                        "",
                        "\tif (!f2fs_lfs_mode(sbi))",
                        "\t\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;",
                        "\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;",
                        "\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;",
                        "\tsm_info->min_seq_blocks = sbi->blocks_per_seg * sbi->segs_per_sec;",
                        "\tsm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;",
                        "\tsm_info->min_ssr_sections = reserved_sections(sbi);",
                        "",
                        "\tINIT_LIST_HEAD(&sm_info->sit_entry_set);",
                        "",
                        "\tinit_rwsem(&sm_info->curseg_lock);",
                        "",
                        "\tif (!f2fs_readonly(sbi->sb)) {",
                        "\t\terr = f2fs_create_flush_cmd_control(sbi);",
                        "\t\tif (err)",
                        "\t\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = create_discard_cmd_control(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = build_sit_info(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_free_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\t/* reinit free segmap based on SIT */",
                        "\terr = build_sit_entries(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_free_segmap(sbi);",
                        "\terr = build_dirty_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = sanity_check_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_min_max_mtime(sbi);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 4721,
                    "highlight": 4792
                }
            ],
            "ins_idx": 68,
            "addr": "0xffffffff8161ec83"
        },
        "4364": {
            "name": "+0x2dd9",
            "parent_idx": 3331,
            "source_line": [
                {
                    "file": "fs/f2fs/segment.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.h?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n317",
                    "code": [
                        "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,",
                        "\t\t\t\t\t\tunsigned int segno)",
                        "{",
                        "\tstruct sit_info *sit_i = SIT_I(sbi);",
                        "\treturn &sit_i->sentries[segno];",
                        "}"
                    ],
                    "start": 313,
                    "highlight": 317
                },
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4710",
                    "code": [
                        "/*",
                        " * Update min, max modified time for cost-benefit GC algorithm",
                        " */",
                        "static void init_min_max_mtime(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct sit_info *sit_i = SIT_I(sbi);",
                        "\tunsigned int segno;",
                        "",
                        "\tdown_write(&sit_i->sentry_lock);",
                        "",
                        "\tsit_i->min_mtime = ULLONG_MAX;",
                        "",
                        "\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {",
                        "\t\tunsigned int i;",
                        "\t\tunsigned long long mtime = 0;",
                        "",
                        "\t\tfor (i = 0; i < sbi->segs_per_sec; i++)",
                        "\t\t\tmtime += get_seg_entry(sbi, segno + i)->mtime;",
                        "",
                        "\t\tmtime = div_u64(mtime, sbi->segs_per_sec);",
                        "",
                        "\t\tif (sit_i->min_mtime > mtime)",
                        "\t\t\tsit_i->min_mtime = mtime;",
                        "\t}",
                        "\tsit_i->max_mtime = get_mtime(sbi, false);",
                        "\tup_write(&sit_i->sentry_lock);",
                        "}"
                    ],
                    "start": 4693,
                    "highlight": 4710
                },
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4792",
                    "code": [
                        "int f2fs_build_segment_manager(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);",
                        "\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);",
                        "\tstruct f2fs_sm_info *sm_info;",
                        "\tint err;",
                        "",
                        "\tsm_info = f2fs_kzalloc(sbi, sizeof(struct f2fs_sm_info), GFP_KERNEL);",
                        "\tif (!sm_info)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\t/* init sm info */",
                        "\tsbi->sm_info = sm_info;",
                        "\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);",
                        "\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);",
                        "\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);",
                        "\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);",
                        "\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);",
                        "\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);",
                        "\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);",
                        "\tsm_info->rec_prefree_segments = sm_info->main_segments *",
                        "\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;",
                        "\tif (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)",
                        "\t\tsm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;",
                        "",
                        "\tif (!f2fs_lfs_mode(sbi))",
                        "\t\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;",
                        "\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;",
                        "\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;",
                        "\tsm_info->min_seq_blocks = sbi->blocks_per_seg * sbi->segs_per_sec;",
                        "\tsm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;",
                        "\tsm_info->min_ssr_sections = reserved_sections(sbi);",
                        "",
                        "\tINIT_LIST_HEAD(&sm_info->sit_entry_set);",
                        "",
                        "\tinit_rwsem(&sm_info->curseg_lock);",
                        "",
                        "\tif (!f2fs_readonly(sbi->sb)) {",
                        "\t\terr = f2fs_create_flush_cmd_control(sbi);",
                        "\t\tif (err)",
                        "\t\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = create_discard_cmd_control(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = build_sit_info(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_free_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\t/* reinit free segmap based on SIT */",
                        "\terr = build_sit_entries(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_free_segmap(sbi);",
                        "\terr = build_dirty_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = sanity_check_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_min_max_mtime(sbi);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 4721,
                    "highlight": 4792
                }
            ],
            "ins_idx": 105,
            "addr": "0xffffffff8161ec69"
        },
        "3474": {
            "name": "+0x474",
            "parent_idx": 3331,
            "source_line": [
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4028",
                    "code": [
                        "static int build_sit_info(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);",
                        "\tstruct sit_info *sit_i;",
                        "\tunsigned int sit_segs, start;",
                        "\tchar *src_bitmap, *bitmap;",
                        "\tunsigned int bitmap_size, main_bitmap_size, sit_bitmap_size;",
                        "",
                        "\t/* allocate memory for SIT information */",
                        "\tsit_i = f2fs_kzalloc(sbi, sizeof(struct sit_info), GFP_KERNEL);",
                        "\tif (!sit_i)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tSM_I(sbi)->sit_info = sit_i;",
                        "",
                        "\tsit_i->sentries =",
                        "\t\tf2fs_kvzalloc(sbi, array_size(sizeof(struct seg_entry),",
                        "\t\t\t\t\t      MAIN_SEGS(sbi)),",
                        "\t\t\t      GFP_KERNEL);",
                        "\tif (!sit_i->sentries)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tmain_bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));",
                        "\tsit_i->dirty_sentries_bitmap = f2fs_kvzalloc(sbi, main_bitmap_size,",
                        "\t\t\t\t\t\t\t\tGFP_KERNEL);",
                        "\tif (!sit_i->dirty_sentries_bitmap)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "#ifdef CONFIG_F2FS_CHECK_FS",
                        "\tbitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * 4;",
                        "#else",
                        "\tbitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * 3;",
                        "#endif",
                        "\tsit_i->bitmap = f2fs_kvzalloc(sbi, bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->bitmap)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tbitmap = sit_i->bitmap;",
                        "",
                        "\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {",
                        "\t\tsit_i->sentries[start].cur_valid_map = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "",
                        "\t\tsit_i->sentries[start].ckpt_valid_map = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "",
                        "#ifdef CONFIG_F2FS_CHECK_FS",
                        "\t\tsit_i->sentries[start].cur_valid_map_mir = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "#endif",
                        "",
                        "\t\tsit_i->sentries[start].discard_map = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "\t}",
                        "",
                        "\tsit_i->tmp_map = f2fs_kzalloc(sbi, SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);",
                        "\tif (!sit_i->tmp_map)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tif (__is_large_section(sbi)) {",
                        "\t\tsit_i->sec_entries =",
                        "\t\t\tf2fs_kvzalloc(sbi, array_size(sizeof(struct sec_entry),",
                        "\t\t\t\t\t\t      MAIN_SECS(sbi)),",
                        "\t\t\t\t      GFP_KERNEL);",
                        "\t\tif (!sit_i->sec_entries)",
                        "\t\t\treturn -ENOMEM;",
                        "\t}",
                        "",
                        "\t/* get information related with SIT */",
                        "\tsit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;",
                        "",
                        "\t/* setup SIT bitmap from ckeckpoint pack */",
                        "\tsit_bitmap_size = __bitmap_size(sbi, SIT_BITMAP);",
                        "\tsrc_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);",
                        "",
                        "\tsit_i->sit_bitmap = kmemdup(src_bitmap, sit_bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->sit_bitmap)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "#ifdef CONFIG_F2FS_CHECK_FS",
                        "\tsit_i->sit_bitmap_mir = kmemdup(src_bitmap,",
                        "\t\t\t\t\tsit_bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->sit_bitmap_mir)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tsit_i->invalid_segmap = f2fs_kvzalloc(sbi,",
                        "\t\t\t\t\tmain_bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->invalid_segmap)",
                        "\t\treturn -ENOMEM;",
                        "#endif",
                        "",
                        "\t/* init SIT information */",
                        "\tsit_i->s_ops = &default_salloc_ops;",
                        "",
                        "\tsit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);",
                        "\tsit_i->sit_blocks = sit_segs << sbi->log_blocks_per_seg;",
                        "\tsit_i->written_valid_blocks = 0;",
                        "\tsit_i->bitmap_size = sit_bitmap_size;",
                        "\tsit_i->dirty_sentries = 0;",
                        "\tsit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;",
                        "\tsit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);",
                        "\tsit_i->mounted_time = ktime_get_boottime_seconds();",
                        "\tinit_rwsem(&sit_i->sentry_lock);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 4013,
                    "highlight": 4028
                },
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4768",
                    "code": [
                        "int f2fs_build_segment_manager(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);",
                        "\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);",
                        "\tstruct f2fs_sm_info *sm_info;",
                        "\tint err;",
                        "",
                        "\tsm_info = f2fs_kzalloc(sbi, sizeof(struct f2fs_sm_info), GFP_KERNEL);",
                        "\tif (!sm_info)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\t/* init sm info */",
                        "\tsbi->sm_info = sm_info;",
                        "\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);",
                        "\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);",
                        "\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);",
                        "\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);",
                        "\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);",
                        "\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);",
                        "\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);",
                        "\tsm_info->rec_prefree_segments = sm_info->main_segments *",
                        "\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;",
                        "\tif (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)",
                        "\t\tsm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;",
                        "",
                        "\tif (!f2fs_lfs_mode(sbi))",
                        "\t\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;",
                        "\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;",
                        "\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;",
                        "\tsm_info->min_seq_blocks = sbi->blocks_per_seg * sbi->segs_per_sec;",
                        "\tsm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;",
                        "\tsm_info->min_ssr_sections = reserved_sections(sbi);",
                        "",
                        "\tINIT_LIST_HEAD(&sm_info->sit_entry_set);",
                        "",
                        "\tinit_rwsem(&sm_info->curseg_lock);",
                        "",
                        "\tif (!f2fs_readonly(sbi->sb)) {",
                        "\t\terr = f2fs_create_flush_cmd_control(sbi);",
                        "\t\tif (err)",
                        "\t\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = create_discard_cmd_control(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = build_sit_info(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_free_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\t/* reinit free segmap based on SIT */",
                        "\terr = build_sit_entries(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_free_segmap(sbi);",
                        "\terr = build_dirty_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = sanity_check_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_min_max_mtime(sbi);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 4721,
                    "highlight": 4768
                }
            ],
            "ins_idx": 156,
            "addr": "0xffffffff8161c304"
        },
        "3473": {
            "name": "+0x460",
            "parent_idx": 3331,
            "source_line": [
                {
                    "file": "./include/linux/mm.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/mm.h?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n757",
                    "code": [
                        "extern void *kvmalloc_node(size_t size, gfp_t flags, int node);",
                        "static inline void *kvmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kvmalloc_node(size, flags, NUMA_NO_NODE);",
                        "}"
                    ],
                    "start": 754,
                    "highlight": 757
                },
                {
                    "file": "fs/f2fs/f2fs.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/f2fs.h?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n3030",
                    "code": [
                        "static inline void *f2fs_kvmalloc(struct f2fs_sb_info *sbi,",
                        "\t\t\t\t\tsize_t size, gfp_t flags)",
                        "{",
                        "\tif (time_to_inject(sbi, FAULT_KVMALLOC)) {",
                        "\t\tf2fs_show_injection_info(sbi, FAULT_KVMALLOC);",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\treturn kvmalloc(size, flags);",
                        "}"
                    ],
                    "start": 3022,
                    "highlight": 3030
                },
                {
                    "file": "fs/f2fs/f2fs.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/f2fs.h?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n3036",
                    "code": [
                        "static inline void *f2fs_kvzalloc(struct f2fs_sb_info *sbi,",
                        "\t\t\t\t\tsize_t size, gfp_t flags)",
                        "{",
                        "\treturn f2fs_kvmalloc(sbi, size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 3033,
                    "highlight": 3036
                },
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4029",
                    "code": [
                        "static int build_sit_info(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);",
                        "\tstruct sit_info *sit_i;",
                        "\tunsigned int sit_segs, start;",
                        "\tchar *src_bitmap, *bitmap;",
                        "\tunsigned int bitmap_size, main_bitmap_size, sit_bitmap_size;",
                        "",
                        "\t/* allocate memory for SIT information */",
                        "\tsit_i = f2fs_kzalloc(sbi, sizeof(struct sit_info), GFP_KERNEL);",
                        "\tif (!sit_i)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tSM_I(sbi)->sit_info = sit_i;",
                        "",
                        "\tsit_i->sentries =",
                        "\t\tf2fs_kvzalloc(sbi, array_size(sizeof(struct seg_entry),",
                        "\t\t\t\t\t      MAIN_SEGS(sbi)),",
                        "\t\t\t      GFP_KERNEL);",
                        "\tif (!sit_i->sentries)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tmain_bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));",
                        "\tsit_i->dirty_sentries_bitmap = f2fs_kvzalloc(sbi, main_bitmap_size,",
                        "\t\t\t\t\t\t\t\tGFP_KERNEL);",
                        "\tif (!sit_i->dirty_sentries_bitmap)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "#ifdef CONFIG_F2FS_CHECK_FS",
                        "\tbitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * 4;",
                        "#else",
                        "\tbitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * 3;",
                        "#endif",
                        "\tsit_i->bitmap = f2fs_kvzalloc(sbi, bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->bitmap)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tbitmap = sit_i->bitmap;",
                        "",
                        "\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {",
                        "\t\tsit_i->sentries[start].cur_valid_map = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "",
                        "\t\tsit_i->sentries[start].ckpt_valid_map = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "",
                        "#ifdef CONFIG_F2FS_CHECK_FS",
                        "\t\tsit_i->sentries[start].cur_valid_map_mir = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "#endif",
                        "",
                        "\t\tsit_i->sentries[start].discard_map = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "\t}",
                        "",
                        "\tsit_i->tmp_map = f2fs_kzalloc(sbi, SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);",
                        "\tif (!sit_i->tmp_map)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tif (__is_large_section(sbi)) {",
                        "\t\tsit_i->sec_entries =",
                        "\t\t\tf2fs_kvzalloc(sbi, array_size(sizeof(struct sec_entry),",
                        "\t\t\t\t\t\t      MAIN_SECS(sbi)),",
                        "\t\t\t\t      GFP_KERNEL);",
                        "\t\tif (!sit_i->sec_entries)",
                        "\t\t\treturn -ENOMEM;",
                        "\t}",
                        "",
                        "\t/* get information related with SIT */",
                        "\tsit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;",
                        "",
                        "\t/* setup SIT bitmap from ckeckpoint pack */",
                        "\tsit_bitmap_size = __bitmap_size(sbi, SIT_BITMAP);",
                        "\tsrc_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);",
                        "",
                        "\tsit_i->sit_bitmap = kmemdup(src_bitmap, sit_bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->sit_bitmap)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "#ifdef CONFIG_F2FS_CHECK_FS",
                        "\tsit_i->sit_bitmap_mir = kmemdup(src_bitmap,",
                        "\t\t\t\t\tsit_bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->sit_bitmap_mir)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tsit_i->invalid_segmap = f2fs_kvzalloc(sbi,",
                        "\t\t\t\t\tmain_bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->invalid_segmap)",
                        "\t\treturn -ENOMEM;",
                        "#endif",
                        "",
                        "\t/* init SIT information */",
                        "\tsit_i->s_ops = &default_salloc_ops;",
                        "",
                        "\tsit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);",
                        "\tsit_i->sit_blocks = sit_segs << sbi->log_blocks_per_seg;",
                        "\tsit_i->written_valid_blocks = 0;",
                        "\tsit_i->bitmap_size = sit_bitmap_size;",
                        "\tsit_i->dirty_sentries = 0;",
                        "\tsit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;",
                        "\tsit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);",
                        "\tsit_i->mounted_time = ktime_get_boottime_seconds();",
                        "\tinit_rwsem(&sit_i->sentry_lock);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 4013,
                    "highlight": 4029
                },
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4768",
                    "code": [
                        "int f2fs_build_segment_manager(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);",
                        "\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);",
                        "\tstruct f2fs_sm_info *sm_info;",
                        "\tint err;",
                        "",
                        "\tsm_info = f2fs_kzalloc(sbi, sizeof(struct f2fs_sm_info), GFP_KERNEL);",
                        "\tif (!sm_info)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\t/* init sm info */",
                        "\tsbi->sm_info = sm_info;",
                        "\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);",
                        "\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);",
                        "\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);",
                        "\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);",
                        "\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);",
                        "\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);",
                        "\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);",
                        "\tsm_info->rec_prefree_segments = sm_info->main_segments *",
                        "\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;",
                        "\tif (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)",
                        "\t\tsm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;",
                        "",
                        "\tif (!f2fs_lfs_mode(sbi))",
                        "\t\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;",
                        "\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;",
                        "\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;",
                        "\tsm_info->min_seq_blocks = sbi->blocks_per_seg * sbi->segs_per_sec;",
                        "\tsm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;",
                        "\tsm_info->min_ssr_sections = reserved_sections(sbi);",
                        "",
                        "\tINIT_LIST_HEAD(&sm_info->sit_entry_set);",
                        "",
                        "\tinit_rwsem(&sm_info->curseg_lock);",
                        "",
                        "\tif (!f2fs_readonly(sbi->sb)) {",
                        "\t\terr = f2fs_create_flush_cmd_control(sbi);",
                        "\t\tif (err)",
                        "\t\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = create_discard_cmd_control(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = build_sit_info(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_free_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\t/* reinit free segmap based on SIT */",
                        "\terr = build_sit_entries(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_free_segmap(sbi);",
                        "\terr = build_dirty_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = sanity_check_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_min_max_mtime(sbi);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 4721,
                    "highlight": 4768
                }
            ],
            "ins_idx": 211,
            "addr": "0xffffffff8161c2f0"
        },
        "3472": {
            "name": "+0x162",
            "parent_idx": 3471,
            "source_line": [
                {
                    "file": "lib/stackdepot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/stackdepot.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n318",
                    "code": [
                        "/**",
                        " * stack_depot_save - Save a stack trace from an array",
                        " *",
                        " * @entries:\t\tPointer to storage array",
                        " * @nr_entries:\t\tSize of the storage array",
                        " * @alloc_flags:\tAllocation gfp flags",
                        " *",
                        " * Return: The handle of the stack struct stored in depot",
                        " */",
                        "depot_stack_handle_t stack_depot_save(unsigned long *entries,",
                        "\t\t\t\t      unsigned int nr_entries,",
                        "\t\t\t\t      gfp_t alloc_flags)",
                        "{",
                        "\tstruct stack_record *found = NULL, **bucket;",
                        "\tdepot_stack_handle_t retval = 0;",
                        "\tstruct page *page = NULL;",
                        "\tvoid *prealloc = NULL;",
                        "\tunsigned long flags;",
                        "\tu32 hash;",
                        "",
                        "\tif (unlikely(nr_entries == 0))",
                        "\t\tgoto fast_exit;",
                        "",
                        "\thash = hash_stack(entries, nr_entries);",
                        "\tbucket = &stack_table[hash & STACK_HASH_MASK];",
                        "",
                        "\t/*",
                        "\t * Fast path: look the stack trace up without locking.",
                        "\t * The smp_load_acquire() here pairs with smp_store_release() to",
                        "\t * |bucket| below.",
                        "\t */",
                        "\tfound = find_stack(smp_load_acquire(bucket), entries,",
                        "\t\t\t   nr_entries, hash);",
                        "\tif (found)",
                        "\t\tgoto exit;",
                        "",
                        "\t/*",
                        "\t * Check if the current or the next stack slab need to be initialized.",
                        "\t * If so, allocate the memory - we won't be able to do that under the",
                        "\t * lock.",
                        "\t *",
                        "\t * The smp_load_acquire() here pairs with smp_store_release() to",
                        "\t * |next_slab_inited| in depot_alloc_stack() and init_stack_slab().",
                        "\t */",
                        "\tif (unlikely(!smp_load_acquire(&next_slab_inited))) {",
                        "\t\t/*",
                        "\t\t * Zero out zone modifiers, as we don't have specific zone",
                        "\t\t * requirements. Keep the flags related to allocation in atomic",
                        "\t\t * contexts and I/O.",
                        "\t\t */",
                        "\t\talloc_flags &= ~GFP_ZONEMASK;",
                        "\t\talloc_flags &= (GFP_ATOMIC | GFP_KERNEL);",
                        "\t\talloc_flags |= __GFP_NOWARN;",
                        "\t\tpage = alloc_pages(alloc_flags, STACK_ALLOC_ORDER);",
                        "\t\tif (page)",
                        "\t\t\tprealloc = page_address(page);",
                        "\t}",
                        "",
                        "\tspin_lock_irqsave(&depot_lock, flags);",
                        "",
                        "\tfound = find_stack(*bucket, entries, nr_entries, hash);",
                        "\tif (!found) {",
                        "\t\tstruct stack_record *new =",
                        "\t\t\tdepot_alloc_stack(entries, nr_entries,",
                        "\t\t\t\t\t  hash, &prealloc, alloc_flags);",
                        "\t\tif (new) {",
                        "\t\t\tnew->next = *bucket;",
                        "\t\t\t/*",
                        "\t\t\t * This smp_store_release() pairs with",
                        "\t\t\t * smp_load_acquire() from |bucket| above.",
                        "\t\t\t */",
                        "\t\t\tsmp_store_release(bucket, new);",
                        "\t\t\tfound = new;",
                        "\t\t}",
                        "\t} else if (prealloc) {",
                        "\t\t/*",
                        "\t\t * We didn't need to store this stack trace, but let's keep",
                        "\t\t * the preallocated memory for the future.",
                        "\t\t */",
                        "\t\tWARN_ON(!init_stack_slab(&prealloc));",
                        "\t}",
                        "",
                        "\tspin_unlock_irqrestore(&depot_lock, flags);",
                        "exit:",
                        "\tif (prealloc) {",
                        "\t\t/* Nobody used this memory, ok to free it. */",
                        "\t\tfree_pages((unsigned long)prealloc, STACK_ALLOC_ORDER);",
                        "\t}",
                        "\tif (found)",
                        "\t\tretval = found->handle.handle;",
                        "fast_exit:",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 226,
                    "highlight": 318
                }
            ],
            "ins_idx": 271,
            "addr": "0xffffffff81757222"
        },
        "3471": {
            "name": "kvmalloc_node",
            "parent_idx": 3331,
            "source_line": [
                {
                    "file": "./include/linux/mm.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/mm.h?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n757",
                    "code": [
                        "extern void *kvmalloc_node(size_t size, gfp_t flags, int node);",
                        "static inline void *kvmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kvmalloc_node(size, flags, NUMA_NO_NODE);",
                        "}"
                    ],
                    "start": 754,
                    "highlight": 757
                },
                {
                    "file": "fs/f2fs/f2fs.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/f2fs.h?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n3030",
                    "code": [
                        "static inline void *f2fs_kvmalloc(struct f2fs_sb_info *sbi,",
                        "\t\t\t\t\tsize_t size, gfp_t flags)",
                        "{",
                        "\tif (time_to_inject(sbi, FAULT_KVMALLOC)) {",
                        "\t\tf2fs_show_injection_info(sbi, FAULT_KVMALLOC);",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\treturn kvmalloc(size, flags);",
                        "}"
                    ],
                    "start": 3022,
                    "highlight": 3030
                },
                {
                    "file": "fs/f2fs/f2fs.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/f2fs.h?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n3036",
                    "code": [
                        "static inline void *f2fs_kvzalloc(struct f2fs_sb_info *sbi,",
                        "\t\t\t\t\tsize_t size, gfp_t flags)",
                        "{",
                        "\treturn f2fs_kvmalloc(sbi, size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 3033,
                    "highlight": 3036
                },
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4029",
                    "code": [
                        "static int build_sit_info(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);",
                        "\tstruct sit_info *sit_i;",
                        "\tunsigned int sit_segs, start;",
                        "\tchar *src_bitmap, *bitmap;",
                        "\tunsigned int bitmap_size, main_bitmap_size, sit_bitmap_size;",
                        "",
                        "\t/* allocate memory for SIT information */",
                        "\tsit_i = f2fs_kzalloc(sbi, sizeof(struct sit_info), GFP_KERNEL);",
                        "\tif (!sit_i)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tSM_I(sbi)->sit_info = sit_i;",
                        "",
                        "\tsit_i->sentries =",
                        "\t\tf2fs_kvzalloc(sbi, array_size(sizeof(struct seg_entry),",
                        "\t\t\t\t\t      MAIN_SEGS(sbi)),",
                        "\t\t\t      GFP_KERNEL);",
                        "\tif (!sit_i->sentries)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tmain_bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));",
                        "\tsit_i->dirty_sentries_bitmap = f2fs_kvzalloc(sbi, main_bitmap_size,",
                        "\t\t\t\t\t\t\t\tGFP_KERNEL);",
                        "\tif (!sit_i->dirty_sentries_bitmap)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "#ifdef CONFIG_F2FS_CHECK_FS",
                        "\tbitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * 4;",
                        "#else",
                        "\tbitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * 3;",
                        "#endif",
                        "\tsit_i->bitmap = f2fs_kvzalloc(sbi, bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->bitmap)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tbitmap = sit_i->bitmap;",
                        "",
                        "\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {",
                        "\t\tsit_i->sentries[start].cur_valid_map = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "",
                        "\t\tsit_i->sentries[start].ckpt_valid_map = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "",
                        "#ifdef CONFIG_F2FS_CHECK_FS",
                        "\t\tsit_i->sentries[start].cur_valid_map_mir = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "#endif",
                        "",
                        "\t\tsit_i->sentries[start].discard_map = bitmap;",
                        "\t\tbitmap += SIT_VBLOCK_MAP_SIZE;",
                        "\t}",
                        "",
                        "\tsit_i->tmp_map = f2fs_kzalloc(sbi, SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);",
                        "\tif (!sit_i->tmp_map)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tif (__is_large_section(sbi)) {",
                        "\t\tsit_i->sec_entries =",
                        "\t\t\tf2fs_kvzalloc(sbi, array_size(sizeof(struct sec_entry),",
                        "\t\t\t\t\t\t      MAIN_SECS(sbi)),",
                        "\t\t\t\t      GFP_KERNEL);",
                        "\t\tif (!sit_i->sec_entries)",
                        "\t\t\treturn -ENOMEM;",
                        "\t}",
                        "",
                        "\t/* get information related with SIT */",
                        "\tsit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;",
                        "",
                        "\t/* setup SIT bitmap from ckeckpoint pack */",
                        "\tsit_bitmap_size = __bitmap_size(sbi, SIT_BITMAP);",
                        "\tsrc_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);",
                        "",
                        "\tsit_i->sit_bitmap = kmemdup(src_bitmap, sit_bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->sit_bitmap)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "#ifdef CONFIG_F2FS_CHECK_FS",
                        "\tsit_i->sit_bitmap_mir = kmemdup(src_bitmap,",
                        "\t\t\t\t\tsit_bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->sit_bitmap_mir)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tsit_i->invalid_segmap = f2fs_kvzalloc(sbi,",
                        "\t\t\t\t\tmain_bitmap_size, GFP_KERNEL);",
                        "\tif (!sit_i->invalid_segmap)",
                        "\t\treturn -ENOMEM;",
                        "#endif",
                        "",
                        "\t/* init SIT information */",
                        "\tsit_i->s_ops = &default_salloc_ops;",
                        "",
                        "\tsit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);",
                        "\tsit_i->sit_blocks = sit_segs << sbi->log_blocks_per_seg;",
                        "\tsit_i->written_valid_blocks = 0;",
                        "\tsit_i->bitmap_size = sit_bitmap_size;",
                        "\tsit_i->dirty_sentries = 0;",
                        "\tsit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;",
                        "\tsit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);",
                        "\tsit_i->mounted_time = ktime_get_boottime_seconds();",
                        "\tinit_rwsem(&sit_i->sentry_lock);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 4013,
                    "highlight": 4029
                },
                {
                    "file": "fs/f2fs/segment.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/f2fs/segment.c?id=171d4ff79f965c1f164705ef0aaea102a6ad238b#n4768",
                    "code": [
                        "int f2fs_build_segment_manager(struct f2fs_sb_info *sbi)",
                        "{",
                        "\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);",
                        "\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);",
                        "\tstruct f2fs_sm_info *sm_info;",
                        "\tint err;",
                        "",
                        "\tsm_info = f2fs_kzalloc(sbi, sizeof(struct f2fs_sm_info), GFP_KERNEL);",
                        "\tif (!sm_info)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\t/* init sm info */",
                        "\tsbi->sm_info = sm_info;",
                        "\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);",
                        "\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);",
                        "\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);",
                        "\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);",
                        "\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);",
                        "\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);",
                        "\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);",
                        "\tsm_info->rec_prefree_segments = sm_info->main_segments *",
                        "\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;",
                        "\tif (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)",
                        "\t\tsm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;",
                        "",
                        "\tif (!f2fs_lfs_mode(sbi))",
                        "\t\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;",
                        "\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;",
                        "\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;",
                        "\tsm_info->min_seq_blocks = sbi->blocks_per_seg * sbi->segs_per_sec;",
                        "\tsm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;",
                        "\tsm_info->min_ssr_sections = reserved_sections(sbi);",
                        "",
                        "\tINIT_LIST_HEAD(&sm_info->sit_entry_set);",
                        "",
                        "\tinit_rwsem(&sm_info->curseg_lock);",
                        "",
                        "\tif (!f2fs_readonly(sbi->sb)) {",
                        "\t\terr = f2fs_create_flush_cmd_control(sbi);",
                        "\t\tif (err)",
                        "\t\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = create_discard_cmd_control(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = build_sit_info(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_free_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\terr = build_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\t/* reinit free segmap based on SIT */",
                        "\terr = build_sit_entries(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_free_segmap(sbi);",
                        "\terr = build_dirty_segmap(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\terr = sanity_check_curseg(sbi);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tinit_min_max_mtime(sbi);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 4721,
                    "highlight": 4768
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8161c2eb"
        }
    },
    "ins": {
        "33": {
            "name": "add r13, qword ptr [r12 + 0x20]",
            "desc": "Invalid Memory Access\nOut of Bound Access.",
            "call_idx": 4389,
            "inputs": [
                8097,
                8098,
                8099
            ],
            "outputs": [
                8100
            ]
        },
        "68": {
            "name": "lea r12, qword ptr [rbp + rcx*8]",
            "desc": "",
            "call_idx": 4388,
            "inputs": [
                8094,
                8095
            ],
            "outputs": [
                8096
            ]
        },
        "105": {
            "name": "mov rbp, qword ptr [rbx + 0x70]",
            "desc": "",
            "call_idx": 4364,
            "inputs": [
                8027,
                8028
            ],
            "outputs": [
                8029
            ]
        },
        "156": {
            "name": "mov qword ptr [rbp + 0x70], rbx",
            "desc": "",
            "call_idx": 3474,
            "inputs": [
                6405,
                6406
            ],
            "outputs": [
                6407
            ]
        },
        "211": {
            "name": "mov rbx, rax",
            "desc": "",
            "call_idx": 3473,
            "inputs": [
                6403
            ],
            "outputs": [
                6404
            ]
        },
        "271": {
            "name": "ret ",
            "desc": "",
            "call_idx": 3472,
            "inputs": [],
            "outputs": [
                6402
            ]
        }
    },
    "data": {
        "8097": {
            "name": "R12",
            "ins_idx": 33,
            "value": "0xffff8881e9f4cbc0",
            "sources": []
        },
        "8098": {
            "name": "[0xffff8881e9f4cbe0]",
            "ins_idx": 33,
            "value": "0x0",
            "sources": []
        },
        "8099": {
            "name": "R13",
            "ins_idx": 33,
            "value": "0x0",
            "sources": []
        },
        "8100": {
            "name": "R13",
            "ins_idx": 33,
            "value": "0x0",
            "sources": []
        },
        "8094": {
            "name": "RCX",
            "ins_idx": 68,
            "value": "0x78",
            "sources": []
        },
        "8095": {
            "name": "RBP",
            "ins_idx": 68,
            "value": "0xffff8881e9f4c800",
            "sources": []
        },
        "8096": {
            "name": "R12",
            "ins_idx": 68,
            "value": "0xffff8881e9f4cbc0",
            "sources": [
                8097
            ]
        },
        "8027": {
            "name": "RBX",
            "ins_idx": 105,
            "value": "0xffff8881e920b600",
            "sources": []
        },
        "8028": {
            "name": "[0xffff8881e920b670]",
            "ins_idx": 105,
            "value": "0xffff8881e9f4c800",
            "sources": []
        },
        "8029": {
            "name": "RBP",
            "ins_idx": 105,
            "value": "0xffff8881e9f4c800",
            "sources": [
                8095
            ]
        },
        "6405": {
            "name": "RBP",
            "ins_idx": 156,
            "value": "0xffff8881e920b600",
            "sources": []
        },
        "6406": {
            "name": "RBX",
            "ins_idx": 156,
            "value": "0xffff8881e9f4c800",
            "sources": []
        },
        "6407": {
            "name": "[0xffff8881e920b670]",
            "ins_idx": 156,
            "value": "0xffff8881e9f4c800",
            "sources": [
                8028
            ]
        },
        "6403": {
            "name": "RAX",
            "ins_idx": 211,
            "value": "0xffff8881e9f4c800",
            "sources": []
        },
        "6404": {
            "name": "RBX",
            "ins_idx": 211,
            "value": "0xffff8881e9f4c800",
            "sources": [
                6406
            ]
        },
        "6402": {
            "name": "RAX",
            "ins_idx": 271,
            "value": "0xffff8881e9f4c800",
            "sources": [
                6403
            ]
        }
    },
    "chain": {
        "33": [
            68
        ],
        "68": [
            105
        ],
        "105": [
            156
        ],
        "156": [
            211
        ],
        "211": [
            271
        ]
    }
}