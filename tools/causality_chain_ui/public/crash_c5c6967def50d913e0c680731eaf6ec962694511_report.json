{
    "report": "https://syzkaller.appspot.com/bug?id=c5c6967def50d913e0c680731eaf6ec962694511",
    "title": "general protection fault in fib_dump_info (2)",
    "call": {
        "1631": {
            "name": "+0x15f",
            "parent_idx": 1606,
            "source_line": [
                {
                    "file": "./include/net/nexthop.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/nexthop.h?id=c3d8f220d012#n240",
                    "code": [
                        "/* called with rcu lock */",
                        "static inline bool nexthop_is_blackhole(const struct nexthop *nh)",
                        "{",
                        "\tconst struct nh_info *nhi;",
                        "",
                        "\tif (nh->is_group) {",
                        "\t\tstruct nh_group *nh_grp;",
                        "",
                        "\t\tnh_grp = rcu_dereference_rtnl(nh->nh_grp);",
                        "\t\tif (nh_grp->num_nh > 1)",
                        "\t\t\treturn false;",
                        "",
                        "\t\tnh = nh_grp->nh_entries[0].nh;",
                        "\t}",
                        "",
                        "\tnhi = rcu_dereference_rtnl(nh->nh_info);",
                        "\treturn nhi->reject_nh;",
                        "}"
                    ],
                    "start": 225,
                    "highlight": 240
                },
                {
                    "file": "net/ipv4/fib_semantics.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/fib_semantics.c?id=c3d8f220d012#n1781",
                    "code": [
                        "int fib_dump_info(struct sk_buff *skb, u32 portid, u32 seq, int event,",
                        "\t\t  struct fib_rt_info *fri, unsigned int flags)",
                        "{",
                        "\tunsigned int nhs = fib_info_num_path(fri->fi);",
                        "\tstruct fib_info *fi = fri->fi;",
                        "\tu32 tb_id = fri->tb_id;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tstruct rtmsg *rtm;",
                        "",
                        "\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), flags);",
                        "\tif (!nlh)",
                        "\t\treturn -EMSGSIZE;",
                        "",
                        "\trtm = nlmsg_data(nlh);",
                        "\trtm->rtm_family = AF_INET;",
                        "\trtm->rtm_dst_len = fri->dst_len;",
                        "\trtm->rtm_src_len = 0;",
                        "\trtm->rtm_tos = fri->tos;",
                        "\tif (tb_id < 256)",
                        "\t\trtm->rtm_table = tb_id;",
                        "\telse",
                        "\t\trtm->rtm_table = RT_TABLE_COMPAT;",
                        "\tif (nla_put_u32(skb, RTA_TABLE, tb_id))",
                        "\t\tgoto nla_put_failure;",
                        "\trtm->rtm_type = fri->type;",
                        "\trtm->rtm_flags = fi->fib_flags;",
                        "\trtm->rtm_scope = fi->fib_scope;",
                        "\trtm->rtm_protocol = fi->fib_protocol;",
                        "",
                        "\tif (rtm->rtm_dst_len &&",
                        "\t    nla_put_in_addr(skb, RTA_DST, fri->dst))",
                        "\t\tgoto nla_put_failure;",
                        "\tif (fi->fib_priority &&",
                        "\t    nla_put_u32(skb, RTA_PRIORITY, fi->fib_priority))",
                        "\t\tgoto nla_put_failure;",
                        "\tif (rtnetlink_put_metrics(skb, fi->fib_metrics->metrics) < 0)",
                        "\t\tgoto nla_put_failure;",
                        "",
                        "\tif (fi->fib_prefsrc &&",
                        "\t    nla_put_in_addr(skb, RTA_PREFSRC, fi->fib_prefsrc))",
                        "\t\tgoto nla_put_failure;",
                        "",
                        "\tif (fi->nh) {",
                        "\t\tif (nla_put_u32(skb, RTA_NH_ID, fi->nh->id))",
                        "\t\t\tgoto nla_put_failure;",
                        "\t\tif (nexthop_is_blackhole(fi->nh))",
                        "\t\t\trtm->rtm_type = RTN_BLACKHOLE;",
                        "\t\tif (!fi->fib_net->ipv4.sysctl_nexthop_compat_mode)",
                        "\t\t\tgoto offload;",
                        "\t}",
                        "",
                        "\tif (nhs == 1) {",
                        "\t\tconst struct fib_nh_common *nhc = fib_info_nhc(fi, 0);",
                        "\t\tunsigned char flags = 0;",
                        "",
                        "\t\tif (fib_nexthop_info(skb, nhc, AF_INET, &flags, false) < 0)",
                        "\t\t\tgoto nla_put_failure;",
                        "",
                        "\t\trtm->rtm_flags = flags;",
                        "#ifdef CONFIG_IP_ROUTE_CLASSID",
                        "\t\tif (nhc->nhc_family == AF_INET) {",
                        "\t\t\tstruct fib_nh *nh;",
                        "",
                        "\t\t\tnh = container_of(nhc, struct fib_nh, nh_common);",
                        "\t\t\tif (nh->nh_tclassid &&",
                        "\t\t\t    nla_put_u32(skb, RTA_FLOW, nh->nh_tclassid))",
                        "\t\t\t\tgoto nla_put_failure;",
                        "\t\t}",
                        "#endif",
                        "\t} else {",
                        "\t\tif (fib_add_multipath(skb, fi) < 0)",
                        "\t\t\tgoto nla_put_failure;",
                        "\t}",
                        "",
                        "offload:",
                        "\tif (fri->offload)",
                        "\t\trtm->rtm_flags |= RTM_F_OFFLOAD;",
                        "\tif (fri->trap)",
                        "\t\trtm->rtm_flags |= RTM_F_TRAP;",
                        "",
                        "\tnlmsg_end(skb, nlh);",
                        "\treturn 0;",
                        "",
                        "nla_put_failure:",
                        "\tnlmsg_cancel(skb, nlh);",
                        "\treturn -EMSGSIZE;",
                        "}"
                    ],
                    "start": 1736,
                    "highlight": 1781
                }
            ],
            "ins_idx": 1,
            "addr": "0xffffffff819b0aff"
        },
        "1606": {
            "name": "fib_dump_info",
            "parent_idx": 1595,
            "source_line": [
                {
                    "file": "net/ipv4/fib_semantics.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/fib_semantics.c?id=c3d8f220d012#n524",
                    "code": [
                        "void rtmsg_fib(int event, __be32 key, struct fib_alias *fa,",
                        "\t       int dst_len, u32 tb_id, const struct nl_info *info,",
                        "\t       unsigned int nlm_flags)",
                        "{",
                        "\tstruct fib_rt_info fri;",
                        "\tstruct sk_buff *skb;",
                        "\tu32 seq = info->nlh ? info->nlh->nlmsg_seq : 0;",
                        "\tint err = -ENOBUFS;",
                        "",
                        "\tskb = nlmsg_new(fib_nlmsg_size(fa->fa_info), GFP_KERNEL);",
                        "\tif (!skb)",
                        "\t\tgoto errout;",
                        "",
                        "\tfri.fi = fa->fa_info;",
                        "\tfri.tb_id = tb_id;",
                        "\tfri.dst = key;",
                        "\tfri.dst_len = dst_len;",
                        "\tfri.tos = fa->fa_tos;",
                        "\tfri.type = fa->fa_type;",
                        "\tfri.offload = fa->offload;",
                        "\tfri.trap = fa->trap;",
                        "\terr = fib_dump_info(skb, info->portid, seq, event, &fri, nlm_flags);",
                        "\tif (err < 0) {",
                        "\t\t/* -EMSGSIZE implies BUG in fib_nlmsg_size() */",
                        "\t\tWARN_ON(err == -EMSGSIZE);",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto errout;",
                        "\t}",
                        "\trtnl_notify(skb, info->nl_net, info->portid, RTNLGRP_IPV4_ROUTE,",
                        "\t\t    info->nlh, GFP_KERNEL);",
                        "\treturn;",
                        "errout:",
                        "\tif (err < 0)",
                        "\t\trtnl_set_sk_err(info->nl_net, RTNLGRP_IPV4_ROUTE, err);",
                        "}"
                    ],
                    "start": 503,
                    "highlight": 524
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819b0f02"
        },
        "1595": {
            "name": "rtmsg_fib",
            "parent_idx": 1553,
            "source_line": [
                {
                    "file": "net/ipv4/fib_trie.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/fib_trie.c?id=c3d8f220d012#n1352",
                    "code": [
                        "/* Caller must hold RTNL. */",
                        "int fib_table_insert(struct net *net, struct fib_table *tb,",
                        "\t\t     struct fib_config *cfg, struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct trie *t = (struct trie *)tb->tb_data;",
                        "\tstruct fib_alias *fa, *new_fa;",
                        "\tstruct key_vector *l, *tp;",
                        "\tu16 nlflags = NLM_F_EXCL;",
                        "\tstruct fib_info *fi;",
                        "\tu8 plen = cfg->fc_dst_len;",
                        "\tu8 slen = KEYLENGTH - plen;",
                        "\tu8 tos = cfg->fc_tos;",
                        "\tu32 key;",
                        "\tint err;",
                        "",
                        "\tkey = ntohl(cfg->fc_dst);",
                        "",
                        "\tif (!fib_valid_key_len(key, plen, extack))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tpr_debug(\"Insert table=%u %08x/%d\\n\", tb->tb_id, key, plen);",
                        "",
                        "\tfi = fib_create_info(cfg, extack);",
                        "\tif (IS_ERR(fi)) {",
                        "\t\terr = PTR_ERR(fi);",
                        "\t\tgoto err;",
                        "\t}",
                        "",
                        "\tl = fib_find_node(t, &tp, key);",
                        "\tfa = l ? fib_find_alias(&l->leaf, slen, tos, fi->fib_priority,",
                        "\t\t\t\ttb->tb_id, false) : NULL;",
                        "",
                        "\t/* Now fa, if non-NULL, points to the first fib alias",
                        "\t * with the same keys [prefix,tos,priority], if such key already",
                        "\t * exists or to the node before which we will insert new one.",
                        "\t *",
                        "\t * If fa is NULL, we will need to allocate a new one and",
                        "\t * insert to the tail of the section matching the suffix length",
                        "\t * of the new alias.",
                        "\t */",
                        "",
                        "\tif (fa && fa->fa_tos == tos &&",
                        "\t    fa->fa_info->fib_priority == fi->fib_priority) {",
                        "\t\tstruct fib_alias *fa_first, *fa_match;",
                        "",
                        "\t\terr = -EEXIST;",
                        "\t\tif (cfg->fc_nlflags & NLM_F_EXCL)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tnlflags &= ~NLM_F_EXCL;",
                        "",
                        "\t\t/* We have 2 goals:",
                        "\t\t * 1. Find exact match for type, scope, fib_info to avoid",
                        "\t\t * duplicate routes",
                        "\t\t * 2. Find next 'fa' (or head), NLM_F_APPEND inserts before it",
                        "\t\t */",
                        "\t\tfa_match = NULL;",
                        "\t\tfa_first = fa;",
                        "\t\thlist_for_each_entry_from(fa, fa_list) {",
                        "\t\t\tif ((fa->fa_slen != slen) ||",
                        "\t\t\t    (fa->tb_id != tb->tb_id) ||",
                        "\t\t\t    (fa->fa_tos != tos))",
                        "\t\t\t\tbreak;",
                        "\t\t\tif (fa->fa_info->fib_priority != fi->fib_priority)",
                        "\t\t\t\tbreak;",
                        "\t\t\tif (fa->fa_type == cfg->fc_type &&",
                        "\t\t\t    fa->fa_info == fi) {",
                        "\t\t\t\tfa_match = fa;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (cfg->fc_nlflags & NLM_F_REPLACE) {",
                        "\t\t\tstruct fib_info *fi_drop;",
                        "\t\t\tu8 state;",
                        "",
                        "\t\t\tnlflags |= NLM_F_REPLACE;",
                        "\t\t\tfa = fa_first;",
                        "\t\t\tif (fa_match) {",
                        "\t\t\t\tif (fa == fa_match)",
                        "\t\t\t\t\terr = 0;",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t\terr = -ENOBUFS;",
                        "\t\t\tnew_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);",
                        "\t\t\tif (!new_fa)",
                        "\t\t\t\tgoto out;",
                        "",
                        "\t\t\tfi_drop = fa->fa_info;",
                        "\t\t\tnew_fa->fa_tos = fa->fa_tos;",
                        "\t\t\tnew_fa->fa_info = fi;",
                        "\t\t\tnew_fa->fa_type = cfg->fc_type;",
                        "\t\t\tstate = fa->fa_state;",
                        "\t\t\tnew_fa->fa_state = state & ~FA_S_ACCESSED;",
                        "\t\t\tnew_fa->fa_slen = fa->fa_slen;",
                        "\t\t\tnew_fa->tb_id = tb->tb_id;",
                        "\t\t\tnew_fa->fa_default = -1;",
                        "\t\t\tnew_fa->offload = 0;",
                        "\t\t\tnew_fa->trap = 0;",
                        "",
                        "\t\t\thlist_replace_rcu(&fa->fa_list, &new_fa->fa_list);",
                        "",
                        "\t\t\tif (fib_find_alias(&l->leaf, fa->fa_slen, 0, 0,",
                        "\t\t\t\t\t   tb->tb_id, true) == new_fa) {",
                        "\t\t\t\tenum fib_event_type fib_event;",
                        "",
                        "\t\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;",
                        "\t\t\t\terr = call_fib_entry_notifiers(net, fib_event,",
                        "\t\t\t\t\t\t\t       key, plen,",
                        "\t\t\t\t\t\t\t       new_fa, extack);",
                        "\t\t\t\tif (err) {",
                        "\t\t\t\t\thlist_replace_rcu(&new_fa->fa_list,",
                        "\t\t\t\t\t\t\t  &fa->fa_list);",
                        "\t\t\t\t\tgoto out_free_new_fa;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\trtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen,",
                        "\t\t\t\t  tb->tb_id, &cfg->fc_nlinfo, nlflags);",
                        "",
                        "\t\t\talias_free_mem_rcu(fa);",
                        "",
                        "\t\t\tfib_release_info(fi_drop);",
                        "\t\t\tif (state & FA_S_ACCESSED)",
                        "\t\t\t\trt_cache_flush(cfg->fc_nlinfo.nl_net);",
                        "",
                        "\t\t\tgoto succeeded;",
                        "\t\t}",
                        "\t\t/* Error if we find a perfect match which",
                        "\t\t * uses the same scope, type, and nexthop",
                        "\t\t * information.",
                        "\t\t */",
                        "\t\tif (fa_match)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tif (cfg->fc_nlflags & NLM_F_APPEND)",
                        "\t\t\tnlflags |= NLM_F_APPEND;",
                        "\t\telse",
                        "\t\t\tfa = fa_first;",
                        "\t}",
                        "\terr = -ENOENT;",
                        "\tif (!(cfg->fc_nlflags & NLM_F_CREATE))",
                        "\t\tgoto out;",
                        "",
                        "\tnlflags |= NLM_F_CREATE;",
                        "\terr = -ENOBUFS;",
                        "\tnew_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);",
                        "\tif (!new_fa)",
                        "\t\tgoto out;",
                        "",
                        "\tnew_fa->fa_info = fi;",
                        "\tnew_fa->fa_tos = tos;",
                        "\tnew_fa->fa_type = cfg->fc_type;",
                        "\tnew_fa->fa_state = 0;",
                        "\tnew_fa->fa_slen = slen;",
                        "\tnew_fa->tb_id = tb->tb_id;",
                        "\tnew_fa->fa_default = -1;",
                        "\tnew_fa->offload = 0;",
                        "\tnew_fa->trap = 0;",
                        "",
                        "\t/* Insert new entry to the list. */",
                        "\terr = fib_insert_alias(t, tp, l, new_fa, fa, key);",
                        "\tif (err)",
                        "\t\tgoto out_free_new_fa;",
                        "",
                        "\t/* The alias was already inserted, so the node must exist. */",
                        "\tl = l ? l : fib_find_node(t, &tp, key);",
                        "\tif (WARN_ON_ONCE(!l))",
                        "\t\tgoto out_free_new_fa;",
                        "",
                        "\tif (fib_find_alias(&l->leaf, new_fa->fa_slen, 0, 0, tb->tb_id, true) ==",
                        "\t    new_fa) {",
                        "\t\tenum fib_event_type fib_event;",
                        "",
                        "\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;",
                        "\t\terr = call_fib_entry_notifiers(net, fib_event, key, plen,",
                        "\t\t\t\t\t       new_fa, extack);",
                        "\t\tif (err)",
                        "\t\t\tgoto out_remove_new_fa;",
                        "\t}",
                        "",
                        "\tif (!plen)",
                        "\t\ttb->tb_num_default++;",
                        "",
                        "\trt_cache_flush(cfg->fc_nlinfo.nl_net);",
                        "\trtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, new_fa->tb_id,",
                        "\t\t  &cfg->fc_nlinfo, nlflags);",
                        "succeeded:",
                        "\treturn 0;",
                        "",
                        "out_remove_new_fa:",
                        "\tfib_remove_alias(t, tp, l, new_fa);",
                        "out_free_new_fa:",
                        "\tkmem_cache_free(fn_alias_kmem, new_fa);",
                        "out:",
                        "\tfib_release_info(fi);",
                        "err:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1167,
                    "highlight": 1352
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819b3be8"
        },
        "1553": {
            "name": "fib_table_insert",
            "parent_idx": 1530,
            "source_line": [
                {
                    "file": "net/ipv4/fib_frontend.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/fib_frontend.c?id=c3d8f220d012#n883",
                    "code": [
                        "static int inet_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t     struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct fib_config cfg;",
                        "\tstruct fib_table *tb;",
                        "\tint err;",
                        "",
                        "\terr = rtm_to_fib_config(net, skb, nlh, &cfg, extack);",
                        "\tif (err < 0)",
                        "\t\tgoto errout;",
                        "",
                        "\ttb = fib_new_table(net, cfg.fc_table);",
                        "\tif (!tb) {",
                        "\t\terr = -ENOBUFS;",
                        "\t\tgoto errout;",
                        "\t}",
                        "",
                        "\terr = fib_table_insert(net, tb, &cfg, extack);",
                        "\tif (!err && cfg.fc_type == RTN_LOCAL)",
                        "\t\tnet->ipv4.fib_has_custom_local_routes = true;",
                        "errout:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 865,
                    "highlight": 883
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819ad7ab"
        },
        "1530": {
            "name": "inet_rtm_newroute(indirect)",
            "parent_idx": 1517,
            "source_line": [
                {
                    "file": "net/core/rtnetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/rtnetlink.c?id=c3d8f220d012#n5563",
                    "code": [
                        "static int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t     struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct rtnl_link *link;",
                        "\tstruct module *owner;",
                        "\tint err = -EOPNOTSUPP;",
                        "\trtnl_doit_func doit;",
                        "\tunsigned int flags;",
                        "\tint kind;",
                        "\tint family;",
                        "\tint type;",
                        "",
                        "\ttype = nlh->nlmsg_type;",
                        "\tif (type > RTM_MAX)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\ttype -= RTM_BASE;",
                        "",
                        "\t/* All the messages must have at least 1 byte length */",
                        "\tif (nlmsg_len(nlh) < sizeof(struct rtgenmsg))",
                        "\t\treturn 0;",
                        "",
                        "\tfamily = ((struct rtgenmsg *)nlmsg_data(nlh))->rtgen_family;",
                        "\tkind = type&3;",
                        "",
                        "\tif (kind != 2 && !netlink_net_capable(skb, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\trcu_read_lock();",
                        "\tif (kind == 2 && nlh->nlmsg_flags&NLM_F_DUMP) {",
                        "\t\tstruct sock *rtnl;",
                        "\t\trtnl_dumpit_func dumpit;",
                        "\t\tu16 min_dump_alloc = 0;",
                        "",
                        "\t\tlink = rtnl_get_link(family, type);",
                        "\t\tif (!link || !link->dumpit) {",
                        "\t\t\tfamily = PF_UNSPEC;",
                        "\t\t\tlink = rtnl_get_link(family, type);",
                        "\t\t\tif (!link || !link->dumpit)",
                        "\t\t\t\tgoto err_unlock;",
                        "\t\t}",
                        "\t\towner = link->owner;",
                        "\t\tdumpit = link->dumpit;",
                        "",
                        "\t\tif (type == RTM_GETLINK - RTM_BASE)",
                        "\t\t\tmin_dump_alloc = rtnl_calcit(skb, nlh);",
                        "",
                        "\t\terr = 0;",
                        "\t\t/* need to do this before rcu_read_unlock() */",
                        "\t\tif (!try_module_get(owner))",
                        "\t\t\terr = -EPROTONOSUPPORT;",
                        "",
                        "\t\trcu_read_unlock();",
                        "",
                        "\t\trtnl = net->rtnl;",
                        "\t\tif (err == 0) {",
                        "\t\t\tstruct netlink_dump_control c = {",
                        "\t\t\t\t.dump\t\t= dumpit,",
                        "\t\t\t\t.min_dump_alloc\t= min_dump_alloc,",
                        "\t\t\t\t.module\t\t= owner,",
                        "\t\t\t};",
                        "\t\t\terr = netlink_dump_start(rtnl, skb, nlh, &c);",
                        "\t\t\t/* netlink_dump_start() will keep a reference on",
                        "\t\t\t * module if dump is still in progress.",
                        "\t\t\t */",
                        "\t\t\tmodule_put(owner);",
                        "\t\t}",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\tlink = rtnl_get_link(family, type);",
                        "\tif (!link || !link->doit) {",
                        "\t\tfamily = PF_UNSPEC;",
                        "\t\tlink = rtnl_get_link(PF_UNSPEC, type);",
                        "\t\tif (!link || !link->doit)",
                        "\t\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\towner = link->owner;",
                        "\tif (!try_module_get(owner)) {",
                        "\t\terr = -EPROTONOSUPPORT;",
                        "\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\tflags = link->flags;",
                        "\tif (flags & RTNL_FLAG_DOIT_UNLOCKED) {",
                        "\t\tdoit = link->doit;",
                        "\t\trcu_read_unlock();",
                        "\t\tif (doit)",
                        "\t\t\terr = doit(skb, nlh, extack);",
                        "\t\tmodule_put(owner);",
                        "\t\treturn err;",
                        "\t}",
                        "\trcu_read_unlock();",
                        "",
                        "\trtnl_lock();",
                        "\tlink = rtnl_get_link(family, type);",
                        "\tif (link && link->doit)",
                        "\t\terr = link->doit(skb, nlh, extack);",
                        "\trtnl_unlock();",
                        "",
                        "\tmodule_put(owner);",
                        "",
                        "\treturn err;",
                        "",
                        "out_unlock:",
                        "\trcu_read_unlock();",
                        "\treturn err;",
                        "",
                        "err_unlock:",
                        "\trcu_read_unlock();",
                        "\treturn -EOPNOTSUPP;",
                        "}"
                    ],
                    "start": 5464,
                    "highlight": 5563
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818eca4c"
        },
        "1517": {
            "name": "rtnetlink_rcv_msg(indirect)",
            "parent_idx": 1514,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c3d8f220d012#n2470",
                    "code": [
                        "int netlink_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *,",
                        "\t\t\t\t\t\t   struct nlmsghdr *,",
                        "\t\t\t\t\t\t   struct netlink_ext_ack *))",
                        "{",
                        "\tstruct netlink_ext_ack extack;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tint err;",
                        "",
                        "\twhile (skb->len >= nlmsg_total_size(0)) {",
                        "\t\tint msglen;",
                        "",
                        "\t\tmemset(&extack, 0, sizeof(extack));",
                        "\t\tnlh = nlmsg_hdr(skb);",
                        "\t\terr = 0;",
                        "",
                        "\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len)",
                        "\t\t\treturn 0;",
                        "",
                        "\t\t/* Only requests are handled by the kernel */",
                        "\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST))",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\t/* Skip control messages */",
                        "\t\tif (nlh->nlmsg_type < NLMSG_MIN_TYPE)",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\terr = cb(skb, nlh, &extack);",
                        "\t\tif (err == -EINTR)",
                        "\t\t\tgoto skip;",
                        "",
                        "ack:",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err)",
                        "\t\t\tnetlink_ack(skb, nlh, err, &extack);",
                        "",
                        "skip:",
                        "\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);",
                        "\t\tif (msglen > skb->len)",
                        "\t\t\tmsglen = skb->len;",
                        "\t\tskb_pull(skb, msglen);",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 2444,
                    "highlight": 2470
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81929e9d"
        },
        "1514": {
            "name": "netlink_rcv_skb(indirect)",
            "parent_idx": 1415,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c3d8f220d012#n1304",
                    "code": [
                        "static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,",
                        "\t\t\t\t  struct sock *ssk)",
                        "{",
                        "\tint ret;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "",
                        "\tret = -ECONNREFUSED;",
                        "\tif (nlk->netlink_rcv != NULL) {",
                        "\t\tret = skb->len;",
                        "\t\tnetlink_skb_set_owner_r(skb, sk);",
                        "\t\tNETLINK_CB(skb).sk = ssk;",
                        "\t\tnetlink_deliver_tap_kernel(sk, ssk, skb);",
                        "\t\tnlk->netlink_rcv(skb);",
                        "\t\tconsume_skb(skb);",
                        "\t} else {",
                        "\t\tkfree_skb(skb);",
                        "\t}",
                        "\tsock_put(sk);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1292,
                    "highlight": 1304
                },
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c3d8f220d012#n1330",
                    "code": [
                        "int netlink_unicast(struct sock *ssk, struct sk_buff *skb,",
                        "\t\t    u32 portid, int nonblock)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tint err;",
                        "\tlong timeo;",
                        "",
                        "\tskb = netlink_trim(skb, gfp_any());",
                        "",
                        "\ttimeo = sock_sndtimeo(ssk, nonblock);",
                        "retry:",
                        "\tsk = netlink_getsockbyportid(ssk, portid);",
                        "\tif (IS_ERR(sk)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn PTR_ERR(sk);",
                        "\t}",
                        "\tif (netlink_is_kernel(sk))",
                        "\t\treturn netlink_unicast_kernel(sk, skb, ssk);",
                        "",
                        "\tif (sk_filter(sk, skb)) {",
                        "\t\terr = skb->len;",
                        "\t\tkfree_skb(skb);",
                        "\t\tsock_put(sk);",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = netlink_attachskb(sk, skb, &timeo, ssk);",
                        "\tif (err == 1)",
                        "\t\tgoto retry;",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\treturn netlink_sendskb(sk, skb);",
                        "}"
                    ],
                    "start": 1313,
                    "highlight": 1330
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8192962f"
        },
        "1415": {
            "name": "netlink_unicast",
            "parent_idx": 1230,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c3d8f220d012#n1919",
                    "code": [
                        "static int netlink_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "\tDECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);",
                        "\tu32 dst_portid;",
                        "\tu32 dst_group;",
                        "\tstruct sk_buff *skb;",
                        "\tint err;",
                        "\tstruct scm_cookie scm;",
                        "\tu32 netlink_skb_flags = 0;",
                        "",
                        "\tif (msg->msg_flags&MSG_OOB)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\terr = scm_send(sock, msg, &scm, true);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tif (msg->msg_namelen) {",
                        "\t\terr = -EINVAL;",
                        "\t\tif (msg->msg_namelen < sizeof(struct sockaddr_nl))",
                        "\t\t\tgoto out;",
                        "\t\tif (addr->nl_family != AF_NETLINK)",
                        "\t\t\tgoto out;",
                        "\t\tdst_portid = addr->nl_pid;",
                        "\t\tdst_group = ffs(addr->nl_groups);",
                        "\t\terr =  -EPERM;",
                        "\t\tif ((dst_group || dst_portid) &&",
                        "\t\t    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))",
                        "\t\t\tgoto out;",
                        "\t\tnetlink_skb_flags |= NETLINK_SKB_DST;",
                        "\t} else {",
                        "\t\tdst_portid = nlk->dst_portid;",
                        "\t\tdst_group = nlk->dst_group;",
                        "\t}",
                        "",
                        "\tif (!nlk->bound) {",
                        "\t\terr = netlink_autobind(sock);",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t} else {",
                        "\t\t/* Ensure nlk is hashed and visible. */",
                        "\t\tsmp_rmb();",
                        "\t}",
                        "",
                        "\terr = -EMSGSIZE;",
                        "\tif (len > sk->sk_sndbuf - 32)",
                        "\t\tgoto out;",
                        "\terr = -ENOBUFS;",
                        "\tskb = netlink_alloc_large_skb(len, dst_group);",
                        "\tif (skb == NULL)",
                        "\t\tgoto out;",
                        "",
                        "\tNETLINK_CB(skb).portid\t= nlk->portid;",
                        "\tNETLINK_CB(skb).dst_group = dst_group;",
                        "\tNETLINK_CB(skb).creds\t= scm.creds;",
                        "\tNETLINK_CB(skb).flags\t= netlink_skb_flags;",
                        "",
                        "\terr = -EFAULT;",
                        "\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\terr = security_netlink_send(sk, skb);",
                        "\tif (err) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (dst_group) {",
                        "\t\trefcount_inc(&skb->users);",
                        "\t\tnetlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);",
                        "\t}",
                        "\terr = netlink_unicast(sk, skb, dst_portid, msg->msg_flags&MSG_DONTWAIT);",
                        "",
                        "out:",
                        "\tscm_destroy(&scm);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1844,
                    "highlight": 1919
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8192991b"
        },
        "1230": {
            "name": "netlink_sendmsg(indirect)",
            "parent_idx": 1222,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c3d8f220d012#n651",
                    "code": [
                        "INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t   size_t));",
                        "INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t    size_t));",
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,",
                        "\t\t\t\t     inet_sendmsg, sock, msg,",
                        "\t\t\t\t     msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 645,
                    "highlight": 651
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c3d8f220d012#n671",
                    "code": [
                        "/**",
                        " *\tsock_sendmsg - send a message through @sock",
                        " *\t@sock: socket",
                        " *\t@msg: message to send",
                        " *",
                        " *\tSends @msg through @sock, passing through LSM.",
                        " *\tReturns the number of bytes sent, or an error code.",
                        " */",
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 658,
                    "highlight": 671
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818b5fc4"
        },
        "1222": {
            "name": "sock_sendmsg",
            "parent_idx": 1219,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c3d8f220d012#n2353",
                    "code": [
                        "static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,",
                        "\t\t\t   unsigned int flags, struct used_address *used_address,",
                        "\t\t\t   unsigned int allowed_msghdr_flags)",
                        "{",
                        "\tunsigned char ctl[sizeof(struct cmsghdr) + 20]",
                        "\t\t\t\t__aligned(sizeof(__kernel_size_t));",
                        "\t/* 20 is size of ipv6_pktinfo */",
                        "\tunsigned char *ctl_buf = ctl;",
                        "\tint ctl_len;",
                        "\tssize_t err;",
                        "",
                        "\terr = -ENOBUFS;",
                        "",
                        "\tif (msg_sys->msg_controllen > INT_MAX)",
                        "\t\tgoto out;",
                        "\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);",
                        "\tctl_len = msg_sys->msg_controllen;",
                        "\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
                        "\t\terr =",
                        "\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,",
                        "\t\t\t\t\t\t     sizeof(ctl));",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t\tctl_buf = msg_sys->msg_control;",
                        "\t\tctl_len = msg_sys->msg_controllen;",
                        "\t} else if (ctl_len) {",
                        "\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=",
                        "\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));",
                        "\t\tif (ctl_len > sizeof(ctl)) {",
                        "\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);",
                        "\t\t\tif (ctl_buf == NULL)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\terr = -EFAULT;",
                        "\t\tif (copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len))",
                        "\t\t\tgoto out_freectl;",
                        "\t\tmsg_sys->msg_control = ctl_buf;",
                        "\t\tmsg_sys->msg_control_is_user = false;",
                        "\t}",
                        "\tmsg_sys->msg_flags = flags;",
                        "",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;",
                        "\t/*",
                        "\t * If this is sendmmsg() and current destination address is same as",
                        "\t * previously succeeded address, omit asking LSM's decision.",
                        "\t * used_address->name_len is initialized to UINT_MAX so that the first",
                        "\t * destination address never matches.",
                        "\t */",
                        "\tif (used_address && msg_sys->msg_name &&",
                        "\t    used_address->name_len == msg_sys->msg_namelen &&",
                        "\t    !memcmp(&used_address->name, msg_sys->msg_name,",
                        "\t\t    used_address->name_len)) {",
                        "\t\terr = sock_sendmsg_nosec(sock, msg_sys);",
                        "\t\tgoto out_freectl;",
                        "\t}",
                        "\terr = sock_sendmsg(sock, msg_sys);",
                        "\t/*",
                        "\t * If this is sendmmsg() and sending to current destination address was",
                        "\t * successful, remember it.",
                        "\t */",
                        "\tif (used_address && err >= 0) {",
                        "\t\tused_address->name_len = msg_sys->msg_namelen;",
                        "\t\tif (msg_sys->msg_name)",
                        "\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,",
                        "\t\t\t       used_address->name_len);",
                        "\t}",
                        "",
                        "out_freectl:",
                        "\tif (ctl_buf != ctl)",
                        "\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2297,
                    "highlight": 2353
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818b62dd"
        },
        "1219": {
            "name": "____sys_sendmsg",
            "parent_idx": 1209,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c3d8f220d012#n2407",
                    "code": [
                        "\terr = ____sys_sendmsg(sock, msg_sys, flags, used_address,",
                        "\t\t\t\tallowed_msghdr_flags);",
                        "\tkfree(iov);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2407,
                    "highlight": 2407
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818b8b5b"
        },
        "1209": {
            "name": "___sys_sendmsg",
            "parent_idx": 1187,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c3d8f220d012#n2440",
                    "code": [
                        "\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);",
                        "",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2440,
                    "highlight": 2440
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818b8c1f"
        },
        "1187": {
            "name": "__x64_sys_sendmsg(indirect)",
            "parent_idx": 1179,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=c3d8f220d012#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b4a5ee"
        },
        "1179": {
            "name": "do_syscall_64",
            "parent_idx": 1172,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=c3d8f220d012#n118",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 118
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "1172": {
            "name": "54_syscall_10",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1630": {
            "name": "+0x2b8",
            "parent_idx": 1606,
            "source_line": [
                {
                    "file": "./include/net/nexthop.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/nexthop.h?id=c3d8f220d012#n237",
                    "code": [
                        "/* called with rcu lock */",
                        "static inline bool nexthop_is_blackhole(const struct nexthop *nh)",
                        "{",
                        "\tconst struct nh_info *nhi;",
                        "",
                        "\tif (nh->is_group) {",
                        "\t\tstruct nh_group *nh_grp;",
                        "",
                        "\t\tnh_grp = rcu_dereference_rtnl(nh->nh_grp);",
                        "\t\tif (nh_grp->num_nh > 1)",
                        "\t\t\treturn false;",
                        "",
                        "\t\tnh = nh_grp->nh_entries[0].nh;",
                        "\t}",
                        "",
                        "\tnhi = rcu_dereference_rtnl(nh->nh_info);",
                        "\treturn nhi->reject_nh;",
                        "}"
                    ],
                    "start": 225,
                    "highlight": 237
                },
                {
                    "file": "net/ipv4/fib_semantics.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/fib_semantics.c?id=c3d8f220d012#n1781",
                    "code": [
                        "int fib_dump_info(struct sk_buff *skb, u32 portid, u32 seq, int event,",
                        "\t\t  struct fib_rt_info *fri, unsigned int flags)",
                        "{",
                        "\tunsigned int nhs = fib_info_num_path(fri->fi);",
                        "\tstruct fib_info *fi = fri->fi;",
                        "\tu32 tb_id = fri->tb_id;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tstruct rtmsg *rtm;",
                        "",
                        "\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), flags);",
                        "\tif (!nlh)",
                        "\t\treturn -EMSGSIZE;",
                        "",
                        "\trtm = nlmsg_data(nlh);",
                        "\trtm->rtm_family = AF_INET;",
                        "\trtm->rtm_dst_len = fri->dst_len;",
                        "\trtm->rtm_src_len = 0;",
                        "\trtm->rtm_tos = fri->tos;",
                        "\tif (tb_id < 256)",
                        "\t\trtm->rtm_table = tb_id;",
                        "\telse",
                        "\t\trtm->rtm_table = RT_TABLE_COMPAT;",
                        "\tif (nla_put_u32(skb, RTA_TABLE, tb_id))",
                        "\t\tgoto nla_put_failure;",
                        "\trtm->rtm_type = fri->type;",
                        "\trtm->rtm_flags = fi->fib_flags;",
                        "\trtm->rtm_scope = fi->fib_scope;",
                        "\trtm->rtm_protocol = fi->fib_protocol;",
                        "",
                        "\tif (rtm->rtm_dst_len &&",
                        "\t    nla_put_in_addr(skb, RTA_DST, fri->dst))",
                        "\t\tgoto nla_put_failure;",
                        "\tif (fi->fib_priority &&",
                        "\t    nla_put_u32(skb, RTA_PRIORITY, fi->fib_priority))",
                        "\t\tgoto nla_put_failure;",
                        "\tif (rtnetlink_put_metrics(skb, fi->fib_metrics->metrics) < 0)",
                        "\t\tgoto nla_put_failure;",
                        "",
                        "\tif (fi->fib_prefsrc &&",
                        "\t    nla_put_in_addr(skb, RTA_PREFSRC, fi->fib_prefsrc))",
                        "\t\tgoto nla_put_failure;",
                        "",
                        "\tif (fi->nh) {",
                        "\t\tif (nla_put_u32(skb, RTA_NH_ID, fi->nh->id))",
                        "\t\t\tgoto nla_put_failure;",
                        "\t\tif (nexthop_is_blackhole(fi->nh))",
                        "\t\t\trtm->rtm_type = RTN_BLACKHOLE;",
                        "\t\tif (!fi->fib_net->ipv4.sysctl_nexthop_compat_mode)",
                        "\t\t\tgoto offload;",
                        "\t}",
                        "",
                        "\tif (nhs == 1) {",
                        "\t\tconst struct fib_nh_common *nhc = fib_info_nhc(fi, 0);",
                        "\t\tunsigned char flags = 0;",
                        "",
                        "\t\tif (fib_nexthop_info(skb, nhc, AF_INET, &flags, false) < 0)",
                        "\t\t\tgoto nla_put_failure;",
                        "",
                        "\t\trtm->rtm_flags = flags;",
                        "#ifdef CONFIG_IP_ROUTE_CLASSID",
                        "\t\tif (nhc->nhc_family == AF_INET) {",
                        "\t\t\tstruct fib_nh *nh;",
                        "",
                        "\t\t\tnh = container_of(nhc, struct fib_nh, nh_common);",
                        "\t\t\tif (nh->nh_tclassid &&",
                        "\t\t\t    nla_put_u32(skb, RTA_FLOW, nh->nh_tclassid))",
                        "\t\t\t\tgoto nla_put_failure;",
                        "\t\t}",
                        "#endif",
                        "\t} else {",
                        "\t\tif (fib_add_multipath(skb, fi) < 0)",
                        "\t\t\tgoto nla_put_failure;",
                        "\t}",
                        "",
                        "offload:",
                        "\tif (fri->offload)",
                        "\t\trtm->rtm_flags |= RTM_F_OFFLOAD;",
                        "\tif (fri->trap)",
                        "\t\trtm->rtm_flags |= RTM_F_TRAP;",
                        "",
                        "\tnlmsg_end(skb, nlh);",
                        "\treturn 0;",
                        "",
                        "nla_put_failure:",
                        "\tnlmsg_cancel(skb, nlh);",
                        "\treturn -EMSGSIZE;",
                        "}"
                    ],
                    "start": 1736,
                    "highlight": 1781
                }
            ],
            "ins_idx": 10,
            "addr": "0xffffffff819b0c58"
        },
        "744": {
            "name": "+0x0",
            "parent_idx": 743,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=c3d8f220d012#n3983",
                    "code": [
                        "#ifdef CONFIG_NUMA",
                        "static void *kmalloc_large_node(size_t size, gfp_t flags, int node)",
                        "{",
                        "\tstruct page *page;",
                        "\tvoid *ptr = NULL;",
                        "\tunsigned int order = get_order(size);",
                        "",
                        "\tflags |= __GFP_COMP;",
                        "\tpage = alloc_pages_node(node, flags, order);",
                        "\tif (page) {",
                        "\t\tptr = page_address(page);",
                        "\t\tmod_node_page_state(page_pgdat(page), NR_SLAB_UNRECLAIMABLE_B,",
                        "\t\t\t\t    PAGE_SIZE << order);",
                        "\t}",
                        "",
                        "\treturn kmalloc_large_node_hook(ptr, size, flags);",
                        "}"
                    ],
                    "start": 3975,
                    "highlight": 3983
                }
            ],
            "ins_idx": 20,
            "addr": "0xffffffff811dbc30"
        },
        "743": {
            "name": "__kmalloc",
            "parent_idx": 698,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=c3d8f220d012#n559",
                    "code": [
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 554,
                    "highlight": 559
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=c3d8f220d012#n666",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 659,
                    "highlight": 666
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n141",
                    "code": [
                        "static struct nh_group *nexthop_grp_alloc(u16 num_nh)",
                        "{",
                        "\tsize_t sz = offsetof(struct nexthop, nh_grp)",
                        "\t\t    + sizeof(struct nh_group)",
                        "\t\t    + sizeof(struct nh_grp_entry) * num_nh;",
                        "\tstruct nh_group *nhg;",
                        "",
                        "\tnhg = kzalloc(sz, GFP_KERNEL);",
                        "\tif (nhg)",
                        "\t\tnhg->num_nh = num_nh;",
                        "",
                        "\treturn nhg;",
                        "}"
                    ],
                    "start": 134,
                    "highlight": 141
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1196",
                    "code": [
                        "static struct nexthop *nexthop_create_group(struct net *net,",
                        "\t\t\t\t\t    struct nh_config *cfg)",
                        "{",
                        "\tstruct nlattr *grps_attr = cfg->nh_grp;",
                        "\tstruct nexthop_grp *entry = nla_data(grps_attr);",
                        "\tu16 num_nh = nla_len(grps_attr) / sizeof(*entry);",
                        "\tstruct nh_group *nhg;",
                        "\tstruct nexthop *nh;",
                        "\tint i;",
                        "",
                        "\tnh = nexthop_alloc();",
                        "\tif (!nh)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tnh->is_group = 1;",
                        "",
                        "\tnhg = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg) {",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "",
                        "\t/* spare group used for removals */",
                        "\tnhg->spare = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg->spare) {",
                        "\t\tkfree(nhg);",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "\tnhg->spare->spare = nhg;",
                        "",
                        "\tfor (i = 0; i < nhg->num_nh; ++i) {",
                        "\t\tstruct nexthop *nhe;",
                        "\t\tstruct nh_info *nhi;",
                        "",
                        "\t\tnhe = nexthop_find_by_id(net, entry[i].id);",
                        "\t\tif (!nexthop_get(nhe))",
                        "\t\t\tgoto out_no_nh;",
                        "",
                        "\t\tnhi = rtnl_dereference(nhe->nh_info);",
                        "\t\tif (nhi->family == AF_INET)",
                        "\t\t\tnhg->has_v4 = true;",
                        "",
                        "\t\tnhg->nh_entries[i].nh = nhe;",
                        "\t\tnhg->nh_entries[i].weight = entry[i].weight + 1;",
                        "\t\tlist_add(&nhg->nh_entries[i].nh_list, &nhe->grp_list);",
                        "\t\tnhg->nh_entries[i].nh_parent = nh;",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp_type == NEXTHOP_GRP_TYPE_MPATH) {",
                        "\t\tnhg->mpath = 1;",
                        "\t\tnh_group_rebalance(nhg);",
                        "\t}",
                        "",
                        "\tif (cfg->nh_fdb)",
                        "\t\tnhg->fdb_nh = 1;",
                        "",
                        "\trcu_assign_pointer(nh->nh_grp, nhg);",
                        "",
                        "\treturn nh;",
                        "",
                        "out_no_nh:",
                        "\tfor (; i >= 0; --i)",
                        "\t\tnexthop_put(nhg->nh_entries[i].nh);",
                        "",
                        "\tkfree(nhg->spare);",
                        "\tkfree(nhg);",
                        "\tkfree(nh);",
                        "",
                        "\treturn ERR_PTR(-ENOENT);",
                        "}"
                    ],
                    "start": 1180,
                    "highlight": 1196
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1397",
                    "code": [
                        "/* called with rtnl lock held */",
                        "static struct nexthop *nexthop_add(struct net *net, struct nh_config *cfg,",
                        "\t\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\tif (cfg->nlflags & NLM_F_REPLACE && !cfg->nh_id) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Replace requires nexthop id\");",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "\t}",
                        "",
                        "\tif (!cfg->nh_id) {",
                        "\t\tcfg->nh_id = nh_find_unused_id(net);",
                        "\t\tif (!cfg->nh_id) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"No unused id\");",
                        "\t\t\treturn ERR_PTR(-EINVAL);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp)",
                        "\t\tnh = nexthop_create_group(net, cfg);",
                        "\telse",
                        "\t\tnh = nexthop_create(net, cfg, extack);",
                        "",
                        "\tif (IS_ERR(nh))",
                        "\t\treturn nh;",
                        "",
                        "\trefcount_set(&nh->refcnt, 1);",
                        "\tnh->id = cfg->nh_id;",
                        "\tnh->protocol = cfg->nh_protocol;",
                        "\tnh->net = net;",
                        "",
                        "\terr = insert_nexthop(net, nh, cfg, extack);",
                        "\tif (err) {",
                        "\t\t__remove_nexthop(net, nh, NULL);",
                        "\t\tnexthop_put(nh);",
                        "\t\tnh = ERR_PTR(err);",
                        "\t}",
                        "",
                        "\treturn nh;",
                        "}"
                    ],
                    "start": 1376,
                    "highlight": 1397
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1611",
                    "code": [
                        "/* rtnl */",
                        "static int rtm_new_nexthop(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct nh_config cfg;",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\terr = rtm_to_nh_config(net, skb, nlh, &cfg, extack);",
                        "\tif (!err) {",
                        "\t\tnh = nexthop_add(net, &cfg, extack);",
                        "\t\tif (IS_ERR(nh))",
                        "\t\t\terr = PTR_ERR(nh);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1600,
                    "highlight": 1611
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819bbbf9"
        },
        "698": {
            "name": "rtm_new_nexthop(indirect)",
            "parent_idx": 668,
            "source_line": [
                {
                    "file": "net/core/rtnetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/rtnetlink.c?id=c3d8f220d012#n5563",
                    "code": [
                        "static int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t     struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct rtnl_link *link;",
                        "\tstruct module *owner;",
                        "\tint err = -EOPNOTSUPP;",
                        "\trtnl_doit_func doit;",
                        "\tunsigned int flags;",
                        "\tint kind;",
                        "\tint family;",
                        "\tint type;",
                        "",
                        "\ttype = nlh->nlmsg_type;",
                        "\tif (type > RTM_MAX)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\ttype -= RTM_BASE;",
                        "",
                        "\t/* All the messages must have at least 1 byte length */",
                        "\tif (nlmsg_len(nlh) < sizeof(struct rtgenmsg))",
                        "\t\treturn 0;",
                        "",
                        "\tfamily = ((struct rtgenmsg *)nlmsg_data(nlh))->rtgen_family;",
                        "\tkind = type&3;",
                        "",
                        "\tif (kind != 2 && !netlink_net_capable(skb, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\trcu_read_lock();",
                        "\tif (kind == 2 && nlh->nlmsg_flags&NLM_F_DUMP) {",
                        "\t\tstruct sock *rtnl;",
                        "\t\trtnl_dumpit_func dumpit;",
                        "\t\tu16 min_dump_alloc = 0;",
                        "",
                        "\t\tlink = rtnl_get_link(family, type);",
                        "\t\tif (!link || !link->dumpit) {",
                        "\t\t\tfamily = PF_UNSPEC;",
                        "\t\t\tlink = rtnl_get_link(family, type);",
                        "\t\t\tif (!link || !link->dumpit)",
                        "\t\t\t\tgoto err_unlock;",
                        "\t\t}",
                        "\t\towner = link->owner;",
                        "\t\tdumpit = link->dumpit;",
                        "",
                        "\t\tif (type == RTM_GETLINK - RTM_BASE)",
                        "\t\t\tmin_dump_alloc = rtnl_calcit(skb, nlh);",
                        "",
                        "\t\terr = 0;",
                        "\t\t/* need to do this before rcu_read_unlock() */",
                        "\t\tif (!try_module_get(owner))",
                        "\t\t\terr = -EPROTONOSUPPORT;",
                        "",
                        "\t\trcu_read_unlock();",
                        "",
                        "\t\trtnl = net->rtnl;",
                        "\t\tif (err == 0) {",
                        "\t\t\tstruct netlink_dump_control c = {",
                        "\t\t\t\t.dump\t\t= dumpit,",
                        "\t\t\t\t.min_dump_alloc\t= min_dump_alloc,",
                        "\t\t\t\t.module\t\t= owner,",
                        "\t\t\t};",
                        "\t\t\terr = netlink_dump_start(rtnl, skb, nlh, &c);",
                        "\t\t\t/* netlink_dump_start() will keep a reference on",
                        "\t\t\t * module if dump is still in progress.",
                        "\t\t\t */",
                        "\t\t\tmodule_put(owner);",
                        "\t\t}",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\tlink = rtnl_get_link(family, type);",
                        "\tif (!link || !link->doit) {",
                        "\t\tfamily = PF_UNSPEC;",
                        "\t\tlink = rtnl_get_link(PF_UNSPEC, type);",
                        "\t\tif (!link || !link->doit)",
                        "\t\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\towner = link->owner;",
                        "\tif (!try_module_get(owner)) {",
                        "\t\terr = -EPROTONOSUPPORT;",
                        "\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\tflags = link->flags;",
                        "\tif (flags & RTNL_FLAG_DOIT_UNLOCKED) {",
                        "\t\tdoit = link->doit;",
                        "\t\trcu_read_unlock();",
                        "\t\tif (doit)",
                        "\t\t\terr = doit(skb, nlh, extack);",
                        "\t\tmodule_put(owner);",
                        "\t\treturn err;",
                        "\t}",
                        "\trcu_read_unlock();",
                        "",
                        "\trtnl_lock();",
                        "\tlink = rtnl_get_link(family, type);",
                        "\tif (link && link->doit)",
                        "\t\terr = link->doit(skb, nlh, extack);",
                        "\trtnl_unlock();",
                        "",
                        "\tmodule_put(owner);",
                        "",
                        "\treturn err;",
                        "",
                        "out_unlock:",
                        "\trcu_read_unlock();",
                        "\treturn err;",
                        "",
                        "err_unlock:",
                        "\trcu_read_unlock();",
                        "\treturn -EOPNOTSUPP;",
                        "}"
                    ],
                    "start": 5464,
                    "highlight": 5563
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818eca4c"
        },
        "668": {
            "name": "rtnetlink_rcv_msg(indirect)",
            "parent_idx": 662,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c3d8f220d012#n2470",
                    "code": [
                        "int netlink_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *,",
                        "\t\t\t\t\t\t   struct nlmsghdr *,",
                        "\t\t\t\t\t\t   struct netlink_ext_ack *))",
                        "{",
                        "\tstruct netlink_ext_ack extack;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tint err;",
                        "",
                        "\twhile (skb->len >= nlmsg_total_size(0)) {",
                        "\t\tint msglen;",
                        "",
                        "\t\tmemset(&extack, 0, sizeof(extack));",
                        "\t\tnlh = nlmsg_hdr(skb);",
                        "\t\terr = 0;",
                        "",
                        "\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len)",
                        "\t\t\treturn 0;",
                        "",
                        "\t\t/* Only requests are handled by the kernel */",
                        "\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST))",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\t/* Skip control messages */",
                        "\t\tif (nlh->nlmsg_type < NLMSG_MIN_TYPE)",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\terr = cb(skb, nlh, &extack);",
                        "\t\tif (err == -EINTR)",
                        "\t\t\tgoto skip;",
                        "",
                        "ack:",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err)",
                        "\t\t\tnetlink_ack(skb, nlh, err, &extack);",
                        "",
                        "skip:",
                        "\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);",
                        "\t\tif (msglen > skb->len)",
                        "\t\t\tmsglen = skb->len;",
                        "\t\tskb_pull(skb, msglen);",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 2444,
                    "highlight": 2470
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81929e9d"
        },
        "662": {
            "name": "netlink_rcv_skb(indirect)",
            "parent_idx": 563,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c3d8f220d012#n1304",
                    "code": [
                        "static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,",
                        "\t\t\t\t  struct sock *ssk)",
                        "{",
                        "\tint ret;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "",
                        "\tret = -ECONNREFUSED;",
                        "\tif (nlk->netlink_rcv != NULL) {",
                        "\t\tret = skb->len;",
                        "\t\tnetlink_skb_set_owner_r(skb, sk);",
                        "\t\tNETLINK_CB(skb).sk = ssk;",
                        "\t\tnetlink_deliver_tap_kernel(sk, ssk, skb);",
                        "\t\tnlk->netlink_rcv(skb);",
                        "\t\tconsume_skb(skb);",
                        "\t} else {",
                        "\t\tkfree_skb(skb);",
                        "\t}",
                        "\tsock_put(sk);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1292,
                    "highlight": 1304
                },
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c3d8f220d012#n1330",
                    "code": [
                        "int netlink_unicast(struct sock *ssk, struct sk_buff *skb,",
                        "\t\t    u32 portid, int nonblock)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tint err;",
                        "\tlong timeo;",
                        "",
                        "\tskb = netlink_trim(skb, gfp_any());",
                        "",
                        "\ttimeo = sock_sndtimeo(ssk, nonblock);",
                        "retry:",
                        "\tsk = netlink_getsockbyportid(ssk, portid);",
                        "\tif (IS_ERR(sk)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn PTR_ERR(sk);",
                        "\t}",
                        "\tif (netlink_is_kernel(sk))",
                        "\t\treturn netlink_unicast_kernel(sk, skb, ssk);",
                        "",
                        "\tif (sk_filter(sk, skb)) {",
                        "\t\terr = skb->len;",
                        "\t\tkfree_skb(skb);",
                        "\t\tsock_put(sk);",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = netlink_attachskb(sk, skb, &timeo, ssk);",
                        "\tif (err == 1)",
                        "\t\tgoto retry;",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\treturn netlink_sendskb(sk, skb);",
                        "}"
                    ],
                    "start": 1313,
                    "highlight": 1330
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8192962f"
        },
        "563": {
            "name": "netlink_unicast",
            "parent_idx": 455,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c3d8f220d012#n1919",
                    "code": [
                        "static int netlink_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "\tDECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);",
                        "\tu32 dst_portid;",
                        "\tu32 dst_group;",
                        "\tstruct sk_buff *skb;",
                        "\tint err;",
                        "\tstruct scm_cookie scm;",
                        "\tu32 netlink_skb_flags = 0;",
                        "",
                        "\tif (msg->msg_flags&MSG_OOB)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\terr = scm_send(sock, msg, &scm, true);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tif (msg->msg_namelen) {",
                        "\t\terr = -EINVAL;",
                        "\t\tif (msg->msg_namelen < sizeof(struct sockaddr_nl))",
                        "\t\t\tgoto out;",
                        "\t\tif (addr->nl_family != AF_NETLINK)",
                        "\t\t\tgoto out;",
                        "\t\tdst_portid = addr->nl_pid;",
                        "\t\tdst_group = ffs(addr->nl_groups);",
                        "\t\terr =  -EPERM;",
                        "\t\tif ((dst_group || dst_portid) &&",
                        "\t\t    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))",
                        "\t\t\tgoto out;",
                        "\t\tnetlink_skb_flags |= NETLINK_SKB_DST;",
                        "\t} else {",
                        "\t\tdst_portid = nlk->dst_portid;",
                        "\t\tdst_group = nlk->dst_group;",
                        "\t}",
                        "",
                        "\tif (!nlk->bound) {",
                        "\t\terr = netlink_autobind(sock);",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t} else {",
                        "\t\t/* Ensure nlk is hashed and visible. */",
                        "\t\tsmp_rmb();",
                        "\t}",
                        "",
                        "\terr = -EMSGSIZE;",
                        "\tif (len > sk->sk_sndbuf - 32)",
                        "\t\tgoto out;",
                        "\terr = -ENOBUFS;",
                        "\tskb = netlink_alloc_large_skb(len, dst_group);",
                        "\tif (skb == NULL)",
                        "\t\tgoto out;",
                        "",
                        "\tNETLINK_CB(skb).portid\t= nlk->portid;",
                        "\tNETLINK_CB(skb).dst_group = dst_group;",
                        "\tNETLINK_CB(skb).creds\t= scm.creds;",
                        "\tNETLINK_CB(skb).flags\t= netlink_skb_flags;",
                        "",
                        "\terr = -EFAULT;",
                        "\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\terr = security_netlink_send(sk, skb);",
                        "\tif (err) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (dst_group) {",
                        "\t\trefcount_inc(&skb->users);",
                        "\t\tnetlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);",
                        "\t}",
                        "\terr = netlink_unicast(sk, skb, dst_portid, msg->msg_flags&MSG_DONTWAIT);",
                        "",
                        "out:",
                        "\tscm_destroy(&scm);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1844,
                    "highlight": 1919
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8192991b"
        },
        "455": {
            "name": "netlink_sendmsg(indirect)",
            "parent_idx": 440,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c3d8f220d012#n651",
                    "code": [
                        "INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t   size_t));",
                        "INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t    size_t));",
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,",
                        "\t\t\t\t     inet_sendmsg, sock, msg,",
                        "\t\t\t\t     msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 645,
                    "highlight": 651
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c3d8f220d012#n671",
                    "code": [
                        "/**",
                        " *\tsock_sendmsg - send a message through @sock",
                        " *\t@sock: socket",
                        " *\t@msg: message to send",
                        " *",
                        " *\tSends @msg through @sock, passing through LSM.",
                        " *\tReturns the number of bytes sent, or an error code.",
                        " */",
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 658,
                    "highlight": 671
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818b5fc4"
        },
        "440": {
            "name": "sock_sendmsg",
            "parent_idx": 435,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c3d8f220d012#n2353",
                    "code": [
                        "static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,",
                        "\t\t\t   unsigned int flags, struct used_address *used_address,",
                        "\t\t\t   unsigned int allowed_msghdr_flags)",
                        "{",
                        "\tunsigned char ctl[sizeof(struct cmsghdr) + 20]",
                        "\t\t\t\t__aligned(sizeof(__kernel_size_t));",
                        "\t/* 20 is size of ipv6_pktinfo */",
                        "\tunsigned char *ctl_buf = ctl;",
                        "\tint ctl_len;",
                        "\tssize_t err;",
                        "",
                        "\terr = -ENOBUFS;",
                        "",
                        "\tif (msg_sys->msg_controllen > INT_MAX)",
                        "\t\tgoto out;",
                        "\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);",
                        "\tctl_len = msg_sys->msg_controllen;",
                        "\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
                        "\t\terr =",
                        "\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,",
                        "\t\t\t\t\t\t     sizeof(ctl));",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t\tctl_buf = msg_sys->msg_control;",
                        "\t\tctl_len = msg_sys->msg_controllen;",
                        "\t} else if (ctl_len) {",
                        "\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=",
                        "\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));",
                        "\t\tif (ctl_len > sizeof(ctl)) {",
                        "\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);",
                        "\t\t\tif (ctl_buf == NULL)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\terr = -EFAULT;",
                        "\t\tif (copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len))",
                        "\t\t\tgoto out_freectl;",
                        "\t\tmsg_sys->msg_control = ctl_buf;",
                        "\t\tmsg_sys->msg_control_is_user = false;",
                        "\t}",
                        "\tmsg_sys->msg_flags = flags;",
                        "",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;",
                        "\t/*",
                        "\t * If this is sendmmsg() and current destination address is same as",
                        "\t * previously succeeded address, omit asking LSM's decision.",
                        "\t * used_address->name_len is initialized to UINT_MAX so that the first",
                        "\t * destination address never matches.",
                        "\t */",
                        "\tif (used_address && msg_sys->msg_name &&",
                        "\t    used_address->name_len == msg_sys->msg_namelen &&",
                        "\t    !memcmp(&used_address->name, msg_sys->msg_name,",
                        "\t\t    used_address->name_len)) {",
                        "\t\terr = sock_sendmsg_nosec(sock, msg_sys);",
                        "\t\tgoto out_freectl;",
                        "\t}",
                        "\terr = sock_sendmsg(sock, msg_sys);",
                        "\t/*",
                        "\t * If this is sendmmsg() and sending to current destination address was",
                        "\t * successful, remember it.",
                        "\t */",
                        "\tif (used_address && err >= 0) {",
                        "\t\tused_address->name_len = msg_sys->msg_namelen;",
                        "\t\tif (msg_sys->msg_name)",
                        "\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,",
                        "\t\t\t       used_address->name_len);",
                        "\t}",
                        "",
                        "out_freectl:",
                        "\tif (ctl_buf != ctl)",
                        "\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2297,
                    "highlight": 2353
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818b62dd"
        },
        "435": {
            "name": "____sys_sendmsg",
            "parent_idx": 343,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c3d8f220d012#n2407",
                    "code": [
                        "\terr = ____sys_sendmsg(sock, msg_sys, flags, used_address,",
                        "\t\t\t\tallowed_msghdr_flags);",
                        "\tkfree(iov);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2407,
                    "highlight": 2407
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818b8b5b"
        },
        "343": {
            "name": "___sys_sendmsg",
            "parent_idx": 312,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c3d8f220d012#n2440",
                    "code": [
                        "\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);",
                        "",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2440,
                    "highlight": 2440
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818b8c1f"
        },
        "312": {
            "name": "__x64_sys_sendmsg(indirect)",
            "parent_idx": 304,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=c3d8f220d012#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b4a5ee"
        },
        "304": {
            "name": "do_syscall_64",
            "parent_idx": 294,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=c3d8f220d012#n118",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 118
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "294": {
            "name": "11_syscall_5",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1629": {
            "name": "+0x2a6",
            "parent_idx": 1606,
            "source_line": [
                {
                    "file": "./include/net/nexthop.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/nexthop.h?id=c3d8f220d012#n233",
                    "code": [
                        "/* called with rcu lock */",
                        "static inline bool nexthop_is_blackhole(const struct nexthop *nh)",
                        "{",
                        "\tconst struct nh_info *nhi;",
                        "",
                        "\tif (nh->is_group) {",
                        "\t\tstruct nh_group *nh_grp;",
                        "",
                        "\t\tnh_grp = rcu_dereference_rtnl(nh->nh_grp);",
                        "\t\tif (nh_grp->num_nh > 1)",
                        "\t\t\treturn false;",
                        "",
                        "\t\tnh = nh_grp->nh_entries[0].nh;",
                        "\t}",
                        "",
                        "\tnhi = rcu_dereference_rtnl(nh->nh_info);",
                        "\treturn nhi->reject_nh;",
                        "}"
                    ],
                    "start": 225,
                    "highlight": 233
                },
                {
                    "file": "net/ipv4/fib_semantics.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/fib_semantics.c?id=c3d8f220d012#n1781",
                    "code": [
                        "int fib_dump_info(struct sk_buff *skb, u32 portid, u32 seq, int event,",
                        "\t\t  struct fib_rt_info *fri, unsigned int flags)",
                        "{",
                        "\tunsigned int nhs = fib_info_num_path(fri->fi);",
                        "\tstruct fib_info *fi = fri->fi;",
                        "\tu32 tb_id = fri->tb_id;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tstruct rtmsg *rtm;",
                        "",
                        "\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), flags);",
                        "\tif (!nlh)",
                        "\t\treturn -EMSGSIZE;",
                        "",
                        "\trtm = nlmsg_data(nlh);",
                        "\trtm->rtm_family = AF_INET;",
                        "\trtm->rtm_dst_len = fri->dst_len;",
                        "\trtm->rtm_src_len = 0;",
                        "\trtm->rtm_tos = fri->tos;",
                        "\tif (tb_id < 256)",
                        "\t\trtm->rtm_table = tb_id;",
                        "\telse",
                        "\t\trtm->rtm_table = RT_TABLE_COMPAT;",
                        "\tif (nla_put_u32(skb, RTA_TABLE, tb_id))",
                        "\t\tgoto nla_put_failure;",
                        "\trtm->rtm_type = fri->type;",
                        "\trtm->rtm_flags = fi->fib_flags;",
                        "\trtm->rtm_scope = fi->fib_scope;",
                        "\trtm->rtm_protocol = fi->fib_protocol;",
                        "",
                        "\tif (rtm->rtm_dst_len &&",
                        "\t    nla_put_in_addr(skb, RTA_DST, fri->dst))",
                        "\t\tgoto nla_put_failure;",
                        "\tif (fi->fib_priority &&",
                        "\t    nla_put_u32(skb, RTA_PRIORITY, fi->fib_priority))",
                        "\t\tgoto nla_put_failure;",
                        "\tif (rtnetlink_put_metrics(skb, fi->fib_metrics->metrics) < 0)",
                        "\t\tgoto nla_put_failure;",
                        "",
                        "\tif (fi->fib_prefsrc &&",
                        "\t    nla_put_in_addr(skb, RTA_PREFSRC, fi->fib_prefsrc))",
                        "\t\tgoto nla_put_failure;",
                        "",
                        "\tif (fi->nh) {",
                        "\t\tif (nla_put_u32(skb, RTA_NH_ID, fi->nh->id))",
                        "\t\t\tgoto nla_put_failure;",
                        "\t\tif (nexthop_is_blackhole(fi->nh))",
                        "\t\t\trtm->rtm_type = RTN_BLACKHOLE;",
                        "\t\tif (!fi->fib_net->ipv4.sysctl_nexthop_compat_mode)",
                        "\t\t\tgoto offload;",
                        "\t}",
                        "",
                        "\tif (nhs == 1) {",
                        "\t\tconst struct fib_nh_common *nhc = fib_info_nhc(fi, 0);",
                        "\t\tunsigned char flags = 0;",
                        "",
                        "\t\tif (fib_nexthop_info(skb, nhc, AF_INET, &flags, false) < 0)",
                        "\t\t\tgoto nla_put_failure;",
                        "",
                        "\t\trtm->rtm_flags = flags;",
                        "#ifdef CONFIG_IP_ROUTE_CLASSID",
                        "\t\tif (nhc->nhc_family == AF_INET) {",
                        "\t\t\tstruct fib_nh *nh;",
                        "",
                        "\t\t\tnh = container_of(nhc, struct fib_nh, nh_common);",
                        "\t\t\tif (nh->nh_tclassid &&",
                        "\t\t\t    nla_put_u32(skb, RTA_FLOW, nh->nh_tclassid))",
                        "\t\t\t\tgoto nla_put_failure;",
                        "\t\t}",
                        "#endif",
                        "\t} else {",
                        "\t\tif (fib_add_multipath(skb, fi) < 0)",
                        "\t\t\tgoto nla_put_failure;",
                        "\t}",
                        "",
                        "offload:",
                        "\tif (fri->offload)",
                        "\t\trtm->rtm_flags |= RTM_F_OFFLOAD;",
                        "\tif (fri->trap)",
                        "\t\trtm->rtm_flags |= RTM_F_TRAP;",
                        "",
                        "\tnlmsg_end(skb, nlh);",
                        "\treturn 0;",
                        "",
                        "nla_put_failure:",
                        "\tnlmsg_cancel(skb, nlh);",
                        "\treturn -EMSGSIZE;",
                        "}"
                    ],
                    "start": 1736,
                    "highlight": 1781
                }
            ],
            "ins_idx": 19,
            "addr": "0xffffffff819b0c46"
        },
        "750": {
            "name": "+0x4da",
            "parent_idx": 698,
            "source_line": [
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1237",
                    "code": [
                        "static struct nexthop *nexthop_create_group(struct net *net,",
                        "\t\t\t\t\t    struct nh_config *cfg)",
                        "{",
                        "\tstruct nlattr *grps_attr = cfg->nh_grp;",
                        "\tstruct nexthop_grp *entry = nla_data(grps_attr);",
                        "\tu16 num_nh = nla_len(grps_attr) / sizeof(*entry);",
                        "\tstruct nh_group *nhg;",
                        "\tstruct nexthop *nh;",
                        "\tint i;",
                        "",
                        "\tnh = nexthop_alloc();",
                        "\tif (!nh)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tnh->is_group = 1;",
                        "",
                        "\tnhg = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg) {",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "",
                        "\t/* spare group used for removals */",
                        "\tnhg->spare = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg->spare) {",
                        "\t\tkfree(nhg);",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "\tnhg->spare->spare = nhg;",
                        "",
                        "\tfor (i = 0; i < nhg->num_nh; ++i) {",
                        "\t\tstruct nexthop *nhe;",
                        "\t\tstruct nh_info *nhi;",
                        "",
                        "\t\tnhe = nexthop_find_by_id(net, entry[i].id);",
                        "\t\tif (!nexthop_get(nhe))",
                        "\t\t\tgoto out_no_nh;",
                        "",
                        "\t\tnhi = rtnl_dereference(nhe->nh_info);",
                        "\t\tif (nhi->family == AF_INET)",
                        "\t\t\tnhg->has_v4 = true;",
                        "",
                        "\t\tnhg->nh_entries[i].nh = nhe;",
                        "\t\tnhg->nh_entries[i].weight = entry[i].weight + 1;",
                        "\t\tlist_add(&nhg->nh_entries[i].nh_list, &nhe->grp_list);",
                        "\t\tnhg->nh_entries[i].nh_parent = nh;",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp_type == NEXTHOP_GRP_TYPE_MPATH) {",
                        "\t\tnhg->mpath = 1;",
                        "\t\tnh_group_rebalance(nhg);",
                        "\t}",
                        "",
                        "\tif (cfg->nh_fdb)",
                        "\t\tnhg->fdb_nh = 1;",
                        "",
                        "\trcu_assign_pointer(nh->nh_grp, nhg);",
                        "",
                        "\treturn nh;",
                        "",
                        "out_no_nh:",
                        "\tfor (; i >= 0; --i)",
                        "\t\tnexthop_put(nhg->nh_entries[i].nh);",
                        "",
                        "\tkfree(nhg->spare);",
                        "\tkfree(nhg);",
                        "\tkfree(nh);",
                        "",
                        "\treturn ERR_PTR(-ENOENT);",
                        "}"
                    ],
                    "start": 1180,
                    "highlight": 1237
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1397",
                    "code": [
                        "/* called with rtnl lock held */",
                        "static struct nexthop *nexthop_add(struct net *net, struct nh_config *cfg,",
                        "\t\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\tif (cfg->nlflags & NLM_F_REPLACE && !cfg->nh_id) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Replace requires nexthop id\");",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "\t}",
                        "",
                        "\tif (!cfg->nh_id) {",
                        "\t\tcfg->nh_id = nh_find_unused_id(net);",
                        "\t\tif (!cfg->nh_id) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"No unused id\");",
                        "\t\t\treturn ERR_PTR(-EINVAL);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp)",
                        "\t\tnh = nexthop_create_group(net, cfg);",
                        "\telse",
                        "\t\tnh = nexthop_create(net, cfg, extack);",
                        "",
                        "\tif (IS_ERR(nh))",
                        "\t\treturn nh;",
                        "",
                        "\trefcount_set(&nh->refcnt, 1);",
                        "\tnh->id = cfg->nh_id;",
                        "\tnh->protocol = cfg->nh_protocol;",
                        "\tnh->net = net;",
                        "",
                        "\terr = insert_nexthop(net, nh, cfg, extack);",
                        "\tif (err) {",
                        "\t\t__remove_nexthop(net, nh, NULL);",
                        "\t\tnexthop_put(nh);",
                        "\t\tnh = ERR_PTR(err);",
                        "\t}",
                        "",
                        "\treturn nh;",
                        "}"
                    ],
                    "start": 1376,
                    "highlight": 1397
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1611",
                    "code": [
                        "/* rtnl */",
                        "static int rtm_new_nexthop(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct nh_config cfg;",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\terr = rtm_to_nh_config(net, skb, nlh, &cfg, extack);",
                        "\tif (!err) {",
                        "\t\tnh = nexthop_add(net, &cfg, extack);",
                        "\t\tif (IS_ERR(nh))",
                        "\t\t\terr = PTR_ERR(nh);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1600,
                    "highlight": 1611
                }
            ],
            "ins_idx": 32,
            "addr": "0xffffffff819bbd6a"
        },
        "749": {
            "name": "+0xe26",
            "parent_idx": 698,
            "source_line": [
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1231",
                    "code": [
                        "static struct nexthop *nexthop_create_group(struct net *net,",
                        "\t\t\t\t\t    struct nh_config *cfg)",
                        "{",
                        "\tstruct nlattr *grps_attr = cfg->nh_grp;",
                        "\tstruct nexthop_grp *entry = nla_data(grps_attr);",
                        "\tu16 num_nh = nla_len(grps_attr) / sizeof(*entry);",
                        "\tstruct nh_group *nhg;",
                        "\tstruct nexthop *nh;",
                        "\tint i;",
                        "",
                        "\tnh = nexthop_alloc();",
                        "\tif (!nh)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tnh->is_group = 1;",
                        "",
                        "\tnhg = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg) {",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "",
                        "\t/* spare group used for removals */",
                        "\tnhg->spare = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg->spare) {",
                        "\t\tkfree(nhg);",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "\tnhg->spare->spare = nhg;",
                        "",
                        "\tfor (i = 0; i < nhg->num_nh; ++i) {",
                        "\t\tstruct nexthop *nhe;",
                        "\t\tstruct nh_info *nhi;",
                        "",
                        "\t\tnhe = nexthop_find_by_id(net, entry[i].id);",
                        "\t\tif (!nexthop_get(nhe))",
                        "\t\t\tgoto out_no_nh;",
                        "",
                        "\t\tnhi = rtnl_dereference(nhe->nh_info);",
                        "\t\tif (nhi->family == AF_INET)",
                        "\t\t\tnhg->has_v4 = true;",
                        "",
                        "\t\tnhg->nh_entries[i].nh = nhe;",
                        "\t\tnhg->nh_entries[i].weight = entry[i].weight + 1;",
                        "\t\tlist_add(&nhg->nh_entries[i].nh_list, &nhe->grp_list);",
                        "\t\tnhg->nh_entries[i].nh_parent = nh;",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp_type == NEXTHOP_GRP_TYPE_MPATH) {",
                        "\t\tnhg->mpath = 1;",
                        "\t\tnh_group_rebalance(nhg);",
                        "\t}",
                        "",
                        "\tif (cfg->nh_fdb)",
                        "\t\tnhg->fdb_nh = 1;",
                        "",
                        "\trcu_assign_pointer(nh->nh_grp, nhg);",
                        "",
                        "\treturn nh;",
                        "",
                        "out_no_nh:",
                        "\tfor (; i >= 0; --i)",
                        "\t\tnexthop_put(nhg->nh_entries[i].nh);",
                        "",
                        "\tkfree(nhg->spare);",
                        "\tkfree(nhg);",
                        "\tkfree(nh);",
                        "",
                        "\treturn ERR_PTR(-ENOENT);",
                        "}"
                    ],
                    "start": 1180,
                    "highlight": 1231
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1397",
                    "code": [
                        "/* called with rtnl lock held */",
                        "static struct nexthop *nexthop_add(struct net *net, struct nh_config *cfg,",
                        "\t\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\tif (cfg->nlflags & NLM_F_REPLACE && !cfg->nh_id) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Replace requires nexthop id\");",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "\t}",
                        "",
                        "\tif (!cfg->nh_id) {",
                        "\t\tcfg->nh_id = nh_find_unused_id(net);",
                        "\t\tif (!cfg->nh_id) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"No unused id\");",
                        "\t\t\treturn ERR_PTR(-EINVAL);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp)",
                        "\t\tnh = nexthop_create_group(net, cfg);",
                        "\telse",
                        "\t\tnh = nexthop_create(net, cfg, extack);",
                        "",
                        "\tif (IS_ERR(nh))",
                        "\t\treturn nh;",
                        "",
                        "\trefcount_set(&nh->refcnt, 1);",
                        "\tnh->id = cfg->nh_id;",
                        "\tnh->protocol = cfg->nh_protocol;",
                        "\tnh->net = net;",
                        "",
                        "\terr = insert_nexthop(net, nh, cfg, extack);",
                        "\tif (err) {",
                        "\t\t__remove_nexthop(net, nh, NULL);",
                        "\t\tnexthop_put(nh);",
                        "\t\tnh = ERR_PTR(err);",
                        "\t}",
                        "",
                        "\treturn nh;",
                        "}"
                    ],
                    "start": 1376,
                    "highlight": 1397
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1611",
                    "code": [
                        "/* rtnl */",
                        "static int rtm_new_nexthop(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct nh_config cfg;",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\terr = rtm_to_nh_config(net, skb, nlh, &cfg, extack);",
                        "\tif (!err) {",
                        "\t\tnh = nexthop_add(net, &cfg, extack);",
                        "\t\tif (IS_ERR(nh))",
                        "\t\t\terr = PTR_ERR(nh);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1600,
                    "highlight": 1611
                }
            ],
            "ins_idx": 48,
            "addr": "0xffffffff819bc6b6"
        },
        "748": {
            "name": "+0xe1a",
            "parent_idx": 698,
            "source_line": [
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1231",
                    "code": [
                        "static struct nexthop *nexthop_create_group(struct net *net,",
                        "\t\t\t\t\t    struct nh_config *cfg)",
                        "{",
                        "\tstruct nlattr *grps_attr = cfg->nh_grp;",
                        "\tstruct nexthop_grp *entry = nla_data(grps_attr);",
                        "\tu16 num_nh = nla_len(grps_attr) / sizeof(*entry);",
                        "\tstruct nh_group *nhg;",
                        "\tstruct nexthop *nh;",
                        "\tint i;",
                        "",
                        "\tnh = nexthop_alloc();",
                        "\tif (!nh)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tnh->is_group = 1;",
                        "",
                        "\tnhg = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg) {",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "",
                        "\t/* spare group used for removals */",
                        "\tnhg->spare = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg->spare) {",
                        "\t\tkfree(nhg);",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "\tnhg->spare->spare = nhg;",
                        "",
                        "\tfor (i = 0; i < nhg->num_nh; ++i) {",
                        "\t\tstruct nexthop *nhe;",
                        "\t\tstruct nh_info *nhi;",
                        "",
                        "\t\tnhe = nexthop_find_by_id(net, entry[i].id);",
                        "\t\tif (!nexthop_get(nhe))",
                        "\t\t\tgoto out_no_nh;",
                        "",
                        "\t\tnhi = rtnl_dereference(nhe->nh_info);",
                        "\t\tif (nhi->family == AF_INET)",
                        "\t\t\tnhg->has_v4 = true;",
                        "",
                        "\t\tnhg->nh_entries[i].nh = nhe;",
                        "\t\tnhg->nh_entries[i].weight = entry[i].weight + 1;",
                        "\t\tlist_add(&nhg->nh_entries[i].nh_list, &nhe->grp_list);",
                        "\t\tnhg->nh_entries[i].nh_parent = nh;",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp_type == NEXTHOP_GRP_TYPE_MPATH) {",
                        "\t\tnhg->mpath = 1;",
                        "\t\tnh_group_rebalance(nhg);",
                        "\t}",
                        "",
                        "\tif (cfg->nh_fdb)",
                        "\t\tnhg->fdb_nh = 1;",
                        "",
                        "\trcu_assign_pointer(nh->nh_grp, nhg);",
                        "",
                        "\treturn nh;",
                        "",
                        "out_no_nh:",
                        "\tfor (; i >= 0; --i)",
                        "\t\tnexthop_put(nhg->nh_entries[i].nh);",
                        "",
                        "\tkfree(nhg->spare);",
                        "\tkfree(nhg);",
                        "\tkfree(nh);",
                        "",
                        "\treturn ERR_PTR(-ENOENT);",
                        "}"
                    ],
                    "start": 1180,
                    "highlight": 1231
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1397",
                    "code": [
                        "/* called with rtnl lock held */",
                        "static struct nexthop *nexthop_add(struct net *net, struct nh_config *cfg,",
                        "\t\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\tif (cfg->nlflags & NLM_F_REPLACE && !cfg->nh_id) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Replace requires nexthop id\");",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "\t}",
                        "",
                        "\tif (!cfg->nh_id) {",
                        "\t\tcfg->nh_id = nh_find_unused_id(net);",
                        "\t\tif (!cfg->nh_id) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"No unused id\");",
                        "\t\t\treturn ERR_PTR(-EINVAL);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp)",
                        "\t\tnh = nexthop_create_group(net, cfg);",
                        "\telse",
                        "\t\tnh = nexthop_create(net, cfg, extack);",
                        "",
                        "\tif (IS_ERR(nh))",
                        "\t\treturn nh;",
                        "",
                        "\trefcount_set(&nh->refcnt, 1);",
                        "\tnh->id = cfg->nh_id;",
                        "\tnh->protocol = cfg->nh_protocol;",
                        "\tnh->net = net;",
                        "",
                        "\terr = insert_nexthop(net, nh, cfg, extack);",
                        "\tif (err) {",
                        "\t\t__remove_nexthop(net, nh, NULL);",
                        "\t\tnexthop_put(nh);",
                        "\t\tnh = ERR_PTR(err);",
                        "\t}",
                        "",
                        "\treturn nh;",
                        "}"
                    ],
                    "start": 1376,
                    "highlight": 1397
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1611",
                    "code": [
                        "/* rtnl */",
                        "static int rtm_new_nexthop(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct nh_config cfg;",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\terr = rtm_to_nh_config(net, skb, nlh, &cfg, extack);",
                        "\tif (!err) {",
                        "\t\tnh = nexthop_add(net, &cfg, extack);",
                        "\t\tif (IS_ERR(nh))",
                        "\t\t\terr = PTR_ERR(nh);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1600,
                    "highlight": 1611
                }
            ],
            "ins_idx": 69,
            "addr": "0xffffffff819bc6aa"
        },
        "747": {
            "name": "+0x390",
            "parent_idx": 698,
            "source_line": [
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n142",
                    "code": [
                        "static struct nh_group *nexthop_grp_alloc(u16 num_nh)",
                        "{",
                        "\tsize_t sz = offsetof(struct nexthop, nh_grp)",
                        "\t\t    + sizeof(struct nh_group)",
                        "\t\t    + sizeof(struct nh_grp_entry) * num_nh;",
                        "\tstruct nh_group *nhg;",
                        "",
                        "\tnhg = kzalloc(sz, GFP_KERNEL);",
                        "\tif (nhg)",
                        "\t\tnhg->num_nh = num_nh;",
                        "",
                        "\treturn nhg;",
                        "}"
                    ],
                    "start": 134,
                    "highlight": 142
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1203",
                    "code": [
                        "static struct nexthop *nexthop_create_group(struct net *net,",
                        "\t\t\t\t\t    struct nh_config *cfg)",
                        "{",
                        "\tstruct nlattr *grps_attr = cfg->nh_grp;",
                        "\tstruct nexthop_grp *entry = nla_data(grps_attr);",
                        "\tu16 num_nh = nla_len(grps_attr) / sizeof(*entry);",
                        "\tstruct nh_group *nhg;",
                        "\tstruct nexthop *nh;",
                        "\tint i;",
                        "",
                        "\tnh = nexthop_alloc();",
                        "\tif (!nh)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tnh->is_group = 1;",
                        "",
                        "\tnhg = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg) {",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "",
                        "\t/* spare group used for removals */",
                        "\tnhg->spare = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg->spare) {",
                        "\t\tkfree(nhg);",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "\tnhg->spare->spare = nhg;",
                        "",
                        "\tfor (i = 0; i < nhg->num_nh; ++i) {",
                        "\t\tstruct nexthop *nhe;",
                        "\t\tstruct nh_info *nhi;",
                        "",
                        "\t\tnhe = nexthop_find_by_id(net, entry[i].id);",
                        "\t\tif (!nexthop_get(nhe))",
                        "\t\t\tgoto out_no_nh;",
                        "",
                        "\t\tnhi = rtnl_dereference(nhe->nh_info);",
                        "\t\tif (nhi->family == AF_INET)",
                        "\t\t\tnhg->has_v4 = true;",
                        "",
                        "\t\tnhg->nh_entries[i].nh = nhe;",
                        "\t\tnhg->nh_entries[i].weight = entry[i].weight + 1;",
                        "\t\tlist_add(&nhg->nh_entries[i].nh_list, &nhe->grp_list);",
                        "\t\tnhg->nh_entries[i].nh_parent = nh;",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp_type == NEXTHOP_GRP_TYPE_MPATH) {",
                        "\t\tnhg->mpath = 1;",
                        "\t\tnh_group_rebalance(nhg);",
                        "\t}",
                        "",
                        "\tif (cfg->nh_fdb)",
                        "\t\tnhg->fdb_nh = 1;",
                        "",
                        "\trcu_assign_pointer(nh->nh_grp, nhg);",
                        "",
                        "\treturn nh;",
                        "",
                        "out_no_nh:",
                        "\tfor (; i >= 0; --i)",
                        "\t\tnexthop_put(nhg->nh_entries[i].nh);",
                        "",
                        "\tkfree(nhg->spare);",
                        "\tkfree(nhg);",
                        "\tkfree(nh);",
                        "",
                        "\treturn ERR_PTR(-ENOENT);",
                        "}"
                    ],
                    "start": 1180,
                    "highlight": 1203
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1397",
                    "code": [
                        "/* called with rtnl lock held */",
                        "static struct nexthop *nexthop_add(struct net *net, struct nh_config *cfg,",
                        "\t\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\tif (cfg->nlflags & NLM_F_REPLACE && !cfg->nh_id) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Replace requires nexthop id\");",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "\t}",
                        "",
                        "\tif (!cfg->nh_id) {",
                        "\t\tcfg->nh_id = nh_find_unused_id(net);",
                        "\t\tif (!cfg->nh_id) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"No unused id\");",
                        "\t\t\treturn ERR_PTR(-EINVAL);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp)",
                        "\t\tnh = nexthop_create_group(net, cfg);",
                        "\telse",
                        "\t\tnh = nexthop_create(net, cfg, extack);",
                        "",
                        "\tif (IS_ERR(nh))",
                        "\t\treturn nh;",
                        "",
                        "\trefcount_set(&nh->refcnt, 1);",
                        "\tnh->id = cfg->nh_id;",
                        "\tnh->protocol = cfg->nh_protocol;",
                        "\tnh->net = net;",
                        "",
                        "\terr = insert_nexthop(net, nh, cfg, extack);",
                        "\tif (err) {",
                        "\t\t__remove_nexthop(net, nh, NULL);",
                        "\t\tnexthop_put(nh);",
                        "\t\tnh = ERR_PTR(err);",
                        "\t}",
                        "",
                        "\treturn nh;",
                        "}"
                    ],
                    "start": 1376,
                    "highlight": 1397
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1611",
                    "code": [
                        "/* rtnl */",
                        "static int rtm_new_nexthop(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct nh_config cfg;",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\terr = rtm_to_nh_config(net, skb, nlh, &cfg, extack);",
                        "\tif (!err) {",
                        "\t\tnh = nexthop_add(net, &cfg, extack);",
                        "\t\tif (IS_ERR(nh))",
                        "\t\t\terr = PTR_ERR(nh);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1600,
                    "highlight": 1611
                }
            ],
            "ins_idx": 92,
            "addr": "0xffffffff819bbc20"
        },
        "746": {
            "name": "+0x384",
            "parent_idx": 698,
            "source_line": [
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n143",
                    "code": [
                        "static struct nh_group *nexthop_grp_alloc(u16 num_nh)",
                        "{",
                        "\tsize_t sz = offsetof(struct nexthop, nh_grp)",
                        "\t\t    + sizeof(struct nh_group)",
                        "\t\t    + sizeof(struct nh_grp_entry) * num_nh;",
                        "\tstruct nh_group *nhg;",
                        "",
                        "\tnhg = kzalloc(sz, GFP_KERNEL);",
                        "\tif (nhg)",
                        "\t\tnhg->num_nh = num_nh;",
                        "",
                        "\treturn nhg;",
                        "}"
                    ],
                    "start": 134,
                    "highlight": 143
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1196",
                    "code": [
                        "static struct nexthop *nexthop_create_group(struct net *net,",
                        "\t\t\t\t\t    struct nh_config *cfg)",
                        "{",
                        "\tstruct nlattr *grps_attr = cfg->nh_grp;",
                        "\tstruct nexthop_grp *entry = nla_data(grps_attr);",
                        "\tu16 num_nh = nla_len(grps_attr) / sizeof(*entry);",
                        "\tstruct nh_group *nhg;",
                        "\tstruct nexthop *nh;",
                        "\tint i;",
                        "",
                        "\tnh = nexthop_alloc();",
                        "\tif (!nh)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tnh->is_group = 1;",
                        "",
                        "\tnhg = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg) {",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "",
                        "\t/* spare group used for removals */",
                        "\tnhg->spare = nexthop_grp_alloc(num_nh);",
                        "\tif (!nhg->spare) {",
                        "\t\tkfree(nhg);",
                        "\t\tkfree(nh);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "\tnhg->spare->spare = nhg;",
                        "",
                        "\tfor (i = 0; i < nhg->num_nh; ++i) {",
                        "\t\tstruct nexthop *nhe;",
                        "\t\tstruct nh_info *nhi;",
                        "",
                        "\t\tnhe = nexthop_find_by_id(net, entry[i].id);",
                        "\t\tif (!nexthop_get(nhe))",
                        "\t\t\tgoto out_no_nh;",
                        "",
                        "\t\tnhi = rtnl_dereference(nhe->nh_info);",
                        "\t\tif (nhi->family == AF_INET)",
                        "\t\t\tnhg->has_v4 = true;",
                        "",
                        "\t\tnhg->nh_entries[i].nh = nhe;",
                        "\t\tnhg->nh_entries[i].weight = entry[i].weight + 1;",
                        "\t\tlist_add(&nhg->nh_entries[i].nh_list, &nhe->grp_list);",
                        "\t\tnhg->nh_entries[i].nh_parent = nh;",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp_type == NEXTHOP_GRP_TYPE_MPATH) {",
                        "\t\tnhg->mpath = 1;",
                        "\t\tnh_group_rebalance(nhg);",
                        "\t}",
                        "",
                        "\tif (cfg->nh_fdb)",
                        "\t\tnhg->fdb_nh = 1;",
                        "",
                        "\trcu_assign_pointer(nh->nh_grp, nhg);",
                        "",
                        "\treturn nh;",
                        "",
                        "out_no_nh:",
                        "\tfor (; i >= 0; --i)",
                        "\t\tnexthop_put(nhg->nh_entries[i].nh);",
                        "",
                        "\tkfree(nhg->spare);",
                        "\tkfree(nhg);",
                        "\tkfree(nh);",
                        "",
                        "\treturn ERR_PTR(-ENOENT);",
                        "}"
                    ],
                    "start": 1180,
                    "highlight": 1196
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1397",
                    "code": [
                        "/* called with rtnl lock held */",
                        "static struct nexthop *nexthop_add(struct net *net, struct nh_config *cfg,",
                        "\t\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\tif (cfg->nlflags & NLM_F_REPLACE && !cfg->nh_id) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Replace requires nexthop id\");",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "\t}",
                        "",
                        "\tif (!cfg->nh_id) {",
                        "\t\tcfg->nh_id = nh_find_unused_id(net);",
                        "\t\tif (!cfg->nh_id) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"No unused id\");",
                        "\t\t\treturn ERR_PTR(-EINVAL);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (cfg->nh_grp)",
                        "\t\tnh = nexthop_create_group(net, cfg);",
                        "\telse",
                        "\t\tnh = nexthop_create(net, cfg, extack);",
                        "",
                        "\tif (IS_ERR(nh))",
                        "\t\treturn nh;",
                        "",
                        "\trefcount_set(&nh->refcnt, 1);",
                        "\tnh->id = cfg->nh_id;",
                        "\tnh->protocol = cfg->nh_protocol;",
                        "\tnh->net = net;",
                        "",
                        "\terr = insert_nexthop(net, nh, cfg, extack);",
                        "\tif (err) {",
                        "\t\t__remove_nexthop(net, nh, NULL);",
                        "\t\tnexthop_put(nh);",
                        "\t\tnh = ERR_PTR(err);",
                        "\t}",
                        "",
                        "\treturn nh;",
                        "}"
                    ],
                    "start": 1376,
                    "highlight": 1397
                },
                {
                    "file": "net/ipv4/nexthop.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/nexthop.c?id=c3d8f220d012#n1611",
                    "code": [
                        "/* rtnl */",
                        "static int rtm_new_nexthop(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct nh_config cfg;",
                        "\tstruct nexthop *nh;",
                        "\tint err;",
                        "",
                        "\terr = rtm_to_nh_config(net, skb, nlh, &cfg, extack);",
                        "\tif (!err) {",
                        "\t\tnh = nexthop_add(net, &cfg, extack);",
                        "\t\tif (IS_ERR(nh))",
                        "\t\t\terr = PTR_ERR(nh);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1600,
                    "highlight": 1611
                }
            ],
            "ins_idx": 115,
            "addr": "0xffffffff819bbc14"
        }
    },
    "ins": {
        "1": {
            "name": "mov rax, qword ptr [rax + 0x80]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x80",
            "call_idx": 1631,
            "inputs": [
                3139,
                3140
            ],
            "outputs": [
                3141
            ]
        },
        "10": {
            "name": "mov rax, qword ptr [rax + 0x10]",
            "desc": "Heap Use Before Initialization",
            "call_idx": 1630,
            "inputs": [
                3136,
                3137
            ],
            "outputs": [
                3138
            ]
        },
        "20": {
            "name": "push r15",
            "desc": "Source of base address MEMALLOC 0x0",
            "call_idx": 744,
            "inputs": [],
            "outputs": [
                1443
            ]
        },
        "19": {
            "name": "mov rax, qword ptr [rax + 0x80]",
            "desc": "",
            "call_idx": 1629,
            "inputs": [
                3133,
                3134
            ],
            "outputs": [
                3135
            ]
        },
        "32": {
            "name": "mov qword ptr [r15 + 0x80], r8",
            "desc": "",
            "call_idx": 750,
            "inputs": [
                1459,
                1460
            ],
            "outputs": [
                1461
            ]
        },
        "48": {
            "name": "mov r8, qword ptr [rbp - 0x168]",
            "desc": "",
            "call_idx": 749,
            "inputs": [
                1456,
                1457
            ],
            "outputs": [
                1458
            ]
        },
        "69": {
            "name": "mov qword ptr [rbp - 0x168], r8",
            "desc": "",
            "call_idx": 748,
            "inputs": [
                1453,
                1454
            ],
            "outputs": [
                1455
            ]
        },
        "92": {
            "name": "mov r8, qword ptr [rbp - 0x170]",
            "desc": "",
            "call_idx": 747,
            "inputs": [
                1450,
                1451
            ],
            "outputs": [
                1452
            ]
        },
        "115": {
            "name": "mov qword ptr [rbp - 0x170], rax",
            "desc": "",
            "call_idx": 746,
            "inputs": [
                1447,
                1448
            ],
            "outputs": [
                1449
            ]
        }
    },
    "data": {
        "3139": {
            "name": "RAX",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "3140": {
            "name": "[0x80]",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "3141": {
            "name": "RAX",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "3136": {
            "name": "RAX",
            "ins_idx": 10,
            "value": "0xffff888235688a80",
            "sources": []
        },
        "3137": {
            "name": "[0xffff888235688a90]",
            "ins_idx": 10,
            "value": "0x0",
            "sources": []
        },
        "3138": {
            "name": "RAX",
            "ins_idx": 10,
            "value": "0x0",
            "sources": [
                3139
            ]
        },
        "1443": {
            "name": "RAX",
            "ins_idx": 20,
            "value": "0xffff888235688a80",
            "sources": [
                3136,
                1448
            ]
        },
        "3133": {
            "name": "RAX",
            "ins_idx": 19,
            "value": "0xffff8882356883c0",
            "sources": []
        },
        "3134": {
            "name": "[0xffff888235688440]",
            "ins_idx": 19,
            "value": "0xffff888235688a80",
            "sources": []
        },
        "3135": {
            "name": "RAX",
            "ins_idx": 19,
            "value": "0xffff888235688a80",
            "sources": [
                3136
            ]
        },
        "1459": {
            "name": "R15",
            "ins_idx": 32,
            "value": "0xffff8882356883c0",
            "sources": []
        },
        "1460": {
            "name": "R8",
            "ins_idx": 32,
            "value": "0xffff888235688a80",
            "sources": []
        },
        "1461": {
            "name": "[0xffff888235688440]",
            "ins_idx": 32,
            "value": "0xffff888235688a80",
            "sources": [
                3134
            ]
        },
        "1456": {
            "name": "RBP",
            "ins_idx": 48,
            "value": "0xffffc9000024fb40",
            "sources": []
        },
        "1457": {
            "name": "[0xffffc9000024f9d8]",
            "ins_idx": 48,
            "value": "0xffff888235688a80",
            "sources": []
        },
        "1458": {
            "name": "R8",
            "ins_idx": 48,
            "value": "0xffff888235688a80",
            "sources": [
                1460
            ]
        },
        "1453": {
            "name": "RBP",
            "ins_idx": 69,
            "value": "0xffffc9000024fb40",
            "sources": []
        },
        "1454": {
            "name": "R8",
            "ins_idx": 69,
            "value": "0xffff888235688a80",
            "sources": []
        },
        "1455": {
            "name": "[0xffffc9000024f9d8]",
            "ins_idx": 69,
            "value": "0xffff888235688a80",
            "sources": [
                1457
            ]
        },
        "1450": {
            "name": "RBP",
            "ins_idx": 92,
            "value": "0xffffc9000024fb40",
            "sources": []
        },
        "1451": {
            "name": "[0xffffc9000024f9d0]",
            "ins_idx": 92,
            "value": "0xffff888235688a80",
            "sources": []
        },
        "1452": {
            "name": "R8",
            "ins_idx": 92,
            "value": "0xffff888235688a80",
            "sources": [
                1454
            ]
        },
        "1447": {
            "name": "RBP",
            "ins_idx": 115,
            "value": "0xffffc9000024fb40",
            "sources": []
        },
        "1448": {
            "name": "RAX",
            "ins_idx": 115,
            "value": "0xffff888235688a80",
            "sources": []
        },
        "1449": {
            "name": "[0xffffc9000024f9d0]",
            "ins_idx": 115,
            "value": "0xffff888235688a80",
            "sources": [
                1451
            ]
        }
    },
    "chain": {
        "1": [
            10
        ],
        "10": [
            20,
            19
        ],
        "19": [
            32
        ],
        "32": [
            48
        ],
        "48": [
            69
        ],
        "69": [
            92
        ],
        "92": [
            115
        ],
        "115": [
            20
        ]
    }
}