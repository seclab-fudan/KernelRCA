{
    "report": "https://syzkaller.appspot.com/bug?id=41872265f1e3e0489eb0cc8762f8d48b3667afdb",
    "title": "general protection fault in rxrpc_connect_call",
    "call": {
        "278": {
            "name": "+0x34",
            "parent_idx": 276,
            "source_line": [
                {
                    "file": "net/rxrpc/conn_client.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/rxrpc/conn_client.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n690",
                    "code": [
                        "/*",
                        " * find a connection for a call",
                        " * - called in process context with IRQs enabled",
                        " */",
                        "int rxrpc_connect_call(struct rxrpc_sock *rx,",
                        "\t\t       struct rxrpc_call *call,",
                        "\t\t       struct rxrpc_conn_parameters *cp,",
                        "\t\t       struct sockaddr_rxrpc *srx,",
                        "\t\t       gfp_t gfp)",
                        "{",
                        "\tstruct rxrpc_net *rxnet = cp->local->rxnet;",
                        "\tint ret;",
                        "",
                        "\t_enter(\"{%d,%lx},\", call->debug_id, call->user_call_ID);",
                        "",
                        "\trxrpc_discard_expired_client_conns(&rxnet->client_conn_reaper);",
                        "\trxrpc_cull_active_client_conns(rxnet);",
                        "",
                        "\tret = rxrpc_get_client_conn(rx, call, cp, srx, gfp);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "",
                        "\trxrpc_animate_client_conn(rxnet, call->conn);",
                        "\trxrpc_activate_channels(call->conn);",
                        "",
                        "\tret = rxrpc_wait_for_channel(call, gfp);",
                        "\tif (ret < 0) {",
                        "\t\trxrpc_disconnect_client_call(call);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tspin_lock_bh(&call->conn->params.peer->lock);",
                        "\thlist_add_head_rcu(&call->error_link,",
                        "\t\t\t   &call->conn->params.peer->error_targets);",
                        "\tspin_unlock_bh(&call->conn->params.peer->lock);",
                        "",
                        "out:",
                        "\t_leave(\" = %d\", ret);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 680,
                    "highlight": 690
                }
            ],
            "ins_idx": 1,
            "addr": "0xffffffff81983494"
        },
        "276": {
            "name": "rxrpc_connect_call",
            "parent_idx": 270,
            "source_line": [
                {
                    "file": "net/rxrpc/call_object.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/rxrpc/call_object.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n291",
                    "code": [
                        "/*",
                        " * Set up a call for the given parameters.",
                        " * - Called with the socket lock held, which it must release.",
                        " * - If it returns a call, the call's lock will need releasing by the caller.",
                        " */",
                        "struct rxrpc_call *rxrpc_new_client_call(struct rxrpc_sock *rx,",
                        "\t\t\t\t\t struct rxrpc_conn_parameters *cp,",
                        "\t\t\t\t\t struct sockaddr_rxrpc *srx,",
                        "\t\t\t\t\t struct rxrpc_call_params *p,",
                        "\t\t\t\t\t gfp_t gfp,",
                        "\t\t\t\t\t unsigned int debug_id)",
                        "\t__releases(&rx->sk.sk_lock.slock)",
                        "\t__acquires(&call->user_mutex)",
                        "{",
                        "\tstruct rxrpc_call *call, *xcall;",
                        "\tstruct rxrpc_net *rxnet;",
                        "\tstruct rb_node *parent, **pp;",
                        "\tconst void *here = __builtin_return_address(0);",
                        "\tint ret;",
                        "",
                        "\t_enter(\"%p,%lx\", rx, p->user_call_ID);",
                        "",
                        "\tcall = rxrpc_alloc_client_call(rx, srx, gfp, debug_id);",
                        "\tif (IS_ERR(call)) {",
                        "\t\trelease_sock(&rx->sk);",
                        "\t\t_leave(\" = %ld\", PTR_ERR(call));",
                        "\t\treturn call;",
                        "\t}",
                        "",
                        "\tcall->tx_total_len = p->tx_total_len;",
                        "\ttrace_rxrpc_call(call, rxrpc_call_new_client, atomic_read(&call->usage),",
                        "\t\t\t here, (const void *)p->user_call_ID);",
                        "",
                        "\t/* We need to protect a partially set up call against the user as we",
                        "\t * will be acting outside the socket lock.",
                        "\t */",
                        "\tmutex_lock(&call->user_mutex);",
                        "",
                        "\t/* Publish the call, even though it is incompletely set up as yet */",
                        "\twrite_lock(&rx->call_lock);",
                        "",
                        "\tpp = &rx->calls.rb_node;",
                        "\tparent = NULL;",
                        "\twhile (*pp) {",
                        "\t\tparent = *pp;",
                        "\t\txcall = rb_entry(parent, struct rxrpc_call, sock_node);",
                        "",
                        "\t\tif (p->user_call_ID < xcall->user_call_ID)",
                        "\t\t\tpp = &(*pp)->rb_left;",
                        "\t\telse if (p->user_call_ID > xcall->user_call_ID)",
                        "\t\t\tpp = &(*pp)->rb_right;",
                        "\t\telse",
                        "\t\t\tgoto error_dup_user_ID;",
                        "\t}",
                        "",
                        "\trcu_assign_pointer(call->socket, rx);",
                        "\tcall->user_call_ID = p->user_call_ID;",
                        "\t__set_bit(RXRPC_CALL_HAS_USERID, &call->flags);",
                        "\trxrpc_get_call(call, rxrpc_call_got_userid);",
                        "\trb_link_node(&call->sock_node, parent, pp);",
                        "\trb_insert_color(&call->sock_node, &rx->calls);",
                        "\tlist_add(&call->sock_link, &rx->sock_calls);",
                        "",
                        "\twrite_unlock(&rx->call_lock);",
                        "",
                        "\trxnet = call->rxnet;",
                        "\twrite_lock(&rxnet->call_lock);",
                        "\tlist_add_tail(&call->link, &rxnet->calls);",
                        "\twrite_unlock(&rxnet->call_lock);",
                        "",
                        "\t/* From this point on, the call is protected by its own lock. */",
                        "\trelease_sock(&rx->sk);",
                        "",
                        "\t/* Set up or get a connection record and set the protocol parameters,",
                        "\t * including channel number and call ID.",
                        "\t */",
                        "\tret = rxrpc_connect_call(rx, call, cp, srx, gfp);",
                        "\tif (ret < 0)",
                        "\t\tgoto error;",
                        "",
                        "\ttrace_rxrpc_call(call, rxrpc_call_connected, atomic_read(&call->usage),",
                        "\t\t\t here, NULL);",
                        "",
                        "\trxrpc_start_call_timer(call);",
                        "",
                        "\t_net(\"CALL new %d on CONN %d\", call->debug_id, call->conn->debug_id);",
                        "",
                        "\t_leave(\" = %p [new]\", call);",
                        "\treturn call;",
                        "",
                        "\t/* We unexpectedly found the user ID in the list after taking",
                        "\t * the call_lock.  This shouldn't happen unless the user races",
                        "\t * with itself and tries to add the same user ID twice at the",
                        "\t * same time in different threads.",
                        "\t */",
                        "error_dup_user_ID:",
                        "\twrite_unlock(&rx->call_lock);",
                        "\trelease_sock(&rx->sk);",
                        "\tret = -EEXIST;",
                        "",
                        "error:",
                        "\t__rxrpc_set_call_completion(call, RXRPC_CALL_LOCAL_ERROR,",
                        "\t\t\t\t    RX_CALL_DEAD, ret);",
                        "\ttrace_rxrpc_call(call, rxrpc_call_error, atomic_read(&call->usage),",
                        "\t\t\t here, ERR_PTR(ret));",
                        "\trxrpc_release_call(rx, call);",
                        "\tmutex_unlock(&call->user_mutex);",
                        "\trxrpc_put_call(call, rxrpc_call_put);",
                        "\t_leave(\" = %d\", ret);",
                        "\treturn ERR_PTR(ret);",
                        "}"
                    ],
                    "start": 215,
                    "highlight": 291
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81981c34"
        },
        "270": {
            "name": "rxrpc_new_client_call",
            "parent_idx": 261,
            "source_line": [
                {
                    "file": "net/rxrpc/sendmsg.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/rxrpc/sendmsg.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n593",
                    "code": [
                        "/*",
                        " * Create a new client call for sendmsg().",
                        " * - Called with the socket lock held, which it must release.",
                        " * - If it returns a call, the call's lock will need releasing by the caller.",
                        " */",
                        "static struct rxrpc_call *",
                        "rxrpc_new_client_call_for_sendmsg(struct rxrpc_sock *rx, struct msghdr *msg,",
                        "\t\t\t\t  struct rxrpc_send_params *p)",
                        "\t__releases(&rx->sk.sk_lock.slock)",
                        "\t__acquires(&call->user_mutex)",
                        "{",
                        "\tstruct rxrpc_conn_parameters cp;",
                        "\tstruct rxrpc_call *call;",
                        "\tstruct key *key;",
                        "",
                        "\tDECLARE_SOCKADDR(struct sockaddr_rxrpc *, srx, msg->msg_name);",
                        "",
                        "\t_enter(\"\");",
                        "",
                        "\tif (!msg->msg_name) {",
                        "\t\trelease_sock(&rx->sk);",
                        "\t\treturn ERR_PTR(-EDESTADDRREQ);",
                        "\t}",
                        "",
                        "\tkey = rx->key;",
                        "\tif (key && !rx->key->payload.data[0])",
                        "\t\tkey = NULL;",
                        "",
                        "\tmemset(&cp, 0, sizeof(cp));",
                        "\tcp.local\t\t= rx->local;",
                        "\tcp.key\t\t\t= rx->key;",
                        "\tcp.security_level\t= rx->min_sec_level;",
                        "\tcp.exclusive\t\t= rx->exclusive | p->exclusive;",
                        "\tcp.upgrade\t\t= p->upgrade;",
                        "\tcp.service_id\t\t= srx->srx_service;",
                        "\tcall = rxrpc_new_client_call(rx, &cp, srx, &p->call, GFP_KERNEL,",
                        "\t\t\t\t     atomic_inc_return(&rxrpc_debug_id));",
                        "\t/* The socket is now unlocked */",
                        "",
                        "\trxrpc_put_peer(cp.peer);",
                        "\t_leave(\" = %p\\n\", call);",
                        "\treturn call;",
                        "}"
                    ],
                    "start": 558,
                    "highlight": 593
                },
                {
                    "file": "net/rxrpc/sendmsg.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/rxrpc/sendmsg.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n649",
                    "code": [
                        "/*",
                        " * send a message forming part of a client call through an RxRPC socket",
                        " * - caller holds the socket locked",
                        " * - the socket may be either a client socket or a server socket",
                        " */",
                        "int rxrpc_do_sendmsg(struct rxrpc_sock *rx, struct msghdr *msg, size_t len)",
                        "\t__releases(&rx->sk.sk_lock.slock)",
                        "\t__releases(&call->user_mutex)",
                        "{",
                        "\tenum rxrpc_call_state state;",
                        "\tstruct rxrpc_call *call;",
                        "\tunsigned long now, j;",
                        "\tint ret;",
                        "",
                        "\tstruct rxrpc_send_params p = {",
                        "\t\t.call.tx_total_len\t= -1,",
                        "\t\t.call.user_call_ID\t= 0,",
                        "\t\t.call.nr_timeouts\t= 0,",
                        "\t\t.abort_code\t\t= 0,",
                        "\t\t.command\t\t= RXRPC_CMD_SEND_DATA,",
                        "\t\t.exclusive\t\t= false,",
                        "\t\t.upgrade\t\t= false,",
                        "\t};",
                        "",
                        "\t_enter(\"\");",
                        "",
                        "\tret = rxrpc_sendmsg_cmsg(msg, &p);",
                        "\tif (ret < 0)",
                        "\t\tgoto error_release_sock;",
                        "",
                        "\tif (p.command == RXRPC_CMD_ACCEPT) {",
                        "\t\tret = -EINVAL;",
                        "\t\tif (rx->sk.sk_state != RXRPC_SERVER_LISTENING)",
                        "\t\t\tgoto error_release_sock;",
                        "\t\tcall = rxrpc_accept_call(rx, p.call.user_call_ID, NULL);",
                        "\t\t/* The socket is now unlocked. */",
                        "\t\tif (IS_ERR(call))",
                        "\t\t\treturn PTR_ERR(call);",
                        "\t\tret = 0;",
                        "\t\tgoto out_put_unlock;",
                        "\t}",
                        "",
                        "\tcall = rxrpc_find_call_by_user_ID(rx, p.call.user_call_ID);",
                        "\tif (!call) {",
                        "\t\tret = -EBADSLT;",
                        "\t\tif (p.command != RXRPC_CMD_SEND_DATA)",
                        "\t\t\tgoto error_release_sock;",
                        "\t\tcall = rxrpc_new_client_call_for_sendmsg(rx, msg, &p);",
                        "\t\t/* The socket is now unlocked... */",
                        "\t\tif (IS_ERR(call))",
                        "\t\t\treturn PTR_ERR(call);",
                        "\t\t/* ... and we have the call lock. */",
                        "\t} else {",
                        "\t\tswitch (READ_ONCE(call->state)) {",
                        "\t\tcase RXRPC_CALL_UNINITIALISED:",
                        "\t\tcase RXRPC_CALL_CLIENT_AWAIT_CONN:",
                        "\t\tcase RXRPC_CALL_SERVER_PREALLOC:",
                        "\t\tcase RXRPC_CALL_SERVER_SECURING:",
                        "\t\tcase RXRPC_CALL_SERVER_ACCEPTING:",
                        "\t\t\tret = -EBUSY;",
                        "\t\t\tgoto error_release_sock;",
                        "\t\tdefault:",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\tret = mutex_lock_interruptible(&call->user_mutex);",
                        "\t\trelease_sock(&rx->sk);",
                        "\t\tif (ret < 0) {",
                        "\t\t\tret = -ERESTARTSYS;",
                        "\t\t\tgoto error_put;",
                        "\t\t}",
                        "",
                        "\t\tif (p.call.tx_total_len != -1) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tif (call->tx_total_len != -1 ||",
                        "\t\t\t    call->tx_pending ||",
                        "\t\t\t    call->tx_top != 0)",
                        "\t\t\t\tgoto error_put;",
                        "\t\t\tcall->tx_total_len = p.call.tx_total_len;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (p.call.nr_timeouts) {",
                        "\tcase 3:",
                        "\t\tj = msecs_to_jiffies(p.call.timeouts.normal);",
                        "\t\tif (p.call.timeouts.normal > 0 && j == 0)",
                        "\t\t\tj = 1;",
                        "\t\tWRITE_ONCE(call->next_rx_timo, j);",
                        "\t\t/* Fall through */",
                        "\tcase 2:",
                        "\t\tj = msecs_to_jiffies(p.call.timeouts.idle);",
                        "\t\tif (p.call.timeouts.idle > 0 && j == 0)",
                        "\t\t\tj = 1;",
                        "\t\tWRITE_ONCE(call->next_req_timo, j);",
                        "\t\t/* Fall through */",
                        "\tcase 1:",
                        "\t\tif (p.call.timeouts.hard > 0) {",
                        "\t\t\tj = msecs_to_jiffies(p.call.timeouts.hard);",
                        "\t\t\tnow = jiffies;",
                        "\t\t\tj += now;",
                        "\t\t\tWRITE_ONCE(call->expect_term_by, j);",
                        "\t\t\trxrpc_reduce_call_timer(call, j, now,",
                        "\t\t\t\t\t\trxrpc_timer_set_for_hard);",
                        "\t\t}",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tstate = READ_ONCE(call->state);",
                        "\t_debug(\"CALL %d USR %lx ST %d on CONN %p\",",
                        "\t       call->debug_id, call->user_call_ID, state, call->conn);",
                        "",
                        "\tif (state >= RXRPC_CALL_COMPLETE) {",
                        "\t\t/* it's too late for this call */",
                        "\t\tret = -ESHUTDOWN;",
                        "\t} else if (p.command == RXRPC_CMD_SEND_ABORT) {",
                        "\t\tret = 0;",
                        "\t\tif (rxrpc_abort_call(\"CMD\", call, 0, p.abort_code, -ECONNABORTED))",
                        "\t\t\tret = rxrpc_send_abort_packet(call);",
                        "\t} else if (p.command != RXRPC_CMD_SEND_DATA) {",
                        "\t\tret = -EINVAL;",
                        "\t} else if (rxrpc_is_client_call(call) &&",
                        "\t\t   state != RXRPC_CALL_CLIENT_SEND_REQUEST) {",
                        "\t\t/* request phase complete for this client call */",
                        "\t\tret = -EPROTO;",
                        "\t} else if (rxrpc_is_service_call(call) &&",
                        "\t\t   state != RXRPC_CALL_SERVER_ACK_REQUEST &&",
                        "\t\t   state != RXRPC_CALL_SERVER_SEND_REPLY) {",
                        "\t\t/* Reply phase not begun or not complete for service call. */",
                        "\t\tret = -EPROTO;",
                        "\t} else {",
                        "\t\tret = rxrpc_send_data(rx, call, msg, len, NULL);",
                        "\t}",
                        "",
                        "out_put_unlock:",
                        "\tmutex_unlock(&call->user_mutex);",
                        "error_put:",
                        "\trxrpc_put_call(call, rxrpc_call_put);",
                        "\t_leave(\" = %d\", ret);",
                        "\treturn ret;",
                        "",
                        "error_release_sock:",
                        "\trelease_sock(&rx->sk);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 602,
                    "highlight": 649
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81991983"
        },
        "261": {
            "name": "rxrpc_sendmsg(indirect)",
            "parent_idx": 253,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n621",
                    "code": [
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = sock->ops->sendmsg(sock, msg, msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 619,
                    "highlight": 621
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n631",
                    "code": [
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 626,
                    "highlight": 631
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817f190f"
        },
        "253": {
            "name": "sock_sendmsg",
            "parent_idx": 244,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n2116",
                    "code": [
                        "static int ___sys_sendmsg(struct socket *sock, struct user_msghdr __user *msg,",
                        "\t\t\t struct msghdr *msg_sys, unsigned int flags,",
                        "\t\t\t struct used_address *used_address,",
                        "\t\t\t unsigned int allowed_msghdr_flags)",
                        "{",
                        "\tstruct compat_msghdr __user *msg_compat =",
                        "\t    (struct compat_msghdr __user *)msg;",
                        "\tstruct sockaddr_storage address;",
                        "\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;",
                        "\tunsigned char ctl[sizeof(struct cmsghdr) + 20]",
                        "\t\t\t\t__aligned(sizeof(__kernel_size_t));",
                        "\t/* 20 is size of ipv6_pktinfo */",
                        "\tunsigned char *ctl_buf = ctl;",
                        "\tint ctl_len;",
                        "\tssize_t err;",
                        "",
                        "\tmsg_sys->msg_name = &address;",
                        "",
                        "\tif (MSG_CMSG_COMPAT & flags)",
                        "\t\terr = get_compat_msghdr(msg_sys, msg_compat, NULL, &iov);",
                        "\telse",
                        "\t\terr = copy_msghdr_from_user(msg_sys, msg, NULL, &iov);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\terr = -ENOBUFS;",
                        "",
                        "\tif (msg_sys->msg_controllen > INT_MAX)",
                        "\t\tgoto out_freeiov;",
                        "\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);",
                        "\tctl_len = msg_sys->msg_controllen;",
                        "\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
                        "\t\terr =",
                        "\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,",
                        "\t\t\t\t\t\t     sizeof(ctl));",
                        "\t\tif (err)",
                        "\t\t\tgoto out_freeiov;",
                        "\t\tctl_buf = msg_sys->msg_control;",
                        "\t\tctl_len = msg_sys->msg_controllen;",
                        "\t} else if (ctl_len) {",
                        "\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=",
                        "\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));",
                        "\t\tif (ctl_len > sizeof(ctl)) {",
                        "\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);",
                        "\t\t\tif (ctl_buf == NULL)",
                        "\t\t\t\tgoto out_freeiov;",
                        "\t\t}",
                        "\t\terr = -EFAULT;",
                        "\t\t/*",
                        "\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.",
                        "\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted",
                        "\t\t * checking falls down on this.",
                        "\t\t */",
                        "\t\tif (copy_from_user(ctl_buf,",
                        "\t\t\t\t   (void __user __force *)msg_sys->msg_control,",
                        "\t\t\t\t   ctl_len))",
                        "\t\t\tgoto out_freectl;",
                        "\t\tmsg_sys->msg_control = ctl_buf;",
                        "\t}",
                        "\tmsg_sys->msg_flags = flags;",
                        "",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;",
                        "\t/*",
                        "\t * If this is sendmmsg() and current destination address is same as",
                        "\t * previously succeeded address, omit asking LSM's decision.",
                        "\t * used_address->name_len is initialized to UINT_MAX so that the first",
                        "\t * destination address never matches.",
                        "\t */",
                        "\tif (used_address && msg_sys->msg_name &&",
                        "\t    used_address->name_len == msg_sys->msg_namelen &&",
                        "\t    !memcmp(&used_address->name, msg_sys->msg_name,",
                        "\t\t    used_address->name_len)) {",
                        "\t\terr = sock_sendmsg_nosec(sock, msg_sys);",
                        "\t\tgoto out_freectl;",
                        "\t}",
                        "\terr = sock_sendmsg(sock, msg_sys);",
                        "\t/*",
                        "\t * If this is sendmmsg() and sending to current destination address was",
                        "\t * successful, remember it.",
                        "\t */",
                        "\tif (used_address && err >= 0) {",
                        "\t\tused_address->name_len = msg_sys->msg_namelen;",
                        "\t\tif (msg_sys->msg_name)",
                        "\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,",
                        "\t\t\t       used_address->name_len);",
                        "\t}",
                        "",
                        "out_freectl:",
                        "\tif (ctl_buf != ctl)",
                        "\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);",
                        "out_freeiov:",
                        "\tkfree(iov);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2040,
                    "highlight": 2116
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817f229c"
        },
        "244": {
            "name": "___sys_sendmsg",
            "parent_idx": 223,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n2154",
                    "code": [
                        "\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);",
                        "",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2154,
                    "highlight": 2154
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817f4b9f"
        },
        "223": {
            "name": "__x64_sys_sendmsg(indirect)",
            "parent_idx": 220,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n290",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\t/*",
                        "\t * NB: Native and x32 syscalls are dispatched from the same",
                        "\t * table.  The only functional difference is the x32 bit in",
                        "\t * regs->orig_ax, which changes the behavior of some syscalls.",
                        "\t */",
                        "\tnr &= __SYSCALL_MASK;",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 271,
                    "highlight": 290
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8100243e"
        },
        "220": {
            "name": "do_syscall_64",
            "parent_idx": 213,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n175",
                    "code": [
                        "ENTRY(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "GLOBAL(entry_SYSCALL_64_after_hwframe)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "213": {
            "name": "27_syscall_3",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "277": {
            "name": "+0x31",
            "parent_idx": 276,
            "source_line": [
                {
                    "file": "net/rxrpc/conn_client.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/rxrpc/conn_client.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n690",
                    "code": [
                        "/*",
                        " * find a connection for a call",
                        " * - called in process context with IRQs enabled",
                        " */",
                        "int rxrpc_connect_call(struct rxrpc_sock *rx,",
                        "\t\t       struct rxrpc_call *call,",
                        "\t\t       struct rxrpc_conn_parameters *cp,",
                        "\t\t       struct sockaddr_rxrpc *srx,",
                        "\t\t       gfp_t gfp)",
                        "{",
                        "\tstruct rxrpc_net *rxnet = cp->local->rxnet;",
                        "\tint ret;",
                        "",
                        "\t_enter(\"{%d,%lx},\", call->debug_id, call->user_call_ID);",
                        "",
                        "\trxrpc_discard_expired_client_conns(&rxnet->client_conn_reaper);",
                        "\trxrpc_cull_active_client_conns(rxnet);",
                        "",
                        "\tret = rxrpc_get_client_conn(rx, call, cp, srx, gfp);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "",
                        "\trxrpc_animate_client_conn(rxnet, call->conn);",
                        "\trxrpc_activate_channels(call->conn);",
                        "",
                        "\tret = rxrpc_wait_for_channel(call, gfp);",
                        "\tif (ret < 0) {",
                        "\t\trxrpc_disconnect_client_call(call);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tspin_lock_bh(&call->conn->params.peer->lock);",
                        "\thlist_add_head_rcu(&call->error_link,",
                        "\t\t\t   &call->conn->params.peer->error_targets);",
                        "\tspin_unlock_bh(&call->conn->params.peer->lock);",
                        "",
                        "out:",
                        "\t_leave(\" = %d\", ret);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 680,
                    "highlight": 690
                }
            ],
            "ins_idx": 2,
            "addr": "0xffffffff81983491"
        },
        "268": {
            "name": "+0x4e4",
            "parent_idx": 261,
            "source_line": [
                {
                    "file": "net/rxrpc/sendmsg.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/rxrpc/sendmsg.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n587",
                    "code": [
                        "/*",
                        " * Create a new client call for sendmsg().",
                        " * - Called with the socket lock held, which it must release.",
                        " * - If it returns a call, the call's lock will need releasing by the caller.",
                        " */",
                        "static struct rxrpc_call *",
                        "rxrpc_new_client_call_for_sendmsg(struct rxrpc_sock *rx, struct msghdr *msg,",
                        "\t\t\t\t  struct rxrpc_send_params *p)",
                        "\t__releases(&rx->sk.sk_lock.slock)",
                        "\t__acquires(&call->user_mutex)",
                        "{",
                        "\tstruct rxrpc_conn_parameters cp;",
                        "\tstruct rxrpc_call *call;",
                        "\tstruct key *key;",
                        "",
                        "\tDECLARE_SOCKADDR(struct sockaddr_rxrpc *, srx, msg->msg_name);",
                        "",
                        "\t_enter(\"\");",
                        "",
                        "\tif (!msg->msg_name) {",
                        "\t\trelease_sock(&rx->sk);",
                        "\t\treturn ERR_PTR(-EDESTADDRREQ);",
                        "\t}",
                        "",
                        "\tkey = rx->key;",
                        "\tif (key && !rx->key->payload.data[0])",
                        "\t\tkey = NULL;",
                        "",
                        "\tmemset(&cp, 0, sizeof(cp));",
                        "\tcp.local\t\t= rx->local;",
                        "\tcp.key\t\t\t= rx->key;",
                        "\tcp.security_level\t= rx->min_sec_level;",
                        "\tcp.exclusive\t\t= rx->exclusive | p->exclusive;",
                        "\tcp.upgrade\t\t= p->upgrade;",
                        "\tcp.service_id\t\t= srx->srx_service;",
                        "\tcall = rxrpc_new_client_call(rx, &cp, srx, &p->call, GFP_KERNEL,",
                        "\t\t\t\t     atomic_inc_return(&rxrpc_debug_id));",
                        "\t/* The socket is now unlocked */",
                        "",
                        "\trxrpc_put_peer(cp.peer);",
                        "\t_leave(\" = %p\\n\", call);",
                        "\treturn call;",
                        "}"
                    ],
                    "start": 558,
                    "highlight": 587
                },
                {
                    "file": "net/rxrpc/sendmsg.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/rxrpc/sendmsg.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n649",
                    "code": [
                        "/*",
                        " * send a message forming part of a client call through an RxRPC socket",
                        " * - caller holds the socket locked",
                        " * - the socket may be either a client socket or a server socket",
                        " */",
                        "int rxrpc_do_sendmsg(struct rxrpc_sock *rx, struct msghdr *msg, size_t len)",
                        "\t__releases(&rx->sk.sk_lock.slock)",
                        "\t__releases(&call->user_mutex)",
                        "{",
                        "\tenum rxrpc_call_state state;",
                        "\tstruct rxrpc_call *call;",
                        "\tunsigned long now, j;",
                        "\tint ret;",
                        "",
                        "\tstruct rxrpc_send_params p = {",
                        "\t\t.call.tx_total_len\t= -1,",
                        "\t\t.call.user_call_ID\t= 0,",
                        "\t\t.call.nr_timeouts\t= 0,",
                        "\t\t.abort_code\t\t= 0,",
                        "\t\t.command\t\t= RXRPC_CMD_SEND_DATA,",
                        "\t\t.exclusive\t\t= false,",
                        "\t\t.upgrade\t\t= false,",
                        "\t};",
                        "",
                        "\t_enter(\"\");",
                        "",
                        "\tret = rxrpc_sendmsg_cmsg(msg, &p);",
                        "\tif (ret < 0)",
                        "\t\tgoto error_release_sock;",
                        "",
                        "\tif (p.command == RXRPC_CMD_ACCEPT) {",
                        "\t\tret = -EINVAL;",
                        "\t\tif (rx->sk.sk_state != RXRPC_SERVER_LISTENING)",
                        "\t\t\tgoto error_release_sock;",
                        "\t\tcall = rxrpc_accept_call(rx, p.call.user_call_ID, NULL);",
                        "\t\t/* The socket is now unlocked. */",
                        "\t\tif (IS_ERR(call))",
                        "\t\t\treturn PTR_ERR(call);",
                        "\t\tret = 0;",
                        "\t\tgoto out_put_unlock;",
                        "\t}",
                        "",
                        "\tcall = rxrpc_find_call_by_user_ID(rx, p.call.user_call_ID);",
                        "\tif (!call) {",
                        "\t\tret = -EBADSLT;",
                        "\t\tif (p.command != RXRPC_CMD_SEND_DATA)",
                        "\t\t\tgoto error_release_sock;",
                        "\t\tcall = rxrpc_new_client_call_for_sendmsg(rx, msg, &p);",
                        "\t\t/* The socket is now unlocked... */",
                        "\t\tif (IS_ERR(call))",
                        "\t\t\treturn PTR_ERR(call);",
                        "\t\t/* ... and we have the call lock. */",
                        "\t} else {",
                        "\t\tswitch (READ_ONCE(call->state)) {",
                        "\t\tcase RXRPC_CALL_UNINITIALISED:",
                        "\t\tcase RXRPC_CALL_CLIENT_AWAIT_CONN:",
                        "\t\tcase RXRPC_CALL_SERVER_PREALLOC:",
                        "\t\tcase RXRPC_CALL_SERVER_SECURING:",
                        "\t\tcase RXRPC_CALL_SERVER_ACCEPTING:",
                        "\t\t\tret = -EBUSY;",
                        "\t\t\tgoto error_release_sock;",
                        "\t\tdefault:",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\tret = mutex_lock_interruptible(&call->user_mutex);",
                        "\t\trelease_sock(&rx->sk);",
                        "\t\tif (ret < 0) {",
                        "\t\t\tret = -ERESTARTSYS;",
                        "\t\t\tgoto error_put;",
                        "\t\t}",
                        "",
                        "\t\tif (p.call.tx_total_len != -1) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tif (call->tx_total_len != -1 ||",
                        "\t\t\t    call->tx_pending ||",
                        "\t\t\t    call->tx_top != 0)",
                        "\t\t\t\tgoto error_put;",
                        "\t\t\tcall->tx_total_len = p.call.tx_total_len;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (p.call.nr_timeouts) {",
                        "\tcase 3:",
                        "\t\tj = msecs_to_jiffies(p.call.timeouts.normal);",
                        "\t\tif (p.call.timeouts.normal > 0 && j == 0)",
                        "\t\t\tj = 1;",
                        "\t\tWRITE_ONCE(call->next_rx_timo, j);",
                        "\t\t/* Fall through */",
                        "\tcase 2:",
                        "\t\tj = msecs_to_jiffies(p.call.timeouts.idle);",
                        "\t\tif (p.call.timeouts.idle > 0 && j == 0)",
                        "\t\t\tj = 1;",
                        "\t\tWRITE_ONCE(call->next_req_timo, j);",
                        "\t\t/* Fall through */",
                        "\tcase 1:",
                        "\t\tif (p.call.timeouts.hard > 0) {",
                        "\t\t\tj = msecs_to_jiffies(p.call.timeouts.hard);",
                        "\t\t\tnow = jiffies;",
                        "\t\t\tj += now;",
                        "\t\t\tWRITE_ONCE(call->expect_term_by, j);",
                        "\t\t\trxrpc_reduce_call_timer(call, j, now,",
                        "\t\t\t\t\t\trxrpc_timer_set_for_hard);",
                        "\t\t}",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tstate = READ_ONCE(call->state);",
                        "\t_debug(\"CALL %d USR %lx ST %d on CONN %p\",",
                        "\t       call->debug_id, call->user_call_ID, state, call->conn);",
                        "",
                        "\tif (state >= RXRPC_CALL_COMPLETE) {",
                        "\t\t/* it's too late for this call */",
                        "\t\tret = -ESHUTDOWN;",
                        "\t} else if (p.command == RXRPC_CMD_SEND_ABORT) {",
                        "\t\tret = 0;",
                        "\t\tif (rxrpc_abort_call(\"CMD\", call, 0, p.abort_code, -ECONNABORTED))",
                        "\t\t\tret = rxrpc_send_abort_packet(call);",
                        "\t} else if (p.command != RXRPC_CMD_SEND_DATA) {",
                        "\t\tret = -EINVAL;",
                        "\t} else if (rxrpc_is_client_call(call) &&",
                        "\t\t   state != RXRPC_CALL_CLIENT_SEND_REQUEST) {",
                        "\t\t/* request phase complete for this client call */",
                        "\t\tret = -EPROTO;",
                        "\t} else if (rxrpc_is_service_call(call) &&",
                        "\t\t   state != RXRPC_CALL_SERVER_ACK_REQUEST &&",
                        "\t\t   state != RXRPC_CALL_SERVER_SEND_REPLY) {",
                        "\t\t/* Reply phase not begun or not complete for service call. */",
                        "\t\tret = -EPROTO;",
                        "\t} else {",
                        "\t\tret = rxrpc_send_data(rx, call, msg, len, NULL);",
                        "\t}",
                        "",
                        "out_put_unlock:",
                        "\tmutex_unlock(&call->user_mutex);",
                        "error_put:",
                        "\trxrpc_put_call(call, rxrpc_call_put);",
                        "\t_leave(\" = %d\", ret);",
                        "\treturn ret;",
                        "",
                        "error_release_sock:",
                        "\trelease_sock(&rx->sk);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 602,
                    "highlight": 649
                }
            ],
            "ins_idx": 4,
            "addr": "0xffffffff81991934"
        },
        "267": {
            "name": "+0x4c0",
            "parent_idx": 261,
            "source_line": [
                {
                    "file": "net/rxrpc/sendmsg.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/rxrpc/sendmsg.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n587",
                    "code": [
                        "/*",
                        " * Create a new client call for sendmsg().",
                        " * - Called with the socket lock held, which it must release.",
                        " * - If it returns a call, the call's lock will need releasing by the caller.",
                        " */",
                        "static struct rxrpc_call *",
                        "rxrpc_new_client_call_for_sendmsg(struct rxrpc_sock *rx, struct msghdr *msg,",
                        "\t\t\t\t  struct rxrpc_send_params *p)",
                        "\t__releases(&rx->sk.sk_lock.slock)",
                        "\t__acquires(&call->user_mutex)",
                        "{",
                        "\tstruct rxrpc_conn_parameters cp;",
                        "\tstruct rxrpc_call *call;",
                        "\tstruct key *key;",
                        "",
                        "\tDECLARE_SOCKADDR(struct sockaddr_rxrpc *, srx, msg->msg_name);",
                        "",
                        "\t_enter(\"\");",
                        "",
                        "\tif (!msg->msg_name) {",
                        "\t\trelease_sock(&rx->sk);",
                        "\t\treturn ERR_PTR(-EDESTADDRREQ);",
                        "\t}",
                        "",
                        "\tkey = rx->key;",
                        "\tif (key && !rx->key->payload.data[0])",
                        "\t\tkey = NULL;",
                        "",
                        "\tmemset(&cp, 0, sizeof(cp));",
                        "\tcp.local\t\t= rx->local;",
                        "\tcp.key\t\t\t= rx->key;",
                        "\tcp.security_level\t= rx->min_sec_level;",
                        "\tcp.exclusive\t\t= rx->exclusive | p->exclusive;",
                        "\tcp.upgrade\t\t= p->upgrade;",
                        "\tcp.service_id\t\t= srx->srx_service;",
                        "\tcall = rxrpc_new_client_call(rx, &cp, srx, &p->call, GFP_KERNEL,",
                        "\t\t\t\t     atomic_inc_return(&rxrpc_debug_id));",
                        "\t/* The socket is now unlocked */",
                        "",
                        "\trxrpc_put_peer(cp.peer);",
                        "\t_leave(\" = %p\\n\", call);",
                        "\treturn call;",
                        "}"
                    ],
                    "start": 558,
                    "highlight": 587
                },
                {
                    "file": "net/rxrpc/sendmsg.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/rxrpc/sendmsg.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n649",
                    "code": [
                        "/*",
                        " * send a message forming part of a client call through an RxRPC socket",
                        " * - caller holds the socket locked",
                        " * - the socket may be either a client socket or a server socket",
                        " */",
                        "int rxrpc_do_sendmsg(struct rxrpc_sock *rx, struct msghdr *msg, size_t len)",
                        "\t__releases(&rx->sk.sk_lock.slock)",
                        "\t__releases(&call->user_mutex)",
                        "{",
                        "\tenum rxrpc_call_state state;",
                        "\tstruct rxrpc_call *call;",
                        "\tunsigned long now, j;",
                        "\tint ret;",
                        "",
                        "\tstruct rxrpc_send_params p = {",
                        "\t\t.call.tx_total_len\t= -1,",
                        "\t\t.call.user_call_ID\t= 0,",
                        "\t\t.call.nr_timeouts\t= 0,",
                        "\t\t.abort_code\t\t= 0,",
                        "\t\t.command\t\t= RXRPC_CMD_SEND_DATA,",
                        "\t\t.exclusive\t\t= false,",
                        "\t\t.upgrade\t\t= false,",
                        "\t};",
                        "",
                        "\t_enter(\"\");",
                        "",
                        "\tret = rxrpc_sendmsg_cmsg(msg, &p);",
                        "\tif (ret < 0)",
                        "\t\tgoto error_release_sock;",
                        "",
                        "\tif (p.command == RXRPC_CMD_ACCEPT) {",
                        "\t\tret = -EINVAL;",
                        "\t\tif (rx->sk.sk_state != RXRPC_SERVER_LISTENING)",
                        "\t\t\tgoto error_release_sock;",
                        "\t\tcall = rxrpc_accept_call(rx, p.call.user_call_ID, NULL);",
                        "\t\t/* The socket is now unlocked. */",
                        "\t\tif (IS_ERR(call))",
                        "\t\t\treturn PTR_ERR(call);",
                        "\t\tret = 0;",
                        "\t\tgoto out_put_unlock;",
                        "\t}",
                        "",
                        "\tcall = rxrpc_find_call_by_user_ID(rx, p.call.user_call_ID);",
                        "\tif (!call) {",
                        "\t\tret = -EBADSLT;",
                        "\t\tif (p.command != RXRPC_CMD_SEND_DATA)",
                        "\t\t\tgoto error_release_sock;",
                        "\t\tcall = rxrpc_new_client_call_for_sendmsg(rx, msg, &p);",
                        "\t\t/* The socket is now unlocked... */",
                        "\t\tif (IS_ERR(call))",
                        "\t\t\treturn PTR_ERR(call);",
                        "\t\t/* ... and we have the call lock. */",
                        "\t} else {",
                        "\t\tswitch (READ_ONCE(call->state)) {",
                        "\t\tcase RXRPC_CALL_UNINITIALISED:",
                        "\t\tcase RXRPC_CALL_CLIENT_AWAIT_CONN:",
                        "\t\tcase RXRPC_CALL_SERVER_PREALLOC:",
                        "\t\tcase RXRPC_CALL_SERVER_SECURING:",
                        "\t\tcase RXRPC_CALL_SERVER_ACCEPTING:",
                        "\t\t\tret = -EBUSY;",
                        "\t\t\tgoto error_release_sock;",
                        "\t\tdefault:",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\tret = mutex_lock_interruptible(&call->user_mutex);",
                        "\t\trelease_sock(&rx->sk);",
                        "\t\tif (ret < 0) {",
                        "\t\t\tret = -ERESTARTSYS;",
                        "\t\t\tgoto error_put;",
                        "\t\t}",
                        "",
                        "\t\tif (p.call.tx_total_len != -1) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tif (call->tx_total_len != -1 ||",
                        "\t\t\t    call->tx_pending ||",
                        "\t\t\t    call->tx_top != 0)",
                        "\t\t\t\tgoto error_put;",
                        "\t\t\tcall->tx_total_len = p.call.tx_total_len;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (p.call.nr_timeouts) {",
                        "\tcase 3:",
                        "\t\tj = msecs_to_jiffies(p.call.timeouts.normal);",
                        "\t\tif (p.call.timeouts.normal > 0 && j == 0)",
                        "\t\t\tj = 1;",
                        "\t\tWRITE_ONCE(call->next_rx_timo, j);",
                        "\t\t/* Fall through */",
                        "\tcase 2:",
                        "\t\tj = msecs_to_jiffies(p.call.timeouts.idle);",
                        "\t\tif (p.call.timeouts.idle > 0 && j == 0)",
                        "\t\t\tj = 1;",
                        "\t\tWRITE_ONCE(call->next_req_timo, j);",
                        "\t\t/* Fall through */",
                        "\tcase 1:",
                        "\t\tif (p.call.timeouts.hard > 0) {",
                        "\t\t\tj = msecs_to_jiffies(p.call.timeouts.hard);",
                        "\t\t\tnow = jiffies;",
                        "\t\t\tj += now;",
                        "\t\t\tWRITE_ONCE(call->expect_term_by, j);",
                        "\t\t\trxrpc_reduce_call_timer(call, j, now,",
                        "\t\t\t\t\t\trxrpc_timer_set_for_hard);",
                        "\t\t}",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tstate = READ_ONCE(call->state);",
                        "\t_debug(\"CALL %d USR %lx ST %d on CONN %p\",",
                        "\t       call->debug_id, call->user_call_ID, state, call->conn);",
                        "",
                        "\tif (state >= RXRPC_CALL_COMPLETE) {",
                        "\t\t/* it's too late for this call */",
                        "\t\tret = -ESHUTDOWN;",
                        "\t} else if (p.command == RXRPC_CMD_SEND_ABORT) {",
                        "\t\tret = 0;",
                        "\t\tif (rxrpc_abort_call(\"CMD\", call, 0, p.abort_code, -ECONNABORTED))",
                        "\t\t\tret = rxrpc_send_abort_packet(call);",
                        "\t} else if (p.command != RXRPC_CMD_SEND_DATA) {",
                        "\t\tret = -EINVAL;",
                        "\t} else if (rxrpc_is_client_call(call) &&",
                        "\t\t   state != RXRPC_CALL_CLIENT_SEND_REQUEST) {",
                        "\t\t/* request phase complete for this client call */",
                        "\t\tret = -EPROTO;",
                        "\t} else if (rxrpc_is_service_call(call) &&",
                        "\t\t   state != RXRPC_CALL_SERVER_ACK_REQUEST &&",
                        "\t\t   state != RXRPC_CALL_SERVER_SEND_REPLY) {",
                        "\t\t/* Reply phase not begun or not complete for service call. */",
                        "\t\tret = -EPROTO;",
                        "\t} else {",
                        "\t\tret = rxrpc_send_data(rx, call, msg, len, NULL);",
                        "\t}",
                        "",
                        "out_put_unlock:",
                        "\tmutex_unlock(&call->user_mutex);",
                        "error_put:",
                        "\trxrpc_put_call(call, rxrpc_call_put);",
                        "\t_leave(\" = %d\", ret);",
                        "\treturn ret;",
                        "",
                        "error_release_sock:",
                        "\trelease_sock(&rx->sk);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 602,
                    "highlight": 649
                }
            ],
            "ins_idx": 8,
            "addr": "0xffffffff81991910"
        },
        "58": {
            "name": "+0x4a",
            "parent_idx": 45,
            "source_line": [
                {
                    "file": "arch/x86/lib/memset_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/lib/memset_64.S?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n98",
                    "code": [
                        "ENTRY(memset_orig)",
                        "\tmovq %rdi,%r10",
                        "",
                        "\t/* expand byte value  */",
                        "\tmovzbl %sil,%ecx",
                        "\tmovabs $0x0101010101010101,%rax",
                        "\timulq  %rcx,%rax",
                        "",
                        "\t/* align dst */",
                        "\tmovl  %edi,%r9d",
                        "\tandl  $7,%r9d",
                        "\tjnz  .Lbad_alignment",
                        ".Lafter_bad_alignment:",
                        "",
                        "\tmovq  %rdx,%rcx",
                        "\tshrq  $6,%rcx",
                        "\tjz\t .Lhandle_tail",
                        "",
                        "\t.p2align 4",
                        ".Lloop_64:",
                        "\tdecq  %rcx",
                        "\tmovq  %rax,(%rdi)",
                        "\tmovq  %rax,8(%rdi)",
                        "\tmovq  %rax,16(%rdi)",
                        "\tmovq  %rax,24(%rdi)",
                        "\tmovq  %rax,32(%rdi)",
                        "\tmovq  %rax,40(%rdi)",
                        "\tmovq  %rax,48(%rdi)",
                        "\tmovq  %rax,56(%rdi)",
                        "\tleaq  64(%rdi),%rdi",
                        "\tjnz    .Lloop_64",
                        "",
                        "\t/* Handle tail in loops. The loops should be faster than hard",
                        "\t   to predict jump tables. */",
                        "\t.p2align 4",
                        ".Lhandle_tail:",
                        "\tmovl\t%edx,%ecx",
                        "\tandl    $63&(~7),%ecx",
                        "\tjz \t\t.Lhandle_7",
                        "\tshrl\t$3,%ecx",
                        "\t.p2align 4",
                        ".Lloop_8:",
                        "\tdecl   %ecx",
                        "\tmovq  %rax,(%rdi)",
                        "\tleaq  8(%rdi),%rdi",
                        "\tjnz    .Lloop_8",
                        "",
                        ".Lhandle_7:",
                        "\tandl\t$7,%edx",
                        "\tjz      .Lende",
                        "\t.p2align 4",
                        ".Lloop_1:",
                        "\tdecl    %edx",
                        "\tmovb \t%al,(%rdi)",
                        "\tleaq\t1(%rdi),%rdi",
                        "\tjnz     .Lloop_1",
                        "",
                        ".Lende:",
                        "\tmovq\t%r10,%rax",
                        "\tret",
                        "",
                        ".Lbad_alignment:",
                        "\tcmpq $7,%rdx",
                        "\tjbe\t.Lhandle_7",
                        "\tmovq %rax,(%rdi)\t/* unaligned store */",
                        "\tmovq $8,%r8",
                        "\tsubq %r9,%r8",
                        "\taddq %r8,%rdi",
                        "\tsubq %r8,%rdx",
                        "\tjmp .Lafter_bad_alignment",
                        ".Lfinal:",
                        "ENDPROC(memset_orig)"
                    ],
                    "start": 71,
                    "highlight": 98
                }
            ],
            "ins_idx": 12,
            "addr": "0xffffffff81a5e1ba"
        },
        "45": {
            "name": "memset",
            "parent_idx": 39,
            "source_line": [
                {
                    "file": "./include/net/sock.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/sock.h?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n1046",
                    "code": [
                        "/*",
                        " * caches using SLAB_TYPESAFE_BY_RCU should let .next pointer from nulls nodes",
                        " * un-modified. Special care is taken when initializing object to zero.",
                        " */",
                        "static inline void sk_prot_clear_nulls(struct sock *sk, int size)",
                        "{",
                        "\tif (offsetof(struct sock, sk_node.next) != 0)",
                        "\t\tmemset(sk, 0, offsetof(struct sock, sk_node.next));",
                        "\tmemset(&sk->sk_node.pprev, 0,",
                        "\t       size - offsetof(struct sock, sk_node.pprev));",
                        "}"
                    ],
                    "start": 1038,
                    "highlight": 1046
                },
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n1475",
                    "code": [
                        "static struct sock *sk_prot_alloc(struct proto *prot, gfp_t priority,",
                        "\t\tint family)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tstruct kmem_cache *slab;",
                        "",
                        "\tslab = prot->slab;",
                        "\tif (slab != NULL) {",
                        "\t\tsk = kmem_cache_alloc(slab, priority & ~__GFP_ZERO);",
                        "\t\tif (!sk)",
                        "\t\t\treturn sk;",
                        "\t\tif (priority & __GFP_ZERO)",
                        "\t\t\tsk_prot_clear_nulls(sk, prot->obj_size);",
                        "\t} else",
                        "\t\tsk = kmalloc(prot->obj_size, priority);",
                        "",
                        "\tif (sk != NULL) {",
                        "\t\tif (security_sk_alloc(sk, family, priority))",
                        "\t\t\tgoto out_free;",
                        "",
                        "\t\tif (!try_module_get(prot->owner))",
                        "\t\t\tgoto out_free_sec;",
                        "\t\tsk_tx_queue_clear(sk);",
                        "\t}",
                        "",
                        "\treturn sk;",
                        "",
                        "out_free_sec:",
                        "\tsecurity_sk_free(sk);",
                        "out_free:",
                        "\tif (slab != NULL)",
                        "\t\tkmem_cache_free(slab, sk);",
                        "\telse",
                        "\t\tkfree(sk);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 1463,
                    "highlight": 1475
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817f5ca7"
        },
        "39": {
            "name": "sk_prot_alloc",
            "parent_idx": 36,
            "source_line": [
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n1531",
                    "code": [
                        "/**",
                        " *\tsk_alloc - All socket objects are allocated here",
                        " *\t@net: the applicable net namespace",
                        " *\t@family: protocol family",
                        " *\t@priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc)",
                        " *\t@prot: struct proto associated with this new sock instance",
                        " *\t@kern: is this to be a kernel socket?",
                        " */",
                        "struct sock *sk_alloc(struct net *net, int family, gfp_t priority,",
                        "\t\t      struct proto *prot, int kern)",
                        "{",
                        "\tstruct sock *sk;",
                        "",
                        "\tsk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);",
                        "\tif (sk) {",
                        "\t\tsk->sk_family = family;",
                        "\t\t/*",
                        "\t\t * See comment in struct sock definition to understand",
                        "\t\t * why we need sk_prot_creator -acme",
                        "\t\t */",
                        "\t\tsk->sk_prot = sk->sk_prot_creator = prot;",
                        "\t\tsk->sk_kern_sock = kern;",
                        "\t\tsock_lock_init(sk);",
                        "\t\tsk->sk_net_refcnt = kern ? 0 : 1;",
                        "\t\tif (likely(sk->sk_net_refcnt)) {",
                        "\t\t\tget_net(net);",
                        "\t\t\tsock_inuse_add(net, 1);",
                        "\t\t}",
                        "",
                        "\t\tsock_net_set(sk, net);",
                        "\t\trefcount_set(&sk->sk_wmem_alloc, 1);",
                        "",
                        "\t\tmem_cgroup_sk_alloc(sk);",
                        "\t\tcgroup_sk_alloc(&sk->sk_cgrp_data);",
                        "\t\tsock_update_classid(&sk->sk_cgrp_data);",
                        "\t\tsock_update_netprioidx(&sk->sk_cgrp_data);",
                        "\t}",
                        "",
                        "\treturn sk;",
                        "}"
                    ],
                    "start": 1518,
                    "highlight": 1531
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817f7d92"
        },
        "36": {
            "name": "sk_alloc",
            "parent_idx": 34,
            "source_line": [
                {
                    "file": "net/rxrpc/af_rxrpc.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/rxrpc/af_rxrpc.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n748",
                    "code": [
                        "/*",
                        " * create an RxRPC socket",
                        " */",
                        "static int rxrpc_create(struct net *net, struct socket *sock, int protocol,",
                        "\t\t\tint kern)",
                        "{",
                        "\tstruct rxrpc_net *rxnet;",
                        "\tstruct rxrpc_sock *rx;",
                        "\tstruct sock *sk;",
                        "",
                        "\t_enter(\"%p,%d\", sock, protocol);",
                        "",
                        "\t/* we support transport protocol UDP/UDP6 only */",
                        "\tif (protocol != PF_INET &&",
                        "\t    IS_ENABLED(CONFIG_AF_RXRPC_IPV6) && protocol != PF_INET6)",
                        "\t\treturn -EPROTONOSUPPORT;",
                        "",
                        "\tif (sock->type != SOCK_DGRAM)",
                        "\t\treturn -ESOCKTNOSUPPORT;",
                        "",
                        "\tsock->ops = &rxrpc_rpc_ops;",
                        "\tsock->state = SS_UNCONNECTED;",
                        "",
                        "\tsk = sk_alloc(net, PF_RXRPC, GFP_KERNEL, &rxrpc_proto, kern);",
                        "\tif (!sk)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tsock_init_data(sock, sk);",
                        "\tsock_set_flag(sk, SOCK_RCU_FREE);",
                        "\tsk->sk_state\t\t= RXRPC_UNBOUND;",
                        "\tsk->sk_write_space\t= rxrpc_write_space;",
                        "\tsk->sk_max_ack_backlog\t= 0;",
                        "\tsk->sk_destruct\t\t= rxrpc_sock_destructor;",
                        "",
                        "\trx = rxrpc_sk(sk);",
                        "\trx->family = protocol;",
                        "\trx->calls = RB_ROOT;",
                        "",
                        "\tspin_lock_init(&rx->incoming_lock);",
                        "\tINIT_LIST_HEAD(&rx->sock_calls);",
                        "\tINIT_LIST_HEAD(&rx->to_be_accepted);",
                        "\tINIT_LIST_HEAD(&rx->recvmsg_q);",
                        "\trwlock_init(&rx->recvmsg_lock);",
                        "\trwlock_init(&rx->call_lock);",
                        "\tmemset(&rx->srx, 0, sizeof(rx->srx));",
                        "",
                        "\trxnet = rxrpc_net(sock_net(&rx->sk));",
                        "\ttimer_reduce(&rxnet->peer_keepalive_timer, jiffies + 1);",
                        "",
                        "\t_leave(\" = 0 [%p]\", rx);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 725,
                    "highlight": 748
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8197bee5"
        },
        "34": {
            "name": "rxrpc_create(indirect)",
            "parent_idx": 9,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n1277",
                    "code": [
                        "int __sock_create(struct net *net, int family, int type, int protocol,",
                        "\t\t\t struct socket **res, int kern)",
                        "{",
                        "\tint err;",
                        "\tstruct socket *sock;",
                        "\tconst struct net_proto_family *pf;",
                        "",
                        "\t/*",
                        "\t *      Check protocol is in range",
                        "\t */",
                        "\tif (family < 0 || family >= NPROTO)",
                        "\t\treturn -EAFNOSUPPORT;",
                        "\tif (type < 0 || type >= SOCK_MAX)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\t/* Compatibility.",
                        "",
                        "\t   This uglymoron is moved from INET layer to here to avoid",
                        "\t   deadlock in module load.",
                        "\t */",
                        "\tif (family == PF_INET && type == SOCK_PACKET) {",
                        "\t\tpr_info_once(\"%s uses obsolete (PF_INET,SOCK_PACKET)\\n\",",
                        "\t\t\t     current->comm);",
                        "\t\tfamily = PF_PACKET;",
                        "\t}",
                        "",
                        "\terr = security_socket_create(family, type, protocol, kern);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\t/*",
                        "\t *\tAllocate the socket and allow the family to set things up. if",
                        "\t *\tthe protocol is 0, the family is instructed to select an appropriate",
                        "\t *\tdefault.",
                        "\t */",
                        "\tsock = sock_alloc();",
                        "\tif (!sock) {",
                        "\t\tnet_warn_ratelimited(\"socket: no more sockets\\n\");",
                        "\t\treturn -ENFILE;\t/* Not exactly a match, but its the",
                        "\t\t\t\t   closest posix thing */",
                        "\t}",
                        "",
                        "\tsock->type = type;",
                        "",
                        "#ifdef CONFIG_MODULES",
                        "\t/* Attempt to load a protocol module if the find failed.",
                        "\t *",
                        "\t * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user",
                        "\t * requested real, full-featured networking support upon configuration.",
                        "\t * Otherwise module support will break!",
                        "\t */",
                        "\tif (rcu_access_pointer(net_families[family]) == NULL)",
                        "\t\trequest_module(\"net-pf-%d\", family);",
                        "#endif",
                        "",
                        "\trcu_read_lock();",
                        "\tpf = rcu_dereference(net_families[family]);",
                        "\terr = -EAFNOSUPPORT;",
                        "\tif (!pf)",
                        "\t\tgoto out_release;",
                        "",
                        "\t/*",
                        "\t * We will call the ->create function, that possibly is in a loadable",
                        "\t * module, so we have to bump that loadable module refcnt first.",
                        "\t */",
                        "\tif (!try_module_get(pf->owner))",
                        "\t\tgoto out_release;",
                        "",
                        "\t/* Now protected by module ref count */",
                        "\trcu_read_unlock();",
                        "",
                        "\terr = pf->create(net, sock, protocol, kern);",
                        "\tif (err < 0)",
                        "\t\tgoto out_module_put;",
                        "",
                        "\t/*",
                        "\t * Now to bump the refcnt of the [loadable] module that owns this",
                        "\t * socket at sock_release time we decrement its refcnt.",
                        "\t */",
                        "\tif (!try_module_get(sock->ops->owner))",
                        "\t\tgoto out_module_busy;",
                        "",
                        "\t/*",
                        "\t * Now that we're done with the ->create function, the [loadable]",
                        "\t * module can have its refcnt decremented",
                        "\t */",
                        "\tmodule_put(pf->owner);",
                        "\terr = security_socket_post_create(sock, family, type, protocol, kern);",
                        "\tif (err)",
                        "\t\tgoto out_sock_release;",
                        "\t*res = sock;",
                        "",
                        "\treturn 0;",
                        "",
                        "out_module_busy:",
                        "\terr = -EAFNOSUPPORT;",
                        "out_module_put:",
                        "\tsock->ops = NULL;",
                        "\tmodule_put(pf->owner);",
                        "out_sock_release:",
                        "\tsock_release(sock);",
                        "\treturn err;",
                        "",
                        "out_release:",
                        "\trcu_read_unlock();",
                        "\tgoto out_sock_release;",
                        "}"
                    ],
                    "start": 1206,
                    "highlight": 1277
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817f109d"
        },
        "9": {
            "name": "__sock_create",
            "parent_idx": 6,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n1317",
                    "code": [
                        "int sock_create(int family, int type, int protocol, struct socket **res)",
                        "{",
                        "\treturn __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);",
                        "}"
                    ],
                    "start": 1315,
                    "highlight": 1317
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n1347",
                    "code": [
                        "int __sys_socket(int family, int type, int protocol)",
                        "{",
                        "\tint retval;",
                        "\tstruct socket *sock;",
                        "\tint flags;",
                        "",
                        "\t/* Check the SOCK_* constants for consistency.  */",
                        "\tBUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);",
                        "\tBUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);",
                        "\tBUILD_BUG_ON(SOCK_CLOEXEC & SOCK_TYPE_MASK);",
                        "\tBUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);",
                        "",
                        "\tflags = type & ~SOCK_TYPE_MASK;",
                        "\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))",
                        "\t\treturn -EINVAL;",
                        "\ttype &= SOCK_TYPE_MASK;",
                        "",
                        "\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))",
                        "\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;",
                        "",
                        "\tretval = sock_create(family, type, protocol, &sock);",
                        "\tif (retval < 0)",
                        "\t\treturn retval;",
                        "",
                        "\treturn sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));",
                        "}"
                    ],
                    "start": 1327,
                    "highlight": 1347
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817f3bbf"
        },
        "6": {
            "name": "__sys_socket",
            "parent_idx": 5,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n1356",
                    "code": [
                        "SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)",
                        "{",
                        "\treturn __sys_socket(family, type, protocol);",
                        "}"
                    ],
                    "start": 1354,
                    "highlight": 1356
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n1354",
                    "code": [
                        "int __sys_socket(int family, int type, int protocol)",
                        "{",
                        "\tint retval;",
                        "\tstruct socket *sock;",
                        "\tint flags;",
                        "",
                        "\t/* Check the SOCK_* constants for consistency.  */",
                        "\tBUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);",
                        "\tBUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);",
                        "\tBUILD_BUG_ON(SOCK_CLOEXEC & SOCK_TYPE_MASK);",
                        "\tBUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);",
                        "",
                        "\tflags = type & ~SOCK_TYPE_MASK;",
                        "\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))",
                        "\t\treturn -EINVAL;",
                        "\ttype &= SOCK_TYPE_MASK;",
                        "",
                        "\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))",
                        "\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;",
                        "",
                        "\tretval = sock_create(family, type, protocol, &sock);",
                        "\tif (retval < 0)",
                        "\t\treturn retval;",
                        "",
                        "\treturn sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)",
                        "{",
                        "\treturn __sys_socket(family, type, protocol);",
                        "}"
                    ],
                    "start": 1327,
                    "highlight": 1354
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817f3c5c"
        },
        "5": {
            "name": "__x64_sys_socket(indirect)",
            "parent_idx": 4,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n290",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\t/*",
                        "\t * NB: Native and x32 syscalls are dispatched from the same",
                        "\t * table.  The only functional difference is the x32 bit in",
                        "\t * regs->orig_ax, which changes the behavior of some syscalls.",
                        "\t */",
                        "\tnr &= __SYSCALL_MASK;",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 271,
                    "highlight": 290
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8100243e"
        },
        "4": {
            "name": "do_syscall_64",
            "parent_idx": 2,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n175",
                    "code": [
                        "ENTRY(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "GLOBAL(entry_SYSCALL_64_after_hwframe)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "2": {
            "name": "11_syscall_1",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "48": {
            "name": "+0x11",
            "parent_idx": 45,
            "source_line": [
                {
                    "file": "arch/x86/lib/memset_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/lib/memset_64.S?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n77",
                    "code": [
                        "ENTRY(memset_orig)",
                        "\tmovq %rdi,%r10",
                        "",
                        "\t/* expand byte value  */",
                        "\tmovzbl %sil,%ecx",
                        "\tmovabs $0x0101010101010101,%rax",
                        "\timulq  %rcx,%rax",
                        "",
                        "\t/* align dst */",
                        "\tmovl  %edi,%r9d",
                        "\tandl  $7,%r9d",
                        "\tjnz  .Lbad_alignment",
                        ".Lafter_bad_alignment:",
                        "",
                        "\tmovq  %rdx,%rcx",
                        "\tshrq  $6,%rcx",
                        "\tjz\t .Lhandle_tail",
                        "",
                        "\t.p2align 4",
                        ".Lloop_64:",
                        "\tdecq  %rcx",
                        "\tmovq  %rax,(%rdi)",
                        "\tmovq  %rax,8(%rdi)",
                        "\tmovq  %rax,16(%rdi)",
                        "\tmovq  %rax,24(%rdi)",
                        "\tmovq  %rax,32(%rdi)",
                        "\tmovq  %rax,40(%rdi)",
                        "\tmovq  %rax,48(%rdi)",
                        "\tmovq  %rax,56(%rdi)",
                        "\tleaq  64(%rdi),%rdi",
                        "\tjnz    .Lloop_64",
                        "",
                        "\t/* Handle tail in loops. The loops should be faster than hard",
                        "\t   to predict jump tables. */",
                        "\t.p2align 4",
                        ".Lhandle_tail:",
                        "\tmovl\t%edx,%ecx",
                        "\tandl    $63&(~7),%ecx",
                        "\tjz \t\t.Lhandle_7",
                        "\tshrl\t$3,%ecx",
                        "\t.p2align 4",
                        ".Lloop_8:",
                        "\tdecl   %ecx",
                        "\tmovq  %rax,(%rdi)",
                        "\tleaq  8(%rdi),%rdi",
                        "\tjnz    .Lloop_8",
                        "",
                        ".Lhandle_7:",
                        "\tandl\t$7,%edx",
                        "\tjz      .Lende",
                        "\t.p2align 4",
                        ".Lloop_1:",
                        "\tdecl    %edx",
                        "\tmovb \t%al,(%rdi)",
                        "\tleaq\t1(%rdi),%rdi",
                        "\tjnz     .Lloop_1",
                        "",
                        ".Lende:",
                        "\tmovq\t%r10,%rax",
                        "\tret",
                        "",
                        ".Lbad_alignment:",
                        "\tcmpq $7,%rdx",
                        "\tjbe\t.Lhandle_7",
                        "\tmovq %rax,(%rdi)\t/* unaligned store */",
                        "\tmovq $8,%r8",
                        "\tsubq %r9,%r8",
                        "\taddq %r8,%rdi",
                        "\tsubq %r8,%rdx",
                        "\tjmp .Lafter_bad_alignment",
                        ".Lfinal:",
                        "ENDPROC(memset_orig)"
                    ],
                    "start": 71,
                    "highlight": 77
                }
            ],
            "ins_idx": 15,
            "addr": "0xffffffff81a5e181"
        },
        "46": {
            "name": "+0x3",
            "parent_idx": 45,
            "source_line": [
                {
                    "file": "arch/x86/lib/memset_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/lib/memset_64.S?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n75",
                    "code": [
                        "ENTRY(memset_orig)",
                        "\tmovq %rdi,%r10",
                        "",
                        "\t/* expand byte value  */",
                        "\tmovzbl %sil,%ecx",
                        "\tmovabs $0x0101010101010101,%rax",
                        "\timulq  %rcx,%rax",
                        "",
                        "\t/* align dst */",
                        "\tmovl  %edi,%r9d",
                        "\tandl  $7,%r9d",
                        "\tjnz  .Lbad_alignment",
                        ".Lafter_bad_alignment:",
                        "",
                        "\tmovq  %rdx,%rcx",
                        "\tshrq  $6,%rcx",
                        "\tjz\t .Lhandle_tail",
                        "",
                        "\t.p2align 4",
                        ".Lloop_64:",
                        "\tdecq  %rcx",
                        "\tmovq  %rax,(%rdi)",
                        "\tmovq  %rax,8(%rdi)",
                        "\tmovq  %rax,16(%rdi)",
                        "\tmovq  %rax,24(%rdi)",
                        "\tmovq  %rax,32(%rdi)",
                        "\tmovq  %rax,40(%rdi)",
                        "\tmovq  %rax,48(%rdi)",
                        "\tmovq  %rax,56(%rdi)",
                        "\tleaq  64(%rdi),%rdi",
                        "\tjnz    .Lloop_64",
                        "",
                        "\t/* Handle tail in loops. The loops should be faster than hard",
                        "\t   to predict jump tables. */",
                        "\t.p2align 4",
                        ".Lhandle_tail:",
                        "\tmovl\t%edx,%ecx",
                        "\tandl    $63&(~7),%ecx",
                        "\tjz \t\t.Lhandle_7",
                        "\tshrl\t$3,%ecx",
                        "\t.p2align 4",
                        ".Lloop_8:",
                        "\tdecl   %ecx",
                        "\tmovq  %rax,(%rdi)",
                        "\tleaq  8(%rdi),%rdi",
                        "\tjnz    .Lloop_8",
                        "",
                        ".Lhandle_7:",
                        "\tandl\t$7,%edx",
                        "\tjz      .Lende",
                        "\t.p2align 4",
                        ".Lloop_1:",
                        "\tdecl    %edx",
                        "\tmovb \t%al,(%rdi)",
                        "\tleaq\t1(%rdi),%rdi",
                        "\tjnz     .Lloop_1",
                        "",
                        ".Lende:",
                        "\tmovq\t%r10,%rax",
                        "\tret",
                        "",
                        ".Lbad_alignment:",
                        "\tcmpq $7,%rdx",
                        "\tjbe\t.Lhandle_7",
                        "\tmovq %rax,(%rdi)\t/* unaligned store */",
                        "\tmovq $8,%r8",
                        "\tsubq %r9,%r8",
                        "\taddq %r8,%rdi",
                        "\tsubq %r8,%rdx",
                        "\tjmp .Lafter_bad_alignment",
                        ".Lfinal:",
                        "ENDPROC(memset_orig)"
                    ],
                    "start": 71,
                    "highlight": 75
                }
            ],
            "ins_idx": 18,
            "addr": "0xffffffff81a5e173"
        },
        "43": {
            "name": "+0xf2",
            "parent_idx": 39,
            "source_line": [
                {
                    "file": "./include/net/sock.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/sock.h?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n1046",
                    "code": [
                        "/*",
                        " * caches using SLAB_TYPESAFE_BY_RCU should let .next pointer from nulls nodes",
                        " * un-modified. Special care is taken when initializing object to zero.",
                        " */",
                        "static inline void sk_prot_clear_nulls(struct sock *sk, int size)",
                        "{",
                        "\tif (offsetof(struct sock, sk_node.next) != 0)",
                        "\t\tmemset(sk, 0, offsetof(struct sock, sk_node.next));",
                        "\tmemset(&sk->sk_node.pprev, 0,",
                        "\t       size - offsetof(struct sock, sk_node.pprev));",
                        "}"
                    ],
                    "start": 1038,
                    "highlight": 1046
                },
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=787a3b4322763284a594a5dd3680508c0bfb20b0#n1475",
                    "code": [
                        "static struct sock *sk_prot_alloc(struct proto *prot, gfp_t priority,",
                        "\t\tint family)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tstruct kmem_cache *slab;",
                        "",
                        "\tslab = prot->slab;",
                        "\tif (slab != NULL) {",
                        "\t\tsk = kmem_cache_alloc(slab, priority & ~__GFP_ZERO);",
                        "\t\tif (!sk)",
                        "\t\t\treturn sk;",
                        "\t\tif (priority & __GFP_ZERO)",
                        "\t\t\tsk_prot_clear_nulls(sk, prot->obj_size);",
                        "\t} else",
                        "\t\tsk = kmalloc(prot->obj_size, priority);",
                        "",
                        "\tif (sk != NULL) {",
                        "\t\tif (security_sk_alloc(sk, family, priority))",
                        "\t\t\tgoto out_free;",
                        "",
                        "\t\tif (!try_module_get(prot->owner))",
                        "\t\t\tgoto out_free_sec;",
                        "\t\tsk_tx_queue_clear(sk);",
                        "\t}",
                        "",
                        "\treturn sk;",
                        "",
                        "out_free_sec:",
                        "\tsecurity_sk_free(sk);",
                        "out_free:",
                        "\tif (slab != NULL)",
                        "\t\tkmem_cache_free(slab, sk);",
                        "\telse",
                        "\t\tkfree(sk);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 1463,
                    "highlight": 1475
                }
            ],
            "ins_idx": 23,
            "addr": "0xffffffff817f5c92"
        }
    },
    "ins": {
        "1": {
            "name": "mov r12, qword ptr [rax + 0x18]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x18",
            "call_idx": 278,
            "inputs": [
                503,
                504
            ],
            "outputs": [
                505
            ]
        },
        "2": {
            "name": "mov rax, qword ptr [rdx]",
            "desc": "",
            "call_idx": 277,
            "inputs": [
                500,
                501
            ],
            "outputs": [
                502
            ]
        },
        "4": {
            "name": "mov qword ptr [rsp + 0x10], rcx",
            "desc": "",
            "call_idx": 268,
            "inputs": [
                487,
                488
            ],
            "outputs": [
                489
            ]
        },
        "8": {
            "name": "mov rcx, qword ptr [r14 + 0x2e0]",
            "desc": "",
            "call_idx": 267,
            "inputs": [
                484,
                485
            ],
            "outputs": [
                486
            ]
        },
        "12": {
            "name": "mov qword ptr [rdi + 0x30], rax",
            "desc": "",
            "call_idx": 58,
            "inputs": [
                78,
                79
            ],
            "outputs": [
                80
            ]
        },
        "15": {
            "name": "imul rax, rcx",
            "desc": "",
            "call_idx": 48,
            "inputs": [
                57,
                58
            ],
            "outputs": [
                59
            ]
        },
        "18": {
            "name": "movzx ecx, sil",
            "desc": "",
            "call_idx": 46,
            "inputs": [
                54
            ],
            "outputs": [
                55
            ]
        },
        "23": {
            "name": "xor esi, esi",
            "desc": "Source of base address CONST 0x0",
            "call_idx": 43,
            "inputs": [
                49,
                50
            ],
            "outputs": [
                51
            ]
        }
    },
    "data": {
        "503": {
            "name": "RAX",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "504": {
            "name": "[0x18]",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "505": {
            "name": "R12",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "500": {
            "name": "RDX",
            "ins_idx": 2,
            "value": "0xffffc90000d3fc98",
            "sources": []
        },
        "501": {
            "name": "[0xffffc90000d3fc98]",
            "ins_idx": 2,
            "value": "0x0",
            "sources": []
        },
        "502": {
            "name": "RAX",
            "ins_idx": 2,
            "value": "0x0",
            "sources": [
                503
            ]
        },
        "487": {
            "name": "RSP",
            "ins_idx": 4,
            "value": "0xffffc90000d3fc88",
            "sources": []
        },
        "488": {
            "name": "RCX",
            "ins_idx": 4,
            "value": "0x0",
            "sources": []
        },
        "489": {
            "name": "[0xffffc90000d3fc98]",
            "ins_idx": 4,
            "value": "0x0",
            "sources": [
                501
            ]
        },
        "484": {
            "name": "R14",
            "ins_idx": 8,
            "value": "0xffff888235a0a000",
            "sources": []
        },
        "485": {
            "name": "[0xffff888235a0a2e0]",
            "ins_idx": 8,
            "value": "0x0",
            "sources": []
        },
        "486": {
            "name": "RCX",
            "ins_idx": 8,
            "value": "0x0",
            "sources": [
                488
            ]
        },
        "78": {
            "name": "RDI",
            "ins_idx": 12,
            "value": "0xffff888235a0a2b0",
            "sources": []
        },
        "79": {
            "name": "RAX",
            "ins_idx": 12,
            "value": "0x0",
            "sources": []
        },
        "80": {
            "name": "[0xffff888235a0a2e0]",
            "ins_idx": 12,
            "value": "0x0",
            "sources": [
                485
            ]
        },
        "57": {
            "name": "RCX",
            "ins_idx": 15,
            "value": "0x0",
            "sources": []
        },
        "58": {
            "name": "RAX",
            "ins_idx": 15,
            "value": "0x101010101010101",
            "sources": []
        },
        "59": {
            "name": "RAX",
            "ins_idx": 15,
            "value": "0x0",
            "sources": [
                79
            ]
        },
        "54": {
            "name": "RSI",
            "ins_idx": 18,
            "value": "0x0",
            "sources": []
        },
        "55": {
            "name": "RCX",
            "ins_idx": 18,
            "value": "0x0",
            "sources": [
                57
            ]
        },
        "49": {
            "name": "RSI",
            "ins_idx": 23,
            "value": "0x0",
            "sources": []
        },
        "50": {
            "name": "RSI",
            "ins_idx": 23,
            "value": "0x0",
            "sources": []
        },
        "51": {
            "name": "RSI",
            "ins_idx": 23,
            "value": "0x0",
            "sources": [
                54
            ]
        }
    },
    "chain": {
        "1": [
            2
        ],
        "2": [
            4
        ],
        "4": [
            8
        ],
        "8": [
            12
        ],
        "12": [
            15
        ],
        "15": [
            18
        ],
        "18": [
            23
        ]
    }
}