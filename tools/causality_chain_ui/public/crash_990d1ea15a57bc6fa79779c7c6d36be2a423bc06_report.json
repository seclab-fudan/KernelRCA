{
    "report": "https://syzkaller.appspot.com/bug?id=990d1ea15a57bc6fa79779c7c6d36be2a423bc06",
    "title": "general protection fault in xt_rateest_tg_checkentry",
    "call": {
        "68": {
            "name": "+0x28",
            "parent_idx": 66,
            "source_line": [
                {
                    "file": "./include/linux/compiler.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/compiler.h?id=46cf053e#n199",
                    "code": [
                        "static __always_inline",
                        "void __read_once_size(const volatile void *p, void *res, int size)",
                        "{",
                        "\t__READ_ONCE_SIZE;",
                        "}"
                    ],
                    "start": 196,
                    "highlight": 199
                },
                {
                    "file": "./include/net/netns/generic.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/netns/generic.h?id=46cf053e#n45",
                    "code": [
                        "static inline void *net_generic(const struct net *net, unsigned int id)",
                        "{",
                        "\tstruct net_generic *ng;",
                        "\tvoid *ptr;",
                        "",
                        "\trcu_read_lock();",
                        "\tng = rcu_dereference(net->gen);",
                        "\tptr = ng->ptr[id];",
                        "\trcu_read_unlock();",
                        "",
                        "\treturn ptr;",
                        "}"
                    ],
                    "start": 39,
                    "highlight": 45
                },
                {
                    "file": "net/netfilter/xt_RATEEST.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/xt_RATEEST.c?id=46cf053e#n109",
                    "code": [
                        "static int xt_rateest_tg_checkentry(const struct xt_tgchk_param *par)",
                        "{",
                        "\tstruct xt_rateest_net *xn = net_generic(par->net, xt_rateest_id);",
                        "\tstruct xt_rateest_target_info *info = par->targinfo;",
                        "\tstruct xt_rateest *est;",
                        "\tstruct {",
                        "\t\tstruct nlattr\t\topt;",
                        "\t\tstruct gnet_estimator\test;",
                        "\t} cfg;",
                        "\tint ret;",
                        "",
                        "\tnet_get_random_once(&jhash_rnd, sizeof(jhash_rnd));",
                        "",
                        "\tmutex_lock(&xn->hash_lock);",
                        "\test = __xt_rateest_lookup(xn, info->name);",
                        "\tif (est) {",
                        "\t\tmutex_unlock(&xn->hash_lock);",
                        "\t\t/*",
                        "\t\t * If estimator parameters are specified, they must match the",
                        "\t\t * existing estimator.",
                        "\t\t */",
                        "\t\tif ((!info->interval && !info->ewma_log) ||",
                        "\t\t    (info->interval != est->params.interval ||",
                        "\t\t     info->ewma_log != est->params.ewma_log)) {",
                        "\t\t\txt_rateest_put(par->net, est);",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "\t\tinfo->est = est;",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\tret = -ENOMEM;",
                        "\test = kzalloc(sizeof(*est), GFP_KERNEL);",
                        "\tif (!est)",
                        "\t\tgoto err1;",
                        "",
                        "\tstrlcpy(est->name, info->name, sizeof(est->name));",
                        "\tspin_lock_init(&est->lock);",
                        "\test->refcnt\t\t= 1;",
                        "\test->params.interval\t= info->interval;",
                        "\test->params.ewma_log\t= info->ewma_log;",
                        "",
                        "\tcfg.opt.nla_len\t\t= nla_attr_size(sizeof(cfg.est));",
                        "\tcfg.opt.nla_type\t= TCA_STATS_RATE_EST;",
                        "\tcfg.est.interval\t= info->interval;",
                        "\tcfg.est.ewma_log\t= info->ewma_log;",
                        "",
                        "\tret = gen_new_estimator(&est->bstats, NULL, &est->rate_est,",
                        "\t\t\t\t&est->lock, NULL, &cfg.opt);",
                        "\tif (ret < 0)",
                        "\t\tgoto err2;",
                        "",
                        "\tinfo->est = est;",
                        "\txt_rateest_hash_insert(xn, est);",
                        "\tmutex_unlock(&xn->hash_lock);",
                        "\treturn 0;",
                        "",
                        "err2:",
                        "\tkfree(est);",
                        "err1:",
                        "\tmutex_unlock(&xn->hash_lock);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 107,
                    "highlight": 109
                }
            ],
            "ins_idx": 2,
            "addr": "0xffffffff81914d18"
        },
        "66": {
            "name": "xt_rateest_tg_checkentry(indirect)",
            "parent_idx": 63,
            "source_line": [
                {
                    "file": "net/netfilter/x_tables.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/x_tables.c?id=46cf053e#n1019",
                    "code": [
                        "int xt_check_target(struct xt_tgchk_param *par,",
                        "\t\t    unsigned int size, u16 proto, bool inv_proto)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tif (XT_ALIGN(par->target->targetsize) != size) {",
                        "\t\tpr_err_ratelimited(\"%s_tables: %s.%u target: invalid size %u (kernel) != (user) %u\\n\",",
                        "\t\t\t\t   xt_prefix[par->family], par->target->name,",
                        "\t\t\t\t   par->target->revision,",
                        "\t\t\t\t   XT_ALIGN(par->target->targetsize), size);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "\tif (par->target->table != NULL &&",
                        "\t    strcmp(par->target->table, par->table) != 0) {",
                        "\t\tpr_info_ratelimited(\"%s_tables: %s target: only valid in %s table, not %s\\n\",",
                        "\t\t\t\t    xt_prefix[par->family], par->target->name,",
                        "\t\t\t\t    par->target->table, par->table);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "\tif (par->target->hooks && (par->hook_mask & ~par->target->hooks) != 0) {",
                        "\t\tchar used[64], allow[64];",
                        "",
                        "\t\tpr_info_ratelimited(\"%s_tables: %s target: used from hooks %s, but only usable from %s\\n\",",
                        "\t\t\t\t    xt_prefix[par->family], par->target->name,",
                        "\t\t\t\t    textify_hooks(used, sizeof(used),",
                        "\t\t\t\t\t\t  par->hook_mask, par->family),",
                        "\t\t\t\t    textify_hooks(allow, sizeof(allow),",
                        "\t\t\t\t\t\t  par->target->hooks,",
                        "\t\t\t\t\t\t  par->family));",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "\tif (par->target->proto && (par->target->proto != proto || inv_proto)) {",
                        "\t\tpr_info_ratelimited(\"%s_tables: %s target: only valid for protocol %u\\n\",",
                        "\t\t\t\t    xt_prefix[par->family], par->target->name,",
                        "\t\t\t\t    par->target->proto);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "\tif (par->target->checkentry != NULL) {",
                        "\t\tret = par->target->checkentry(par);",
                        "\t\tif (ret < 0)",
                        "\t\t\treturn ret;",
                        "\t\telse if (ret > 0)",
                        "\t\t\t/* Flag up potential errors. */",
                        "\t\t\treturn -EIO;",
                        "\t}",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 981,
                    "highlight": 1019
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8191304d"
        },
        "63": {
            "name": "xt_check_target",
            "parent_idx": 44,
            "source_line": [
                {
                    "file": "net/ipv4/netfilter/arp_tables.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/netfilter/arp_tables.c?id=46cf053e#n399",
                    "code": [
                        "\treturn xt_check_target(&par, t->u.target_size - sizeof(*t), 0, false);",
                        "}"
                    ],
                    "start": 399,
                    "highlight": 399
                },
                {
                    "file": "net/ipv4/netfilter/arp_tables.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/netfilter/arp_tables.c?id=46cf053e#n422",
                    "code": [
                        "static inline int",
                        "find_check_entry(struct arpt_entry *e, const char *name, unsigned int size,",
                        "\t\t struct xt_percpu_counter_alloc_state *alloc_state)",
                        "{",
                        "\tstruct xt_entry_target *t;",
                        "\tstruct xt_target *target;",
                        "\tint ret;",
                        "",
                        "\tif (!xt_percpu_counter_alloc(alloc_state, &e->counters))",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tt = arpt_get_target(e);",
                        "\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,",
                        "\t\t\t\t\tt->u.user.revision);",
                        "\tif (IS_ERR(target)) {",
                        "\t\tret = PTR_ERR(target);",
                        "\t\tgoto out;",
                        "\t}",
                        "\tt->u.kernel.target = target;",
                        "",
                        "\tret = check_target(e, name);",
                        "\tif (ret)",
                        "\t\tgoto err;",
                        "\treturn 0;",
                        "err:",
                        "\tmodule_put(t->u.kernel.target->me);",
                        "out:",
                        "\txt_percpu_counter_free(&e->counters);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 402,
                    "highlight": 422
                },
                {
                    "file": "net/ipv4/netfilter/arp_tables.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/netfilter/arp_tables.c?id=46cf053e#n572",
                    "code": [
                        "/* Checks and translates the user-supplied table segment (held in",
                        " * newinfo).",
                        " */",
                        "static int translate_table(struct xt_table_info *newinfo, void *entry0,",
                        "\t\t\t   const struct arpt_replace *repl)",
                        "{",
                        "\tstruct xt_percpu_counter_alloc_state alloc_state = { 0 };",
                        "\tstruct arpt_entry *iter;",
                        "\tunsigned int *offsets;",
                        "\tunsigned int i;",
                        "\tint ret = 0;",
                        "",
                        "\tnewinfo->size = repl->size;",
                        "\tnewinfo->number = repl->num_entries;",
                        "",
                        "\t/* Init all hooks to impossible value. */",
                        "\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {",
                        "\t\tnewinfo->hook_entry[i] = 0xFFFFFFFF;",
                        "\t\tnewinfo->underflow[i] = 0xFFFFFFFF;",
                        "\t}",
                        "",
                        "\toffsets = xt_alloc_entry_offsets(newinfo->number);",
                        "\tif (!offsets)",
                        "\t\treturn -ENOMEM;",
                        "\ti = 0;",
                        "",
                        "\t/* Walk through entries, checking offsets. */",
                        "\txt_entry_foreach(iter, entry0, newinfo->size) {",
                        "\t\tret = check_entry_size_and_hooks(iter, newinfo, entry0,",
                        "\t\t\t\t\t\t entry0 + repl->size,",
                        "\t\t\t\t\t\t repl->hook_entry,",
                        "\t\t\t\t\t\t repl->underflow,",
                        "\t\t\t\t\t\t repl->valid_hooks);",
                        "\t\tif (ret != 0)",
                        "\t\t\tgoto out_free;",
                        "\t\tif (i < repl->num_entries)",
                        "\t\t\toffsets[i] = (void *)iter - entry0;",
                        "\t\t++i;",
                        "\t\tif (strcmp(arpt_get_target(iter)->u.user.name,",
                        "\t\t    XT_ERROR_TARGET) == 0)",
                        "\t\t\t++newinfo->stacksize;",
                        "\t}",
                        "",
                        "\tret = -EINVAL;",
                        "\tif (i != repl->num_entries)",
                        "\t\tgoto out_free;",
                        "",
                        "\tret = xt_check_table_hooks(newinfo, repl->valid_hooks);",
                        "\tif (ret)",
                        "\t\tgoto out_free;",
                        "",
                        "\tif (!mark_source_chains(newinfo, repl->valid_hooks, entry0, offsets)) {",
                        "\t\tret = -ELOOP;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "\tkvfree(offsets);",
                        "",
                        "\t/* Finally, each sanity check must pass */",
                        "\ti = 0;",
                        "\txt_entry_foreach(iter, entry0, newinfo->size) {",
                        "\t\tret = find_check_entry(iter, repl->name, repl->size,",
                        "\t\t\t\t       &alloc_state);",
                        "\t\tif (ret != 0)",
                        "\t\t\tbreak;",
                        "\t\t++i;",
                        "\t}",
                        "",
                        "\tif (ret != 0) {",
                        "\t\txt_entry_foreach(iter, entry0, newinfo->size) {",
                        "\t\t\tif (i-- == 0)",
                        "\t\t\t\tbreak;",
                        "\t\t\tcleanup_entry(iter);",
                        "\t\t}",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\treturn ret;",
                        " out_free:",
                        "\tkvfree(offsets);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 512,
                    "highlight": 572
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81984525"
        },
        "44": {
            "name": "translate_table",
            "parent_idx": 26,
            "source_line": [
                {
                    "file": "net/ipv4/netfilter/arp_tables.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/netfilter/arp_tables.c?id=46cf053e#n977",
                    "code": [
                        "static int do_replace(struct net *net, const void __user *user,",
                        "\t\t      unsigned int len)",
                        "{",
                        "\tint ret;",
                        "\tstruct arpt_replace tmp;",
                        "\tstruct xt_table_info *newinfo;",
                        "\tvoid *loc_cpu_entry;",
                        "\tstruct arpt_entry *iter;",
                        "",
                        "\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)",
                        "\t\treturn -EFAULT;",
                        "",
                        "\t/* overflow check */",
                        "\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))",
                        "\t\treturn -ENOMEM;",
                        "\tif (tmp.num_counters == 0)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\ttmp.name[sizeof(tmp.name)-1] = 0;",
                        "",
                        "\tnewinfo = xt_alloc_table_info(tmp.size);",
                        "\tif (!newinfo)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tloc_cpu_entry = newinfo->entries;",
                        "\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),",
                        "\t\t\t   tmp.size) != 0) {",
                        "\t\tret = -EFAULT;",
                        "\t\tgoto free_newinfo;",
                        "\t}",
                        "",
                        "\tret = translate_table(newinfo, loc_cpu_entry, &tmp);",
                        "\tif (ret != 0)",
                        "\t\tgoto free_newinfo;",
                        "",
                        "\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,",
                        "\t\t\t   tmp.num_counters, tmp.counters);",
                        "\tif (ret)",
                        "\t\tgoto free_newinfo_untrans;",
                        "\treturn 0;",
                        "",
                        " free_newinfo_untrans:",
                        "\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)",
                        "\t\tcleanup_entry(iter);",
                        " free_newinfo:",
                        "\txt_free_table_info(newinfo);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 946,
                    "highlight": 977
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81986090"
        },
        "26": {
            "name": "do_arpt_set_ctl(indirect)",
            "parent_idx": 16,
            "source_line": [
                {
                    "file": "net/netfilter/nf_sockopt.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_sockopt.c?id=46cf053e#n106",
                    "code": [
                        "/* Call get/setsockopt() */",
                        "static int nf_sockopt(struct sock *sk, u_int8_t pf, int val,",
                        "\t\t      char __user *opt, int *len, int get)",
                        "{",
                        "\tstruct nf_sockopt_ops *ops;",
                        "\tint ret;",
                        "",
                        "\tops = nf_sockopt_find(sk, pf, val, get);",
                        "\tif (IS_ERR(ops))",
                        "\t\treturn PTR_ERR(ops);",
                        "",
                        "\tif (get)",
                        "\t\tret = ops->get(sk, val, opt, len);",
                        "\telse",
                        "\t\tret = ops->set(sk, val, opt, *len);",
                        "",
                        "\tmodule_put(ops->owner);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 92,
                    "highlight": 106
                },
                {
                    "file": "net/netfilter/nf_sockopt.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_sockopt.c?id=46cf053e#n115",
                    "code": [
                        "int nf_setsockopt(struct sock *sk, u_int8_t pf, int val, char __user *opt,",
                        "\t\t  unsigned int len)",
                        "{",
                        "\treturn nf_sockopt(sk, pf, val, opt, &len, 0);",
                        "}"
                    ],
                    "start": 112,
                    "highlight": 115
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818e041a"
        },
        "16": {
            "name": "ip_setsockopt(indirect)",
            "parent_idx": 13,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=46cf053e#n2117",
                    "code": [
                        "static int __sys_setsockopt(int fd, int level, int optname,",
                        "\t\t\t    char __user *optval, int optlen)",
                        "{",
                        "\tmm_segment_t oldfs = get_fs();",
                        "\tchar *kernel_optval = NULL;",
                        "\tint err, fput_needed;",
                        "\tstruct socket *sock;",
                        "",
                        "\tif (optlen < 0)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (sock != NULL) {",
                        "\t\terr = security_socket_setsockopt(sock, level, optname);",
                        "\t\tif (err)",
                        "\t\t\tgoto out_put;",
                        "",
                        "\t\terr = BPF_CGROUP_RUN_PROG_SETSOCKOPT(sock->sk, &level,",
                        "\t\t\t\t\t\t     &optname, optval, &optlen,",
                        "\t\t\t\t\t\t     &kernel_optval);",
                        "",
                        "\t\tif (err < 0) {",
                        "\t\t\tgoto out_put;",
                        "\t\t} else if (err > 0) {",
                        "\t\t\terr = 0;",
                        "\t\t\tgoto out_put;",
                        "\t\t}",
                        "",
                        "\t\tif (kernel_optval) {",
                        "\t\t\tset_fs(KERNEL_DS);",
                        "\t\t\toptval = (char __user __force *)kernel_optval;",
                        "\t\t}",
                        "",
                        "\t\tif (level == SOL_SOCKET)",
                        "\t\t\terr =",
                        "\t\t\t    sock_setsockopt(sock, level, optname, optval,",
                        "\t\t\t\t\t    optlen);",
                        "\t\telse",
                        "\t\t\terr =",
                        "\t\t\t    sock->ops->setsockopt(sock, level, optname, optval,",
                        "\t\t\t\t\t\t  optlen);",
                        "",
                        "\t\tif (kernel_optval) {",
                        "\t\t\tset_fs(oldfs);",
                        "\t\t\tkfree(kernel_optval);",
                        "\t\t}",
                        "out_put:",
                        "\t\tfput_light(sock->file, fput_needed);",
                        "\t}",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2078,
                    "highlight": 2117
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81865558"
        },
        "13": {
            "name": "__sys_setsockopt",
            "parent_idx": 11,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=46cf053e#n2133",
                    "code": [
                        "SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,",
                        "\t\tchar __user *, optval, int, optlen)",
                        "{",
                        "\treturn __sys_setsockopt(fd, level, optname, optval, optlen);",
                        "}"
                    ],
                    "start": 2130,
                    "highlight": 2133
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=46cf053e#n2130",
                    "code": [
                        "static int __sys_setsockopt(int fd, int level, int optname,",
                        "\t\t\t    char __user *optval, int optlen)",
                        "{",
                        "\tmm_segment_t oldfs = get_fs();",
                        "\tchar *kernel_optval = NULL;",
                        "\tint err, fput_needed;",
                        "\tstruct socket *sock;",
                        "",
                        "\tif (optlen < 0)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (sock != NULL) {",
                        "\t\terr = security_socket_setsockopt(sock, level, optname);",
                        "\t\tif (err)",
                        "\t\t\tgoto out_put;",
                        "",
                        "\t\terr = BPF_CGROUP_RUN_PROG_SETSOCKOPT(sock->sk, &level,",
                        "\t\t\t\t\t\t     &optname, optval, &optlen,",
                        "\t\t\t\t\t\t     &kernel_optval);",
                        "",
                        "\t\tif (err < 0) {",
                        "\t\t\tgoto out_put;",
                        "\t\t} else if (err > 0) {",
                        "\t\t\terr = 0;",
                        "\t\t\tgoto out_put;",
                        "\t\t}",
                        "",
                        "\t\tif (kernel_optval) {",
                        "\t\t\tset_fs(KERNEL_DS);",
                        "\t\t\toptval = (char __user __force *)kernel_optval;",
                        "\t\t}",
                        "",
                        "\t\tif (level == SOL_SOCKET)",
                        "\t\t\terr =",
                        "\t\t\t    sock_setsockopt(sock, level, optname, optval,",
                        "\t\t\t\t\t    optlen);",
                        "\t\telse",
                        "\t\t\terr =",
                        "\t\t\t    sock->ops->setsockopt(sock, level, optname, optval,",
                        "\t\t\t\t\t\t  optlen);",
                        "",
                        "\t\tif (kernel_optval) {",
                        "\t\t\tset_fs(oldfs);",
                        "\t\t\tkfree(kernel_optval);",
                        "\t\t}",
                        "out_put:",
                        "\t\tfput_light(sock->file, fput_needed);",
                        "\t}",
                        "\treturn err;",
                        "}",
                        "",
                        "SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,",
                        "\t\tchar __user *, optval, int, optlen)",
                        "{",
                        "\treturn __sys_setsockopt(fd, level, optname, optval, optlen);",
                        "}"
                    ],
                    "start": 2078,
                    "highlight": 2130
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818655d7"
        },
        "11": {
            "name": "__x64_sys_setsockopt(indirect)",
            "parent_idx": 8,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=46cf053e#n294",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 281,
                    "highlight": 294
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff810027d9"
        },
        "8": {
            "name": "do_syscall_64",
            "parent_idx": 2,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=46cf053e#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "2": {
            "name": "18_syscall_3",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "67": {
            "name": "+0xf",
            "parent_idx": 66,
            "source_line": [
                {
                    "file": "net/netfilter/xt_RATEEST.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/xt_RATEEST.c?id=46cf053e#n109",
                    "code": [
                        "static int xt_rateest_tg_checkentry(const struct xt_tgchk_param *par)",
                        "{",
                        "\tstruct xt_rateest_net *xn = net_generic(par->net, xt_rateest_id);",
                        "\tstruct xt_rateest_target_info *info = par->targinfo;",
                        "\tstruct xt_rateest *est;",
                        "\tstruct {",
                        "\t\tstruct nlattr\t\topt;",
                        "\t\tstruct gnet_estimator\test;",
                        "\t} cfg;",
                        "\tint ret;",
                        "",
                        "\tnet_get_random_once(&jhash_rnd, sizeof(jhash_rnd));",
                        "",
                        "\tmutex_lock(&xn->hash_lock);",
                        "\test = __xt_rateest_lookup(xn, info->name);",
                        "\tif (est) {",
                        "\t\tmutex_unlock(&xn->hash_lock);",
                        "\t\t/*",
                        "\t\t * If estimator parameters are specified, they must match the",
                        "\t\t * existing estimator.",
                        "\t\t */",
                        "\t\tif ((!info->interval && !info->ewma_log) ||",
                        "\t\t    (info->interval != est->params.interval ||",
                        "\t\t     info->ewma_log != est->params.ewma_log)) {",
                        "\t\t\txt_rateest_put(par->net, est);",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "\t\tinfo->est = est;",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\tret = -ENOMEM;",
                        "\test = kzalloc(sizeof(*est), GFP_KERNEL);",
                        "\tif (!est)",
                        "\t\tgoto err1;",
                        "",
                        "\tstrlcpy(est->name, info->name, sizeof(est->name));",
                        "\tspin_lock_init(&est->lock);",
                        "\test->refcnt\t\t= 1;",
                        "\test->params.interval\t= info->interval;",
                        "\test->params.ewma_log\t= info->ewma_log;",
                        "",
                        "\tcfg.opt.nla_len\t\t= nla_attr_size(sizeof(cfg.est));",
                        "\tcfg.opt.nla_type\t= TCA_STATS_RATE_EST;",
                        "\tcfg.est.interval\t= info->interval;",
                        "\tcfg.est.ewma_log\t= info->ewma_log;",
                        "",
                        "\tret = gen_new_estimator(&est->bstats, NULL, &est->rate_est,",
                        "\t\t\t\t&est->lock, NULL, &cfg.opt);",
                        "\tif (ret < 0)",
                        "\t\tgoto err2;",
                        "",
                        "\tinfo->est = est;",
                        "\txt_rateest_hash_insert(xn, est);",
                        "\tmutex_unlock(&xn->hash_lock);",
                        "\treturn 0;",
                        "",
                        "err2:",
                        "\tkfree(est);",
                        "err1:",
                        "\tmutex_unlock(&xn->hash_lock);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 107,
                    "highlight": 109
                }
            ],
            "ins_idx": 4,
            "addr": "0xffffffff81914cff"
        },
        "61": {
            "name": "+0x3ca",
            "parent_idx": 44,
            "source_line": [
                {
                    "file": "net/ipv4/netfilter/arp_tables.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/netfilter/arp_tables.c?id=46cf053e#n390",
                    "code": [
                        "static inline int check_target(struct arpt_entry *e, const char *name)",
                        "{",
                        "\tstruct xt_entry_target *t = arpt_get_target(e);",
                        "\tstruct xt_tgchk_param par = {",
                        "\t\t.table     = name,",
                        "\t\t.entryinfo = e,",
                        "\t\t.target    = t->u.kernel.target,",
                        "\t\t.targinfo  = t->data,",
                        "\t\t.hook_mask = e->comefrom,",
                        "\t\t.family    = NFPROTO_ARP,",
                        "\t};",
                        "",
                        "\treturn xt_check_target(&par, t->u.target_size - sizeof(*t), 0, false);",
                        "}"
                    ],
                    "start": 387,
                    "highlight": 390
                },
                {
                    "file": "net/ipv4/netfilter/arp_tables.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/netfilter/arp_tables.c?id=46cf053e#n422",
                    "code": [
                        "static inline int",
                        "find_check_entry(struct arpt_entry *e, const char *name, unsigned int size,",
                        "\t\t struct xt_percpu_counter_alloc_state *alloc_state)",
                        "{",
                        "\tstruct xt_entry_target *t;",
                        "\tstruct xt_target *target;",
                        "\tint ret;",
                        "",
                        "\tif (!xt_percpu_counter_alloc(alloc_state, &e->counters))",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tt = arpt_get_target(e);",
                        "\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,",
                        "\t\t\t\t\tt->u.user.revision);",
                        "\tif (IS_ERR(target)) {",
                        "\t\tret = PTR_ERR(target);",
                        "\t\tgoto out;",
                        "\t}",
                        "\tt->u.kernel.target = target;",
                        "",
                        "\tret = check_target(e, name);",
                        "\tif (ret)",
                        "\t\tgoto err;",
                        "\treturn 0;",
                        "err:",
                        "\tmodule_put(t->u.kernel.target->me);",
                        "out:",
                        "\txt_percpu_counter_free(&e->counters);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 402,
                    "highlight": 422
                },
                {
                    "file": "net/ipv4/netfilter/arp_tables.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/netfilter/arp_tables.c?id=46cf053e#n572",
                    "code": [
                        "/* Checks and translates the user-supplied table segment (held in",
                        " * newinfo).",
                        " */",
                        "static int translate_table(struct xt_table_info *newinfo, void *entry0,",
                        "\t\t\t   const struct arpt_replace *repl)",
                        "{",
                        "\tstruct xt_percpu_counter_alloc_state alloc_state = { 0 };",
                        "\tstruct arpt_entry *iter;",
                        "\tunsigned int *offsets;",
                        "\tunsigned int i;",
                        "\tint ret = 0;",
                        "",
                        "\tnewinfo->size = repl->size;",
                        "\tnewinfo->number = repl->num_entries;",
                        "",
                        "\t/* Init all hooks to impossible value. */",
                        "\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {",
                        "\t\tnewinfo->hook_entry[i] = 0xFFFFFFFF;",
                        "\t\tnewinfo->underflow[i] = 0xFFFFFFFF;",
                        "\t}",
                        "",
                        "\toffsets = xt_alloc_entry_offsets(newinfo->number);",
                        "\tif (!offsets)",
                        "\t\treturn -ENOMEM;",
                        "\ti = 0;",
                        "",
                        "\t/* Walk through entries, checking offsets. */",
                        "\txt_entry_foreach(iter, entry0, newinfo->size) {",
                        "\t\tret = check_entry_size_and_hooks(iter, newinfo, entry0,",
                        "\t\t\t\t\t\t entry0 + repl->size,",
                        "\t\t\t\t\t\t repl->hook_entry,",
                        "\t\t\t\t\t\t repl->underflow,",
                        "\t\t\t\t\t\t repl->valid_hooks);",
                        "\t\tif (ret != 0)",
                        "\t\t\tgoto out_free;",
                        "\t\tif (i < repl->num_entries)",
                        "\t\t\toffsets[i] = (void *)iter - entry0;",
                        "\t\t++i;",
                        "\t\tif (strcmp(arpt_get_target(iter)->u.user.name,",
                        "\t\t    XT_ERROR_TARGET) == 0)",
                        "\t\t\t++newinfo->stacksize;",
                        "\t}",
                        "",
                        "\tret = -EINVAL;",
                        "\tif (i != repl->num_entries)",
                        "\t\tgoto out_free;",
                        "",
                        "\tret = xt_check_table_hooks(newinfo, repl->valid_hooks);",
                        "\tif (ret)",
                        "\t\tgoto out_free;",
                        "",
                        "\tif (!mark_source_chains(newinfo, repl->valid_hooks, entry0, offsets)) {",
                        "\t\tret = -ELOOP;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "\tkvfree(offsets);",
                        "",
                        "\t/* Finally, each sanity check must pass */",
                        "\ti = 0;",
                        "\txt_entry_foreach(iter, entry0, newinfo->size) {",
                        "\t\tret = find_check_entry(iter, repl->name, repl->size,",
                        "\t\t\t\t       &alloc_state);",
                        "\t\tif (ret != 0)",
                        "\t\t\tbreak;",
                        "\t\t++i;",
                        "\t}",
                        "",
                        "\tif (ret != 0) {",
                        "\t\txt_entry_foreach(iter, entry0, newinfo->size) {",
                        "\t\t\tif (i-- == 0)",
                        "\t\t\t\tbreak;",
                        "\t\t\tcleanup_entry(iter);",
                        "\t\t}",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\treturn ret;",
                        " out_free:",
                        "\tkvfree(offsets);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 512,
                    "highlight": 572
                }
            ],
            "ins_idx": 8,
            "addr": "0xffffffff819844da"
        },
        "60": {
            "name": "+0x3c3",
            "parent_idx": 44,
            "source_line": [
                {
                    "file": "net/ipv4/netfilter/arp_tables.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/netfilter/arp_tables.c?id=46cf053e#n390",
                    "code": [
                        "static inline int check_target(struct arpt_entry *e, const char *name)",
                        "{",
                        "\tstruct xt_entry_target *t = arpt_get_target(e);",
                        "\tstruct xt_tgchk_param par = {",
                        "\t\t.table     = name,",
                        "\t\t.entryinfo = e,",
                        "\t\t.target    = t->u.kernel.target,",
                        "\t\t.targinfo  = t->data,",
                        "\t\t.hook_mask = e->comefrom,",
                        "\t\t.family    = NFPROTO_ARP,",
                        "\t};",
                        "",
                        "\treturn xt_check_target(&par, t->u.target_size - sizeof(*t), 0, false);",
                        "}"
                    ],
                    "start": 387,
                    "highlight": 390
                },
                {
                    "file": "net/ipv4/netfilter/arp_tables.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/netfilter/arp_tables.c?id=46cf053e#n422",
                    "code": [
                        "static inline int",
                        "find_check_entry(struct arpt_entry *e, const char *name, unsigned int size,",
                        "\t\t struct xt_percpu_counter_alloc_state *alloc_state)",
                        "{",
                        "\tstruct xt_entry_target *t;",
                        "\tstruct xt_target *target;",
                        "\tint ret;",
                        "",
                        "\tif (!xt_percpu_counter_alloc(alloc_state, &e->counters))",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tt = arpt_get_target(e);",
                        "\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,",
                        "\t\t\t\t\tt->u.user.revision);",
                        "\tif (IS_ERR(target)) {",
                        "\t\tret = PTR_ERR(target);",
                        "\t\tgoto out;",
                        "\t}",
                        "\tt->u.kernel.target = target;",
                        "",
                        "\tret = check_target(e, name);",
                        "\tif (ret)",
                        "\t\tgoto err;",
                        "\treturn 0;",
                        "err:",
                        "\tmodule_put(t->u.kernel.target->me);",
                        "out:",
                        "\txt_percpu_counter_free(&e->counters);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 402,
                    "highlight": 422
                },
                {
                    "file": "net/ipv4/netfilter/arp_tables.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/netfilter/arp_tables.c?id=46cf053e#n572",
                    "code": [
                        "/* Checks and translates the user-supplied table segment (held in",
                        " * newinfo).",
                        " */",
                        "static int translate_table(struct xt_table_info *newinfo, void *entry0,",
                        "\t\t\t   const struct arpt_replace *repl)",
                        "{",
                        "\tstruct xt_percpu_counter_alloc_state alloc_state = { 0 };",
                        "\tstruct arpt_entry *iter;",
                        "\tunsigned int *offsets;",
                        "\tunsigned int i;",
                        "\tint ret = 0;",
                        "",
                        "\tnewinfo->size = repl->size;",
                        "\tnewinfo->number = repl->num_entries;",
                        "",
                        "\t/* Init all hooks to impossible value. */",
                        "\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {",
                        "\t\tnewinfo->hook_entry[i] = 0xFFFFFFFF;",
                        "\t\tnewinfo->underflow[i] = 0xFFFFFFFF;",
                        "\t}",
                        "",
                        "\toffsets = xt_alloc_entry_offsets(newinfo->number);",
                        "\tif (!offsets)",
                        "\t\treturn -ENOMEM;",
                        "\ti = 0;",
                        "",
                        "\t/* Walk through entries, checking offsets. */",
                        "\txt_entry_foreach(iter, entry0, newinfo->size) {",
                        "\t\tret = check_entry_size_and_hooks(iter, newinfo, entry0,",
                        "\t\t\t\t\t\t entry0 + repl->size,",
                        "\t\t\t\t\t\t repl->hook_entry,",
                        "\t\t\t\t\t\t repl->underflow,",
                        "\t\t\t\t\t\t repl->valid_hooks);",
                        "\t\tif (ret != 0)",
                        "\t\t\tgoto out_free;",
                        "\t\tif (i < repl->num_entries)",
                        "\t\t\toffsets[i] = (void *)iter - entry0;",
                        "\t\t++i;",
                        "\t\tif (strcmp(arpt_get_target(iter)->u.user.name,",
                        "\t\t    XT_ERROR_TARGET) == 0)",
                        "\t\t\t++newinfo->stacksize;",
                        "\t}",
                        "",
                        "\tret = -EINVAL;",
                        "\tif (i != repl->num_entries)",
                        "\t\tgoto out_free;",
                        "",
                        "\tret = xt_check_table_hooks(newinfo, repl->valid_hooks);",
                        "\tif (ret)",
                        "\t\tgoto out_free;",
                        "",
                        "\tif (!mark_source_chains(newinfo, repl->valid_hooks, entry0, offsets)) {",
                        "\t\tret = -ELOOP;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "\tkvfree(offsets);",
                        "",
                        "\t/* Finally, each sanity check must pass */",
                        "\ti = 0;",
                        "\txt_entry_foreach(iter, entry0, newinfo->size) {",
                        "\t\tret = find_check_entry(iter, repl->name, repl->size,",
                        "\t\t\t\t       &alloc_state);",
                        "\t\tif (ret != 0)",
                        "\t\t\tbreak;",
                        "\t\t++i;",
                        "\t}",
                        "",
                        "\tif (ret != 0) {",
                        "\t\txt_entry_foreach(iter, entry0, newinfo->size) {",
                        "\t\t\tif (i-- == 0)",
                        "\t\t\t\tbreak;",
                        "\t\t\tcleanup_entry(iter);",
                        "\t\t}",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\treturn ret;",
                        " out_free:",
                        "\tkvfree(offsets);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 512,
                    "highlight": 572
                }
            ],
            "ins_idx": 12,
            "addr": "0xffffffff819844d3"
        }
    },
    "ins": {
        "2": {
            "name": "mov rdx, qword ptr [rdx + 0xbb0]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0xbb0",
            "call_idx": 68,
            "inputs": [
                97,
                98
            ],
            "outputs": [
                99
            ]
        },
        "4": {
            "name": "mov rdx, qword ptr [rdi]",
            "desc": "",
            "call_idx": 67,
            "inputs": [
                94,
                95
            ],
            "outputs": [
                96
            ]
        },
        "8": {
            "name": "rep stosq qword ptr [rdi], rax",
            "desc": "",
            "call_idx": 61,
            "inputs": [
                85,
                86
            ],
            "outputs": [
                87
            ]
        },
        "12": {
            "name": "xor eax, eax",
            "desc": "Source of base address CONST 0x0",
            "call_idx": 60,
            "inputs": [
                82,
                83
            ],
            "outputs": [
                84
            ]
        }
    },
    "data": {
        "97": {
            "name": "RDX",
            "ins_idx": 2,
            "value": "0x0",
            "sources": []
        },
        "98": {
            "name": "[0xbb0]",
            "ins_idx": 2,
            "value": "0x0",
            "sources": []
        },
        "99": {
            "name": "RDX",
            "ins_idx": 2,
            "value": "0x0",
            "sources": []
        },
        "94": {
            "name": "RDI",
            "ins_idx": 4,
            "value": "0xffffc90000253db8",
            "sources": []
        },
        "95": {
            "name": "[0xffffc90000253db8]",
            "ins_idx": 4,
            "value": "0x0",
            "sources": []
        },
        "96": {
            "name": "RDX",
            "ins_idx": 4,
            "value": "0x0",
            "sources": [
                97
            ]
        },
        "85": {
            "name": "RAX",
            "ins_idx": 8,
            "value": "0x0",
            "sources": []
        },
        "86": {
            "name": "RDI",
            "ins_idx": 8,
            "value": "0xffffc90000253db8",
            "sources": []
        },
        "87": {
            "name": "[0xffffc90000253db8]",
            "ins_idx": 8,
            "value": "0x0",
            "sources": [
                95
            ]
        },
        "82": {
            "name": "RAX",
            "ins_idx": 12,
            "value": "0x0",
            "sources": []
        },
        "83": {
            "name": "RAX",
            "ins_idx": 12,
            "value": "0x0",
            "sources": []
        },
        "84": {
            "name": "RAX",
            "ins_idx": 12,
            "value": "0x0",
            "sources": [
                85
            ]
        }
    },
    "chain": {
        "2": [
            4
        ],
        "4": [
            8
        ],
        "8": [
            12
        ]
    }
}