{
    "report": "https://syzkaller.appspot.com/bug?id=3674e1e163310d45ad3b0371f90b06b56af44697",
    "title": "general protection fault in nft_tunnel_get_init",
    "call": {
        "1630": {
            "name": "+0x18",
            "parent_idx": 1628,
            "source_line": [
                {
                    "file": "net/netfilter/nft_tunnel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_tunnel.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n83",
                    "code": [
                        "static int nft_tunnel_get_init(const struct nft_ctx *ctx,",
                        "\t\t\t       const struct nft_expr *expr,",
                        "\t\t\t       const struct nlattr * const tb[])",
                        "{",
                        "\tstruct nft_tunnel *priv = nft_expr_priv(expr);",
                        "\tu32 len;",
                        "",
                        "\tif (!tb[NFTA_TUNNEL_KEY] &&",
                        "\t    !tb[NFTA_TUNNEL_DREG])",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tpriv->key = ntohl(nla_get_be32(tb[NFTA_TUNNEL_KEY]));",
                        "\tswitch (priv->key) {",
                        "\tcase NFT_TUNNEL_PATH:",
                        "\t\tlen = sizeof(u8);",
                        "\t\tbreak;",
                        "\tcase NFT_TUNNEL_ID:",
                        "\t\tlen = sizeof(u32);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\treturn -EOPNOTSUPP;",
                        "\t}",
                        "",
                        "\tpriv->dreg = nft_parse_register(tb[NFTA_TUNNEL_DREG]);",
                        "",
                        "\tif (tb[NFTA_TUNNEL_MODE]) {",
                        "\t\tpriv->mode = ntohl(nla_get_be32(tb[NFTA_TUNNEL_MODE]));",
                        "\t\tif (priv->mode > NFT_TUNNEL_MODE_MAX)",
                        "\t\t\treturn -EOPNOTSUPP;",
                        "\t} else {",
                        "\t\tpriv->mode = NFT_TUNNEL_MODE_NONE;",
                        "\t}",
                        "",
                        "\treturn nft_validate_register_store(ctx, priv->dreg, NULL,",
                        "\t\t\t\t\t   NFT_DATA_VALUE, len);",
                        "}"
                    ],
                    "start": 72,
                    "highlight": 83
                }
            ],
            "ins_idx": 1,
            "addr": "0xffffffff8190fd58"
        },
        "1628": {
            "name": "nft_tunnel_get_init(indirect)",
            "parent_idx": 1588,
            "source_line": [
                {
                    "file": "net/netfilter/nf_tables_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n2466",
                    "code": [
                        "static int nf_tables_newexpr(const struct nft_ctx *ctx,",
                        "\t\t\t     const struct nft_expr_info *info,",
                        "\t\t\t     struct nft_expr *expr)",
                        "{",
                        "\tconst struct nft_expr_ops *ops = info->ops;",
                        "\tint err;",
                        "",
                        "\texpr->ops = ops;",
                        "\tif (ops->init) {",
                        "\t\terr = ops->init(ctx, expr, (const struct nlattr **)info->tb);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err1;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "err1:",
                        "\texpr->ops = NULL;",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2457,
                    "highlight": 2466
                },
                {
                    "file": "net/netfilter/nf_tables_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n3074",
                    "code": [
                        "static int nf_tables_newrule(struct net *net, struct sock *nlsk,",
                        "\t\t\t     struct sk_buff *skb, const struct nlmsghdr *nlh,",
                        "\t\t\t     const struct nlattr * const nla[],",
                        "\t\t\t     struct netlink_ext_ack *extack)",
                        "{",
                        "\tconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);",
                        "\tu8 genmask = nft_genmask_next(net);",
                        "\tstruct nft_expr_info *info = NULL;",
                        "\tint family = nfmsg->nfgen_family;",
                        "\tstruct nft_flow_rule *flow;",
                        "\tstruct nft_table *table;",
                        "\tstruct nft_chain *chain;",
                        "\tstruct nft_rule *rule, *old_rule = NULL;",
                        "\tstruct nft_userdata *udata;",
                        "\tstruct nft_trans *trans = NULL;",
                        "\tstruct nft_expr *expr;",
                        "\tstruct nft_ctx ctx;",
                        "\tstruct nlattr *tmp;",
                        "\tunsigned int size, i, n, ulen = 0, usize = 0;",
                        "\tint err, rem;",
                        "\tu64 handle, pos_handle;",
                        "",
                        "\tlockdep_assert_held(&net->nft.commit_mutex);",
                        "",
                        "\ttable = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask);",
                        "\tif (IS_ERR(table)) {",
                        "\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);",
                        "\t\treturn PTR_ERR(table);",
                        "\t}",
                        "",
                        "\tchain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask);",
                        "\tif (IS_ERR(chain)) {",
                        "\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);",
                        "\t\treturn PTR_ERR(chain);",
                        "\t}",
                        "",
                        "\tif (nla[NFTA_RULE_HANDLE]) {",
                        "\t\thandle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));",
                        "\t\trule = __nft_rule_lookup(chain, handle);",
                        "\t\tif (IS_ERR(rule)) {",
                        "\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);",
                        "\t\t\treturn PTR_ERR(rule);",
                        "\t\t}",
                        "",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_EXCL) {",
                        "\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);",
                        "\t\t\treturn -EEXIST;",
                        "\t\t}",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_REPLACE)",
                        "\t\t\told_rule = rule;",
                        "\t\telse",
                        "\t\t\treturn -EOPNOTSUPP;",
                        "\t} else {",
                        "\t\tif (!(nlh->nlmsg_flags & NLM_F_CREATE) ||",
                        "\t\t    nlh->nlmsg_flags & NLM_F_REPLACE)",
                        "\t\t\treturn -EINVAL;",
                        "\t\thandle = nf_tables_alloc_handle(table);",
                        "",
                        "\t\tif (chain->use == UINT_MAX)",
                        "\t\t\treturn -EOVERFLOW;",
                        "",
                        "\t\tif (nla[NFTA_RULE_POSITION]) {",
                        "\t\t\tpos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));",
                        "\t\t\told_rule = __nft_rule_lookup(chain, pos_handle);",
                        "\t\t\tif (IS_ERR(old_rule)) {",
                        "\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);",
                        "\t\t\t\treturn PTR_ERR(old_rule);",
                        "\t\t\t}",
                        "\t\t} else if (nla[NFTA_RULE_POSITION_ID]) {",
                        "\t\t\told_rule = nft_rule_lookup_byid(net, nla[NFTA_RULE_POSITION_ID]);",
                        "\t\t\tif (IS_ERR(old_rule)) {",
                        "\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);",
                        "\t\t\t\treturn PTR_ERR(old_rule);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tnft_ctx_init(&ctx, net, skb, nlh, family, table, chain, nla);",
                        "",
                        "\tn = 0;",
                        "\tsize = 0;",
                        "\tif (nla[NFTA_RULE_EXPRESSIONS]) {",
                        "\t\tinfo = kvmalloc_array(NFT_RULE_MAXEXPRS,",
                        "\t\t\t\t      sizeof(struct nft_expr_info),",
                        "\t\t\t\t      GFP_KERNEL);",
                        "\t\tif (!info)",
                        "\t\t\treturn -ENOMEM;",
                        "",
                        "\t\tnla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) {",
                        "\t\t\terr = -EINVAL;",
                        "\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM)",
                        "\t\t\t\tgoto err1;",
                        "\t\t\tif (n == NFT_RULE_MAXEXPRS)",
                        "\t\t\t\tgoto err1;",
                        "\t\t\terr = nf_tables_expr_parse(&ctx, tmp, &info[n]);",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\tgoto err1;",
                        "\t\t\tsize += info[n].ops->size;",
                        "\t\t\tn++;",
                        "\t\t}",
                        "\t}",
                        "\t/* Check for overflow of dlen field */",
                        "\terr = -EFBIG;",
                        "\tif (size >= 1 << 12)",
                        "\t\tgoto err1;",
                        "",
                        "\tif (nla[NFTA_RULE_USERDATA]) {",
                        "\t\tulen = nla_len(nla[NFTA_RULE_USERDATA]);",
                        "\t\tif (ulen > 0)",
                        "\t\t\tusize = sizeof(struct nft_userdata) + ulen;",
                        "\t}",
                        "",
                        "\terr = -ENOMEM;",
                        "\trule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL);",
                        "\tif (rule == NULL)",
                        "\t\tgoto err1;",
                        "",
                        "\tnft_activate_next(net, rule);",
                        "",
                        "\trule->handle = handle;",
                        "\trule->dlen   = size;",
                        "\trule->udata  = ulen ? 1 : 0;",
                        "",
                        "\tif (ulen) {",
                        "\t\tudata = nft_userdata(rule);",
                        "\t\tudata->len = ulen - 1;",
                        "\t\tnla_memcpy(udata->data, nla[NFTA_RULE_USERDATA], ulen);",
                        "\t}",
                        "",
                        "\texpr = nft_expr_first(rule);",
                        "\tfor (i = 0; i < n; i++) {",
                        "\t\terr = nf_tables_newexpr(&ctx, &info[i], expr);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err2;",
                        "",
                        "\t\tif (info[i].ops->validate)",
                        "\t\t\tnft_validate_state_update(net, NFT_VALIDATE_NEED);",
                        "",
                        "\t\tinfo[i].ops = NULL;",
                        "\t\texpr = nft_expr_next(expr);",
                        "\t}",
                        "",
                        "\tif (nlh->nlmsg_flags & NLM_F_REPLACE) {",
                        "\t\ttrans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);",
                        "\t\tif (trans == NULL) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto err2;",
                        "\t\t}",
                        "\t\terr = nft_delrule(&ctx, old_rule);",
                        "\t\tif (err < 0) {",
                        "\t\t\tnft_trans_destroy(trans);",
                        "\t\t\tgoto err2;",
                        "\t\t}",
                        "",
                        "\t\tlist_add_tail_rcu(&rule->list, &old_rule->list);",
                        "\t} else {",
                        "\t\ttrans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);",
                        "\t\tif (!trans) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto err2;",
                        "\t\t}",
                        "",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_APPEND) {",
                        "\t\t\tif (old_rule)",
                        "\t\t\t\tlist_add_rcu(&rule->list, &old_rule->list);",
                        "\t\t\telse",
                        "\t\t\t\tlist_add_tail_rcu(&rule->list, &chain->rules);",
                        "\t\t } else {",
                        "\t\t\tif (old_rule)",
                        "\t\t\t\tlist_add_tail_rcu(&rule->list, &old_rule->list);",
                        "\t\t\telse",
                        "\t\t\t\tlist_add_rcu(&rule->list, &chain->rules);",
                        "\t\t}",
                        "\t}",
                        "\tkvfree(info);",
                        "\tchain->use++;",
                        "",
                        "\tif (net->nft.validate_state == NFT_VALIDATE_DO)",
                        "\t\treturn nft_table_validate(net, table);",
                        "",
                        "\tif (chain->flags & NFT_CHAIN_HW_OFFLOAD) {",
                        "\t\tflow = nft_flow_rule_create(net, rule);",
                        "\t\tif (IS_ERR(flow))",
                        "\t\t\treturn PTR_ERR(flow);",
                        "",
                        "\t\tnft_trans_flow_rule(trans) = flow;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "err2:",
                        "\tnf_tables_rule_release(&ctx, rule);",
                        "err1:",
                        "\tfor (i = 0; i < n; i++) {",
                        "\t\tif (info[i].ops) {",
                        "\t\t\tmodule_put(info[i].ops->type->owner);",
                        "\t\t\tif (info[i].ops->type->release_ops)",
                        "\t\t\t\tinfo[i].ops->type->release_ops(info[i].ops);",
                        "\t\t}",
                        "\t}",
                        "\tkvfree(info);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2943,
                    "highlight": 3074
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81904565"
        },
        "1588": {
            "name": "nf_tables_newrule(indirect)",
            "parent_idx": 1587,
            "source_line": [
                {
                    "file": "net/netfilter/nfnetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nfnetlink.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n433",
                    "code": [
                        "static void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t\tu16 subsys_id, u32 genid)",
                        "{",
                        "\tstruct sk_buff *oskb = skb;",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tconst struct nfnetlink_subsystem *ss;",
                        "\tconst struct nfnl_callback *nc;",
                        "\tstruct netlink_ext_ack extack;",
                        "\tLIST_HEAD(err_list);",
                        "\tu32 status;",
                        "\tint err;",
                        "",
                        "\tif (subsys_id >= NFNL_SUBSYS_COUNT)",
                        "\t\treturn netlink_ack(skb, nlh, -EINVAL, NULL);",
                        "replay:",
                        "\tstatus = 0;",
                        "",
                        "\tskb = netlink_skb_clone(oskb, GFP_KERNEL);",
                        "\tif (!skb)",
                        "\t\treturn netlink_ack(oskb, nlh, -ENOMEM, NULL);",
                        "",
                        "\tnfnl_lock(subsys_id);",
                        "\tss = nfnl_dereference_protected(subsys_id);",
                        "\tif (!ss) {",
                        "#ifdef CONFIG_MODULES",
                        "\t\tnfnl_unlock(subsys_id);",
                        "\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);",
                        "\t\tnfnl_lock(subsys_id);",
                        "\t\tss = nfnl_dereference_protected(subsys_id);",
                        "\t\tif (!ss)",
                        "#endif",
                        "\t\t{",
                        "\t\t\tnfnl_unlock(subsys_id);",
                        "\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP, NULL);",
                        "\t\t\treturn kfree_skb(skb);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (!ss->valid_genid || !ss->commit || !ss->abort) {",
                        "\t\tnfnl_unlock(subsys_id);",
                        "\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP, NULL);",
                        "\t\treturn kfree_skb(skb);",
                        "\t}",
                        "",
                        "\tif (!try_module_get(ss->owner)) {",
                        "\t\tnfnl_unlock(subsys_id);",
                        "\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP, NULL);",
                        "\t\treturn kfree_skb(skb);",
                        "\t}",
                        "",
                        "\tif (!ss->valid_genid(net, genid)) {",
                        "\t\tmodule_put(ss->owner);",
                        "\t\tnfnl_unlock(subsys_id);",
                        "\t\tnetlink_ack(oskb, nlh, -ERESTART, NULL);",
                        "\t\treturn kfree_skb(skb);",
                        "\t}",
                        "",
                        "\tnfnl_unlock(subsys_id);",
                        "",
                        "\twhile (skb->len >= nlmsg_total_size(0)) {",
                        "\t\tint msglen, type;",
                        "",
                        "\t\tif (fatal_signal_pending(current)) {",
                        "\t\t\tnfnl_err_reset(&err_list);",
                        "\t\t\terr = -EINTR;",
                        "\t\t\tstatus = NFNL_BATCH_FAILURE;",
                        "\t\t\tgoto done;",
                        "\t\t}",
                        "",
                        "\t\tmemset(&extack, 0, sizeof(extack));",
                        "\t\tnlh = nlmsg_hdr(skb);",
                        "\t\terr = 0;",
                        "",
                        "\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||",
                        "\t\t    skb->len < nlh->nlmsg_len ||",
                        "\t\t    nlmsg_len(nlh) < sizeof(struct nfgenmsg)) {",
                        "\t\t\tnfnl_err_reset(&err_list);",
                        "\t\t\tstatus |= NFNL_BATCH_FAILURE;",
                        "\t\t\tgoto done;",
                        "\t\t}",
                        "",
                        "\t\t/* Only requests are handled by the kernel */",
                        "\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {",
                        "\t\t\terr = -EINVAL;",
                        "\t\t\tgoto ack;",
                        "\t\t}",
                        "",
                        "\t\ttype = nlh->nlmsg_type;",
                        "\t\tif (type == NFNL_MSG_BATCH_BEGIN) {",
                        "\t\t\t/* Malformed: Batch begin twice */",
                        "\t\t\tnfnl_err_reset(&err_list);",
                        "\t\t\tstatus |= NFNL_BATCH_FAILURE;",
                        "\t\t\tgoto done;",
                        "\t\t} else if (type == NFNL_MSG_BATCH_END) {",
                        "\t\t\tstatus |= NFNL_BATCH_DONE;",
                        "\t\t\tgoto done;",
                        "\t\t} else if (type < NLMSG_MIN_TYPE) {",
                        "\t\t\terr = -EINVAL;",
                        "\t\t\tgoto ack;",
                        "\t\t}",
                        "",
                        "\t\t/* We only accept a batch with messages for the same",
                        "\t\t * subsystem.",
                        "\t\t */",
                        "\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {",
                        "\t\t\terr = -EINVAL;",
                        "\t\t\tgoto ack;",
                        "\t\t}",
                        "",
                        "\t\tnc = nfnetlink_find_client(type, ss);",
                        "\t\tif (!nc) {",
                        "\t\t\terr = -EINVAL;",
                        "\t\t\tgoto ack;",
                        "\t\t}",
                        "",
                        "\t\t{",
                        "\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));",
                        "\t\t\tu8 cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);",
                        "\t\t\tstruct nlattr *cda[NFNL_MAX_ATTR_COUNT + 1];",
                        "\t\t\tstruct nlattr *attr = (void *)nlh + min_len;",
                        "\t\t\tint attrlen = nlh->nlmsg_len - min_len;",
                        "",
                        "\t\t\t/* Sanity-check NFTA_MAX_ATTR */",
                        "\t\t\tif (ss->cb[cb_id].attr_count > NFNL_MAX_ATTR_COUNT) {",
                        "\t\t\t\terr = -ENOMEM;",
                        "\t\t\t\tgoto ack;",
                        "\t\t\t}",
                        "",
                        "\t\t\terr = nla_parse_deprecated(cda,",
                        "\t\t\t\t\t\t   ss->cb[cb_id].attr_count,",
                        "\t\t\t\t\t\t   attr, attrlen,",
                        "\t\t\t\t\t\t   ss->cb[cb_id].policy, NULL);",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\tgoto ack;",
                        "",
                        "\t\t\tif (nc->call_batch) {",
                        "\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,",
                        "\t\t\t\t\t\t     (const struct nlattr **)cda,",
                        "\t\t\t\t\t\t     &extack);",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* The lock was released to autoload some module, we",
                        "\t\t\t * have to abort and start from scratch using the",
                        "\t\t\t * original skb.",
                        "\t\t\t */",
                        "\t\t\tif (err == -EAGAIN) {",
                        "\t\t\t\tstatus |= NFNL_BATCH_REPLAY;",
                        "\t\t\t\tgoto done;",
                        "\t\t\t}",
                        "\t\t}",
                        "ack:",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {",
                        "\t\t\t/* Errors are delivered once the full batch has been",
                        "\t\t\t * processed, this avoids that the same error is",
                        "\t\t\t * reported several times when replaying the batch.",
                        "\t\t\t */",
                        "\t\t\tif (nfnl_err_add(&err_list, nlh, err, &extack) < 0) {",
                        "\t\t\t\t/* We failed to enqueue an error, reset the",
                        "\t\t\t\t * list of errors and send OOM to userspace",
                        "\t\t\t\t * pointing to the batch header.",
                        "\t\t\t\t */",
                        "\t\t\t\tnfnl_err_reset(&err_list);",
                        "\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM,",
                        "\t\t\t\t\t    NULL);",
                        "\t\t\t\tstatus |= NFNL_BATCH_FAILURE;",
                        "\t\t\t\tgoto done;",
                        "\t\t\t}",
                        "\t\t\t/* We don't stop processing the batch on errors, thus,",
                        "\t\t\t * userspace gets all the errors that the batch",
                        "\t\t\t * triggers.",
                        "\t\t\t */",
                        "\t\t\tif (err)",
                        "\t\t\t\tstatus |= NFNL_BATCH_FAILURE;",
                        "\t\t}",
                        "",
                        "\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);",
                        "\t\tif (msglen > skb->len)",
                        "\t\t\tmsglen = skb->len;",
                        "\t\tskb_pull(skb, msglen);",
                        "\t}",
                        "done:",
                        "\tif (status & NFNL_BATCH_REPLAY) {",
                        "\t\tss->abort(net, oskb);",
                        "\t\tnfnl_err_reset(&err_list);",
                        "\t\tkfree_skb(skb);",
                        "\t\tmodule_put(ss->owner);",
                        "\t\tgoto replay;",
                        "\t} else if (status == NFNL_BATCH_DONE) {",
                        "\t\terr = ss->commit(net, oskb);",
                        "\t\tif (err == -EAGAIN) {",
                        "\t\t\tstatus |= NFNL_BATCH_REPLAY;",
                        "\t\t\tgoto done;",
                        "\t\t} else if (err) {",
                        "\t\t\tss->abort(net, oskb);",
                        "\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), err, NULL);",
                        "\t\t}",
                        "\t} else {",
                        "\t\tss->abort(net, oskb);",
                        "\t}",
                        "\tif (ss->cleanup)",
                        "\t\tss->cleanup(net);",
                        "",
                        "\tnfnl_err_deliver(&err_list, oskb);",
                        "\tkfree_skb(skb);",
                        "\tmodule_put(ss->owner);",
                        "}"
                    ],
                    "start": 297,
                    "highlight": 433
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818e100d"
        },
        "1587": {
            "name": "nfnetlink_rcv_batch",
            "parent_idx": 1586,
            "source_line": [
                {
                    "file": "net/netfilter/nfnetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nfnetlink.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n543",
                    "code": [
                        "static void nfnetlink_rcv_skb_batch(struct sk_buff *skb, struct nlmsghdr *nlh)",
                        "{",
                        "\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));",
                        "\tstruct nlattr *attr = (void *)nlh + min_len;",
                        "\tstruct nlattr *cda[NFNL_BATCH_MAX + 1];",
                        "\tint attrlen = nlh->nlmsg_len - min_len;",
                        "\tstruct nfgenmsg *nfgenmsg;",
                        "\tint msglen, err;",
                        "\tu32 gen_id = 0;",
                        "\tu16 res_id;",
                        "",
                        "\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);",
                        "\tif (msglen > skb->len)",
                        "\t\tmsglen = skb->len;",
                        "",
                        "\tif (skb->len < NLMSG_HDRLEN + sizeof(struct nfgenmsg))",
                        "\t\treturn;",
                        "",
                        "\terr = nla_parse_deprecated(cda, NFNL_BATCH_MAX, attr, attrlen,",
                        "\t\t\t\t   nfnl_batch_policy, NULL);",
                        "\tif (err < 0) {",
                        "\t\tnetlink_ack(skb, nlh, err, NULL);",
                        "\t\treturn;",
                        "\t}",
                        "\tif (cda[NFNL_BATCH_GENID])",
                        "\t\tgen_id = ntohl(nla_get_be32(cda[NFNL_BATCH_GENID]));",
                        "",
                        "\tnfgenmsg = nlmsg_data(nlh);",
                        "\tskb_pull(skb, msglen);",
                        "\t/* Work around old nft using host byte order */",
                        "\tif (nfgenmsg->res_id == NFNL_SUBSYS_NFTABLES)",
                        "\t\tres_id = NFNL_SUBSYS_NFTABLES;",
                        "\telse",
                        "\t\tres_id = ntohs(nfgenmsg->res_id);",
                        "",
                        "\tnfnetlink_rcv_batch(skb, nlh, res_id, gen_id);",
                        "}"
                    ],
                    "start": 508,
                    "highlight": 543
                },
                {
                    "file": "net/netfilter/nfnetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nfnetlink.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n561",
                    "code": [
                        "static void nfnetlink_rcv(struct sk_buff *skb)",
                        "{",
                        "\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);",
                        "",
                        "\tif (skb->len < NLMSG_HDRLEN ||",
                        "\t    nlh->nlmsg_len < NLMSG_HDRLEN ||",
                        "\t    skb->len < nlh->nlmsg_len)",
                        "\t\treturn;",
                        "",
                        "\tif (!netlink_net_capable(skb, CAP_NET_ADMIN)) {",
                        "\t\tnetlink_ack(skb, nlh, -EPERM, NULL);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\tif (nlh->nlmsg_type == NFNL_MSG_BATCH_BEGIN)",
                        "\t\tnfnetlink_rcv_skb_batch(skb, nlh);",
                        "\telse",
                        "\t\tnetlink_rcv_skb(skb, nfnetlink_rcv_msg);",
                        "}"
                    ],
                    "start": 546,
                    "highlight": 561
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818e16a4"
        },
        "1586": {
            "name": "nfnetlink_rcv(indirect)",
            "parent_idx": 1585,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n1302",
                    "code": [
                        "static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,",
                        "\t\t\t\t  struct sock *ssk)",
                        "{",
                        "\tint ret;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "",
                        "\tret = -ECONNREFUSED;",
                        "\tif (nlk->netlink_rcv != NULL) {",
                        "\t\tret = skb->len;",
                        "\t\tnetlink_skb_set_owner_r(skb, sk);",
                        "\t\tNETLINK_CB(skb).sk = ssk;",
                        "\t\tnetlink_deliver_tap_kernel(sk, ssk, skb);",
                        "\t\tnlk->netlink_rcv(skb);",
                        "\t\tconsume_skb(skb);",
                        "\t} else {",
                        "\t\tkfree_skb(skb);",
                        "\t}",
                        "\tsock_put(sk);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1290,
                    "highlight": 1302
                },
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n1328",
                    "code": [
                        "int netlink_unicast(struct sock *ssk, struct sk_buff *skb,",
                        "\t\t    u32 portid, int nonblock)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tint err;",
                        "\tlong timeo;",
                        "",
                        "\tskb = netlink_trim(skb, gfp_any());",
                        "",
                        "\ttimeo = sock_sndtimeo(ssk, nonblock);",
                        "retry:",
                        "\tsk = netlink_getsockbyportid(ssk, portid);",
                        "\tif (IS_ERR(sk)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn PTR_ERR(sk);",
                        "\t}",
                        "\tif (netlink_is_kernel(sk))",
                        "\t\treturn netlink_unicast_kernel(sk, skb, ssk);",
                        "",
                        "\tif (sk_filter(sk, skb)) {",
                        "\t\terr = skb->len;",
                        "\t\tkfree_skb(skb);",
                        "\t\tsock_put(sk);",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = netlink_attachskb(sk, skb, &timeo, ssk);",
                        "\tif (err == 1)",
                        "\t\tgoto retry;",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\treturn netlink_sendskb(sk, skb);",
                        "}"
                    ],
                    "start": 1311,
                    "highlight": 1328
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818db8af"
        },
        "1585": {
            "name": "netlink_unicast",
            "parent_idx": 1584,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n1917",
                    "code": [
                        "static int netlink_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "\tDECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);",
                        "\tu32 dst_portid;",
                        "\tu32 dst_group;",
                        "\tstruct sk_buff *skb;",
                        "\tint err;",
                        "\tstruct scm_cookie scm;",
                        "\tu32 netlink_skb_flags = 0;",
                        "",
                        "\tif (msg->msg_flags&MSG_OOB)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\terr = scm_send(sock, msg, &scm, true);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tif (msg->msg_namelen) {",
                        "\t\terr = -EINVAL;",
                        "\t\tif (msg->msg_namelen < sizeof(struct sockaddr_nl))",
                        "\t\t\tgoto out;",
                        "\t\tif (addr->nl_family != AF_NETLINK)",
                        "\t\t\tgoto out;",
                        "\t\tdst_portid = addr->nl_pid;",
                        "\t\tdst_group = ffs(addr->nl_groups);",
                        "\t\terr =  -EPERM;",
                        "\t\tif ((dst_group || dst_portid) &&",
                        "\t\t    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))",
                        "\t\t\tgoto out;",
                        "\t\tnetlink_skb_flags |= NETLINK_SKB_DST;",
                        "\t} else {",
                        "\t\tdst_portid = nlk->dst_portid;",
                        "\t\tdst_group = nlk->dst_group;",
                        "\t}",
                        "",
                        "\tif (!nlk->bound) {",
                        "\t\terr = netlink_autobind(sock);",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t} else {",
                        "\t\t/* Ensure nlk is hashed and visible. */",
                        "\t\tsmp_rmb();",
                        "\t}",
                        "",
                        "\terr = -EMSGSIZE;",
                        "\tif (len > sk->sk_sndbuf - 32)",
                        "\t\tgoto out;",
                        "\terr = -ENOBUFS;",
                        "\tskb = netlink_alloc_large_skb(len, dst_group);",
                        "\tif (skb == NULL)",
                        "\t\tgoto out;",
                        "",
                        "\tNETLINK_CB(skb).portid\t= nlk->portid;",
                        "\tNETLINK_CB(skb).dst_group = dst_group;",
                        "\tNETLINK_CB(skb).creds\t= scm.creds;",
                        "\tNETLINK_CB(skb).flags\t= netlink_skb_flags;",
                        "",
                        "\terr = -EFAULT;",
                        "\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\terr = security_netlink_send(sk, skb);",
                        "\tif (err) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (dst_group) {",
                        "\t\trefcount_inc(&skb->users);",
                        "\t\tnetlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);",
                        "\t}",
                        "\terr = netlink_unicast(sk, skb, dst_portid, msg->msg_flags&MSG_DONTWAIT);",
                        "",
                        "out:",
                        "\tscm_destroy(&scm);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1842,
                    "highlight": 1917
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818dbb9b"
        },
        "1584": {
            "name": "netlink_sendmsg(indirect)",
            "parent_idx": 1583,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n639",
                    "code": [
                        "INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t   size_t));",
                        "INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t    size_t));",
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,",
                        "\t\t\t\t     inet_sendmsg, sock, msg,",
                        "\t\t\t\t     msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 633,
                    "highlight": 639
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n659",
                    "code": [
                        "/**",
                        " *\tsock_sendmsg - send a message through @sock",
                        " *\t@sock: socket",
                        " *\t@msg: message to send",
                        " *",
                        " *\tSends @msg through @sock, passing through LSM.",
                        " *\tReturns the number of bytes sent, or an error code.",
                        " */",
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 646,
                    "highlight": 659
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81866294"
        },
        "1583": {
            "name": "sock_sendmsg",
            "parent_idx": 1582,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n2330",
                    "code": [
                        "static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,",
                        "\t\t\t   unsigned int flags, struct used_address *used_address,",
                        "\t\t\t   unsigned int allowed_msghdr_flags)",
                        "{",
                        "\tunsigned char ctl[sizeof(struct cmsghdr) + 20]",
                        "\t\t\t\t__aligned(sizeof(__kernel_size_t));",
                        "\t/* 20 is size of ipv6_pktinfo */",
                        "\tunsigned char *ctl_buf = ctl;",
                        "\tint ctl_len;",
                        "\tssize_t err;",
                        "",
                        "\terr = -ENOBUFS;",
                        "",
                        "\tif (msg_sys->msg_controllen > INT_MAX)",
                        "\t\tgoto out;",
                        "\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);",
                        "\tctl_len = msg_sys->msg_controllen;",
                        "\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
                        "\t\terr =",
                        "\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,",
                        "\t\t\t\t\t\t     sizeof(ctl));",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t\tctl_buf = msg_sys->msg_control;",
                        "\t\tctl_len = msg_sys->msg_controllen;",
                        "\t} else if (ctl_len) {",
                        "\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=",
                        "\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));",
                        "\t\tif (ctl_len > sizeof(ctl)) {",
                        "\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);",
                        "\t\t\tif (ctl_buf == NULL)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\terr = -EFAULT;",
                        "\t\t/*",
                        "\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.",
                        "\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted",
                        "\t\t * checking falls down on this.",
                        "\t\t */",
                        "\t\tif (copy_from_user(ctl_buf,",
                        "\t\t\t\t   (void __user __force *)msg_sys->msg_control,",
                        "\t\t\t\t   ctl_len))",
                        "\t\t\tgoto out_freectl;",
                        "\t\tmsg_sys->msg_control = ctl_buf;",
                        "\t}",
                        "\tmsg_sys->msg_flags = flags;",
                        "",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;",
                        "\t/*",
                        "\t * If this is sendmmsg() and current destination address is same as",
                        "\t * previously succeeded address, omit asking LSM's decision.",
                        "\t * used_address->name_len is initialized to UINT_MAX so that the first",
                        "\t * destination address never matches.",
                        "\t */",
                        "\tif (used_address && msg_sys->msg_name &&",
                        "\t    used_address->name_len == msg_sys->msg_namelen &&",
                        "\t    !memcmp(&used_address->name, msg_sys->msg_name,",
                        "\t\t    used_address->name_len)) {",
                        "\t\terr = sock_sendmsg_nosec(sock, msg_sys);",
                        "\t\tgoto out_freectl;",
                        "\t}",
                        "\terr = sock_sendmsg(sock, msg_sys);",
                        "\t/*",
                        "\t * If this is sendmmsg() and sending to current destination address was",
                        "\t * successful, remember it.",
                        "\t */",
                        "\tif (used_address && err >= 0) {",
                        "\t\tused_address->name_len = msg_sys->msg_namelen;",
                        "\t\tif (msg_sys->msg_name)",
                        "\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,",
                        "\t\t\t       used_address->name_len);",
                        "\t}",
                        "",
                        "out_freectl:",
                        "\tif (ctl_buf != ctl)",
                        "\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2268,
                    "highlight": 2330
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818665a9"
        },
        "1582": {
            "name": "____sys_sendmsg",
            "parent_idx": 1581,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n2384",
                    "code": [
                        "\terr = ____sys_sendmsg(sock, msg_sys, flags, used_address,",
                        "\t\t\t\tallowed_msghdr_flags);",
                        "\tkfree(iov);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2384,
                    "highlight": 2384
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81866f32"
        },
        "1581": {
            "name": "___sys_sendmsg",
            "parent_idx": 1580,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n2417",
                    "code": [
                        "\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);",
                        "",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2417,
                    "highlight": 2417
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81868fff"
        },
        "1580": {
            "name": "__sys_sendmsg(indirect)",
            "parent_idx": 1579,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n294",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 281,
                    "highlight": 294
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff810027c9"
        },
        "1579": {
            "name": "do_syscall_64",
            "parent_idx": 1578,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=51d69817519f5f00041a1a039277f0367d76c82c#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "1578": {
            "name": "37_syscall_6",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1629": {
            "name": "+0xc",
            "parent_idx": 1628,
            "source_line": [
                {
                    "file": "net/netfilter/nft_tunnel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nft_tunnel.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n79",
                    "code": [
                        "static int nft_tunnel_get_init(const struct nft_ctx *ctx,",
                        "\t\t\t       const struct nft_expr *expr,",
                        "\t\t\t       const struct nlattr * const tb[])",
                        "{",
                        "\tstruct nft_tunnel *priv = nft_expr_priv(expr);",
                        "\tu32 len;",
                        "",
                        "\tif (!tb[NFTA_TUNNEL_KEY] &&",
                        "\t    !tb[NFTA_TUNNEL_DREG])",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tpriv->key = ntohl(nla_get_be32(tb[NFTA_TUNNEL_KEY]));",
                        "\tswitch (priv->key) {",
                        "\tcase NFT_TUNNEL_PATH:",
                        "\t\tlen = sizeof(u8);",
                        "\t\tbreak;",
                        "\tcase NFT_TUNNEL_ID:",
                        "\t\tlen = sizeof(u32);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\treturn -EOPNOTSUPP;",
                        "\t}",
                        "",
                        "\tpriv->dreg = nft_parse_register(tb[NFTA_TUNNEL_DREG]);",
                        "",
                        "\tif (tb[NFTA_TUNNEL_MODE]) {",
                        "\t\tpriv->mode = ntohl(nla_get_be32(tb[NFTA_TUNNEL_MODE]));",
                        "\t\tif (priv->mode > NFT_TUNNEL_MODE_MAX)",
                        "\t\t\treturn -EOPNOTSUPP;",
                        "\t} else {",
                        "\t\tpriv->mode = NFT_TUNNEL_MODE_NONE;",
                        "\t}",
                        "",
                        "\treturn nft_validate_register_store(ctx, priv->dreg, NULL,",
                        "\t\t\t\t\t   NFT_DATA_VALUE, len);",
                        "}"
                    ],
                    "start": 72,
                    "highlight": 79
                }
            ],
            "ins_idx": 18,
            "addr": "0xffffffff8190fd4c"
        },
        "1623": {
            "name": "+0x72",
            "parent_idx": 1618,
            "source_line": [
                {
                    "file": "arch/x86/lib/memset_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/lib/memset_64.S?id=51d69817519f5f00041a1a039277f0367d76c82c#n114",
                    "code": [
                        "SYM_FUNC_START_LOCAL(memset_orig)",
                        "\tmovq %rdi,%r10",
                        "",
                        "\t/* expand byte value  */",
                        "\tmovzbl %sil,%ecx",
                        "\tmovabs $0x0101010101010101,%rax",
                        "\timulq  %rcx,%rax",
                        "",
                        "\t/* align dst */",
                        "\tmovl  %edi,%r9d",
                        "\tandl  $7,%r9d",
                        "\tjnz  .Lbad_alignment",
                        ".Lafter_bad_alignment:",
                        "",
                        "\tmovq  %rdx,%rcx",
                        "\tshrq  $6,%rcx",
                        "\tjz\t .Lhandle_tail",
                        "",
                        "\t.p2align 4",
                        ".Lloop_64:",
                        "\tdecq  %rcx",
                        "\tmovq  %rax,(%rdi)",
                        "\tmovq  %rax,8(%rdi)",
                        "\tmovq  %rax,16(%rdi)",
                        "\tmovq  %rax,24(%rdi)",
                        "\tmovq  %rax,32(%rdi)",
                        "\tmovq  %rax,40(%rdi)",
                        "\tmovq  %rax,48(%rdi)",
                        "\tmovq  %rax,56(%rdi)",
                        "\tleaq  64(%rdi),%rdi",
                        "\tjnz    .Lloop_64",
                        "",
                        "\t/* Handle tail in loops. The loops should be faster than hard",
                        "\t   to predict jump tables. */",
                        "\t.p2align 4",
                        ".Lhandle_tail:",
                        "\tmovl\t%edx,%ecx",
                        "\tandl    $63&(~7),%ecx",
                        "\tjz \t\t.Lhandle_7",
                        "\tshrl\t$3,%ecx",
                        "\t.p2align 4",
                        ".Lloop_8:",
                        "\tdecl   %ecx",
                        "\tmovq  %rax,(%rdi)",
                        "\tleaq  8(%rdi),%rdi",
                        "\tjnz    .Lloop_8",
                        "",
                        ".Lhandle_7:",
                        "\tandl\t$7,%edx",
                        "\tjz      .Lende",
                        "\t.p2align 4",
                        ".Lloop_1:",
                        "\tdecl    %edx",
                        "\tmovb \t%al,(%rdi)",
                        "\tleaq\t1(%rdi),%rdi",
                        "\tjnz     .Lloop_1",
                        "",
                        ".Lende:",
                        "\tmovq\t%r10,%rax",
                        "\tret",
                        "",
                        ".Lbad_alignment:",
                        "\tcmpq $7,%rdx",
                        "\tjbe\t.Lhandle_7",
                        "\tmovq %rax,(%rdi)\t/* unaligned store */",
                        "\tmovq $8,%r8",
                        "\tsubq %r9,%r8",
                        "\taddq %r8,%rdi",
                        "\tsubq %r8,%rdx",
                        "\tjmp .Lafter_bad_alignment",
                        ".Lfinal:",
                        "SYM_FUNC_END(memset_orig)"
                    ],
                    "start": 71,
                    "highlight": 114
                }
            ],
            "ins_idx": 36,
            "addr": "0xffffffff81affbb2"
        },
        "1618": {
            "name": "memset",
            "parent_idx": 1611,
            "source_line": [
                {
                    "file": "lib/nlattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/nlattr.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n367",
                    "code": [
                        "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,",
                        "\t\t\t\tconst struct nla_policy *policy,",
                        "\t\t\t\tunsigned int validate,",
                        "\t\t\t\tstruct netlink_ext_ack *extack,",
                        "\t\t\t\tstruct nlattr **tb)",
                        "{",
                        "\tconst struct nlattr *nla;",
                        "\tint rem;",
                        "",
                        "\tif (tb)",
                        "\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));",
                        "",
                        "\tnla_for_each_attr(nla, head, len, rem) {",
                        "\t\tu16 type = nla_type(nla);",
                        "",
                        "\t\tif (type == 0 || type > maxtype) {",
                        "\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {",
                        "\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,",
                        "\t\t\t\t\t\t    \"Unknown attribute type\");",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t\tif (policy) {",
                        "\t\t\tint err = validate_nla(nla, maxtype, policy,",
                        "\t\t\t\t\t       validate, extack);",
                        "",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\treturn err;",
                        "\t\t}",
                        "",
                        "\t\tif (tb)",
                        "\t\t\ttb[type] = (struct nlattr *)nla;",
                        "\t}",
                        "",
                        "\tif (unlikely(rem > 0)) {",
                        "\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",",
                        "\t\t\t\t    rem, current->comm);",
                        "\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");",
                        "\t\tif (validate & NL_VALIDATE_TRAILING)",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 357,
                    "highlight": 367
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff813eaa2c"
        },
        "1611": {
            "name": "__nla_parse",
            "parent_idx": 1596,
            "source_line": [
                {
                    "file": "./include/net/netlink.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/netlink.h?id=51d69817519f5f00041a1a039277f0367d76c82c#n1166",
                    "code": [
                        "/**",
                        " * nla_parse_nested_deprecated - parse nested attributes",
                        " * @tb: destination array with maxtype+1 elements",
                        " * @maxtype: maximum attribute type to be expected",
                        " * @nla: attribute containing the nested attributes",
                        " * @policy: validation policy",
                        " * @extack: extended ACK report struct",
                        " *",
                        " * See nla_parse_deprecated()",
                        " */",
                        "static inline int nla_parse_nested_deprecated(struct nlattr *tb[], int maxtype,",
                        "\t\t\t\t\t      const struct nlattr *nla,",
                        "\t\t\t\t\t      const struct nla_policy *policy,",
                        "\t\t\t\t\t      struct netlink_ext_ack *extack)",
                        "{",
                        "\treturn __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,",
                        "\t\t\t   NL_VALIDATE_LIBERAL, extack);",
                        "}"
                    ],
                    "start": 1151,
                    "highlight": 1166
                },
                {
                    "file": "net/netfilter/nf_tables_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n2425",
                    "code": [
                        "static int nf_tables_expr_parse(const struct nft_ctx *ctx,",
                        "\t\t\t\tconst struct nlattr *nla,",
                        "\t\t\t\tstruct nft_expr_info *info)",
                        "{",
                        "\tconst struct nft_expr_type *type;",
                        "\tconst struct nft_expr_ops *ops;",
                        "\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];",
                        "\tint err;",
                        "",
                        "\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,",
                        "\t\t\t\t\t  nft_expr_policy, NULL);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\ttype = nft_expr_type_get(ctx->net, ctx->family, tb[NFTA_EXPR_NAME]);",
                        "\tif (IS_ERR(type))",
                        "\t\treturn PTR_ERR(type);",
                        "",
                        "\tif (tb[NFTA_EXPR_DATA]) {",
                        "\t\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,",
                        "\t\t\t\t\t\t  tb[NFTA_EXPR_DATA],",
                        "\t\t\t\t\t\t  type->policy, NULL);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err1;",
                        "\t} else",
                        "\t\tmemset(info->tb, 0, sizeof(info->tb[0]) * (type->maxattr + 1));",
                        "",
                        "\tif (type->select_ops != NULL) {",
                        "\t\tops = type->select_ops(ctx,",
                        "\t\t\t\t       (const struct nlattr * const *)info->tb);",
                        "\t\tif (IS_ERR(ops)) {",
                        "\t\t\terr = PTR_ERR(ops);",
                        "#ifdef CONFIG_MODULES",
                        "\t\t\tif (err == -EAGAIN)",
                        "\t\t\t\tnft_expr_type_request_module(ctx->net,",
                        "\t\t\t\t\t\t\t     ctx->family,",
                        "\t\t\t\t\t\t\t     tb[NFTA_EXPR_NAME]);",
                        "#endif",
                        "\t\t\tgoto err1;",
                        "\t\t}",
                        "\t} else",
                        "\t\tops = type->ops;",
                        "",
                        "\tinfo->ops = ops;",
                        "\treturn 0;",
                        "",
                        "err1:",
                        "\tmodule_put(type->owner);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2406,
                    "highlight": 2425
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81900b2e"
        },
        "1596": {
            "name": "nf_tables_expr_parse",
            "parent_idx": 1588,
            "source_line": [
                {
                    "file": "net/netfilter/nf_tables_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_tables_api.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n3037",
                    "code": [
                        "static int nf_tables_newrule(struct net *net, struct sock *nlsk,",
                        "\t\t\t     struct sk_buff *skb, const struct nlmsghdr *nlh,",
                        "\t\t\t     const struct nlattr * const nla[],",
                        "\t\t\t     struct netlink_ext_ack *extack)",
                        "{",
                        "\tconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);",
                        "\tu8 genmask = nft_genmask_next(net);",
                        "\tstruct nft_expr_info *info = NULL;",
                        "\tint family = nfmsg->nfgen_family;",
                        "\tstruct nft_flow_rule *flow;",
                        "\tstruct nft_table *table;",
                        "\tstruct nft_chain *chain;",
                        "\tstruct nft_rule *rule, *old_rule = NULL;",
                        "\tstruct nft_userdata *udata;",
                        "\tstruct nft_trans *trans = NULL;",
                        "\tstruct nft_expr *expr;",
                        "\tstruct nft_ctx ctx;",
                        "\tstruct nlattr *tmp;",
                        "\tunsigned int size, i, n, ulen = 0, usize = 0;",
                        "\tint err, rem;",
                        "\tu64 handle, pos_handle;",
                        "",
                        "\tlockdep_assert_held(&net->nft.commit_mutex);",
                        "",
                        "\ttable = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask);",
                        "\tif (IS_ERR(table)) {",
                        "\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);",
                        "\t\treturn PTR_ERR(table);",
                        "\t}",
                        "",
                        "\tchain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask);",
                        "\tif (IS_ERR(chain)) {",
                        "\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);",
                        "\t\treturn PTR_ERR(chain);",
                        "\t}",
                        "",
                        "\tif (nla[NFTA_RULE_HANDLE]) {",
                        "\t\thandle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));",
                        "\t\trule = __nft_rule_lookup(chain, handle);",
                        "\t\tif (IS_ERR(rule)) {",
                        "\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);",
                        "\t\t\treturn PTR_ERR(rule);",
                        "\t\t}",
                        "",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_EXCL) {",
                        "\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);",
                        "\t\t\treturn -EEXIST;",
                        "\t\t}",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_REPLACE)",
                        "\t\t\told_rule = rule;",
                        "\t\telse",
                        "\t\t\treturn -EOPNOTSUPP;",
                        "\t} else {",
                        "\t\tif (!(nlh->nlmsg_flags & NLM_F_CREATE) ||",
                        "\t\t    nlh->nlmsg_flags & NLM_F_REPLACE)",
                        "\t\t\treturn -EINVAL;",
                        "\t\thandle = nf_tables_alloc_handle(table);",
                        "",
                        "\t\tif (chain->use == UINT_MAX)",
                        "\t\t\treturn -EOVERFLOW;",
                        "",
                        "\t\tif (nla[NFTA_RULE_POSITION]) {",
                        "\t\t\tpos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));",
                        "\t\t\told_rule = __nft_rule_lookup(chain, pos_handle);",
                        "\t\t\tif (IS_ERR(old_rule)) {",
                        "\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);",
                        "\t\t\t\treturn PTR_ERR(old_rule);",
                        "\t\t\t}",
                        "\t\t} else if (nla[NFTA_RULE_POSITION_ID]) {",
                        "\t\t\told_rule = nft_rule_lookup_byid(net, nla[NFTA_RULE_POSITION_ID]);",
                        "\t\t\tif (IS_ERR(old_rule)) {",
                        "\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);",
                        "\t\t\t\treturn PTR_ERR(old_rule);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tnft_ctx_init(&ctx, net, skb, nlh, family, table, chain, nla);",
                        "",
                        "\tn = 0;",
                        "\tsize = 0;",
                        "\tif (nla[NFTA_RULE_EXPRESSIONS]) {",
                        "\t\tinfo = kvmalloc_array(NFT_RULE_MAXEXPRS,",
                        "\t\t\t\t      sizeof(struct nft_expr_info),",
                        "\t\t\t\t      GFP_KERNEL);",
                        "\t\tif (!info)",
                        "\t\t\treturn -ENOMEM;",
                        "",
                        "\t\tnla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) {",
                        "\t\t\terr = -EINVAL;",
                        "\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM)",
                        "\t\t\t\tgoto err1;",
                        "\t\t\tif (n == NFT_RULE_MAXEXPRS)",
                        "\t\t\t\tgoto err1;",
                        "\t\t\terr = nf_tables_expr_parse(&ctx, tmp, &info[n]);",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\tgoto err1;",
                        "\t\t\tsize += info[n].ops->size;",
                        "\t\t\tn++;",
                        "\t\t}",
                        "\t}",
                        "\t/* Check for overflow of dlen field */",
                        "\terr = -EFBIG;",
                        "\tif (size >= 1 << 12)",
                        "\t\tgoto err1;",
                        "",
                        "\tif (nla[NFTA_RULE_USERDATA]) {",
                        "\t\tulen = nla_len(nla[NFTA_RULE_USERDATA]);",
                        "\t\tif (ulen > 0)",
                        "\t\t\tusize = sizeof(struct nft_userdata) + ulen;",
                        "\t}",
                        "",
                        "\terr = -ENOMEM;",
                        "\trule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL);",
                        "\tif (rule == NULL)",
                        "\t\tgoto err1;",
                        "",
                        "\tnft_activate_next(net, rule);",
                        "",
                        "\trule->handle = handle;",
                        "\trule->dlen   = size;",
                        "\trule->udata  = ulen ? 1 : 0;",
                        "",
                        "\tif (ulen) {",
                        "\t\tudata = nft_userdata(rule);",
                        "\t\tudata->len = ulen - 1;",
                        "\t\tnla_memcpy(udata->data, nla[NFTA_RULE_USERDATA], ulen);",
                        "\t}",
                        "",
                        "\texpr = nft_expr_first(rule);",
                        "\tfor (i = 0; i < n; i++) {",
                        "\t\terr = nf_tables_newexpr(&ctx, &info[i], expr);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err2;",
                        "",
                        "\t\tif (info[i].ops->validate)",
                        "\t\t\tnft_validate_state_update(net, NFT_VALIDATE_NEED);",
                        "",
                        "\t\tinfo[i].ops = NULL;",
                        "\t\texpr = nft_expr_next(expr);",
                        "\t}",
                        "",
                        "\tif (nlh->nlmsg_flags & NLM_F_REPLACE) {",
                        "\t\ttrans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);",
                        "\t\tif (trans == NULL) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto err2;",
                        "\t\t}",
                        "\t\terr = nft_delrule(&ctx, old_rule);",
                        "\t\tif (err < 0) {",
                        "\t\t\tnft_trans_destroy(trans);",
                        "\t\t\tgoto err2;",
                        "\t\t}",
                        "",
                        "\t\tlist_add_tail_rcu(&rule->list, &old_rule->list);",
                        "\t} else {",
                        "\t\ttrans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);",
                        "\t\tif (!trans) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto err2;",
                        "\t\t}",
                        "",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_APPEND) {",
                        "\t\t\tif (old_rule)",
                        "\t\t\t\tlist_add_rcu(&rule->list, &old_rule->list);",
                        "\t\t\telse",
                        "\t\t\t\tlist_add_tail_rcu(&rule->list, &chain->rules);",
                        "\t\t } else {",
                        "\t\t\tif (old_rule)",
                        "\t\t\t\tlist_add_tail_rcu(&rule->list, &old_rule->list);",
                        "\t\t\telse",
                        "\t\t\t\tlist_add_rcu(&rule->list, &chain->rules);",
                        "\t\t}",
                        "\t}",
                        "\tkvfree(info);",
                        "\tchain->use++;",
                        "",
                        "\tif (net->nft.validate_state == NFT_VALIDATE_DO)",
                        "\t\treturn nft_table_validate(net, table);",
                        "",
                        "\tif (chain->flags & NFT_CHAIN_HW_OFFLOAD) {",
                        "\t\tflow = nft_flow_rule_create(net, rule);",
                        "\t\tif (IS_ERR(flow))",
                        "\t\t\treturn PTR_ERR(flow);",
                        "",
                        "\t\tnft_trans_flow_rule(trans) = flow;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "err2:",
                        "\tnf_tables_rule_release(&ctx, rule);",
                        "err1:",
                        "\tfor (i = 0; i < n; i++) {",
                        "\t\tif (info[i].ops) {",
                        "\t\t\tmodule_put(info[i].ops->type->owner);",
                        "\t\t\tif (info[i].ops->type->release_ops)",
                        "\t\t\t\tinfo[i].ops->type->release_ops(info[i].ops);",
                        "\t\t}",
                        "\t}",
                        "\tkvfree(info);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2943,
                    "highlight": 3037
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8190428c"
        },
        "1621": {
            "name": "+0x11",
            "parent_idx": 1618,
            "source_line": [
                {
                    "file": "arch/x86/lib/memset_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/lib/memset_64.S?id=51d69817519f5f00041a1a039277f0367d76c82c#n77",
                    "code": [
                        "SYM_FUNC_START_LOCAL(memset_orig)",
                        "\tmovq %rdi,%r10",
                        "",
                        "\t/* expand byte value  */",
                        "\tmovzbl %sil,%ecx",
                        "\tmovabs $0x0101010101010101,%rax",
                        "\timulq  %rcx,%rax",
                        "",
                        "\t/* align dst */",
                        "\tmovl  %edi,%r9d",
                        "\tandl  $7,%r9d",
                        "\tjnz  .Lbad_alignment",
                        ".Lafter_bad_alignment:",
                        "",
                        "\tmovq  %rdx,%rcx",
                        "\tshrq  $6,%rcx",
                        "\tjz\t .Lhandle_tail",
                        "",
                        "\t.p2align 4",
                        ".Lloop_64:",
                        "\tdecq  %rcx",
                        "\tmovq  %rax,(%rdi)",
                        "\tmovq  %rax,8(%rdi)",
                        "\tmovq  %rax,16(%rdi)",
                        "\tmovq  %rax,24(%rdi)",
                        "\tmovq  %rax,32(%rdi)",
                        "\tmovq  %rax,40(%rdi)",
                        "\tmovq  %rax,48(%rdi)",
                        "\tmovq  %rax,56(%rdi)",
                        "\tleaq  64(%rdi),%rdi",
                        "\tjnz    .Lloop_64",
                        "",
                        "\t/* Handle tail in loops. The loops should be faster than hard",
                        "\t   to predict jump tables. */",
                        "\t.p2align 4",
                        ".Lhandle_tail:",
                        "\tmovl\t%edx,%ecx",
                        "\tandl    $63&(~7),%ecx",
                        "\tjz \t\t.Lhandle_7",
                        "\tshrl\t$3,%ecx",
                        "\t.p2align 4",
                        ".Lloop_8:",
                        "\tdecl   %ecx",
                        "\tmovq  %rax,(%rdi)",
                        "\tleaq  8(%rdi),%rdi",
                        "\tjnz    .Lloop_8",
                        "",
                        ".Lhandle_7:",
                        "\tandl\t$7,%edx",
                        "\tjz      .Lende",
                        "\t.p2align 4",
                        ".Lloop_1:",
                        "\tdecl    %edx",
                        "\tmovb \t%al,(%rdi)",
                        "\tleaq\t1(%rdi),%rdi",
                        "\tjnz     .Lloop_1",
                        "",
                        ".Lende:",
                        "\tmovq\t%r10,%rax",
                        "\tret",
                        "",
                        ".Lbad_alignment:",
                        "\tcmpq $7,%rdx",
                        "\tjbe\t.Lhandle_7",
                        "\tmovq %rax,(%rdi)\t/* unaligned store */",
                        "\tmovq $8,%r8",
                        "\tsubq %r9,%r8",
                        "\taddq %r8,%rdi",
                        "\tsubq %r8,%rdx",
                        "\tjmp .Lafter_bad_alignment",
                        ".Lfinal:",
                        "SYM_FUNC_END(memset_orig)"
                    ],
                    "start": 71,
                    "highlight": 77
                }
            ],
            "ins_idx": 61,
            "addr": "0xffffffff81affb51"
        },
        "1619": {
            "name": "+0x3",
            "parent_idx": 1618,
            "source_line": [
                {
                    "file": "arch/x86/lib/memset_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/lib/memset_64.S?id=51d69817519f5f00041a1a039277f0367d76c82c#n75",
                    "code": [
                        "SYM_FUNC_START_LOCAL(memset_orig)",
                        "\tmovq %rdi,%r10",
                        "",
                        "\t/* expand byte value  */",
                        "\tmovzbl %sil,%ecx",
                        "\tmovabs $0x0101010101010101,%rax",
                        "\timulq  %rcx,%rax",
                        "",
                        "\t/* align dst */",
                        "\tmovl  %edi,%r9d",
                        "\tandl  $7,%r9d",
                        "\tjnz  .Lbad_alignment",
                        ".Lafter_bad_alignment:",
                        "",
                        "\tmovq  %rdx,%rcx",
                        "\tshrq  $6,%rcx",
                        "\tjz\t .Lhandle_tail",
                        "",
                        "\t.p2align 4",
                        ".Lloop_64:",
                        "\tdecq  %rcx",
                        "\tmovq  %rax,(%rdi)",
                        "\tmovq  %rax,8(%rdi)",
                        "\tmovq  %rax,16(%rdi)",
                        "\tmovq  %rax,24(%rdi)",
                        "\tmovq  %rax,32(%rdi)",
                        "\tmovq  %rax,40(%rdi)",
                        "\tmovq  %rax,48(%rdi)",
                        "\tmovq  %rax,56(%rdi)",
                        "\tleaq  64(%rdi),%rdi",
                        "\tjnz    .Lloop_64",
                        "",
                        "\t/* Handle tail in loops. The loops should be faster than hard",
                        "\t   to predict jump tables. */",
                        "\t.p2align 4",
                        ".Lhandle_tail:",
                        "\tmovl\t%edx,%ecx",
                        "\tandl    $63&(~7),%ecx",
                        "\tjz \t\t.Lhandle_7",
                        "\tshrl\t$3,%ecx",
                        "\t.p2align 4",
                        ".Lloop_8:",
                        "\tdecl   %ecx",
                        "\tmovq  %rax,(%rdi)",
                        "\tleaq  8(%rdi),%rdi",
                        "\tjnz    .Lloop_8",
                        "",
                        ".Lhandle_7:",
                        "\tandl\t$7,%edx",
                        "\tjz      .Lende",
                        "\t.p2align 4",
                        ".Lloop_1:",
                        "\tdecl    %edx",
                        "\tmovb \t%al,(%rdi)",
                        "\tleaq\t1(%rdi),%rdi",
                        "\tjnz     .Lloop_1",
                        "",
                        ".Lende:",
                        "\tmovq\t%r10,%rax",
                        "\tret",
                        "",
                        ".Lbad_alignment:",
                        "\tcmpq $7,%rdx",
                        "\tjbe\t.Lhandle_7",
                        "\tmovq %rax,(%rdi)\t/* unaligned store */",
                        "\tmovq $8,%r8",
                        "\tsubq %r9,%r8",
                        "\taddq %r8,%rdi",
                        "\tsubq %r8,%rdx",
                        "\tjmp .Lafter_bad_alignment",
                        ".Lfinal:",
                        "SYM_FUNC_END(memset_orig)"
                    ],
                    "start": 71,
                    "highlight": 75
                }
            ],
            "ins_idx": 93,
            "addr": "0xffffffff81affb43"
        },
        "1616": {
            "name": "+0x40",
            "parent_idx": 1611,
            "source_line": [
                {
                    "file": "lib/nlattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/nlattr.c?id=51d69817519f5f00041a1a039277f0367d76c82c#n367",
                    "code": [
                        "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,",
                        "\t\t\t\tconst struct nla_policy *policy,",
                        "\t\t\t\tunsigned int validate,",
                        "\t\t\t\tstruct netlink_ext_ack *extack,",
                        "\t\t\t\tstruct nlattr **tb)",
                        "{",
                        "\tconst struct nlattr *nla;",
                        "\tint rem;",
                        "",
                        "\tif (tb)",
                        "\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));",
                        "",
                        "\tnla_for_each_attr(nla, head, len, rem) {",
                        "\t\tu16 type = nla_type(nla);",
                        "",
                        "\t\tif (type == 0 || type > maxtype) {",
                        "\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {",
                        "\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,",
                        "\t\t\t\t\t\t    \"Unknown attribute type\");",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t\tif (policy) {",
                        "\t\t\tint err = validate_nla(nla, maxtype, policy,",
                        "\t\t\t\t\t       validate, extack);",
                        "",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\treturn err;",
                        "\t\t}",
                        "",
                        "\t\tif (tb)",
                        "\t\t\ttb[type] = (struct nlattr *)nla;",
                        "\t}",
                        "",
                        "\tif (unlikely(rem > 0)) {",
                        "\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",",
                        "\t\t\t\t    rem, current->comm);",
                        "\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");",
                        "\t\tif (validate & NL_VALIDATE_TRAILING)",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 357,
                    "highlight": 367
                }
            ],
            "ins_idx": 136,
            "addr": "0xffffffff813eaa20"
        }
    },
    "ins": {
        "1": {
            "name": "mov eax, dword ptr [rax + 4]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x4",
            "call_idx": 1630,
            "inputs": [
                3021,
                3022
            ],
            "outputs": [
                3023
            ]
        },
        "18": {
            "name": "mov rax, qword ptr [rdx + 8]",
            "desc": "",
            "call_idx": 1629,
            "inputs": [
                3018,
                3019
            ],
            "outputs": [
                3020
            ]
        },
        "36": {
            "name": "mov qword ptr [rdi], rax",
            "desc": "",
            "call_idx": 1623,
            "inputs": [
                3007,
                3008
            ],
            "outputs": [
                3009
            ]
        },
        "61": {
            "name": "imul rax, rcx",
            "desc": "",
            "call_idx": 1621,
            "inputs": [
                3002,
                3003
            ],
            "outputs": [
                3004
            ]
        },
        "93": {
            "name": "movzx ecx, sil",
            "desc": "",
            "call_idx": 1619,
            "inputs": [
                2999
            ],
            "outputs": [
                3000
            ]
        },
        "136": {
            "name": "xor esi, esi",
            "desc": "Source of base address CONST 0x0",
            "call_idx": 1616,
            "inputs": [
                2994,
                2995
            ],
            "outputs": [
                2996
            ]
        }
    },
    "data": {
        "3021": {
            "name": "RAX",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "3022": {
            "name": "[0x4]",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "3023": {
            "name": "RAX",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "3018": {
            "name": "RDX",
            "ins_idx": 18,
            "value": "0xffff888234e20008",
            "sources": []
        },
        "3019": {
            "name": "[0xffff888234e20010]",
            "ins_idx": 18,
            "value": "0x0",
            "sources": []
        },
        "3020": {
            "name": "RAX",
            "ins_idx": 18,
            "value": "0x0",
            "sources": [
                3021
            ]
        },
        "3007": {
            "name": "RAX",
            "ins_idx": 36,
            "value": "0x0",
            "sources": []
        },
        "3008": {
            "name": "RDI",
            "ins_idx": 36,
            "value": "0xffff888234e20010",
            "sources": []
        },
        "3009": {
            "name": "[0xffff888234e20010]",
            "ins_idx": 36,
            "value": "0x0",
            "sources": [
                3019
            ]
        },
        "3002": {
            "name": "RCX",
            "ins_idx": 61,
            "value": "0x0",
            "sources": []
        },
        "3003": {
            "name": "RAX",
            "ins_idx": 61,
            "value": "0x101010101010101",
            "sources": []
        },
        "3004": {
            "name": "RAX",
            "ins_idx": 61,
            "value": "0x0",
            "sources": [
                3007
            ]
        },
        "2999": {
            "name": "RSI",
            "ins_idx": 93,
            "value": "0x0",
            "sources": []
        },
        "3000": {
            "name": "RCX",
            "ins_idx": 93,
            "value": "0x0",
            "sources": [
                3002
            ]
        },
        "2994": {
            "name": "RSI",
            "ins_idx": 136,
            "value": "0x0",
            "sources": []
        },
        "2995": {
            "name": "RSI",
            "ins_idx": 136,
            "value": "0x0",
            "sources": []
        },
        "2996": {
            "name": "RSI",
            "ins_idx": 136,
            "value": "0x0",
            "sources": [
                2999
            ]
        }
    },
    "chain": {
        "1": [
            18
        ],
        "18": [
            36
        ],
        "36": [
            61
        ],
        "61": [
            93
        ],
        "93": [
            136
        ]
    }
}