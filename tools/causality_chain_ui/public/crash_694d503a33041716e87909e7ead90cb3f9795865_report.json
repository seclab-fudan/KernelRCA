{
    "report": "https://syzkaller.appspot.com/bug?id=694d503a33041716e87909e7ead90cb3f9795865",
    "title": "KASAN: slab-out-of-bounds Read in bpf_int_jit_compile",
    "call": {
        "1238": {
            "name": "+0x18ef",
            "parent_idx": 1205,
            "source_line": [
                {
                    "file": "arch/x86/net/bpf_jit_comp.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/net/bpf_jit_comp.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n966",
                    "code": [
                        "static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,",
                        "\t\t  int oldproglen, struct jit_context *ctx)",
                        "{",
                        "\tstruct bpf_insn *insn = bpf_prog->insnsi;",
                        "\tint insn_cnt = bpf_prog->len;",
                        "\tbool seen_exit = false;",
                        "\tu8 temp[BPF_MAX_INSN_SIZE + BPF_INSN_SAFETY];",
                        "\tint i, cnt = 0;",
                        "\tint proglen = 0;",
                        "\tu8 *prog = temp;",
                        "",
                        "\temit_prologue(&prog, bpf_prog->aux->stack_depth,",
                        "\t\t      bpf_prog_was_classic(bpf_prog));",
                        "",
                        "\tfor (i = 0; i < insn_cnt; i++, insn++) {",
                        "\t\tconst s32 imm32 = insn->imm;",
                        "\t\tu32 dst_reg = insn->dst_reg;",
                        "\t\tu32 src_reg = insn->src_reg;",
                        "\t\tu8 b2 = 0, b3 = 0;",
                        "\t\ts64 jmp_offset;",
                        "\t\tu8 jmp_cond;",
                        "\t\tint ilen;",
                        "\t\tu8 *func;",
                        "",
                        "\t\tswitch (insn->code) {",
                        "\t\t\t/* ALU */",
                        "\t\tcase BPF_ALU | BPF_ADD | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_SUB | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_AND | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_OR | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_XOR | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_ADD | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_SUB | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_AND | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_OR | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_XOR | BPF_X:",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_ADD: b2 = 0x01; break;",
                        "\t\t\tcase BPF_SUB: b2 = 0x29; break;",
                        "\t\t\tcase BPF_AND: b2 = 0x21; break;",
                        "\t\t\tcase BPF_OR: b2 = 0x09; break;",
                        "\t\t\tcase BPF_XOR: b2 = 0x31; break;",
                        "\t\t\t}",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(b2, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU64 | BPF_MOV | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_MOV | BPF_X:",
                        "\t\t\temit_mov_reg(&prog,",
                        "\t\t\t\t     BPF_CLASS(insn->code) == BPF_ALU64,",
                        "\t\t\t\t     dst_reg, src_reg);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* neg dst */",
                        "\t\tcase BPF_ALU | BPF_NEG:",
                        "\t\tcase BPF_ALU64 | BPF_NEG:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "\t\t\tEMIT2(0xF7, add_1reg(0xD8, dst_reg));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_ADD | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_SUB | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_AND | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_OR | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_XOR | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_ADD | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_SUB | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_AND | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_OR | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_XOR | BPF_K:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\t/*",
                        "\t\t\t * b3 holds 'normal' opcode, b2 short form only valid",
                        "\t\t\t * in case dst is eax/rax.",
                        "\t\t\t */",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_ADD:",
                        "\t\t\t\tb3 = 0xC0;",
                        "\t\t\t\tb2 = 0x05;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_SUB:",
                        "\t\t\t\tb3 = 0xE8;",
                        "\t\t\t\tb2 = 0x2D;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_AND:",
                        "\t\t\t\tb3 = 0xE0;",
                        "\t\t\t\tb2 = 0x25;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_OR:",
                        "\t\t\t\tb3 = 0xC8;",
                        "\t\t\t\tb2 = 0x0D;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_XOR:",
                        "\t\t\t\tb3 = 0xF0;",
                        "\t\t\t\tb2 = 0x35;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (is_imm8(imm32))",
                        "\t\t\t\tEMIT3(0x83, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\telse if (is_axreg(dst_reg))",
                        "\t\t\t\tEMIT1_off32(b2, imm32);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2_off32(0x81, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU64 | BPF_MOV | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_MOV | BPF_K:",
                        "\t\t\temit_mov_imm32(&prog, BPF_CLASS(insn->code) == BPF_ALU64,",
                        "\t\t\t\t       dst_reg, imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_LD | BPF_IMM | BPF_DW:",
                        "\t\t\temit_mov_imm64(&prog, dst_reg, insn[1].imm, insn[0].imm);",
                        "\t\t\tinsn++;",
                        "\t\t\ti++;",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* dst %= src, dst /= src, dst %= imm32, dst /= imm32 */",
                        "\t\tcase BPF_ALU | BPF_MOD | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_DIV | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_MOD | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_DIV | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_MOD | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_DIV | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_MOD | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_DIV | BPF_K:",
                        "\t\t\tEMIT1(0x50); /* push rax */",
                        "\t\t\tEMIT1(0x52); /* push rdx */",
                        "",
                        "\t\t\tif (BPF_SRC(insn->code) == BPF_X)",
                        "\t\t\t\t/* mov r11, src_reg */",
                        "\t\t\t\tEMIT_mov(AUX_REG, src_reg);",
                        "\t\t\telse",
                        "\t\t\t\t/* mov r11, imm32 */",
                        "\t\t\t\tEMIT3_off32(0x49, 0xC7, 0xC3, imm32);",
                        "",
                        "\t\t\t/* mov rax, dst_reg */",
                        "\t\t\tEMIT_mov(BPF_REG_0, dst_reg);",
                        "",
                        "\t\t\t/*",
                        "\t\t\t * xor edx, edx",
                        "\t\t\t * equivalent to 'xor rdx, rdx', but one byte less",
                        "\t\t\t */",
                        "\t\t\tEMIT2(0x31, 0xd2);",
                        "",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\t/* div r11 */",
                        "\t\t\t\tEMIT3(0x49, 0xF7, 0xF3);",
                        "\t\t\telse",
                        "\t\t\t\t/* div r11d */",
                        "\t\t\t\tEMIT3(0x41, 0xF7, 0xF3);",
                        "",
                        "\t\t\tif (BPF_OP(insn->code) == BPF_MOD)",
                        "\t\t\t\t/* mov r11, rdx */",
                        "\t\t\t\tEMIT3(0x49, 0x89, 0xD3);",
                        "\t\t\telse",
                        "\t\t\t\t/* mov r11, rax */",
                        "\t\t\t\tEMIT3(0x49, 0x89, 0xC3);",
                        "",
                        "\t\t\tEMIT1(0x5A); /* pop rdx */",
                        "\t\t\tEMIT1(0x58); /* pop rax */",
                        "",
                        "\t\t\t/* mov dst_reg, r11 */",
                        "\t\t\tEMIT_mov(dst_reg, AUX_REG);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_MUL | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_MUL | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_MUL | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_MUL | BPF_X:",
                        "\t\t{",
                        "\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;",
                        "",
                        "\t\t\tif (dst_reg != BPF_REG_0)",
                        "\t\t\t\tEMIT1(0x50); /* push rax */",
                        "\t\t\tif (dst_reg != BPF_REG_3)",
                        "\t\t\t\tEMIT1(0x52); /* push rdx */",
                        "",
                        "\t\t\t/* mov r11, dst_reg */",
                        "\t\t\tEMIT_mov(AUX_REG, dst_reg);",
                        "",
                        "\t\t\tif (BPF_SRC(insn->code) == BPF_X)",
                        "\t\t\t\temit_mov_reg(&prog, is64, BPF_REG_0, src_reg);",
                        "\t\t\telse",
                        "\t\t\t\temit_mov_imm32(&prog, is64, BPF_REG_0, imm32);",
                        "",
                        "\t\t\tif (is64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, AUX_REG));",
                        "\t\t\telse if (is_ereg(AUX_REG))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, AUX_REG));",
                        "\t\t\t/* mul(q) r11 */",
                        "\t\t\tEMIT2(0xF7, add_1reg(0xE0, AUX_REG));",
                        "",
                        "\t\t\tif (dst_reg != BPF_REG_3)",
                        "\t\t\t\tEMIT1(0x5A); /* pop rdx */",
                        "\t\t\tif (dst_reg != BPF_REG_0) {",
                        "\t\t\t\t/* mov dst_reg, rax */",
                        "\t\t\t\tEMIT_mov(dst_reg, BPF_REG_0);",
                        "\t\t\t\tEMIT1(0x58); /* pop rax */",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\t\t/* Shifts */",
                        "\t\tcase BPF_ALU | BPF_LSH | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_RSH | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_ARSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_LSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_RSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_ARSH | BPF_K:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_LSH: b3 = 0xE0; break;",
                        "\t\t\tcase BPF_RSH: b3 = 0xE8; break;",
                        "\t\t\tcase BPF_ARSH: b3 = 0xF8; break;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (imm32 == 1)",
                        "\t\t\t\tEMIT2(0xD1, add_1reg(b3, dst_reg));",
                        "\t\t\telse",
                        "\t\t\t\tEMIT3(0xC1, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_LSH | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_RSH | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_ARSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_LSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_RSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_ARSH | BPF_X:",
                        "",
                        "\t\t\t/* Check for bad case when dst_reg == rcx */",
                        "\t\t\tif (dst_reg == BPF_REG_4) {",
                        "\t\t\t\t/* mov r11, dst_reg */",
                        "\t\t\t\tEMIT_mov(AUX_REG, dst_reg);",
                        "\t\t\t\tdst_reg = AUX_REG;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (src_reg != BPF_REG_4) { /* common case */",
                        "\t\t\t\tEMIT1(0x51); /* push rcx */",
                        "",
                        "\t\t\t\t/* mov rcx, src_reg */",
                        "\t\t\t\tEMIT_mov(BPF_REG_4, src_reg);",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* shl %rax, %cl | shr %rax, %cl | sar %rax, %cl */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_LSH: b3 = 0xE0; break;",
                        "\t\t\tcase BPF_RSH: b3 = 0xE8; break;",
                        "\t\t\tcase BPF_ARSH: b3 = 0xF8; break;",
                        "\t\t\t}",
                        "\t\t\tEMIT2(0xD3, add_1reg(b3, dst_reg));",
                        "",
                        "\t\t\tif (src_reg != BPF_REG_4)",
                        "\t\t\t\tEMIT1(0x59); /* pop rcx */",
                        "",
                        "\t\t\tif (insn->dst_reg == BPF_REG_4)",
                        "\t\t\t\t/* mov dst_reg, r11 */",
                        "\t\t\t\tEMIT_mov(insn->dst_reg, AUX_REG);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_END | BPF_FROM_BE:",
                        "\t\t\tswitch (imm32) {",
                        "\t\t\tcase 16:",
                        "\t\t\t\t/* Emit 'ror %ax, 8' to swap lower 2 bytes */",
                        "\t\t\t\tEMIT1(0x66);",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT1(0x41);",
                        "\t\t\t\tEMIT3(0xC1, add_1reg(0xC8, dst_reg), 8);",
                        "",
                        "\t\t\t\t/* Emit 'movzwl eax, ax' */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT3(0x45, 0x0F, 0xB7);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT2(0x0F, 0xB7);",
                        "\t\t\t\tEMIT1(add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 32:",
                        "\t\t\t\t/* Emit 'bswap eax' to swap lower 4 bytes */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT2(0x41, 0x0F);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT1(0x0F);",
                        "\t\t\t\tEMIT1(add_1reg(0xC8, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 64:",
                        "\t\t\t\t/* Emit 'bswap rax' to swap 8 bytes */",
                        "\t\t\t\tEMIT3(add_1mod(0x48, dst_reg), 0x0F,",
                        "\t\t\t\t      add_1reg(0xC8, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_END | BPF_FROM_LE:",
                        "\t\t\tswitch (imm32) {",
                        "\t\t\tcase 16:",
                        "\t\t\t\t/*",
                        "\t\t\t\t * Emit 'movzwl eax, ax' to zero extend 16-bit",
                        "\t\t\t\t * into 64 bit",
                        "\t\t\t\t */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT3(0x45, 0x0F, 0xB7);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT2(0x0F, 0xB7);",
                        "\t\t\t\tEMIT1(add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 32:",
                        "\t\t\t\t/* Emit 'mov eax, eax' to clear upper 32-bits */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT1(0x45);",
                        "\t\t\t\tEMIT2(0x89, add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 64:",
                        "\t\t\t\t/* nop */",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* ST: *(u8*)(dst_reg + off) = imm */",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_B:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT2(0x41, 0xC6);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0xC6);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_H:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT3(0x66, 0x41, 0xC7);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0x66, 0xC7);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_W:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT2(0x41, 0xC7);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0xC7);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_DW:",
                        "\t\t\tEMIT2(add_1mod(0x48, dst_reg), 0xC7);",
                        "",
                        "st:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_1reg(0x40, dst_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_1reg(0x80, dst_reg), insn->off);",
                        "",
                        "\t\t\tEMIT(imm32, bpf_size_to_x86_bytes(BPF_SIZE(insn->code)));",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* STX: *(u8*)(dst_reg + off) = src_reg */",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_B:",
                        "\t\t\t/* Emit 'mov byte ptr [rax + off], al' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg) ||",
                        "\t\t\t    /* We have to add extra byte for x86 SIL, DIL regs */",
                        "\t\t\t    src_reg == BPF_REG_1 || src_reg == BPF_REG_2)",
                        "\t\t\t\tEMIT2(add_2mod(0x40, dst_reg, src_reg), 0x88);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x88);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_H:",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT3(0x66, add_2mod(0x40, dst_reg, src_reg), 0x89);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0x66, 0x89);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_W:",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT2(add_2mod(0x40, dst_reg, src_reg), 0x89);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x89);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_DW:",
                        "\t\t\tEMIT2(add_2mod(0x48, dst_reg, src_reg), 0x89);",
                        "stx:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, dst_reg, src_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* LDX: dst_reg = *(u8*)(src_reg + off) */",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_B:",
                        "\t\t\t/* Emit 'movzx rax, byte ptr [rax + off]' */",
                        "\t\t\tEMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB6);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_H:",
                        "\t\t\t/* Emit 'movzx rax, word ptr [rax + off]' */",
                        "\t\t\tEMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB7);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_W:",
                        "\t\t\t/* Emit 'mov eax, dword ptr [rax+0x14]' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT2(add_2mod(0x40, src_reg, dst_reg), 0x8B);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x8B);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_DW:",
                        "\t\t\t/* Emit 'mov rax, qword ptr [rax+0x14]' */",
                        "\t\t\tEMIT2(add_2mod(0x48, src_reg, dst_reg), 0x8B);",
                        "ldx:\t\t\t/*",
                        "\t\t\t * If insn->off == 0 we can save one extra byte, but",
                        "\t\t\t * special case of x86 R13 which always needs an offset",
                        "\t\t\t * is not worth the hassle",
                        "\t\t\t */",
                        "\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, src_reg, dst_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, src_reg, dst_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* STX XADD: lock *(u32*)(dst_reg + off) += src_reg */",
                        "\t\tcase BPF_STX | BPF_XADD | BPF_W:",
                        "\t\t\t/* Emit 'lock add dword ptr [rax + off], eax' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT3(0xF0, add_2mod(0x40, dst_reg, src_reg), 0x01);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0xF0, 0x01);",
                        "\t\t\tgoto xadd;",
                        "\t\tcase BPF_STX | BPF_XADD | BPF_DW:",
                        "\t\t\tEMIT3(0xF0, add_2mod(0x48, dst_reg, src_reg), 0x01);",
                        "xadd:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, dst_reg, src_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* call */",
                        "\t\tcase BPF_JMP | BPF_CALL:",
                        "\t\t\tfunc = (u8 *) __bpf_call_base + imm32;",
                        "\t\t\tjmp_offset = func - (image + addrs[i]);",
                        "\t\t\tif (!imm32 || !is_simm32(jmp_offset)) {",
                        "\t\t\t\tpr_err(\"unsupported BPF func %d addr %p image %p\\n\",",
                        "\t\t\t\t       imm32, func, image);",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t\tEMIT1_off32(0xE8, jmp_offset);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_TAIL_CALL:",
                        "\t\t\temit_bpf_tail_call(&prog);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* cond jump */",
                        "\t\tcase BPF_JMP | BPF_JEQ | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JNE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JGT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JLT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JGE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JLE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSGT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSLT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSGE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSLE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JEQ | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JNE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JGT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JLT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JGE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JLE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSGT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSLT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSGE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSLE | BPF_X:",
                        "\t\t\t/* cmp dst_reg, src_reg */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(0x39, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JSET | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSET | BPF_X:",
                        "\t\t\t/* test dst_reg, src_reg */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(0x85, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JSET | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSET | BPF_K:",
                        "\t\t\t/* test dst_reg, imm32 */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "\t\t\tEMIT2_off32(0xF7, add_1reg(0xC0, dst_reg), imm32);",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JEQ | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JNE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JGT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JLT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JGE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JLE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSGT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSLT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSGE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSLE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JEQ | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JNE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JGT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JLT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JGE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JLE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSGT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSLT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSGE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSLE | BPF_K:",
                        "\t\t\t/* cmp dst_reg, imm8/32 */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tif (is_imm8(imm32))",
                        "\t\t\t\tEMIT3(0x83, add_1reg(0xF8, dst_reg), imm32);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2_off32(0x81, add_1reg(0xF8, dst_reg), imm32);",
                        "",
                        "emit_cond_jmp:\t\t/* Convert BPF opcode to x86 */",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_JEQ:",
                        "\t\t\t\tjmp_cond = X86_JE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSET:",
                        "\t\t\tcase BPF_JNE:",
                        "\t\t\t\tjmp_cond = X86_JNE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JGT:",
                        "\t\t\t\t/* GT is unsigned '>', JA in x86 */",
                        "\t\t\t\tjmp_cond = X86_JA;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JLT:",
                        "\t\t\t\t/* LT is unsigned '<', JB in x86 */",
                        "\t\t\t\tjmp_cond = X86_JB;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JGE:",
                        "\t\t\t\t/* GE is unsigned '>=', JAE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JAE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JLE:",
                        "\t\t\t\t/* LE is unsigned '<=', JBE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JBE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSGT:",
                        "\t\t\t\t/* Signed '>', GT in x86 */",
                        "\t\t\t\tjmp_cond = X86_JG;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSLT:",
                        "\t\t\t\t/* Signed '<', LT in x86 */",
                        "\t\t\t\tjmp_cond = X86_JL;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSGE:",
                        "\t\t\t\t/* Signed '>=', GE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JGE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSLE:",
                        "\t\t\t\t/* Signed '<=', LE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JLE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tdefault: /* to silence GCC warning */",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tjmp_offset = addrs[i + insn->off] - addrs[i];",
                        "\t\t\tif (is_imm8(jmp_offset)) {",
                        "\t\t\t\tEMIT2(jmp_cond, jmp_offset);",
                        "\t\t\t} else if (is_simm32(jmp_offset)) {",
                        "\t\t\t\tEMIT2_off32(0x0F, jmp_cond + 0x10, jmp_offset);",
                        "\t\t\t} else {",
                        "\t\t\t\tpr_err(\"cond_jmp gen bug %llx\\n\", jmp_offset);",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JA:",
                        "\t\t\tif (insn->off == -1)",
                        "\t\t\t\t/* -1 jmp instructions will always jump",
                        "\t\t\t\t * backwards two bytes. Explicitly handling",
                        "\t\t\t\t * this case avoids wasting too many passes",
                        "\t\t\t\t * when there are long sequences of replaced",
                        "\t\t\t\t * dead code.",
                        "\t\t\t\t */",
                        "\t\t\t\tjmp_offset = -2;",
                        "\t\t\telse",
                        "\t\t\t\tjmp_offset = addrs[i + insn->off] - addrs[i];",
                        "",
                        "\t\t\tif (!jmp_offset)",
                        "\t\t\t\t/* Optimize out nop jumps */",
                        "\t\t\t\tbreak;",
                        "emit_jmp:",
                        "\t\t\tif (is_imm8(jmp_offset)) {",
                        "\t\t\t\tEMIT2(0xEB, jmp_offset);",
                        "\t\t\t} else if (is_simm32(jmp_offset)) {",
                        "\t\t\t\tEMIT1_off32(0xE9, jmp_offset);",
                        "\t\t\t} else {",
                        "\t\t\t\tpr_err(\"jmp gen bug %llx\\n\", jmp_offset);",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_EXIT:",
                        "\t\t\tif (seen_exit) {",
                        "\t\t\t\tjmp_offset = ctx->cleanup_addr - addrs[i];",
                        "\t\t\t\tgoto emit_jmp;",
                        "\t\t\t}",
                        "\t\t\tseen_exit = true;",
                        "\t\t\t/* Update cleanup_addr */",
                        "\t\t\tctx->cleanup_addr = proglen;",
                        "\t\t\tif (!bpf_prog_was_classic(bpf_prog))",
                        "\t\t\t\tEMIT1(0x5B); /* get rid of tail_call_cnt */",
                        "\t\t\tEMIT2(0x41, 0x5F);   /* pop r15 */",
                        "\t\t\tEMIT2(0x41, 0x5E);   /* pop r14 */",
                        "\t\t\tEMIT2(0x41, 0x5D);   /* pop r13 */",
                        "\t\t\tEMIT1(0x5B);         /* pop rbx */",
                        "\t\t\tEMIT1(0xC9);         /* leave */",
                        "\t\t\tEMIT1(0xC3);         /* ret */",
                        "\t\t\tbreak;",
                        "",
                        "\t\tdefault:",
                        "\t\t\t/*",
                        "\t\t\t * By design x86-64 JIT should support all BPF instructions.",
                        "\t\t\t * This error will be seen if new instruction was added",
                        "\t\t\t * to the interpreter, but not to the JIT, or if there is",
                        "\t\t\t * junk in bpf_prog.",
                        "\t\t\t */",
                        "\t\t\tpr_err(\"bpf_jit: unknown opcode %02x\\n\", insn->code);",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "",
                        "\t\tilen = prog - temp;",
                        "\t\tif (ilen > BPF_MAX_INSN_SIZE) {",
                        "\t\t\tpr_err(\"bpf_jit: fatal insn size error\\n\");",
                        "\t\t\treturn -EFAULT;",
                        "\t\t}",
                        "",
                        "\t\tif (image) {",
                        "\t\t\tif (unlikely(proglen + ilen > oldproglen)) {",
                        "\t\t\t\tpr_err(\"bpf_jit: fatal error\\n\");",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tmemcpy(image + proglen, temp, ilen);",
                        "\t\t}",
                        "\t\tproglen += ilen;",
                        "\t\taddrs[i] = proglen;",
                        "\t\tprog = temp;",
                        "\t}",
                        "\treturn proglen;",
                        "}"
                    ],
                    "start": 380,
                    "highlight": 966
                }
            ],
            "ins_idx": 13,
            "addr": "0xffffffff8109d12f"
        },
        "1205": {
            "name": "do_jit",
            "parent_idx": 1187,
            "source_line": [
                {
                    "file": "arch/x86/net/bpf_jit_comp.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/net/bpf_jit_comp.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n1132",
                    "code": [
                        "struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)",
                        "{",
                        "\tstruct bpf_binary_header *header = NULL;",
                        "\tstruct bpf_prog *tmp, *orig_prog = prog;",
                        "\tstruct x64_jit_data *jit_data;",
                        "\tint proglen, oldproglen = 0;",
                        "\tstruct jit_context ctx = {};",
                        "\tbool tmp_blinded = false;",
                        "\tbool extra_pass = false;",
                        "\tu8 *image = NULL;",
                        "\tint *addrs;",
                        "\tint pass;",
                        "\tint i;",
                        "",
                        "\tif (!prog->jit_requested)",
                        "\t\treturn orig_prog;",
                        "",
                        "\ttmp = bpf_jit_blind_constants(prog);",
                        "\t/*",
                        "\t * If blinding was requested and we failed during blinding,",
                        "\t * we must fall back to the interpreter.",
                        "\t */",
                        "\tif (IS_ERR(tmp))",
                        "\t\treturn orig_prog;",
                        "\tif (tmp != prog) {",
                        "\t\ttmp_blinded = true;",
                        "\t\tprog = tmp;",
                        "\t}",
                        "",
                        "\tjit_data = prog->aux->jit_data;",
                        "\tif (!jit_data) {",
                        "\t\tjit_data = kzalloc(sizeof(*jit_data), GFP_KERNEL);",
                        "\t\tif (!jit_data) {",
                        "\t\t\tprog = orig_prog;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tprog->aux->jit_data = jit_data;",
                        "\t}",
                        "\taddrs = jit_data->addrs;",
                        "\tif (addrs) {",
                        "\t\tctx = jit_data->ctx;",
                        "\t\toldproglen = jit_data->proglen;",
                        "\t\timage = jit_data->image;",
                        "\t\theader = jit_data->header;",
                        "\t\textra_pass = true;",
                        "\t\tgoto skip_init_addrs;",
                        "\t}",
                        "\taddrs = kmalloc_array(prog->len, sizeof(*addrs), GFP_KERNEL);",
                        "\tif (!addrs) {",
                        "\t\tprog = orig_prog;",
                        "\t\tgoto out_addrs;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Before first pass, make a rough estimation of addrs[]",
                        "\t * each BPF instruction is translated to less than 64 bytes",
                        "\t */",
                        "\tfor (proglen = 0, i = 0; i < prog->len; i++) {",
                        "\t\tproglen += 64;",
                        "\t\taddrs[i] = proglen;",
                        "\t}",
                        "\tctx.cleanup_addr = proglen;",
                        "skip_init_addrs:",
                        "",
                        "\t/*",
                        "\t * JITed image shrinks with every pass and the loop iterates",
                        "\t * until the image stops shrinking. Very large BPF programs",
                        "\t * may converge on the last pass. In such case do one more",
                        "\t * pass to emit the final image.",
                        "\t */",
                        "\tfor (pass = 0; pass < 20 || image; pass++) {",
                        "\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);",
                        "\t\tif (proglen <= 0) {",
                        "out_image:",
                        "\t\t\timage = NULL;",
                        "\t\t\tif (header)",
                        "\t\t\t\tbpf_jit_binary_free(header);",
                        "\t\t\tprog = orig_prog;",
                        "\t\t\tgoto out_addrs;",
                        "\t\t}",
                        "\t\tif (image) {",
                        "\t\t\tif (proglen != oldproglen) {",
                        "\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",",
                        "\t\t\t\t       proglen, oldproglen);",
                        "\t\t\t\tgoto out_image;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (proglen == oldproglen) {",
                        "\t\t\theader = bpf_jit_binary_alloc(proglen, &image,",
                        "\t\t\t\t\t\t      1, jit_fill_hole);",
                        "\t\t\tif (!header) {",
                        "\t\t\t\tprog = orig_prog;",
                        "\t\t\t\tgoto out_addrs;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\toldproglen = proglen;",
                        "\t\tcond_resched();",
                        "\t}",
                        "",
                        "\tif (bpf_jit_enable > 1)",
                        "\t\tbpf_jit_dump(prog->len, proglen, pass + 1, image);",
                        "",
                        "\tif (image) {",
                        "\t\tif (!prog->is_func || extra_pass) {",
                        "\t\t\tbpf_jit_binary_lock_ro(header);",
                        "\t\t} else {",
                        "\t\t\tjit_data->addrs = addrs;",
                        "\t\t\tjit_data->ctx = ctx;",
                        "\t\t\tjit_data->proglen = proglen;",
                        "\t\t\tjit_data->image = image;",
                        "\t\t\tjit_data->header = header;",
                        "\t\t}",
                        "\t\tprog->bpf_func = (void *)image;",
                        "\t\tprog->jited = 1;",
                        "\t\tprog->jited_len = proglen;",
                        "\t} else {",
                        "\t\tprog = orig_prog;",
                        "\t}",
                        "",
                        "\tif (!image || !prog->is_func || extra_pass) {",
                        "\t\tif (image)",
                        "\t\t\tbpf_prog_fill_jited_linfo(prog, addrs);",
                        "out_addrs:",
                        "\t\tkfree(addrs);",
                        "\t\tkfree(jit_data);",
                        "\t\tprog->aux->jit_data = NULL;",
                        "\t}",
                        "out:",
                        "\tif (tmp_blinded)",
                        "\t\tbpf_jit_prog_release_other(prog, prog == orig_prog ?",
                        "\t\t\t\t\t   tmp : orig_prog);",
                        "\treturn prog;",
                        "}"
                    ],
                    "start": 1061,
                    "highlight": 1132
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8109e394"
        },
        "1187": {
            "name": "bpf_int_jit_compile",
            "parent_idx": 1184,
            "source_line": [
                {
                    "file": "kernel/bpf/core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/core.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n1725",
                    "code": [
                        "/**",
                        " *\tbpf_prog_select_runtime - select exec runtime for BPF program",
                        " *\t@fp: bpf_prog populated with internal BPF program",
                        " *\t@err: pointer to error variable",
                        " *",
                        " * Try to JIT eBPF program, if JIT is not available, use interpreter.",
                        " * The BPF program will be executed via BPF_PROG_RUN() macro.",
                        " */",
                        "struct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err)",
                        "{",
                        "\t/* In case of BPF to BPF calls, verifier did all the prep",
                        "\t * work with regards to JITing, etc.",
                        "\t */",
                        "\tif (fp->bpf_func)",
                        "\t\tgoto finalize;",
                        "",
                        "\tbpf_prog_select_func(fp);",
                        "",
                        "\t/* eBPF JITs can rewrite the program in case constant",
                        "\t * blinding is active. However, in case of error during",
                        "\t * blinding, bpf_int_jit_compile() must always return a",
                        "\t * valid program, which in this case would simply not",
                        "\t * be JITed, but falls back to the interpreter.",
                        "\t */",
                        "\tif (!bpf_prog_is_dev_bound(fp->aux)) {",
                        "\t\t*err = bpf_prog_alloc_jited_linfo(fp);",
                        "\t\tif (*err)",
                        "\t\t\treturn fp;",
                        "",
                        "\t\tfp = bpf_int_jit_compile(fp);",
                        "\t\tif (!fp->jited) {",
                        "\t\t\tbpf_prog_free_jited_linfo(fp);",
                        "#ifdef CONFIG_BPF_JIT_ALWAYS_ON",
                        "\t\t\t*err = -ENOTSUPP;",
                        "\t\t\treturn fp;",
                        "#endif",
                        "\t\t} else {",
                        "\t\t\tbpf_prog_free_unused_jited_linfo(fp);",
                        "\t\t}",
                        "\t} else {",
                        "\t\t*err = bpf_prog_offload_compile(fp);",
                        "\t\tif (*err)",
                        "\t\t\treturn fp;",
                        "\t}",
                        "",
                        "finalize:",
                        "\tbpf_prog_lock_ro(fp);",
                        "",
                        "\t/* The tail call compatibility check can only be done at",
                        "\t * this late stage as we need to determine, if we deal",
                        "\t * with JITed or non JITed program concatenations and not",
                        "\t * all eBPF JITs might immediately support all features.",
                        "\t */",
                        "\t*err = bpf_check_tail_call(fp);",
                        "",
                        "\treturn fp;",
                        "}"
                    ],
                    "start": 1696,
                    "highlight": 1725
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8121f2f8"
        },
        "1184": {
            "name": "bpf_prog_select_runtime",
            "parent_idx": 42,
            "source_line": [
                {
                    "file": "kernel/bpf/syscall.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/syscall.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n1702",
                    "code": [
                        "static int bpf_prog_load(union bpf_attr *attr, union bpf_attr __user *uattr)",
                        "{",
                        "\tenum bpf_prog_type type = attr->prog_type;",
                        "\tstruct bpf_prog *prog;",
                        "\tint err;",
                        "\tchar license[128];",
                        "\tbool is_gpl;",
                        "",
                        "\tif (CHECK_ATTR(BPF_PROG_LOAD))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (attr->prog_flags & ~(BPF_F_STRICT_ALIGNMENT |",
                        "\t\t\t\t BPF_F_ANY_ALIGNMENT |",
                        "\t\t\t\t BPF_F_TEST_RND_HI32))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) &&",
                        "\t    (attr->prog_flags & BPF_F_ANY_ALIGNMENT) &&",
                        "\t    !capable(CAP_SYS_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\t/* copy eBPF program license from user space */",
                        "\tif (strncpy_from_user(license, u64_to_user_ptr(attr->license),",
                        "\t\t\t      sizeof(license) - 1) < 0)",
                        "\t\treturn -EFAULT;",
                        "\tlicense[sizeof(license) - 1] = 0;",
                        "",
                        "\t/* eBPF programs must be GPL compatible to use GPL-ed functions */",
                        "\tis_gpl = license_is_gpl_compatible(license);",
                        "",
                        "\tif (attr->insn_cnt == 0 ||",
                        "\t    attr->insn_cnt > (capable(CAP_SYS_ADMIN) ? BPF_COMPLEXITY_LIMIT_INSNS : BPF_MAXINSNS))",
                        "\t\treturn -E2BIG;",
                        "\tif (type != BPF_PROG_TYPE_SOCKET_FILTER &&",
                        "\t    type != BPF_PROG_TYPE_CGROUP_SKB &&",
                        "\t    !capable(CAP_SYS_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\tbpf_prog_load_fixup_attach_type(attr);",
                        "\tif (bpf_prog_load_check_attach_type(type, attr->expected_attach_type))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\t/* plain bpf_prog allocation */",
                        "\tprog = bpf_prog_alloc(bpf_prog_size(attr->insn_cnt), GFP_USER);",
                        "\tif (!prog)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tprog->expected_attach_type = attr->expected_attach_type;",
                        "",
                        "\tprog->aux->offload_requested = !!attr->prog_ifindex;",
                        "",
                        "\terr = security_bpf_prog_alloc(prog->aux);",
                        "\tif (err)",
                        "\t\tgoto free_prog_nouncharge;",
                        "",
                        "\terr = bpf_prog_charge_memlock(prog);",
                        "\tif (err)",
                        "\t\tgoto free_prog_sec;",
                        "",
                        "\tprog->len = attr->insn_cnt;",
                        "",
                        "\terr = -EFAULT;",
                        "\tif (copy_from_user(prog->insns, u64_to_user_ptr(attr->insns),",
                        "\t\t\t   bpf_prog_insn_size(prog)) != 0)",
                        "\t\tgoto free_prog;",
                        "",
                        "\tprog->orig_prog = NULL;",
                        "\tprog->jited = 0;",
                        "",
                        "\tatomic_set(&prog->aux->refcnt, 1);",
                        "\tprog->gpl_compatible = is_gpl ? 1 : 0;",
                        "",
                        "\tif (bpf_prog_is_dev_bound(prog->aux)) {",
                        "\t\terr = bpf_prog_offload_init(prog, attr);",
                        "\t\tif (err)",
                        "\t\t\tgoto free_prog;",
                        "\t}",
                        "",
                        "\t/* find program type: socket_filter vs tracing_filter */",
                        "\terr = find_prog_type(type, prog);",
                        "\tif (err < 0)",
                        "\t\tgoto free_prog;",
                        "",
                        "\tprog->aux->load_time = ktime_get_boottime_ns();",
                        "\terr = bpf_obj_name_cpy(prog->aux->name, attr->prog_name);",
                        "\tif (err)",
                        "\t\tgoto free_prog;",
                        "",
                        "\t/* run eBPF verifier */",
                        "\terr = bpf_check(&prog, attr, uattr);",
                        "\tif (err < 0)",
                        "\t\tgoto free_used_maps;",
                        "",
                        "\tprog = bpf_prog_select_runtime(prog, &err);",
                        "\tif (err < 0)",
                        "\t\tgoto free_used_maps;",
                        "",
                        "\terr = bpf_prog_alloc_id(prog);",
                        "\tif (err)",
                        "\t\tgoto free_used_maps;",
                        "",
                        "\terr = bpf_prog_new_fd(prog);",
                        "\tif (err < 0) {",
                        "\t\t/* failed to allocate fd.",
                        "\t\t * bpf_prog_put() is needed because the above",
                        "\t\t * bpf_prog_alloc_id() has published the prog",
                        "\t\t * to the userspace and the userspace may",
                        "\t\t * have refcnt-ed it through BPF_PROG_GET_FD_BY_ID.",
                        "\t\t */",
                        "\t\tbpf_prog_put(prog);",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\tbpf_prog_kallsyms_add(prog);",
                        "\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_LOAD, 0);",
                        "\treturn err;",
                        "",
                        "free_used_maps:",
                        "\tbpf_prog_free_linfo(prog);",
                        "\tkvfree(prog->aux->func_info);",
                        "\tbtf_put(prog->aux->btf);",
                        "\tbpf_prog_kallsyms_del_subprogs(prog);",
                        "\tfree_used_maps(prog->aux);",
                        "free_prog:",
                        "\tbpf_prog_uncharge_memlock(prog);",
                        "free_prog_sec:",
                        "\tsecurity_bpf_prog_free(prog->aux);",
                        "free_prog_nouncharge:",
                        "\tbpf_prog_free(prog);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1609,
                    "highlight": 1702
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812229e4"
        },
        "42": {
            "name": "bpf_prog_load",
            "parent_idx": 11,
            "source_line": [
                {
                    "file": "kernel/bpf/syscall.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/syscall.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n2849",
                    "code": [
                        "SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)",
                        "{",
                        "\tunion bpf_attr attr = {};",
                        "\tint err;",
                        "",
                        "\tif (sysctl_unprivileged_bpf_disabled && !capable(CAP_SYS_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\terr = bpf_check_uarg_tail_zero(uattr, sizeof(attr), size);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\tsize = min_t(u32, size, sizeof(attr));",
                        "",
                        "\t/* copy attributes from user space, may be less than sizeof(bpf_attr) */",
                        "\tif (copy_from_user(&attr, uattr, size) != 0)",
                        "\t\treturn -EFAULT;",
                        "",
                        "\terr = security_bpf(cmd, &attr, size);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase BPF_MAP_CREATE:",
                        "\t\terr = map_create(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_LOOKUP_ELEM:",
                        "\t\terr = map_lookup_elem(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_UPDATE_ELEM:",
                        "\t\terr = map_update_elem(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_DELETE_ELEM:",
                        "\t\terr = map_delete_elem(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_GET_NEXT_KEY:",
                        "\t\terr = map_get_next_key(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_FREEZE:",
                        "\t\terr = map_freeze(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_LOAD:",
                        "\t\terr = bpf_prog_load(&attr, uattr);",
                        "\t\tbreak;",
                        "\tcase BPF_OBJ_PIN:",
                        "\t\terr = bpf_obj_pin(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_OBJ_GET:",
                        "\t\terr = bpf_obj_get(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_ATTACH:",
                        "\t\terr = bpf_prog_attach(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_DETACH:",
                        "\t\terr = bpf_prog_detach(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_QUERY:",
                        "\t\terr = bpf_prog_query(&attr, uattr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_TEST_RUN:",
                        "\t\terr = bpf_prog_test_run(&attr, uattr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_GET_NEXT_ID:",
                        "\t\terr = bpf_obj_get_next_id(&attr, uattr,",
                        "\t\t\t\t\t  &prog_idr, &prog_idr_lock);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_GET_NEXT_ID:",
                        "\t\terr = bpf_obj_get_next_id(&attr, uattr,",
                        "\t\t\t\t\t  &map_idr, &map_idr_lock);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_GET_FD_BY_ID:",
                        "\t\terr = bpf_prog_get_fd_by_id(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_GET_FD_BY_ID:",
                        "\t\terr = bpf_map_get_fd_by_id(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_OBJ_GET_INFO_BY_FD:",
                        "\t\terr = bpf_obj_get_info_by_fd(&attr, uattr);",
                        "\t\tbreak;",
                        "\tcase BPF_RAW_TRACEPOINT_OPEN:",
                        "\t\terr = bpf_raw_tracepoint_open(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_BTF_LOAD:",
                        "\t\terr = bpf_btf_load(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_BTF_GET_FD_BY_ID:",
                        "\t\terr = bpf_btf_get_fd_by_id(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_TASK_FD_QUERY:",
                        "\t\terr = bpf_task_fd_query(&attr, uattr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_LOOKUP_AND_DELETE_ELEM:",
                        "\t\terr = map_lookup_and_delete_elem(&attr);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\terr = -EINVAL;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2808,
                    "highlight": 2849
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81223187"
        },
        "11": {
            "name": "__x64_sys_bpf(indirect)",
            "parent_idx": 8,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n296",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\t/*",
                        "\t * NB: Native and x32 syscalls are dispatched from the same",
                        "\t * table.  The only functional difference is the x32 bit in",
                        "\t * regs->orig_ax, which changes the behavior of some syscalls.",
                        "\t */",
                        "\tnr &= __SYSCALL_MASK;",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 277,
                    "highlight": 296
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81003cf9"
        },
        "8": {
            "name": "do_syscall_64",
            "parent_idx": 2,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n175",
                    "code": [
                        "ENTRY(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "GLOBAL(entry_SYSCALL_64_after_hwframe)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "2": {
            "name": "58_syscall_2",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1237": {
            "name": "+0x18e0",
            "parent_idx": 1205,
            "source_line": [
                {
                    "file": "arch/x86/net/bpf_jit_comp.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/net/bpf_jit_comp.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n966",
                    "code": [
                        "static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,",
                        "\t\t  int oldproglen, struct jit_context *ctx)",
                        "{",
                        "\tstruct bpf_insn *insn = bpf_prog->insnsi;",
                        "\tint insn_cnt = bpf_prog->len;",
                        "\tbool seen_exit = false;",
                        "\tu8 temp[BPF_MAX_INSN_SIZE + BPF_INSN_SAFETY];",
                        "\tint i, cnt = 0;",
                        "\tint proglen = 0;",
                        "\tu8 *prog = temp;",
                        "",
                        "\temit_prologue(&prog, bpf_prog->aux->stack_depth,",
                        "\t\t      bpf_prog_was_classic(bpf_prog));",
                        "",
                        "\tfor (i = 0; i < insn_cnt; i++, insn++) {",
                        "\t\tconst s32 imm32 = insn->imm;",
                        "\t\tu32 dst_reg = insn->dst_reg;",
                        "\t\tu32 src_reg = insn->src_reg;",
                        "\t\tu8 b2 = 0, b3 = 0;",
                        "\t\ts64 jmp_offset;",
                        "\t\tu8 jmp_cond;",
                        "\t\tint ilen;",
                        "\t\tu8 *func;",
                        "",
                        "\t\tswitch (insn->code) {",
                        "\t\t\t/* ALU */",
                        "\t\tcase BPF_ALU | BPF_ADD | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_SUB | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_AND | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_OR | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_XOR | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_ADD | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_SUB | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_AND | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_OR | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_XOR | BPF_X:",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_ADD: b2 = 0x01; break;",
                        "\t\t\tcase BPF_SUB: b2 = 0x29; break;",
                        "\t\t\tcase BPF_AND: b2 = 0x21; break;",
                        "\t\t\tcase BPF_OR: b2 = 0x09; break;",
                        "\t\t\tcase BPF_XOR: b2 = 0x31; break;",
                        "\t\t\t}",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(b2, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU64 | BPF_MOV | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_MOV | BPF_X:",
                        "\t\t\temit_mov_reg(&prog,",
                        "\t\t\t\t     BPF_CLASS(insn->code) == BPF_ALU64,",
                        "\t\t\t\t     dst_reg, src_reg);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* neg dst */",
                        "\t\tcase BPF_ALU | BPF_NEG:",
                        "\t\tcase BPF_ALU64 | BPF_NEG:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "\t\t\tEMIT2(0xF7, add_1reg(0xD8, dst_reg));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_ADD | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_SUB | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_AND | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_OR | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_XOR | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_ADD | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_SUB | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_AND | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_OR | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_XOR | BPF_K:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\t/*",
                        "\t\t\t * b3 holds 'normal' opcode, b2 short form only valid",
                        "\t\t\t * in case dst is eax/rax.",
                        "\t\t\t */",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_ADD:",
                        "\t\t\t\tb3 = 0xC0;",
                        "\t\t\t\tb2 = 0x05;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_SUB:",
                        "\t\t\t\tb3 = 0xE8;",
                        "\t\t\t\tb2 = 0x2D;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_AND:",
                        "\t\t\t\tb3 = 0xE0;",
                        "\t\t\t\tb2 = 0x25;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_OR:",
                        "\t\t\t\tb3 = 0xC8;",
                        "\t\t\t\tb2 = 0x0D;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_XOR:",
                        "\t\t\t\tb3 = 0xF0;",
                        "\t\t\t\tb2 = 0x35;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (is_imm8(imm32))",
                        "\t\t\t\tEMIT3(0x83, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\telse if (is_axreg(dst_reg))",
                        "\t\t\t\tEMIT1_off32(b2, imm32);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2_off32(0x81, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU64 | BPF_MOV | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_MOV | BPF_K:",
                        "\t\t\temit_mov_imm32(&prog, BPF_CLASS(insn->code) == BPF_ALU64,",
                        "\t\t\t\t       dst_reg, imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_LD | BPF_IMM | BPF_DW:",
                        "\t\t\temit_mov_imm64(&prog, dst_reg, insn[1].imm, insn[0].imm);",
                        "\t\t\tinsn++;",
                        "\t\t\ti++;",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* dst %= src, dst /= src, dst %= imm32, dst /= imm32 */",
                        "\t\tcase BPF_ALU | BPF_MOD | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_DIV | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_MOD | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_DIV | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_MOD | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_DIV | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_MOD | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_DIV | BPF_K:",
                        "\t\t\tEMIT1(0x50); /* push rax */",
                        "\t\t\tEMIT1(0x52); /* push rdx */",
                        "",
                        "\t\t\tif (BPF_SRC(insn->code) == BPF_X)",
                        "\t\t\t\t/* mov r11, src_reg */",
                        "\t\t\t\tEMIT_mov(AUX_REG, src_reg);",
                        "\t\t\telse",
                        "\t\t\t\t/* mov r11, imm32 */",
                        "\t\t\t\tEMIT3_off32(0x49, 0xC7, 0xC3, imm32);",
                        "",
                        "\t\t\t/* mov rax, dst_reg */",
                        "\t\t\tEMIT_mov(BPF_REG_0, dst_reg);",
                        "",
                        "\t\t\t/*",
                        "\t\t\t * xor edx, edx",
                        "\t\t\t * equivalent to 'xor rdx, rdx', but one byte less",
                        "\t\t\t */",
                        "\t\t\tEMIT2(0x31, 0xd2);",
                        "",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\t/* div r11 */",
                        "\t\t\t\tEMIT3(0x49, 0xF7, 0xF3);",
                        "\t\t\telse",
                        "\t\t\t\t/* div r11d */",
                        "\t\t\t\tEMIT3(0x41, 0xF7, 0xF3);",
                        "",
                        "\t\t\tif (BPF_OP(insn->code) == BPF_MOD)",
                        "\t\t\t\t/* mov r11, rdx */",
                        "\t\t\t\tEMIT3(0x49, 0x89, 0xD3);",
                        "\t\t\telse",
                        "\t\t\t\t/* mov r11, rax */",
                        "\t\t\t\tEMIT3(0x49, 0x89, 0xC3);",
                        "",
                        "\t\t\tEMIT1(0x5A); /* pop rdx */",
                        "\t\t\tEMIT1(0x58); /* pop rax */",
                        "",
                        "\t\t\t/* mov dst_reg, r11 */",
                        "\t\t\tEMIT_mov(dst_reg, AUX_REG);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_MUL | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_MUL | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_MUL | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_MUL | BPF_X:",
                        "\t\t{",
                        "\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;",
                        "",
                        "\t\t\tif (dst_reg != BPF_REG_0)",
                        "\t\t\t\tEMIT1(0x50); /* push rax */",
                        "\t\t\tif (dst_reg != BPF_REG_3)",
                        "\t\t\t\tEMIT1(0x52); /* push rdx */",
                        "",
                        "\t\t\t/* mov r11, dst_reg */",
                        "\t\t\tEMIT_mov(AUX_REG, dst_reg);",
                        "",
                        "\t\t\tif (BPF_SRC(insn->code) == BPF_X)",
                        "\t\t\t\temit_mov_reg(&prog, is64, BPF_REG_0, src_reg);",
                        "\t\t\telse",
                        "\t\t\t\temit_mov_imm32(&prog, is64, BPF_REG_0, imm32);",
                        "",
                        "\t\t\tif (is64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, AUX_REG));",
                        "\t\t\telse if (is_ereg(AUX_REG))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, AUX_REG));",
                        "\t\t\t/* mul(q) r11 */",
                        "\t\t\tEMIT2(0xF7, add_1reg(0xE0, AUX_REG));",
                        "",
                        "\t\t\tif (dst_reg != BPF_REG_3)",
                        "\t\t\t\tEMIT1(0x5A); /* pop rdx */",
                        "\t\t\tif (dst_reg != BPF_REG_0) {",
                        "\t\t\t\t/* mov dst_reg, rax */",
                        "\t\t\t\tEMIT_mov(dst_reg, BPF_REG_0);",
                        "\t\t\t\tEMIT1(0x58); /* pop rax */",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\t\t/* Shifts */",
                        "\t\tcase BPF_ALU | BPF_LSH | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_RSH | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_ARSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_LSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_RSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_ARSH | BPF_K:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_LSH: b3 = 0xE0; break;",
                        "\t\t\tcase BPF_RSH: b3 = 0xE8; break;",
                        "\t\t\tcase BPF_ARSH: b3 = 0xF8; break;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (imm32 == 1)",
                        "\t\t\t\tEMIT2(0xD1, add_1reg(b3, dst_reg));",
                        "\t\t\telse",
                        "\t\t\t\tEMIT3(0xC1, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_LSH | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_RSH | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_ARSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_LSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_RSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_ARSH | BPF_X:",
                        "",
                        "\t\t\t/* Check for bad case when dst_reg == rcx */",
                        "\t\t\tif (dst_reg == BPF_REG_4) {",
                        "\t\t\t\t/* mov r11, dst_reg */",
                        "\t\t\t\tEMIT_mov(AUX_REG, dst_reg);",
                        "\t\t\t\tdst_reg = AUX_REG;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (src_reg != BPF_REG_4) { /* common case */",
                        "\t\t\t\tEMIT1(0x51); /* push rcx */",
                        "",
                        "\t\t\t\t/* mov rcx, src_reg */",
                        "\t\t\t\tEMIT_mov(BPF_REG_4, src_reg);",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* shl %rax, %cl | shr %rax, %cl | sar %rax, %cl */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_LSH: b3 = 0xE0; break;",
                        "\t\t\tcase BPF_RSH: b3 = 0xE8; break;",
                        "\t\t\tcase BPF_ARSH: b3 = 0xF8; break;",
                        "\t\t\t}",
                        "\t\t\tEMIT2(0xD3, add_1reg(b3, dst_reg));",
                        "",
                        "\t\t\tif (src_reg != BPF_REG_4)",
                        "\t\t\t\tEMIT1(0x59); /* pop rcx */",
                        "",
                        "\t\t\tif (insn->dst_reg == BPF_REG_4)",
                        "\t\t\t\t/* mov dst_reg, r11 */",
                        "\t\t\t\tEMIT_mov(insn->dst_reg, AUX_REG);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_END | BPF_FROM_BE:",
                        "\t\t\tswitch (imm32) {",
                        "\t\t\tcase 16:",
                        "\t\t\t\t/* Emit 'ror %ax, 8' to swap lower 2 bytes */",
                        "\t\t\t\tEMIT1(0x66);",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT1(0x41);",
                        "\t\t\t\tEMIT3(0xC1, add_1reg(0xC8, dst_reg), 8);",
                        "",
                        "\t\t\t\t/* Emit 'movzwl eax, ax' */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT3(0x45, 0x0F, 0xB7);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT2(0x0F, 0xB7);",
                        "\t\t\t\tEMIT1(add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 32:",
                        "\t\t\t\t/* Emit 'bswap eax' to swap lower 4 bytes */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT2(0x41, 0x0F);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT1(0x0F);",
                        "\t\t\t\tEMIT1(add_1reg(0xC8, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 64:",
                        "\t\t\t\t/* Emit 'bswap rax' to swap 8 bytes */",
                        "\t\t\t\tEMIT3(add_1mod(0x48, dst_reg), 0x0F,",
                        "\t\t\t\t      add_1reg(0xC8, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_END | BPF_FROM_LE:",
                        "\t\t\tswitch (imm32) {",
                        "\t\t\tcase 16:",
                        "\t\t\t\t/*",
                        "\t\t\t\t * Emit 'movzwl eax, ax' to zero extend 16-bit",
                        "\t\t\t\t * into 64 bit",
                        "\t\t\t\t */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT3(0x45, 0x0F, 0xB7);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT2(0x0F, 0xB7);",
                        "\t\t\t\tEMIT1(add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 32:",
                        "\t\t\t\t/* Emit 'mov eax, eax' to clear upper 32-bits */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT1(0x45);",
                        "\t\t\t\tEMIT2(0x89, add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 64:",
                        "\t\t\t\t/* nop */",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* ST: *(u8*)(dst_reg + off) = imm */",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_B:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT2(0x41, 0xC6);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0xC6);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_H:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT3(0x66, 0x41, 0xC7);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0x66, 0xC7);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_W:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT2(0x41, 0xC7);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0xC7);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_DW:",
                        "\t\t\tEMIT2(add_1mod(0x48, dst_reg), 0xC7);",
                        "",
                        "st:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_1reg(0x40, dst_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_1reg(0x80, dst_reg), insn->off);",
                        "",
                        "\t\t\tEMIT(imm32, bpf_size_to_x86_bytes(BPF_SIZE(insn->code)));",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* STX: *(u8*)(dst_reg + off) = src_reg */",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_B:",
                        "\t\t\t/* Emit 'mov byte ptr [rax + off], al' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg) ||",
                        "\t\t\t    /* We have to add extra byte for x86 SIL, DIL regs */",
                        "\t\t\t    src_reg == BPF_REG_1 || src_reg == BPF_REG_2)",
                        "\t\t\t\tEMIT2(add_2mod(0x40, dst_reg, src_reg), 0x88);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x88);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_H:",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT3(0x66, add_2mod(0x40, dst_reg, src_reg), 0x89);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0x66, 0x89);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_W:",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT2(add_2mod(0x40, dst_reg, src_reg), 0x89);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x89);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_DW:",
                        "\t\t\tEMIT2(add_2mod(0x48, dst_reg, src_reg), 0x89);",
                        "stx:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, dst_reg, src_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* LDX: dst_reg = *(u8*)(src_reg + off) */",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_B:",
                        "\t\t\t/* Emit 'movzx rax, byte ptr [rax + off]' */",
                        "\t\t\tEMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB6);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_H:",
                        "\t\t\t/* Emit 'movzx rax, word ptr [rax + off]' */",
                        "\t\t\tEMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB7);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_W:",
                        "\t\t\t/* Emit 'mov eax, dword ptr [rax+0x14]' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT2(add_2mod(0x40, src_reg, dst_reg), 0x8B);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x8B);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_DW:",
                        "\t\t\t/* Emit 'mov rax, qword ptr [rax+0x14]' */",
                        "\t\t\tEMIT2(add_2mod(0x48, src_reg, dst_reg), 0x8B);",
                        "ldx:\t\t\t/*",
                        "\t\t\t * If insn->off == 0 we can save one extra byte, but",
                        "\t\t\t * special case of x86 R13 which always needs an offset",
                        "\t\t\t * is not worth the hassle",
                        "\t\t\t */",
                        "\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, src_reg, dst_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, src_reg, dst_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* STX XADD: lock *(u32*)(dst_reg + off) += src_reg */",
                        "\t\tcase BPF_STX | BPF_XADD | BPF_W:",
                        "\t\t\t/* Emit 'lock add dword ptr [rax + off], eax' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT3(0xF0, add_2mod(0x40, dst_reg, src_reg), 0x01);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0xF0, 0x01);",
                        "\t\t\tgoto xadd;",
                        "\t\tcase BPF_STX | BPF_XADD | BPF_DW:",
                        "\t\t\tEMIT3(0xF0, add_2mod(0x48, dst_reg, src_reg), 0x01);",
                        "xadd:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, dst_reg, src_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* call */",
                        "\t\tcase BPF_JMP | BPF_CALL:",
                        "\t\t\tfunc = (u8 *) __bpf_call_base + imm32;",
                        "\t\t\tjmp_offset = func - (image + addrs[i]);",
                        "\t\t\tif (!imm32 || !is_simm32(jmp_offset)) {",
                        "\t\t\t\tpr_err(\"unsupported BPF func %d addr %p image %p\\n\",",
                        "\t\t\t\t       imm32, func, image);",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t\tEMIT1_off32(0xE8, jmp_offset);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_TAIL_CALL:",
                        "\t\t\temit_bpf_tail_call(&prog);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* cond jump */",
                        "\t\tcase BPF_JMP | BPF_JEQ | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JNE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JGT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JLT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JGE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JLE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSGT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSLT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSGE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSLE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JEQ | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JNE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JGT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JLT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JGE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JLE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSGT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSLT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSGE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSLE | BPF_X:",
                        "\t\t\t/* cmp dst_reg, src_reg */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(0x39, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JSET | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSET | BPF_X:",
                        "\t\t\t/* test dst_reg, src_reg */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(0x85, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JSET | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSET | BPF_K:",
                        "\t\t\t/* test dst_reg, imm32 */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "\t\t\tEMIT2_off32(0xF7, add_1reg(0xC0, dst_reg), imm32);",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JEQ | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JNE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JGT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JLT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JGE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JLE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSGT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSLT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSGE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSLE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JEQ | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JNE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JGT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JLT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JGE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JLE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSGT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSLT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSGE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSLE | BPF_K:",
                        "\t\t\t/* cmp dst_reg, imm8/32 */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tif (is_imm8(imm32))",
                        "\t\t\t\tEMIT3(0x83, add_1reg(0xF8, dst_reg), imm32);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2_off32(0x81, add_1reg(0xF8, dst_reg), imm32);",
                        "",
                        "emit_cond_jmp:\t\t/* Convert BPF opcode to x86 */",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_JEQ:",
                        "\t\t\t\tjmp_cond = X86_JE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSET:",
                        "\t\t\tcase BPF_JNE:",
                        "\t\t\t\tjmp_cond = X86_JNE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JGT:",
                        "\t\t\t\t/* GT is unsigned '>', JA in x86 */",
                        "\t\t\t\tjmp_cond = X86_JA;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JLT:",
                        "\t\t\t\t/* LT is unsigned '<', JB in x86 */",
                        "\t\t\t\tjmp_cond = X86_JB;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JGE:",
                        "\t\t\t\t/* GE is unsigned '>=', JAE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JAE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JLE:",
                        "\t\t\t\t/* LE is unsigned '<=', JBE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JBE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSGT:",
                        "\t\t\t\t/* Signed '>', GT in x86 */",
                        "\t\t\t\tjmp_cond = X86_JG;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSLT:",
                        "\t\t\t\t/* Signed '<', LT in x86 */",
                        "\t\t\t\tjmp_cond = X86_JL;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSGE:",
                        "\t\t\t\t/* Signed '>=', GE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JGE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSLE:",
                        "\t\t\t\t/* Signed '<=', LE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JLE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tdefault: /* to silence GCC warning */",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tjmp_offset = addrs[i + insn->off] - addrs[i];",
                        "\t\t\tif (is_imm8(jmp_offset)) {",
                        "\t\t\t\tEMIT2(jmp_cond, jmp_offset);",
                        "\t\t\t} else if (is_simm32(jmp_offset)) {",
                        "\t\t\t\tEMIT2_off32(0x0F, jmp_cond + 0x10, jmp_offset);",
                        "\t\t\t} else {",
                        "\t\t\t\tpr_err(\"cond_jmp gen bug %llx\\n\", jmp_offset);",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JA:",
                        "\t\t\tif (insn->off == -1)",
                        "\t\t\t\t/* -1 jmp instructions will always jump",
                        "\t\t\t\t * backwards two bytes. Explicitly handling",
                        "\t\t\t\t * this case avoids wasting too many passes",
                        "\t\t\t\t * when there are long sequences of replaced",
                        "\t\t\t\t * dead code.",
                        "\t\t\t\t */",
                        "\t\t\t\tjmp_offset = -2;",
                        "\t\t\telse",
                        "\t\t\t\tjmp_offset = addrs[i + insn->off] - addrs[i];",
                        "",
                        "\t\t\tif (!jmp_offset)",
                        "\t\t\t\t/* Optimize out nop jumps */",
                        "\t\t\t\tbreak;",
                        "emit_jmp:",
                        "\t\t\tif (is_imm8(jmp_offset)) {",
                        "\t\t\t\tEMIT2(0xEB, jmp_offset);",
                        "\t\t\t} else if (is_simm32(jmp_offset)) {",
                        "\t\t\t\tEMIT1_off32(0xE9, jmp_offset);",
                        "\t\t\t} else {",
                        "\t\t\t\tpr_err(\"jmp gen bug %llx\\n\", jmp_offset);",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_EXIT:",
                        "\t\t\tif (seen_exit) {",
                        "\t\t\t\tjmp_offset = ctx->cleanup_addr - addrs[i];",
                        "\t\t\t\tgoto emit_jmp;",
                        "\t\t\t}",
                        "\t\t\tseen_exit = true;",
                        "\t\t\t/* Update cleanup_addr */",
                        "\t\t\tctx->cleanup_addr = proglen;",
                        "\t\t\tif (!bpf_prog_was_classic(bpf_prog))",
                        "\t\t\t\tEMIT1(0x5B); /* get rid of tail_call_cnt */",
                        "\t\t\tEMIT2(0x41, 0x5F);   /* pop r15 */",
                        "\t\t\tEMIT2(0x41, 0x5E);   /* pop r14 */",
                        "\t\t\tEMIT2(0x41, 0x5D);   /* pop r13 */",
                        "\t\t\tEMIT1(0x5B);         /* pop rbx */",
                        "\t\t\tEMIT1(0xC9);         /* leave */",
                        "\t\t\tEMIT1(0xC3);         /* ret */",
                        "\t\t\tbreak;",
                        "",
                        "\t\tdefault:",
                        "\t\t\t/*",
                        "\t\t\t * By design x86-64 JIT should support all BPF instructions.",
                        "\t\t\t * This error will be seen if new instruction was added",
                        "\t\t\t * to the interpreter, but not to the JIT, or if there is",
                        "\t\t\t * junk in bpf_prog.",
                        "\t\t\t */",
                        "\t\t\tpr_err(\"bpf_jit: unknown opcode %02x\\n\", insn->code);",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "",
                        "\t\tilen = prog - temp;",
                        "\t\tif (ilen > BPF_MAX_INSN_SIZE) {",
                        "\t\t\tpr_err(\"bpf_jit: fatal insn size error\\n\");",
                        "\t\t\treturn -EFAULT;",
                        "\t\t}",
                        "",
                        "\t\tif (image) {",
                        "\t\t\tif (unlikely(proglen + ilen > oldproglen)) {",
                        "\t\t\t\tpr_err(\"bpf_jit: fatal error\\n\");",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tmemcpy(image + proglen, temp, ilen);",
                        "\t\t}",
                        "\t\tproglen += ilen;",
                        "\t\taddrs[i] = proglen;",
                        "\t\tprog = temp;",
                        "\t}",
                        "\treturn proglen;",
                        "}"
                    ],
                    "start": 380,
                    "highlight": 966
                }
            ],
            "ins_idx": 26,
            "addr": "0xffffffff8109d120"
        },
        "1234": {
            "name": "+0x18d6",
            "parent_idx": 1205,
            "source_line": [
                {
                    "file": "arch/x86/net/bpf_jit_comp.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/net/bpf_jit_comp.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n966",
                    "code": [
                        "static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,",
                        "\t\t  int oldproglen, struct jit_context *ctx)",
                        "{",
                        "\tstruct bpf_insn *insn = bpf_prog->insnsi;",
                        "\tint insn_cnt = bpf_prog->len;",
                        "\tbool seen_exit = false;",
                        "\tu8 temp[BPF_MAX_INSN_SIZE + BPF_INSN_SAFETY];",
                        "\tint i, cnt = 0;",
                        "\tint proglen = 0;",
                        "\tu8 *prog = temp;",
                        "",
                        "\temit_prologue(&prog, bpf_prog->aux->stack_depth,",
                        "\t\t      bpf_prog_was_classic(bpf_prog));",
                        "",
                        "\tfor (i = 0; i < insn_cnt; i++, insn++) {",
                        "\t\tconst s32 imm32 = insn->imm;",
                        "\t\tu32 dst_reg = insn->dst_reg;",
                        "\t\tu32 src_reg = insn->src_reg;",
                        "\t\tu8 b2 = 0, b3 = 0;",
                        "\t\ts64 jmp_offset;",
                        "\t\tu8 jmp_cond;",
                        "\t\tint ilen;",
                        "\t\tu8 *func;",
                        "",
                        "\t\tswitch (insn->code) {",
                        "\t\t\t/* ALU */",
                        "\t\tcase BPF_ALU | BPF_ADD | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_SUB | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_AND | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_OR | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_XOR | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_ADD | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_SUB | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_AND | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_OR | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_XOR | BPF_X:",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_ADD: b2 = 0x01; break;",
                        "\t\t\tcase BPF_SUB: b2 = 0x29; break;",
                        "\t\t\tcase BPF_AND: b2 = 0x21; break;",
                        "\t\t\tcase BPF_OR: b2 = 0x09; break;",
                        "\t\t\tcase BPF_XOR: b2 = 0x31; break;",
                        "\t\t\t}",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(b2, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU64 | BPF_MOV | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_MOV | BPF_X:",
                        "\t\t\temit_mov_reg(&prog,",
                        "\t\t\t\t     BPF_CLASS(insn->code) == BPF_ALU64,",
                        "\t\t\t\t     dst_reg, src_reg);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* neg dst */",
                        "\t\tcase BPF_ALU | BPF_NEG:",
                        "\t\tcase BPF_ALU64 | BPF_NEG:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "\t\t\tEMIT2(0xF7, add_1reg(0xD8, dst_reg));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_ADD | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_SUB | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_AND | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_OR | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_XOR | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_ADD | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_SUB | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_AND | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_OR | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_XOR | BPF_K:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\t/*",
                        "\t\t\t * b3 holds 'normal' opcode, b2 short form only valid",
                        "\t\t\t * in case dst is eax/rax.",
                        "\t\t\t */",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_ADD:",
                        "\t\t\t\tb3 = 0xC0;",
                        "\t\t\t\tb2 = 0x05;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_SUB:",
                        "\t\t\t\tb3 = 0xE8;",
                        "\t\t\t\tb2 = 0x2D;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_AND:",
                        "\t\t\t\tb3 = 0xE0;",
                        "\t\t\t\tb2 = 0x25;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_OR:",
                        "\t\t\t\tb3 = 0xC8;",
                        "\t\t\t\tb2 = 0x0D;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_XOR:",
                        "\t\t\t\tb3 = 0xF0;",
                        "\t\t\t\tb2 = 0x35;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (is_imm8(imm32))",
                        "\t\t\t\tEMIT3(0x83, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\telse if (is_axreg(dst_reg))",
                        "\t\t\t\tEMIT1_off32(b2, imm32);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2_off32(0x81, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU64 | BPF_MOV | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_MOV | BPF_K:",
                        "\t\t\temit_mov_imm32(&prog, BPF_CLASS(insn->code) == BPF_ALU64,",
                        "\t\t\t\t       dst_reg, imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_LD | BPF_IMM | BPF_DW:",
                        "\t\t\temit_mov_imm64(&prog, dst_reg, insn[1].imm, insn[0].imm);",
                        "\t\t\tinsn++;",
                        "\t\t\ti++;",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* dst %= src, dst /= src, dst %= imm32, dst /= imm32 */",
                        "\t\tcase BPF_ALU | BPF_MOD | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_DIV | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_MOD | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_DIV | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_MOD | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_DIV | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_MOD | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_DIV | BPF_K:",
                        "\t\t\tEMIT1(0x50); /* push rax */",
                        "\t\t\tEMIT1(0x52); /* push rdx */",
                        "",
                        "\t\t\tif (BPF_SRC(insn->code) == BPF_X)",
                        "\t\t\t\t/* mov r11, src_reg */",
                        "\t\t\t\tEMIT_mov(AUX_REG, src_reg);",
                        "\t\t\telse",
                        "\t\t\t\t/* mov r11, imm32 */",
                        "\t\t\t\tEMIT3_off32(0x49, 0xC7, 0xC3, imm32);",
                        "",
                        "\t\t\t/* mov rax, dst_reg */",
                        "\t\t\tEMIT_mov(BPF_REG_0, dst_reg);",
                        "",
                        "\t\t\t/*",
                        "\t\t\t * xor edx, edx",
                        "\t\t\t * equivalent to 'xor rdx, rdx', but one byte less",
                        "\t\t\t */",
                        "\t\t\tEMIT2(0x31, 0xd2);",
                        "",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\t/* div r11 */",
                        "\t\t\t\tEMIT3(0x49, 0xF7, 0xF3);",
                        "\t\t\telse",
                        "\t\t\t\t/* div r11d */",
                        "\t\t\t\tEMIT3(0x41, 0xF7, 0xF3);",
                        "",
                        "\t\t\tif (BPF_OP(insn->code) == BPF_MOD)",
                        "\t\t\t\t/* mov r11, rdx */",
                        "\t\t\t\tEMIT3(0x49, 0x89, 0xD3);",
                        "\t\t\telse",
                        "\t\t\t\t/* mov r11, rax */",
                        "\t\t\t\tEMIT3(0x49, 0x89, 0xC3);",
                        "",
                        "\t\t\tEMIT1(0x5A); /* pop rdx */",
                        "\t\t\tEMIT1(0x58); /* pop rax */",
                        "",
                        "\t\t\t/* mov dst_reg, r11 */",
                        "\t\t\tEMIT_mov(dst_reg, AUX_REG);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_MUL | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_MUL | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_MUL | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_MUL | BPF_X:",
                        "\t\t{",
                        "\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;",
                        "",
                        "\t\t\tif (dst_reg != BPF_REG_0)",
                        "\t\t\t\tEMIT1(0x50); /* push rax */",
                        "\t\t\tif (dst_reg != BPF_REG_3)",
                        "\t\t\t\tEMIT1(0x52); /* push rdx */",
                        "",
                        "\t\t\t/* mov r11, dst_reg */",
                        "\t\t\tEMIT_mov(AUX_REG, dst_reg);",
                        "",
                        "\t\t\tif (BPF_SRC(insn->code) == BPF_X)",
                        "\t\t\t\temit_mov_reg(&prog, is64, BPF_REG_0, src_reg);",
                        "\t\t\telse",
                        "\t\t\t\temit_mov_imm32(&prog, is64, BPF_REG_0, imm32);",
                        "",
                        "\t\t\tif (is64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, AUX_REG));",
                        "\t\t\telse if (is_ereg(AUX_REG))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, AUX_REG));",
                        "\t\t\t/* mul(q) r11 */",
                        "\t\t\tEMIT2(0xF7, add_1reg(0xE0, AUX_REG));",
                        "",
                        "\t\t\tif (dst_reg != BPF_REG_3)",
                        "\t\t\t\tEMIT1(0x5A); /* pop rdx */",
                        "\t\t\tif (dst_reg != BPF_REG_0) {",
                        "\t\t\t\t/* mov dst_reg, rax */",
                        "\t\t\t\tEMIT_mov(dst_reg, BPF_REG_0);",
                        "\t\t\t\tEMIT1(0x58); /* pop rax */",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\t\t/* Shifts */",
                        "\t\tcase BPF_ALU | BPF_LSH | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_RSH | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_ARSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_LSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_RSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_ARSH | BPF_K:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_LSH: b3 = 0xE0; break;",
                        "\t\t\tcase BPF_RSH: b3 = 0xE8; break;",
                        "\t\t\tcase BPF_ARSH: b3 = 0xF8; break;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (imm32 == 1)",
                        "\t\t\t\tEMIT2(0xD1, add_1reg(b3, dst_reg));",
                        "\t\t\telse",
                        "\t\t\t\tEMIT3(0xC1, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_LSH | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_RSH | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_ARSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_LSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_RSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_ARSH | BPF_X:",
                        "",
                        "\t\t\t/* Check for bad case when dst_reg == rcx */",
                        "\t\t\tif (dst_reg == BPF_REG_4) {",
                        "\t\t\t\t/* mov r11, dst_reg */",
                        "\t\t\t\tEMIT_mov(AUX_REG, dst_reg);",
                        "\t\t\t\tdst_reg = AUX_REG;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (src_reg != BPF_REG_4) { /* common case */",
                        "\t\t\t\tEMIT1(0x51); /* push rcx */",
                        "",
                        "\t\t\t\t/* mov rcx, src_reg */",
                        "\t\t\t\tEMIT_mov(BPF_REG_4, src_reg);",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* shl %rax, %cl | shr %rax, %cl | sar %rax, %cl */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_LSH: b3 = 0xE0; break;",
                        "\t\t\tcase BPF_RSH: b3 = 0xE8; break;",
                        "\t\t\tcase BPF_ARSH: b3 = 0xF8; break;",
                        "\t\t\t}",
                        "\t\t\tEMIT2(0xD3, add_1reg(b3, dst_reg));",
                        "",
                        "\t\t\tif (src_reg != BPF_REG_4)",
                        "\t\t\t\tEMIT1(0x59); /* pop rcx */",
                        "",
                        "\t\t\tif (insn->dst_reg == BPF_REG_4)",
                        "\t\t\t\t/* mov dst_reg, r11 */",
                        "\t\t\t\tEMIT_mov(insn->dst_reg, AUX_REG);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_END | BPF_FROM_BE:",
                        "\t\t\tswitch (imm32) {",
                        "\t\t\tcase 16:",
                        "\t\t\t\t/* Emit 'ror %ax, 8' to swap lower 2 bytes */",
                        "\t\t\t\tEMIT1(0x66);",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT1(0x41);",
                        "\t\t\t\tEMIT3(0xC1, add_1reg(0xC8, dst_reg), 8);",
                        "",
                        "\t\t\t\t/* Emit 'movzwl eax, ax' */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT3(0x45, 0x0F, 0xB7);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT2(0x0F, 0xB7);",
                        "\t\t\t\tEMIT1(add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 32:",
                        "\t\t\t\t/* Emit 'bswap eax' to swap lower 4 bytes */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT2(0x41, 0x0F);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT1(0x0F);",
                        "\t\t\t\tEMIT1(add_1reg(0xC8, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 64:",
                        "\t\t\t\t/* Emit 'bswap rax' to swap 8 bytes */",
                        "\t\t\t\tEMIT3(add_1mod(0x48, dst_reg), 0x0F,",
                        "\t\t\t\t      add_1reg(0xC8, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_END | BPF_FROM_LE:",
                        "\t\t\tswitch (imm32) {",
                        "\t\t\tcase 16:",
                        "\t\t\t\t/*",
                        "\t\t\t\t * Emit 'movzwl eax, ax' to zero extend 16-bit",
                        "\t\t\t\t * into 64 bit",
                        "\t\t\t\t */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT3(0x45, 0x0F, 0xB7);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT2(0x0F, 0xB7);",
                        "\t\t\t\tEMIT1(add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 32:",
                        "\t\t\t\t/* Emit 'mov eax, eax' to clear upper 32-bits */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT1(0x45);",
                        "\t\t\t\tEMIT2(0x89, add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 64:",
                        "\t\t\t\t/* nop */",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* ST: *(u8*)(dst_reg + off) = imm */",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_B:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT2(0x41, 0xC6);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0xC6);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_H:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT3(0x66, 0x41, 0xC7);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0x66, 0xC7);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_W:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT2(0x41, 0xC7);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0xC7);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_DW:",
                        "\t\t\tEMIT2(add_1mod(0x48, dst_reg), 0xC7);",
                        "",
                        "st:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_1reg(0x40, dst_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_1reg(0x80, dst_reg), insn->off);",
                        "",
                        "\t\t\tEMIT(imm32, bpf_size_to_x86_bytes(BPF_SIZE(insn->code)));",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* STX: *(u8*)(dst_reg + off) = src_reg */",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_B:",
                        "\t\t\t/* Emit 'mov byte ptr [rax + off], al' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg) ||",
                        "\t\t\t    /* We have to add extra byte for x86 SIL, DIL regs */",
                        "\t\t\t    src_reg == BPF_REG_1 || src_reg == BPF_REG_2)",
                        "\t\t\t\tEMIT2(add_2mod(0x40, dst_reg, src_reg), 0x88);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x88);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_H:",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT3(0x66, add_2mod(0x40, dst_reg, src_reg), 0x89);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0x66, 0x89);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_W:",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT2(add_2mod(0x40, dst_reg, src_reg), 0x89);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x89);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_DW:",
                        "\t\t\tEMIT2(add_2mod(0x48, dst_reg, src_reg), 0x89);",
                        "stx:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, dst_reg, src_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* LDX: dst_reg = *(u8*)(src_reg + off) */",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_B:",
                        "\t\t\t/* Emit 'movzx rax, byte ptr [rax + off]' */",
                        "\t\t\tEMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB6);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_H:",
                        "\t\t\t/* Emit 'movzx rax, word ptr [rax + off]' */",
                        "\t\t\tEMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB7);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_W:",
                        "\t\t\t/* Emit 'mov eax, dword ptr [rax+0x14]' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT2(add_2mod(0x40, src_reg, dst_reg), 0x8B);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x8B);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_DW:",
                        "\t\t\t/* Emit 'mov rax, qword ptr [rax+0x14]' */",
                        "\t\t\tEMIT2(add_2mod(0x48, src_reg, dst_reg), 0x8B);",
                        "ldx:\t\t\t/*",
                        "\t\t\t * If insn->off == 0 we can save one extra byte, but",
                        "\t\t\t * special case of x86 R13 which always needs an offset",
                        "\t\t\t * is not worth the hassle",
                        "\t\t\t */",
                        "\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, src_reg, dst_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, src_reg, dst_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* STX XADD: lock *(u32*)(dst_reg + off) += src_reg */",
                        "\t\tcase BPF_STX | BPF_XADD | BPF_W:",
                        "\t\t\t/* Emit 'lock add dword ptr [rax + off], eax' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT3(0xF0, add_2mod(0x40, dst_reg, src_reg), 0x01);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0xF0, 0x01);",
                        "\t\t\tgoto xadd;",
                        "\t\tcase BPF_STX | BPF_XADD | BPF_DW:",
                        "\t\t\tEMIT3(0xF0, add_2mod(0x48, dst_reg, src_reg), 0x01);",
                        "xadd:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, dst_reg, src_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* call */",
                        "\t\tcase BPF_JMP | BPF_CALL:",
                        "\t\t\tfunc = (u8 *) __bpf_call_base + imm32;",
                        "\t\t\tjmp_offset = func - (image + addrs[i]);",
                        "\t\t\tif (!imm32 || !is_simm32(jmp_offset)) {",
                        "\t\t\t\tpr_err(\"unsupported BPF func %d addr %p image %p\\n\",",
                        "\t\t\t\t       imm32, func, image);",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t\tEMIT1_off32(0xE8, jmp_offset);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_TAIL_CALL:",
                        "\t\t\temit_bpf_tail_call(&prog);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* cond jump */",
                        "\t\tcase BPF_JMP | BPF_JEQ | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JNE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JGT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JLT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JGE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JLE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSGT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSLT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSGE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSLE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JEQ | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JNE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JGT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JLT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JGE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JLE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSGT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSLT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSGE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSLE | BPF_X:",
                        "\t\t\t/* cmp dst_reg, src_reg */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(0x39, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JSET | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSET | BPF_X:",
                        "\t\t\t/* test dst_reg, src_reg */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(0x85, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JSET | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSET | BPF_K:",
                        "\t\t\t/* test dst_reg, imm32 */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "\t\t\tEMIT2_off32(0xF7, add_1reg(0xC0, dst_reg), imm32);",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JEQ | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JNE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JGT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JLT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JGE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JLE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSGT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSLT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSGE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSLE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JEQ | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JNE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JGT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JLT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JGE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JLE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSGT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSLT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSGE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSLE | BPF_K:",
                        "\t\t\t/* cmp dst_reg, imm8/32 */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tif (is_imm8(imm32))",
                        "\t\t\t\tEMIT3(0x83, add_1reg(0xF8, dst_reg), imm32);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2_off32(0x81, add_1reg(0xF8, dst_reg), imm32);",
                        "",
                        "emit_cond_jmp:\t\t/* Convert BPF opcode to x86 */",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_JEQ:",
                        "\t\t\t\tjmp_cond = X86_JE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSET:",
                        "\t\t\tcase BPF_JNE:",
                        "\t\t\t\tjmp_cond = X86_JNE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JGT:",
                        "\t\t\t\t/* GT is unsigned '>', JA in x86 */",
                        "\t\t\t\tjmp_cond = X86_JA;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JLT:",
                        "\t\t\t\t/* LT is unsigned '<', JB in x86 */",
                        "\t\t\t\tjmp_cond = X86_JB;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JGE:",
                        "\t\t\t\t/* GE is unsigned '>=', JAE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JAE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JLE:",
                        "\t\t\t\t/* LE is unsigned '<=', JBE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JBE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSGT:",
                        "\t\t\t\t/* Signed '>', GT in x86 */",
                        "\t\t\t\tjmp_cond = X86_JG;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSLT:",
                        "\t\t\t\t/* Signed '<', LT in x86 */",
                        "\t\t\t\tjmp_cond = X86_JL;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSGE:",
                        "\t\t\t\t/* Signed '>=', GE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JGE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSLE:",
                        "\t\t\t\t/* Signed '<=', LE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JLE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tdefault: /* to silence GCC warning */",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tjmp_offset = addrs[i + insn->off] - addrs[i];",
                        "\t\t\tif (is_imm8(jmp_offset)) {",
                        "\t\t\t\tEMIT2(jmp_cond, jmp_offset);",
                        "\t\t\t} else if (is_simm32(jmp_offset)) {",
                        "\t\t\t\tEMIT2_off32(0x0F, jmp_cond + 0x10, jmp_offset);",
                        "\t\t\t} else {",
                        "\t\t\t\tpr_err(\"cond_jmp gen bug %llx\\n\", jmp_offset);",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JA:",
                        "\t\t\tif (insn->off == -1)",
                        "\t\t\t\t/* -1 jmp instructions will always jump",
                        "\t\t\t\t * backwards two bytes. Explicitly handling",
                        "\t\t\t\t * this case avoids wasting too many passes",
                        "\t\t\t\t * when there are long sequences of replaced",
                        "\t\t\t\t * dead code.",
                        "\t\t\t\t */",
                        "\t\t\t\tjmp_offset = -2;",
                        "\t\t\telse",
                        "\t\t\t\tjmp_offset = addrs[i + insn->off] - addrs[i];",
                        "",
                        "\t\t\tif (!jmp_offset)",
                        "\t\t\t\t/* Optimize out nop jumps */",
                        "\t\t\t\tbreak;",
                        "emit_jmp:",
                        "\t\t\tif (is_imm8(jmp_offset)) {",
                        "\t\t\t\tEMIT2(0xEB, jmp_offset);",
                        "\t\t\t} else if (is_simm32(jmp_offset)) {",
                        "\t\t\t\tEMIT1_off32(0xE9, jmp_offset);",
                        "\t\t\t} else {",
                        "\t\t\t\tpr_err(\"jmp gen bug %llx\\n\", jmp_offset);",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_EXIT:",
                        "\t\t\tif (seen_exit) {",
                        "\t\t\t\tjmp_offset = ctx->cleanup_addr - addrs[i];",
                        "\t\t\t\tgoto emit_jmp;",
                        "\t\t\t}",
                        "\t\t\tseen_exit = true;",
                        "\t\t\t/* Update cleanup_addr */",
                        "\t\t\tctx->cleanup_addr = proglen;",
                        "\t\t\tif (!bpf_prog_was_classic(bpf_prog))",
                        "\t\t\t\tEMIT1(0x5B); /* get rid of tail_call_cnt */",
                        "\t\t\tEMIT2(0x41, 0x5F);   /* pop r15 */",
                        "\t\t\tEMIT2(0x41, 0x5E);   /* pop r14 */",
                        "\t\t\tEMIT2(0x41, 0x5D);   /* pop r13 */",
                        "\t\t\tEMIT1(0x5B);         /* pop rbx */",
                        "\t\t\tEMIT1(0xC9);         /* leave */",
                        "\t\t\tEMIT1(0xC3);         /* ret */",
                        "\t\t\tbreak;",
                        "",
                        "\t\tdefault:",
                        "\t\t\t/*",
                        "\t\t\t * By design x86-64 JIT should support all BPF instructions.",
                        "\t\t\t * This error will be seen if new instruction was added",
                        "\t\t\t * to the interpreter, but not to the JIT, or if there is",
                        "\t\t\t * junk in bpf_prog.",
                        "\t\t\t */",
                        "\t\t\tpr_err(\"bpf_jit: unknown opcode %02x\\n\", insn->code);",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "",
                        "\t\tilen = prog - temp;",
                        "\t\tif (ilen > BPF_MAX_INSN_SIZE) {",
                        "\t\t\tpr_err(\"bpf_jit: fatal insn size error\\n\");",
                        "\t\t\treturn -EFAULT;",
                        "\t\t}",
                        "",
                        "\t\tif (image) {",
                        "\t\t\tif (unlikely(proglen + ilen > oldproglen)) {",
                        "\t\t\t\tpr_err(\"bpf_jit: fatal error\\n\");",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tmemcpy(image + proglen, temp, ilen);",
                        "\t\t}",
                        "\t\tproglen += ilen;",
                        "\t\taddrs[i] = proglen;",
                        "\t\tprog = temp;",
                        "\t}",
                        "\treturn proglen;",
                        "}"
                    ],
                    "start": 380,
                    "highlight": 966
                }
            ],
            "ins_idx": 41,
            "addr": "0xffffffff8109d116"
        },
        "1208": {
            "name": "+0x1d",
            "parent_idx": 1205,
            "source_line": [
                {
                    "file": "arch/x86/net/bpf_jit_comp.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/net/bpf_jit_comp.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n382",
                    "code": [
                        "static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,",
                        "\t\t  int oldproglen, struct jit_context *ctx)",
                        "{",
                        "\tstruct bpf_insn *insn = bpf_prog->insnsi;",
                        "\tint insn_cnt = bpf_prog->len;",
                        "\tbool seen_exit = false;",
                        "\tu8 temp[BPF_MAX_INSN_SIZE + BPF_INSN_SAFETY];",
                        "\tint i, cnt = 0;",
                        "\tint proglen = 0;",
                        "\tu8 *prog = temp;",
                        "",
                        "\temit_prologue(&prog, bpf_prog->aux->stack_depth,",
                        "\t\t      bpf_prog_was_classic(bpf_prog));",
                        "",
                        "\tfor (i = 0; i < insn_cnt; i++, insn++) {",
                        "\t\tconst s32 imm32 = insn->imm;",
                        "\t\tu32 dst_reg = insn->dst_reg;",
                        "\t\tu32 src_reg = insn->src_reg;",
                        "\t\tu8 b2 = 0, b3 = 0;",
                        "\t\ts64 jmp_offset;",
                        "\t\tu8 jmp_cond;",
                        "\t\tint ilen;",
                        "\t\tu8 *func;",
                        "",
                        "\t\tswitch (insn->code) {",
                        "\t\t\t/* ALU */",
                        "\t\tcase BPF_ALU | BPF_ADD | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_SUB | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_AND | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_OR | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_XOR | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_ADD | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_SUB | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_AND | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_OR | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_XOR | BPF_X:",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_ADD: b2 = 0x01; break;",
                        "\t\t\tcase BPF_SUB: b2 = 0x29; break;",
                        "\t\t\tcase BPF_AND: b2 = 0x21; break;",
                        "\t\t\tcase BPF_OR: b2 = 0x09; break;",
                        "\t\t\tcase BPF_XOR: b2 = 0x31; break;",
                        "\t\t\t}",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(b2, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU64 | BPF_MOV | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_MOV | BPF_X:",
                        "\t\t\temit_mov_reg(&prog,",
                        "\t\t\t\t     BPF_CLASS(insn->code) == BPF_ALU64,",
                        "\t\t\t\t     dst_reg, src_reg);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* neg dst */",
                        "\t\tcase BPF_ALU | BPF_NEG:",
                        "\t\tcase BPF_ALU64 | BPF_NEG:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "\t\t\tEMIT2(0xF7, add_1reg(0xD8, dst_reg));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_ADD | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_SUB | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_AND | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_OR | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_XOR | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_ADD | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_SUB | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_AND | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_OR | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_XOR | BPF_K:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\t/*",
                        "\t\t\t * b3 holds 'normal' opcode, b2 short form only valid",
                        "\t\t\t * in case dst is eax/rax.",
                        "\t\t\t */",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_ADD:",
                        "\t\t\t\tb3 = 0xC0;",
                        "\t\t\t\tb2 = 0x05;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_SUB:",
                        "\t\t\t\tb3 = 0xE8;",
                        "\t\t\t\tb2 = 0x2D;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_AND:",
                        "\t\t\t\tb3 = 0xE0;",
                        "\t\t\t\tb2 = 0x25;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_OR:",
                        "\t\t\t\tb3 = 0xC8;",
                        "\t\t\t\tb2 = 0x0D;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_XOR:",
                        "\t\t\t\tb3 = 0xF0;",
                        "\t\t\t\tb2 = 0x35;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (is_imm8(imm32))",
                        "\t\t\t\tEMIT3(0x83, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\telse if (is_axreg(dst_reg))",
                        "\t\t\t\tEMIT1_off32(b2, imm32);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2_off32(0x81, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU64 | BPF_MOV | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_MOV | BPF_K:",
                        "\t\t\temit_mov_imm32(&prog, BPF_CLASS(insn->code) == BPF_ALU64,",
                        "\t\t\t\t       dst_reg, imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_LD | BPF_IMM | BPF_DW:",
                        "\t\t\temit_mov_imm64(&prog, dst_reg, insn[1].imm, insn[0].imm);",
                        "\t\t\tinsn++;",
                        "\t\t\ti++;",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* dst %= src, dst /= src, dst %= imm32, dst /= imm32 */",
                        "\t\tcase BPF_ALU | BPF_MOD | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_DIV | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_MOD | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_DIV | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_MOD | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_DIV | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_MOD | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_DIV | BPF_K:",
                        "\t\t\tEMIT1(0x50); /* push rax */",
                        "\t\t\tEMIT1(0x52); /* push rdx */",
                        "",
                        "\t\t\tif (BPF_SRC(insn->code) == BPF_X)",
                        "\t\t\t\t/* mov r11, src_reg */",
                        "\t\t\t\tEMIT_mov(AUX_REG, src_reg);",
                        "\t\t\telse",
                        "\t\t\t\t/* mov r11, imm32 */",
                        "\t\t\t\tEMIT3_off32(0x49, 0xC7, 0xC3, imm32);",
                        "",
                        "\t\t\t/* mov rax, dst_reg */",
                        "\t\t\tEMIT_mov(BPF_REG_0, dst_reg);",
                        "",
                        "\t\t\t/*",
                        "\t\t\t * xor edx, edx",
                        "\t\t\t * equivalent to 'xor rdx, rdx', but one byte less",
                        "\t\t\t */",
                        "\t\t\tEMIT2(0x31, 0xd2);",
                        "",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\t/* div r11 */",
                        "\t\t\t\tEMIT3(0x49, 0xF7, 0xF3);",
                        "\t\t\telse",
                        "\t\t\t\t/* div r11d */",
                        "\t\t\t\tEMIT3(0x41, 0xF7, 0xF3);",
                        "",
                        "\t\t\tif (BPF_OP(insn->code) == BPF_MOD)",
                        "\t\t\t\t/* mov r11, rdx */",
                        "\t\t\t\tEMIT3(0x49, 0x89, 0xD3);",
                        "\t\t\telse",
                        "\t\t\t\t/* mov r11, rax */",
                        "\t\t\t\tEMIT3(0x49, 0x89, 0xC3);",
                        "",
                        "\t\t\tEMIT1(0x5A); /* pop rdx */",
                        "\t\t\tEMIT1(0x58); /* pop rax */",
                        "",
                        "\t\t\t/* mov dst_reg, r11 */",
                        "\t\t\tEMIT_mov(dst_reg, AUX_REG);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_MUL | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_MUL | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_MUL | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_MUL | BPF_X:",
                        "\t\t{",
                        "\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;",
                        "",
                        "\t\t\tif (dst_reg != BPF_REG_0)",
                        "\t\t\t\tEMIT1(0x50); /* push rax */",
                        "\t\t\tif (dst_reg != BPF_REG_3)",
                        "\t\t\t\tEMIT1(0x52); /* push rdx */",
                        "",
                        "\t\t\t/* mov r11, dst_reg */",
                        "\t\t\tEMIT_mov(AUX_REG, dst_reg);",
                        "",
                        "\t\t\tif (BPF_SRC(insn->code) == BPF_X)",
                        "\t\t\t\temit_mov_reg(&prog, is64, BPF_REG_0, src_reg);",
                        "\t\t\telse",
                        "\t\t\t\temit_mov_imm32(&prog, is64, BPF_REG_0, imm32);",
                        "",
                        "\t\t\tif (is64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, AUX_REG));",
                        "\t\t\telse if (is_ereg(AUX_REG))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, AUX_REG));",
                        "\t\t\t/* mul(q) r11 */",
                        "\t\t\tEMIT2(0xF7, add_1reg(0xE0, AUX_REG));",
                        "",
                        "\t\t\tif (dst_reg != BPF_REG_3)",
                        "\t\t\t\tEMIT1(0x5A); /* pop rdx */",
                        "\t\t\tif (dst_reg != BPF_REG_0) {",
                        "\t\t\t\t/* mov dst_reg, rax */",
                        "\t\t\t\tEMIT_mov(dst_reg, BPF_REG_0);",
                        "\t\t\t\tEMIT1(0x58); /* pop rax */",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\t\t/* Shifts */",
                        "\t\tcase BPF_ALU | BPF_LSH | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_RSH | BPF_K:",
                        "\t\tcase BPF_ALU | BPF_ARSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_LSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_RSH | BPF_K:",
                        "\t\tcase BPF_ALU64 | BPF_ARSH | BPF_K:",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_LSH: b3 = 0xE0; break;",
                        "\t\t\tcase BPF_RSH: b3 = 0xE8; break;",
                        "\t\t\tcase BPF_ARSH: b3 = 0xF8; break;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (imm32 == 1)",
                        "\t\t\t\tEMIT2(0xD1, add_1reg(b3, dst_reg));",
                        "\t\t\telse",
                        "\t\t\t\tEMIT3(0xC1, add_1reg(b3, dst_reg), imm32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_LSH | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_RSH | BPF_X:",
                        "\t\tcase BPF_ALU | BPF_ARSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_LSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_RSH | BPF_X:",
                        "\t\tcase BPF_ALU64 | BPF_ARSH | BPF_X:",
                        "",
                        "\t\t\t/* Check for bad case when dst_reg == rcx */",
                        "\t\t\tif (dst_reg == BPF_REG_4) {",
                        "\t\t\t\t/* mov r11, dst_reg */",
                        "\t\t\t\tEMIT_mov(AUX_REG, dst_reg);",
                        "\t\t\t\tdst_reg = AUX_REG;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (src_reg != BPF_REG_4) { /* common case */",
                        "\t\t\t\tEMIT1(0x51); /* push rcx */",
                        "",
                        "\t\t\t\t/* mov rcx, src_reg */",
                        "\t\t\t\tEMIT_mov(BPF_REG_4, src_reg);",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* shl %rax, %cl | shr %rax, %cl | sar %rax, %cl */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_LSH: b3 = 0xE0; break;",
                        "\t\t\tcase BPF_RSH: b3 = 0xE8; break;",
                        "\t\t\tcase BPF_ARSH: b3 = 0xF8; break;",
                        "\t\t\t}",
                        "\t\t\tEMIT2(0xD3, add_1reg(b3, dst_reg));",
                        "",
                        "\t\t\tif (src_reg != BPF_REG_4)",
                        "\t\t\t\tEMIT1(0x59); /* pop rcx */",
                        "",
                        "\t\t\tif (insn->dst_reg == BPF_REG_4)",
                        "\t\t\t\t/* mov dst_reg, r11 */",
                        "\t\t\t\tEMIT_mov(insn->dst_reg, AUX_REG);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_END | BPF_FROM_BE:",
                        "\t\t\tswitch (imm32) {",
                        "\t\t\tcase 16:",
                        "\t\t\t\t/* Emit 'ror %ax, 8' to swap lower 2 bytes */",
                        "\t\t\t\tEMIT1(0x66);",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT1(0x41);",
                        "\t\t\t\tEMIT3(0xC1, add_1reg(0xC8, dst_reg), 8);",
                        "",
                        "\t\t\t\t/* Emit 'movzwl eax, ax' */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT3(0x45, 0x0F, 0xB7);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT2(0x0F, 0xB7);",
                        "\t\t\t\tEMIT1(add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 32:",
                        "\t\t\t\t/* Emit 'bswap eax' to swap lower 4 bytes */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT2(0x41, 0x0F);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT1(0x0F);",
                        "\t\t\t\tEMIT1(add_1reg(0xC8, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 64:",
                        "\t\t\t\t/* Emit 'bswap rax' to swap 8 bytes */",
                        "\t\t\t\tEMIT3(add_1mod(0x48, dst_reg), 0x0F,",
                        "\t\t\t\t      add_1reg(0xC8, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_ALU | BPF_END | BPF_FROM_LE:",
                        "\t\t\tswitch (imm32) {",
                        "\t\t\tcase 16:",
                        "\t\t\t\t/*",
                        "\t\t\t\t * Emit 'movzwl eax, ax' to zero extend 16-bit",
                        "\t\t\t\t * into 64 bit",
                        "\t\t\t\t */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT3(0x45, 0x0F, 0xB7);",
                        "\t\t\t\telse",
                        "\t\t\t\t\tEMIT2(0x0F, 0xB7);",
                        "\t\t\t\tEMIT1(add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 32:",
                        "\t\t\t\t/* Emit 'mov eax, eax' to clear upper 32-bits */",
                        "\t\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\t\tEMIT1(0x45);",
                        "\t\t\t\tEMIT2(0x89, add_2reg(0xC0, dst_reg, dst_reg));",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 64:",
                        "\t\t\t\t/* nop */",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* ST: *(u8*)(dst_reg + off) = imm */",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_B:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT2(0x41, 0xC6);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0xC6);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_H:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT3(0x66, 0x41, 0xC7);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0x66, 0xC7);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_W:",
                        "\t\t\tif (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT2(0x41, 0xC7);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0xC7);",
                        "\t\t\tgoto st;",
                        "\t\tcase BPF_ST | BPF_MEM | BPF_DW:",
                        "\t\t\tEMIT2(add_1mod(0x48, dst_reg), 0xC7);",
                        "",
                        "st:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_1reg(0x40, dst_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_1reg(0x80, dst_reg), insn->off);",
                        "",
                        "\t\t\tEMIT(imm32, bpf_size_to_x86_bytes(BPF_SIZE(insn->code)));",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* STX: *(u8*)(dst_reg + off) = src_reg */",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_B:",
                        "\t\t\t/* Emit 'mov byte ptr [rax + off], al' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg) ||",
                        "\t\t\t    /* We have to add extra byte for x86 SIL, DIL regs */",
                        "\t\t\t    src_reg == BPF_REG_1 || src_reg == BPF_REG_2)",
                        "\t\t\t\tEMIT2(add_2mod(0x40, dst_reg, src_reg), 0x88);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x88);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_H:",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT3(0x66, add_2mod(0x40, dst_reg, src_reg), 0x89);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0x66, 0x89);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_W:",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT2(add_2mod(0x40, dst_reg, src_reg), 0x89);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x89);",
                        "\t\t\tgoto stx;",
                        "\t\tcase BPF_STX | BPF_MEM | BPF_DW:",
                        "\t\t\tEMIT2(add_2mod(0x48, dst_reg, src_reg), 0x89);",
                        "stx:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, dst_reg, src_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* LDX: dst_reg = *(u8*)(src_reg + off) */",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_B:",
                        "\t\t\t/* Emit 'movzx rax, byte ptr [rax + off]' */",
                        "\t\t\tEMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB6);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_H:",
                        "\t\t\t/* Emit 'movzx rax, word ptr [rax + off]' */",
                        "\t\t\tEMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB7);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_W:",
                        "\t\t\t/* Emit 'mov eax, dword ptr [rax+0x14]' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT2(add_2mod(0x40, src_reg, dst_reg), 0x8B);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1(0x8B);",
                        "\t\t\tgoto ldx;",
                        "\t\tcase BPF_LDX | BPF_MEM | BPF_DW:",
                        "\t\t\t/* Emit 'mov rax, qword ptr [rax+0x14]' */",
                        "\t\t\tEMIT2(add_2mod(0x48, src_reg, dst_reg), 0x8B);",
                        "ldx:\t\t\t/*",
                        "\t\t\t * If insn->off == 0 we can save one extra byte, but",
                        "\t\t\t * special case of x86 R13 which always needs an offset",
                        "\t\t\t * is not worth the hassle",
                        "\t\t\t */",
                        "\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, src_reg, dst_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, src_reg, dst_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* STX XADD: lock *(u32*)(dst_reg + off) += src_reg */",
                        "\t\tcase BPF_STX | BPF_XADD | BPF_W:",
                        "\t\t\t/* Emit 'lock add dword ptr [rax + off], eax' */",
                        "\t\t\tif (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT3(0xF0, add_2mod(0x40, dst_reg, src_reg), 0x01);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2(0xF0, 0x01);",
                        "\t\t\tgoto xadd;",
                        "\t\tcase BPF_STX | BPF_XADD | BPF_DW:",
                        "\t\t\tEMIT3(0xF0, add_2mod(0x48, dst_reg, src_reg), 0x01);",
                        "xadd:\t\t\tif (is_imm8(insn->off))",
                        "\t\t\t\tEMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT1_off32(add_2reg(0x80, dst_reg, src_reg),",
                        "\t\t\t\t\t    insn->off);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* call */",
                        "\t\tcase BPF_JMP | BPF_CALL:",
                        "\t\t\tfunc = (u8 *) __bpf_call_base + imm32;",
                        "\t\t\tjmp_offset = func - (image + addrs[i]);",
                        "\t\t\tif (!imm32 || !is_simm32(jmp_offset)) {",
                        "\t\t\t\tpr_err(\"unsupported BPF func %d addr %p image %p\\n\",",
                        "\t\t\t\t       imm32, func, image);",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t\tEMIT1_off32(0xE8, jmp_offset);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_TAIL_CALL:",
                        "\t\t\temit_bpf_tail_call(&prog);",
                        "\t\t\tbreak;",
                        "",
                        "\t\t\t/* cond jump */",
                        "\t\tcase BPF_JMP | BPF_JEQ | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JNE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JGT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JLT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JGE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JLE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSGT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSLT | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSGE | BPF_X:",
                        "\t\tcase BPF_JMP | BPF_JSLE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JEQ | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JNE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JGT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JLT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JGE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JLE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSGT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSLT | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSGE | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSLE | BPF_X:",
                        "\t\t\t/* cmp dst_reg, src_reg */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(0x39, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JSET | BPF_X:",
                        "\t\tcase BPF_JMP32 | BPF_JSET | BPF_X:",
                        "\t\t\t/* test dst_reg, src_reg */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_2mod(0x48, dst_reg, src_reg));",
                        "\t\t\telse if (is_ereg(dst_reg) || is_ereg(src_reg))",
                        "\t\t\t\tEMIT1(add_2mod(0x40, dst_reg, src_reg));",
                        "\t\t\tEMIT2(0x85, add_2reg(0xC0, dst_reg, src_reg));",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JSET | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSET | BPF_K:",
                        "\t\t\t/* test dst_reg, imm32 */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "\t\t\tEMIT2_off32(0xF7, add_1reg(0xC0, dst_reg), imm32);",
                        "\t\t\tgoto emit_cond_jmp;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JEQ | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JNE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JGT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JLT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JGE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JLE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSGT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSLT | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSGE | BPF_K:",
                        "\t\tcase BPF_JMP | BPF_JSLE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JEQ | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JNE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JGT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JLT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JGE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JLE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSGT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSLT | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSGE | BPF_K:",
                        "\t\tcase BPF_JMP32 | BPF_JSLE | BPF_K:",
                        "\t\t\t/* cmp dst_reg, imm8/32 */",
                        "\t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)",
                        "\t\t\t\tEMIT1(add_1mod(0x48, dst_reg));",
                        "\t\t\telse if (is_ereg(dst_reg))",
                        "\t\t\t\tEMIT1(add_1mod(0x40, dst_reg));",
                        "",
                        "\t\t\tif (is_imm8(imm32))",
                        "\t\t\t\tEMIT3(0x83, add_1reg(0xF8, dst_reg), imm32);",
                        "\t\t\telse",
                        "\t\t\t\tEMIT2_off32(0x81, add_1reg(0xF8, dst_reg), imm32);",
                        "",
                        "emit_cond_jmp:\t\t/* Convert BPF opcode to x86 */",
                        "\t\t\tswitch (BPF_OP(insn->code)) {",
                        "\t\t\tcase BPF_JEQ:",
                        "\t\t\t\tjmp_cond = X86_JE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSET:",
                        "\t\t\tcase BPF_JNE:",
                        "\t\t\t\tjmp_cond = X86_JNE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JGT:",
                        "\t\t\t\t/* GT is unsigned '>', JA in x86 */",
                        "\t\t\t\tjmp_cond = X86_JA;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JLT:",
                        "\t\t\t\t/* LT is unsigned '<', JB in x86 */",
                        "\t\t\t\tjmp_cond = X86_JB;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JGE:",
                        "\t\t\t\t/* GE is unsigned '>=', JAE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JAE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JLE:",
                        "\t\t\t\t/* LE is unsigned '<=', JBE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JBE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSGT:",
                        "\t\t\t\t/* Signed '>', GT in x86 */",
                        "\t\t\t\tjmp_cond = X86_JG;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSLT:",
                        "\t\t\t\t/* Signed '<', LT in x86 */",
                        "\t\t\t\tjmp_cond = X86_JL;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSGE:",
                        "\t\t\t\t/* Signed '>=', GE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JGE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase BPF_JSLE:",
                        "\t\t\t\t/* Signed '<=', LE in x86 */",
                        "\t\t\t\tjmp_cond = X86_JLE;",
                        "\t\t\t\tbreak;",
                        "\t\t\tdefault: /* to silence GCC warning */",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tjmp_offset = addrs[i + insn->off] - addrs[i];",
                        "\t\t\tif (is_imm8(jmp_offset)) {",
                        "\t\t\t\tEMIT2(jmp_cond, jmp_offset);",
                        "\t\t\t} else if (is_simm32(jmp_offset)) {",
                        "\t\t\t\tEMIT2_off32(0x0F, jmp_cond + 0x10, jmp_offset);",
                        "\t\t\t} else {",
                        "\t\t\t\tpr_err(\"cond_jmp gen bug %llx\\n\", jmp_offset);",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_JA:",
                        "\t\t\tif (insn->off == -1)",
                        "\t\t\t\t/* -1 jmp instructions will always jump",
                        "\t\t\t\t * backwards two bytes. Explicitly handling",
                        "\t\t\t\t * this case avoids wasting too many passes",
                        "\t\t\t\t * when there are long sequences of replaced",
                        "\t\t\t\t * dead code.",
                        "\t\t\t\t */",
                        "\t\t\t\tjmp_offset = -2;",
                        "\t\t\telse",
                        "\t\t\t\tjmp_offset = addrs[i + insn->off] - addrs[i];",
                        "",
                        "\t\t\tif (!jmp_offset)",
                        "\t\t\t\t/* Optimize out nop jumps */",
                        "\t\t\t\tbreak;",
                        "emit_jmp:",
                        "\t\t\tif (is_imm8(jmp_offset)) {",
                        "\t\t\t\tEMIT2(0xEB, jmp_offset);",
                        "\t\t\t} else if (is_simm32(jmp_offset)) {",
                        "\t\t\t\tEMIT1_off32(0xE9, jmp_offset);",
                        "\t\t\t} else {",
                        "\t\t\t\tpr_err(\"jmp gen bug %llx\\n\", jmp_offset);",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase BPF_JMP | BPF_EXIT:",
                        "\t\t\tif (seen_exit) {",
                        "\t\t\t\tjmp_offset = ctx->cleanup_addr - addrs[i];",
                        "\t\t\t\tgoto emit_jmp;",
                        "\t\t\t}",
                        "\t\t\tseen_exit = true;",
                        "\t\t\t/* Update cleanup_addr */",
                        "\t\t\tctx->cleanup_addr = proglen;",
                        "\t\t\tif (!bpf_prog_was_classic(bpf_prog))",
                        "\t\t\t\tEMIT1(0x5B); /* get rid of tail_call_cnt */",
                        "\t\t\tEMIT2(0x41, 0x5F);   /* pop r15 */",
                        "\t\t\tEMIT2(0x41, 0x5E);   /* pop r14 */",
                        "\t\t\tEMIT2(0x41, 0x5D);   /* pop r13 */",
                        "\t\t\tEMIT1(0x5B);         /* pop rbx */",
                        "\t\t\tEMIT1(0xC9);         /* leave */",
                        "\t\t\tEMIT1(0xC3);         /* ret */",
                        "\t\t\tbreak;",
                        "",
                        "\t\tdefault:",
                        "\t\t\t/*",
                        "\t\t\t * By design x86-64 JIT should support all BPF instructions.",
                        "\t\t\t * This error will be seen if new instruction was added",
                        "\t\t\t * to the interpreter, but not to the JIT, or if there is",
                        "\t\t\t * junk in bpf_prog.",
                        "\t\t\t */",
                        "\t\t\tpr_err(\"bpf_jit: unknown opcode %02x\\n\", insn->code);",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "",
                        "\t\tilen = prog - temp;",
                        "\t\tif (ilen > BPF_MAX_INSN_SIZE) {",
                        "\t\t\tpr_err(\"bpf_jit: fatal insn size error\\n\");",
                        "\t\t\treturn -EFAULT;",
                        "\t\t}",
                        "",
                        "\t\tif (image) {",
                        "\t\t\tif (unlikely(proglen + ilen > oldproglen)) {",
                        "\t\t\t\tpr_err(\"bpf_jit: fatal error\\n\");",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t\t}",
                        "\t\t\tmemcpy(image + proglen, temp, ilen);",
                        "\t\t}",
                        "\t\tproglen += ilen;",
                        "\t\taddrs[i] = proglen;",
                        "\t\tprog = temp;",
                        "\t}",
                        "\treturn proglen;",
                        "}"
                    ],
                    "start": 380,
                    "highlight": 382
                }
            ],
            "ins_idx": 67,
            "addr": "0xffffffff8109b85d"
        },
        "1203": {
            "name": "+0x1be",
            "parent_idx": 1187,
            "source_line": [
                {
                    "file": "arch/x86/net/bpf_jit_comp.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/net/bpf_jit_comp.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n1132",
                    "code": [
                        "struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)",
                        "{",
                        "\tstruct bpf_binary_header *header = NULL;",
                        "\tstruct bpf_prog *tmp, *orig_prog = prog;",
                        "\tstruct x64_jit_data *jit_data;",
                        "\tint proglen, oldproglen = 0;",
                        "\tstruct jit_context ctx = {};",
                        "\tbool tmp_blinded = false;",
                        "\tbool extra_pass = false;",
                        "\tu8 *image = NULL;",
                        "\tint *addrs;",
                        "\tint pass;",
                        "\tint i;",
                        "",
                        "\tif (!prog->jit_requested)",
                        "\t\treturn orig_prog;",
                        "",
                        "\ttmp = bpf_jit_blind_constants(prog);",
                        "\t/*",
                        "\t * If blinding was requested and we failed during blinding,",
                        "\t * we must fall back to the interpreter.",
                        "\t */",
                        "\tif (IS_ERR(tmp))",
                        "\t\treturn orig_prog;",
                        "\tif (tmp != prog) {",
                        "\t\ttmp_blinded = true;",
                        "\t\tprog = tmp;",
                        "\t}",
                        "",
                        "\tjit_data = prog->aux->jit_data;",
                        "\tif (!jit_data) {",
                        "\t\tjit_data = kzalloc(sizeof(*jit_data), GFP_KERNEL);",
                        "\t\tif (!jit_data) {",
                        "\t\t\tprog = orig_prog;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tprog->aux->jit_data = jit_data;",
                        "\t}",
                        "\taddrs = jit_data->addrs;",
                        "\tif (addrs) {",
                        "\t\tctx = jit_data->ctx;",
                        "\t\toldproglen = jit_data->proglen;",
                        "\t\timage = jit_data->image;",
                        "\t\theader = jit_data->header;",
                        "\t\textra_pass = true;",
                        "\t\tgoto skip_init_addrs;",
                        "\t}",
                        "\taddrs = kmalloc_array(prog->len, sizeof(*addrs), GFP_KERNEL);",
                        "\tif (!addrs) {",
                        "\t\tprog = orig_prog;",
                        "\t\tgoto out_addrs;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Before first pass, make a rough estimation of addrs[]",
                        "\t * each BPF instruction is translated to less than 64 bytes",
                        "\t */",
                        "\tfor (proglen = 0, i = 0; i < prog->len; i++) {",
                        "\t\tproglen += 64;",
                        "\t\taddrs[i] = proglen;",
                        "\t}",
                        "\tctx.cleanup_addr = proglen;",
                        "skip_init_addrs:",
                        "",
                        "\t/*",
                        "\t * JITed image shrinks with every pass and the loop iterates",
                        "\t * until the image stops shrinking. Very large BPF programs",
                        "\t * may converge on the last pass. In such case do one more",
                        "\t * pass to emit the final image.",
                        "\t */",
                        "\tfor (pass = 0; pass < 20 || image; pass++) {",
                        "\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);",
                        "\t\tif (proglen <= 0) {",
                        "out_image:",
                        "\t\t\timage = NULL;",
                        "\t\t\tif (header)",
                        "\t\t\t\tbpf_jit_binary_free(header);",
                        "\t\t\tprog = orig_prog;",
                        "\t\t\tgoto out_addrs;",
                        "\t\t}",
                        "\t\tif (image) {",
                        "\t\t\tif (proglen != oldproglen) {",
                        "\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",",
                        "\t\t\t\t       proglen, oldproglen);",
                        "\t\t\t\tgoto out_image;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (proglen == oldproglen) {",
                        "\t\t\theader = bpf_jit_binary_alloc(proglen, &image,",
                        "\t\t\t\t\t\t      1, jit_fill_hole);",
                        "\t\t\tif (!header) {",
                        "\t\t\t\tprog = orig_prog;",
                        "\t\t\t\tgoto out_addrs;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\toldproglen = proglen;",
                        "\t\tcond_resched();",
                        "\t}",
                        "",
                        "\tif (bpf_jit_enable > 1)",
                        "\t\tbpf_jit_dump(prog->len, proglen, pass + 1, image);",
                        "",
                        "\tif (image) {",
                        "\t\tif (!prog->is_func || extra_pass) {",
                        "\t\t\tbpf_jit_binary_lock_ro(header);",
                        "\t\t} else {",
                        "\t\t\tjit_data->addrs = addrs;",
                        "\t\t\tjit_data->ctx = ctx;",
                        "\t\t\tjit_data->proglen = proglen;",
                        "\t\t\tjit_data->image = image;",
                        "\t\t\tjit_data->header = header;",
                        "\t\t}",
                        "\t\tprog->bpf_func = (void *)image;",
                        "\t\tprog->jited = 1;",
                        "\t\tprog->jited_len = proglen;",
                        "\t} else {",
                        "\t\tprog = orig_prog;",
                        "\t}",
                        "",
                        "\tif (!image || !prog->is_func || extra_pass) {",
                        "\t\tif (image)",
                        "\t\t\tbpf_prog_fill_jited_linfo(prog, addrs);",
                        "out_addrs:",
                        "\t\tkfree(addrs);",
                        "\t\tkfree(jit_data);",
                        "\t\tprog->aux->jit_data = NULL;",
                        "\t}",
                        "out:",
                        "\tif (tmp_blinded)",
                        "\t\tbpf_jit_prog_release_other(prog, prog == orig_prog ?",
                        "\t\t\t\t\t   tmp : orig_prog);",
                        "\treturn prog;",
                        "}"
                    ],
                    "start": 1061,
                    "highlight": 1132
                }
            ],
            "ins_idx": 100,
            "addr": "0xffffffff8109e38e"
        },
        "1202": {
            "name": "+0x4cf",
            "parent_idx": 1187,
            "source_line": [
                {
                    "file": "arch/x86/net/bpf_jit_comp.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/net/bpf_jit_comp.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n1131",
                    "code": [
                        "struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)",
                        "{",
                        "\tstruct bpf_binary_header *header = NULL;",
                        "\tstruct bpf_prog *tmp, *orig_prog = prog;",
                        "\tstruct x64_jit_data *jit_data;",
                        "\tint proglen, oldproglen = 0;",
                        "\tstruct jit_context ctx = {};",
                        "\tbool tmp_blinded = false;",
                        "\tbool extra_pass = false;",
                        "\tu8 *image = NULL;",
                        "\tint *addrs;",
                        "\tint pass;",
                        "\tint i;",
                        "",
                        "\tif (!prog->jit_requested)",
                        "\t\treturn orig_prog;",
                        "",
                        "\ttmp = bpf_jit_blind_constants(prog);",
                        "\t/*",
                        "\t * If blinding was requested and we failed during blinding,",
                        "\t * we must fall back to the interpreter.",
                        "\t */",
                        "\tif (IS_ERR(tmp))",
                        "\t\treturn orig_prog;",
                        "\tif (tmp != prog) {",
                        "\t\ttmp_blinded = true;",
                        "\t\tprog = tmp;",
                        "\t}",
                        "",
                        "\tjit_data = prog->aux->jit_data;",
                        "\tif (!jit_data) {",
                        "\t\tjit_data = kzalloc(sizeof(*jit_data), GFP_KERNEL);",
                        "\t\tif (!jit_data) {",
                        "\t\t\tprog = orig_prog;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tprog->aux->jit_data = jit_data;",
                        "\t}",
                        "\taddrs = jit_data->addrs;",
                        "\tif (addrs) {",
                        "\t\tctx = jit_data->ctx;",
                        "\t\toldproglen = jit_data->proglen;",
                        "\t\timage = jit_data->image;",
                        "\t\theader = jit_data->header;",
                        "\t\textra_pass = true;",
                        "\t\tgoto skip_init_addrs;",
                        "\t}",
                        "\taddrs = kmalloc_array(prog->len, sizeof(*addrs), GFP_KERNEL);",
                        "\tif (!addrs) {",
                        "\t\tprog = orig_prog;",
                        "\t\tgoto out_addrs;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Before first pass, make a rough estimation of addrs[]",
                        "\t * each BPF instruction is translated to less than 64 bytes",
                        "\t */",
                        "\tfor (proglen = 0, i = 0; i < prog->len; i++) {",
                        "\t\tproglen += 64;",
                        "\t\taddrs[i] = proglen;",
                        "\t}",
                        "\tctx.cleanup_addr = proglen;",
                        "skip_init_addrs:",
                        "",
                        "\t/*",
                        "\t * JITed image shrinks with every pass and the loop iterates",
                        "\t * until the image stops shrinking. Very large BPF programs",
                        "\t * may converge on the last pass. In such case do one more",
                        "\t * pass to emit the final image.",
                        "\t */",
                        "\tfor (pass = 0; pass < 20 || image; pass++) {",
                        "\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);",
                        "\t\tif (proglen <= 0) {",
                        "out_image:",
                        "\t\t\timage = NULL;",
                        "\t\t\tif (header)",
                        "\t\t\t\tbpf_jit_binary_free(header);",
                        "\t\t\tprog = orig_prog;",
                        "\t\t\tgoto out_addrs;",
                        "\t\t}",
                        "\t\tif (image) {",
                        "\t\t\tif (proglen != oldproglen) {",
                        "\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",",
                        "\t\t\t\t       proglen, oldproglen);",
                        "\t\t\t\tgoto out_image;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (proglen == oldproglen) {",
                        "\t\t\theader = bpf_jit_binary_alloc(proglen, &image,",
                        "\t\t\t\t\t\t      1, jit_fill_hole);",
                        "\t\t\tif (!header) {",
                        "\t\t\t\tprog = orig_prog;",
                        "\t\t\t\tgoto out_addrs;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\toldproglen = proglen;",
                        "\t\tcond_resched();",
                        "\t}",
                        "",
                        "\tif (bpf_jit_enable > 1)",
                        "\t\tbpf_jit_dump(prog->len, proglen, pass + 1, image);",
                        "",
                        "\tif (image) {",
                        "\t\tif (!prog->is_func || extra_pass) {",
                        "\t\t\tbpf_jit_binary_lock_ro(header);",
                        "\t\t} else {",
                        "\t\t\tjit_data->addrs = addrs;",
                        "\t\t\tjit_data->ctx = ctx;",
                        "\t\t\tjit_data->proglen = proglen;",
                        "\t\t\tjit_data->image = image;",
                        "\t\t\tjit_data->header = header;",
                        "\t\t}",
                        "\t\tprog->bpf_func = (void *)image;",
                        "\t\tprog->jited = 1;",
                        "\t\tprog->jited_len = proglen;",
                        "\t} else {",
                        "\t\tprog = orig_prog;",
                        "\t}",
                        "",
                        "\tif (!image || !prog->is_func || extra_pass) {",
                        "\t\tif (image)",
                        "\t\t\tbpf_prog_fill_jited_linfo(prog, addrs);",
                        "out_addrs:",
                        "\t\tkfree(addrs);",
                        "\t\tkfree(jit_data);",
                        "\t\tprog->aux->jit_data = NULL;",
                        "\t}",
                        "out:",
                        "\tif (tmp_blinded)",
                        "\t\tbpf_jit_prog_release_other(prog, prog == orig_prog ?",
                        "\t\t\t\t\t   tmp : orig_prog);",
                        "\treturn prog;",
                        "}"
                    ],
                    "start": 1061,
                    "highlight": 1131
                }
            ],
            "ins_idx": 137,
            "addr": "0xffffffff8109e69f"
        },
        "1201": {
            "name": "+0x485",
            "parent_idx": 1187,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n676",
                    "code": [
                        "/**",
                        " * kmalloc_array - allocate memory for an array.",
                        " * @n: number of elements.",
                        " * @size: element size.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)",
                        "{",
                        "\tsize_t bytes;",
                        "",
                        "\tif (unlikely(check_mul_overflow(n, size, &bytes)))",
                        "\t\treturn NULL;",
                        "\tif (__builtin_constant_p(n) && __builtin_constant_p(size))",
                        "\t\treturn kmalloc(bytes, flags);",
                        "\treturn __kmalloc(bytes, flags);",
                        "}"
                    ],
                    "start": 662,
                    "highlight": 676
                },
                {
                    "file": "arch/x86/net/bpf_jit_comp.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/net/bpf_jit_comp.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n1108",
                    "code": [
                        "struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)",
                        "{",
                        "\tstruct bpf_binary_header *header = NULL;",
                        "\tstruct bpf_prog *tmp, *orig_prog = prog;",
                        "\tstruct x64_jit_data *jit_data;",
                        "\tint proglen, oldproglen = 0;",
                        "\tstruct jit_context ctx = {};",
                        "\tbool tmp_blinded = false;",
                        "\tbool extra_pass = false;",
                        "\tu8 *image = NULL;",
                        "\tint *addrs;",
                        "\tint pass;",
                        "\tint i;",
                        "",
                        "\tif (!prog->jit_requested)",
                        "\t\treturn orig_prog;",
                        "",
                        "\ttmp = bpf_jit_blind_constants(prog);",
                        "\t/*",
                        "\t * If blinding was requested and we failed during blinding,",
                        "\t * we must fall back to the interpreter.",
                        "\t */",
                        "\tif (IS_ERR(tmp))",
                        "\t\treturn orig_prog;",
                        "\tif (tmp != prog) {",
                        "\t\ttmp_blinded = true;",
                        "\t\tprog = tmp;",
                        "\t}",
                        "",
                        "\tjit_data = prog->aux->jit_data;",
                        "\tif (!jit_data) {",
                        "\t\tjit_data = kzalloc(sizeof(*jit_data), GFP_KERNEL);",
                        "\t\tif (!jit_data) {",
                        "\t\t\tprog = orig_prog;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tprog->aux->jit_data = jit_data;",
                        "\t}",
                        "\taddrs = jit_data->addrs;",
                        "\tif (addrs) {",
                        "\t\tctx = jit_data->ctx;",
                        "\t\toldproglen = jit_data->proglen;",
                        "\t\timage = jit_data->image;",
                        "\t\theader = jit_data->header;",
                        "\t\textra_pass = true;",
                        "\t\tgoto skip_init_addrs;",
                        "\t}",
                        "\taddrs = kmalloc_array(prog->len, sizeof(*addrs), GFP_KERNEL);",
                        "\tif (!addrs) {",
                        "\t\tprog = orig_prog;",
                        "\t\tgoto out_addrs;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Before first pass, make a rough estimation of addrs[]",
                        "\t * each BPF instruction is translated to less than 64 bytes",
                        "\t */",
                        "\tfor (proglen = 0, i = 0; i < prog->len; i++) {",
                        "\t\tproglen += 64;",
                        "\t\taddrs[i] = proglen;",
                        "\t}",
                        "\tctx.cleanup_addr = proglen;",
                        "skip_init_addrs:",
                        "",
                        "\t/*",
                        "\t * JITed image shrinks with every pass and the loop iterates",
                        "\t * until the image stops shrinking. Very large BPF programs",
                        "\t * may converge on the last pass. In such case do one more",
                        "\t * pass to emit the final image.",
                        "\t */",
                        "\tfor (pass = 0; pass < 20 || image; pass++) {",
                        "\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);",
                        "\t\tif (proglen <= 0) {",
                        "out_image:",
                        "\t\t\timage = NULL;",
                        "\t\t\tif (header)",
                        "\t\t\t\tbpf_jit_binary_free(header);",
                        "\t\t\tprog = orig_prog;",
                        "\t\t\tgoto out_addrs;",
                        "\t\t}",
                        "\t\tif (image) {",
                        "\t\t\tif (proglen != oldproglen) {",
                        "\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",",
                        "\t\t\t\t       proglen, oldproglen);",
                        "\t\t\t\tgoto out_image;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (proglen == oldproglen) {",
                        "\t\t\theader = bpf_jit_binary_alloc(proglen, &image,",
                        "\t\t\t\t\t\t      1, jit_fill_hole);",
                        "\t\t\tif (!header) {",
                        "\t\t\t\tprog = orig_prog;",
                        "\t\t\t\tgoto out_addrs;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\toldproglen = proglen;",
                        "\t\tcond_resched();",
                        "\t}",
                        "",
                        "\tif (bpf_jit_enable > 1)",
                        "\t\tbpf_jit_dump(prog->len, proglen, pass + 1, image);",
                        "",
                        "\tif (image) {",
                        "\t\tif (!prog->is_func || extra_pass) {",
                        "\t\t\tbpf_jit_binary_lock_ro(header);",
                        "\t\t} else {",
                        "\t\t\tjit_data->addrs = addrs;",
                        "\t\t\tjit_data->ctx = ctx;",
                        "\t\t\tjit_data->proglen = proglen;",
                        "\t\t\tjit_data->image = image;",
                        "\t\t\tjit_data->header = header;",
                        "\t\t}",
                        "\t\tprog->bpf_func = (void *)image;",
                        "\t\tprog->jited = 1;",
                        "\t\tprog->jited_len = proglen;",
                        "\t} else {",
                        "\t\tprog = orig_prog;",
                        "\t}",
                        "",
                        "\tif (!image || !prog->is_func || extra_pass) {",
                        "\t\tif (image)",
                        "\t\t\tbpf_prog_fill_jited_linfo(prog, addrs);",
                        "out_addrs:",
                        "\t\tkfree(addrs);",
                        "\t\tkfree(jit_data);",
                        "\t\tprog->aux->jit_data = NULL;",
                        "\t}",
                        "out:",
                        "\tif (tmp_blinded)",
                        "\t\tbpf_jit_prog_release_other(prog, prog == orig_prog ?",
                        "\t\t\t\t\t   tmp : orig_prog);",
                        "\treturn prog;",
                        "}"
                    ],
                    "start": 1061,
                    "highlight": 1108
                }
            ],
            "ins_idx": 177,
            "addr": "0xffffffff8109e655"
        },
        "1200": {
            "name": "+0x54",
            "parent_idx": 1199,
            "source_line": [
                {
                    "file": "mm/kasan/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/kasan/common.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n72",
                    "code": [
                        "static inline depot_stack_handle_t save_stack(gfp_t flags)",
                        "{",
                        "\tunsigned long entries[KASAN_STACK_DEPTH];",
                        "\tunsigned int nr_entries;",
                        "",
                        "\tnr_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 0);",
                        "\tnr_entries = filter_irq_stacks(entries, nr_entries);",
                        "\treturn stack_depot_save(entries, nr_entries, flags);",
                        "}"
                    ],
                    "start": 64,
                    "highlight": 72
                }
            ],
            "ins_idx": 219,
            "addr": "0xffffffff813231f4"
        },
        "1199": {
            "name": "__kmalloc",
            "parent_idx": 1187,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n676",
                    "code": [
                        "/**",
                        " * kmalloc_array - allocate memory for an array.",
                        " * @n: number of elements.",
                        " * @size: element size.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)",
                        "{",
                        "\tsize_t bytes;",
                        "",
                        "\tif (unlikely(check_mul_overflow(n, size, &bytes)))",
                        "\t\treturn NULL;",
                        "\tif (__builtin_constant_p(n) && __builtin_constant_p(size))",
                        "\t\treturn kmalloc(bytes, flags);",
                        "\treturn __kmalloc(bytes, flags);",
                        "}"
                    ],
                    "start": 662,
                    "highlight": 676
                },
                {
                    "file": "arch/x86/net/bpf_jit_comp.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/net/bpf_jit_comp.c?id=c6dd78fcb8eefa15dd861889e0f59d301cb5230c#n1108",
                    "code": [
                        "struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)",
                        "{",
                        "\tstruct bpf_binary_header *header = NULL;",
                        "\tstruct bpf_prog *tmp, *orig_prog = prog;",
                        "\tstruct x64_jit_data *jit_data;",
                        "\tint proglen, oldproglen = 0;",
                        "\tstruct jit_context ctx = {};",
                        "\tbool tmp_blinded = false;",
                        "\tbool extra_pass = false;",
                        "\tu8 *image = NULL;",
                        "\tint *addrs;",
                        "\tint pass;",
                        "\tint i;",
                        "",
                        "\tif (!prog->jit_requested)",
                        "\t\treturn orig_prog;",
                        "",
                        "\ttmp = bpf_jit_blind_constants(prog);",
                        "\t/*",
                        "\t * If blinding was requested and we failed during blinding,",
                        "\t * we must fall back to the interpreter.",
                        "\t */",
                        "\tif (IS_ERR(tmp))",
                        "\t\treturn orig_prog;",
                        "\tif (tmp != prog) {",
                        "\t\ttmp_blinded = true;",
                        "\t\tprog = tmp;",
                        "\t}",
                        "",
                        "\tjit_data = prog->aux->jit_data;",
                        "\tif (!jit_data) {",
                        "\t\tjit_data = kzalloc(sizeof(*jit_data), GFP_KERNEL);",
                        "\t\tif (!jit_data) {",
                        "\t\t\tprog = orig_prog;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tprog->aux->jit_data = jit_data;",
                        "\t}",
                        "\taddrs = jit_data->addrs;",
                        "\tif (addrs) {",
                        "\t\tctx = jit_data->ctx;",
                        "\t\toldproglen = jit_data->proglen;",
                        "\t\timage = jit_data->image;",
                        "\t\theader = jit_data->header;",
                        "\t\textra_pass = true;",
                        "\t\tgoto skip_init_addrs;",
                        "\t}",
                        "\taddrs = kmalloc_array(prog->len, sizeof(*addrs), GFP_KERNEL);",
                        "\tif (!addrs) {",
                        "\t\tprog = orig_prog;",
                        "\t\tgoto out_addrs;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Before first pass, make a rough estimation of addrs[]",
                        "\t * each BPF instruction is translated to less than 64 bytes",
                        "\t */",
                        "\tfor (proglen = 0, i = 0; i < prog->len; i++) {",
                        "\t\tproglen += 64;",
                        "\t\taddrs[i] = proglen;",
                        "\t}",
                        "\tctx.cleanup_addr = proglen;",
                        "skip_init_addrs:",
                        "",
                        "\t/*",
                        "\t * JITed image shrinks with every pass and the loop iterates",
                        "\t * until the image stops shrinking. Very large BPF programs",
                        "\t * may converge on the last pass. In such case do one more",
                        "\t * pass to emit the final image.",
                        "\t */",
                        "\tfor (pass = 0; pass < 20 || image; pass++) {",
                        "\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);",
                        "\t\tif (proglen <= 0) {",
                        "out_image:",
                        "\t\t\timage = NULL;",
                        "\t\t\tif (header)",
                        "\t\t\t\tbpf_jit_binary_free(header);",
                        "\t\t\tprog = orig_prog;",
                        "\t\t\tgoto out_addrs;",
                        "\t\t}",
                        "\t\tif (image) {",
                        "\t\t\tif (proglen != oldproglen) {",
                        "\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",",
                        "\t\t\t\t       proglen, oldproglen);",
                        "\t\t\t\tgoto out_image;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (proglen == oldproglen) {",
                        "\t\t\theader = bpf_jit_binary_alloc(proglen, &image,",
                        "\t\t\t\t\t\t      1, jit_fill_hole);",
                        "\t\t\tif (!header) {",
                        "\t\t\t\tprog = orig_prog;",
                        "\t\t\t\tgoto out_addrs;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\toldproglen = proglen;",
                        "\t\tcond_resched();",
                        "\t}",
                        "",
                        "\tif (bpf_jit_enable > 1)",
                        "\t\tbpf_jit_dump(prog->len, proglen, pass + 1, image);",
                        "",
                        "\tif (image) {",
                        "\t\tif (!prog->is_func || extra_pass) {",
                        "\t\t\tbpf_jit_binary_lock_ro(header);",
                        "\t\t} else {",
                        "\t\t\tjit_data->addrs = addrs;",
                        "\t\t\tjit_data->ctx = ctx;",
                        "\t\t\tjit_data->proglen = proglen;",
                        "\t\t\tjit_data->image = image;",
                        "\t\t\tjit_data->header = header;",
                        "\t\t}",
                        "\t\tprog->bpf_func = (void *)image;",
                        "\t\tprog->jited = 1;",
                        "\t\tprog->jited_len = proglen;",
                        "\t} else {",
                        "\t\tprog = orig_prog;",
                        "\t}",
                        "",
                        "\tif (!image || !prog->is_func || extra_pass) {",
                        "\t\tif (image)",
                        "\t\t\tbpf_prog_fill_jited_linfo(prog, addrs);",
                        "out_addrs:",
                        "\t\tkfree(addrs);",
                        "\t\tkfree(jit_data);",
                        "\t\tprog->aux->jit_data = NULL;",
                        "\t}",
                        "out:",
                        "\tif (tmp_blinded)",
                        "\t\tbpf_jit_prog_release_other(prog, prog == orig_prog ?",
                        "\t\t\t\t\t   tmp : orig_prog);",
                        "\treturn prog;",
                        "}"
                    ],
                    "start": 1061,
                    "highlight": 1108
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8109e650"
        }
    },
    "ins": {
        "13": {
            "name": "mov r13d, dword ptr [r12]",
            "desc": "Invalid Memory Access\nOut of Bound Access.",
            "call_idx": 1238,
            "inputs": [
                2420,
                2421
            ],
            "outputs": [
                2422
            ]
        },
        "26": {
            "name": "lea r12, qword ptr [r15 + rax*4]",
            "desc": "",
            "call_idx": 1237,
            "inputs": [
                2417,
                2418
            ],
            "outputs": [
                2419
            ]
        },
        "41": {
            "name": "mov r15, qword ptr [rsp + 0x20]",
            "desc": "",
            "call_idx": 1234,
            "inputs": [
                2409,
                2410
            ],
            "outputs": [
                2411
            ]
        },
        "67": {
            "name": "mov qword ptr [rsp + 0x20], rsi",
            "desc": "",
            "call_idx": 1208,
            "inputs": [
                2359,
                2360
            ],
            "outputs": [
                2361
            ]
        },
        "100": {
            "name": "mov rsi, r13",
            "desc": "",
            "call_idx": 1203,
            "inputs": [
                2352
            ],
            "outputs": [
                2353
            ]
        },
        "137": {
            "name": "mov r13, rbx",
            "desc": "",
            "call_idx": 1202,
            "inputs": [
                2350
            ],
            "outputs": [
                2351
            ]
        },
        "177": {
            "name": "mov rbx, rax",
            "desc": "",
            "call_idx": 1201,
            "inputs": [
                2348
            ],
            "outputs": [
                2349
            ]
        },
        "219": {
            "name": "ret ",
            "desc": "",
            "call_idx": 1200,
            "inputs": [],
            "outputs": [
                2347
            ]
        }
    },
    "data": {
        "2420": {
            "name": "R12",
            "ins_idx": 13,
            "value": "0xffff8881ee3de9dc",
            "sources": []
        },
        "2421": {
            "name": "[0xffff8881ee3de9dc]",
            "ins_idx": 13,
            "value": "0x0",
            "sources": []
        },
        "2422": {
            "name": "R13",
            "ins_idx": 13,
            "value": "0x0",
            "sources": []
        },
        "2417": {
            "name": "RAX",
            "ins_idx": 26,
            "value": "0xffffffffffffffff",
            "sources": []
        },
        "2418": {
            "name": "R15",
            "ins_idx": 26,
            "value": "0xffff8881ee3de9e0",
            "sources": []
        },
        "2419": {
            "name": "R12",
            "ins_idx": 26,
            "value": "0xffff8881ee3de9dc",
            "sources": [
                2420
            ]
        },
        "2409": {
            "name": "RSP",
            "ins_idx": 41,
            "value": "0xffff8881eee8f880",
            "sources": []
        },
        "2410": {
            "name": "[0xffff8881eee8f8a0]",
            "ins_idx": 41,
            "value": "0xffff8881ee3de9e0",
            "sources": []
        },
        "2411": {
            "name": "R15",
            "ins_idx": 41,
            "value": "0xffff8881ee3de9e0",
            "sources": [
                2418
            ]
        },
        "2359": {
            "name": "RSP",
            "ins_idx": 67,
            "value": "0xffff8881eee8f880",
            "sources": []
        },
        "2360": {
            "name": "RSI",
            "ins_idx": 67,
            "value": "0xffff8881ee3de9e0",
            "sources": []
        },
        "2361": {
            "name": "[0xffff8881eee8f8a0]",
            "ins_idx": 67,
            "value": "0xffff8881ee3de9e0",
            "sources": [
                2410
            ]
        },
        "2352": {
            "name": "R13",
            "ins_idx": 100,
            "value": "0xffff8881ee3de9e0",
            "sources": []
        },
        "2353": {
            "name": "RSI",
            "ins_idx": 100,
            "value": "0xffff8881ee3de9e0",
            "sources": [
                2360
            ]
        },
        "2350": {
            "name": "RBX",
            "ins_idx": 137,
            "value": "0xffff8881ee3de9e0",
            "sources": []
        },
        "2351": {
            "name": "R13",
            "ins_idx": 137,
            "value": "0xffff8881ee3de9e0",
            "sources": [
                2352
            ]
        },
        "2348": {
            "name": "RAX",
            "ins_idx": 177,
            "value": "0xffff8881ee3de9e0",
            "sources": []
        },
        "2349": {
            "name": "RBX",
            "ins_idx": 177,
            "value": "0xffff8881ee3de9e0",
            "sources": [
                2350
            ]
        },
        "2347": {
            "name": "RAX",
            "ins_idx": 219,
            "value": "0xffff8881ee3de9e0",
            "sources": [
                2348
            ]
        }
    },
    "chain": {
        "13": [
            26
        ],
        "26": [
            41
        ],
        "41": [
            67
        ],
        "67": [
            100
        ],
        "100": [
            137
        ],
        "137": [
            177
        ],
        "177": [
            219
        ]
    }
}