{
    "report": "https://syzkaller.appspot.com/bug?id=f451140ba972ca7403ecd31763421fb84b9caeac",
    "title": "general protection fault in __apic_accept_irq (2)",
    "call": {
        "1478": {
            "name": "+0x22",
            "parent_idx": 1476,
            "source_line": [
                {
                    "file": "arch/x86/kvm/lapic.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/lapic.c?id=7ae77150d94d#n1039",
                    "code": [
                        "/*",
                        " * Add a pending IRQ into lapic.",
                        " * Return 1 if successfully added and 0 if discarded.",
                        " */",
                        "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,",
                        "\t\t\t     int vector, int level, int trig_mode,",
                        "\t\t\t     struct dest_map *dest_map)",
                        "{",
                        "\tint result = 0;",
                        "\tstruct kvm_vcpu *vcpu = apic->vcpu;",
                        "",
                        "\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,",
                        "\t\t\t\t  trig_mode, vector);",
                        "\tswitch (delivery_mode) {",
                        "\tcase APIC_DM_LOWEST:",
                        "\t\tvcpu->arch.apic_arb_prio++;",
                        "\t\t/* fall through */",
                        "\tcase APIC_DM_FIXED:",
                        "\t\tif (unlikely(trig_mode && !level))",
                        "\t\t\tbreak;",
                        "",
                        "\t\t/* FIXME add logic for vcpu on reset */",
                        "\t\tif (unlikely(!apic_enabled(apic)))",
                        "\t\t\tbreak;",
                        "",
                        "\t\tresult = 1;",
                        "",
                        "\t\tif (dest_map) {",
                        "\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);",
                        "\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;",
                        "\t\t}",
                        "",
                        "\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {",
                        "\t\t\tif (trig_mode)",
                        "\t\t\t\tkvm_lapic_set_vector(vector,",
                        "\t\t\t\t\t\t     apic->regs + APIC_TMR);",
                        "\t\t\telse",
                        "\t\t\t\tkvm_lapic_clear_vector(vector,",
                        "\t\t\t\t\t\t       apic->regs + APIC_TMR);",
                        "\t\t}",
                        "",
                        "\t\tif (kvm_x86_ops.deliver_posted_interrupt(vcpu, vector)) {",
                        "\t\t\tkvm_lapic_set_irr(vector, apic);",
                        "\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);",
                        "\t\t\tkvm_vcpu_kick(vcpu);",
                        "\t\t}",
                        "\t\tbreak;",
                        "",
                        "\tcase APIC_DM_REMRD:",
                        "\t\tresult = 1;",
                        "\t\tvcpu->arch.pv.pv_unhalted = 1;",
                        "\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);",
                        "\t\tkvm_vcpu_kick(vcpu);",
                        "\t\tbreak;",
                        "",
                        "\tcase APIC_DM_SMI:",
                        "\t\tresult = 1;",
                        "\t\tkvm_make_request(KVM_REQ_SMI, vcpu);",
                        "\t\tkvm_vcpu_kick(vcpu);",
                        "\t\tbreak;",
                        "",
                        "\tcase APIC_DM_NMI:",
                        "\t\tresult = 1;",
                        "\t\tkvm_inject_nmi(vcpu);",
                        "\t\tkvm_vcpu_kick(vcpu);",
                        "\t\tbreak;",
                        "",
                        "\tcase APIC_DM_INIT:",
                        "\t\tif (!trig_mode || level) {",
                        "\t\t\tresult = 1;",
                        "\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */",
                        "\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);",
                        "\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);",
                        "\t\t\tkvm_vcpu_kick(vcpu);",
                        "\t\t}",
                        "\t\tbreak;",
                        "",
                        "\tcase APIC_DM_STARTUP:",
                        "\t\tresult = 1;",
                        "\t\tapic->sipi_vector = vector;",
                        "\t\t/* make sure sipi_vector is visible for the receiver */",
                        "\t\tsmp_wmb();",
                        "\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);",
                        "\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);",
                        "\t\tkvm_vcpu_kick(vcpu);",
                        "\t\tbreak;",
                        "",
                        "\tcase APIC_DM_EXTINT:",
                        "\t\t/*",
                        "\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,",
                        "\t\t * before NMI watchdog was enabled. Already handled by",
                        "\t\t * kvm_apic_accept_pic_intr().",
                        "\t\t */",
                        "\t\tbreak;",
                        "",
                        "\tdefault:",
                        "\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",",
                        "\t\t       delivery_mode);",
                        "\t\tbreak;",
                        "\t}",
                        "\treturn result;",
                        "}"
                    ],
                    "start": 1030,
                    "highlight": 1039
                }
            ],
            "ins_idx": 8,
            "addr": "0xffffffff810501f2"
        },
        "1476": {
            "name": "kvm_apic_set_irq",
            "parent_idx": 1467,
            "source_line": [
                {
                    "file": "arch/x86/kvm/x86.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/x86.c?id=7ae77150d94d#n10580",
                    "code": [
                        "void kvm_arch_async_page_present(struct kvm_vcpu *vcpu,",
                        "\t\t\t\t struct kvm_async_pf *work)",
                        "{",
                        "\tstruct kvm_lapic_irq irq = {",
                        "\t\t.delivery_mode = APIC_DM_FIXED,",
                        "\t\t.vector = vcpu->arch.apf.vec",
                        "\t};",
                        "",
                        "\tif (work->wakeup_all)",
                        "\t\twork->arch.token = ~0; /* broadcast wakeup */",
                        "\telse",
                        "\t\tkvm_del_async_pf_gfn(vcpu, work->arch.gfn);",
                        "\ttrace_kvm_async_pf_ready(work->arch.token, work->cr2_or_gpa);",
                        "",
                        "\tif (kvm_pv_async_pf_enabled(vcpu) &&",
                        "\t    !apf_put_user_ready(vcpu, work->arch.token)) {",
                        "\t\tvcpu->arch.apf.pageready_pending = true;",
                        "\t\tkvm_apic_set_irq(vcpu, &irq, NULL);",
                        "\t}",
                        "",
                        "\tvcpu->arch.apf.halted = false;",
                        "\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;",
                        "}"
                    ],
                    "start": 10563,
                    "highlight": 10580
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff810427ab"
        },
        "1467": {
            "name": "kvm_arch_async_page_present",
            "parent_idx": 1458,
            "source_line": [
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/async_pf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/async_pf.c?id=7ae77150d94d#n151",
                    "code": [
                        "void kvm_check_async_pf_completion(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tstruct kvm_async_pf *work;",
                        "",
                        "\twhile (!list_empty_careful(&vcpu->async_pf.done) &&",
                        "\t      kvm_arch_can_dequeue_async_page_present(vcpu)) {",
                        "\t\tspin_lock(&vcpu->async_pf.lock);",
                        "\t\twork = list_first_entry(&vcpu->async_pf.done, typeof(*work),",
                        "\t\t\t\t\t      link);",
                        "\t\tlist_del(&work->link);",
                        "\t\tspin_unlock(&vcpu->async_pf.lock);",
                        "",
                        "\t\tkvm_arch_async_page_ready(vcpu, work);",
                        "\t\tif (!IS_ENABLED(CONFIG_KVM_ASYNC_PF_SYNC))",
                        "\t\t\tkvm_arch_async_page_present(vcpu, work);",
                        "",
                        "\t\tlist_del(&work->queue);",
                        "\t\tvcpu->async_pf.queued--;",
                        "\t\tkmem_cache_free(async_pf_cache, work);",
                        "\t}",
                        "}"
                    ],
                    "start": 137,
                    "highlight": 151
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8102901c"
        },
        "1458": {
            "name": "kvm_check_async_pf_completion",
            "parent_idx": 1437,
            "source_line": [
                {
                    "file": "arch/x86/kvm/x86.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/x86.c?id=7ae77150d94d#n8437",
                    "code": [
                        "/*",
                        " * Returns 1 to let vcpu_run() continue the guest execution loop without",
                        " * exiting to the userspace.  Otherwise, the value will be returned to the",
                        " * userspace.",
                        " */",
                        "static int vcpu_enter_guest(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tint r;",
                        "\tbool req_int_win =",
                        "\t\tdm_request_for_irq_injection(vcpu) &&",
                        "\t\tkvm_cpu_accept_dm_intr(vcpu);",
                        "\tfastpath_t exit_fastpath;",
                        "",
                        "\tbool req_immediate_exit = false;",
                        "",
                        "\tif (kvm_request_pending(vcpu)) {",
                        "\t\tif (kvm_check_request(KVM_REQ_GET_VMCS12_PAGES, vcpu)) {",
                        "\t\t\tif (unlikely(!kvm_x86_ops.nested_ops->get_vmcs12_pages(vcpu))) {",
                        "\t\t\t\tr = 0;",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))",
                        "\t\t\tkvm_mmu_unload(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))",
                        "\t\t\t__kvm_migrate_timers(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))",
                        "\t\t\tkvm_gen_update_masterclock(vcpu->kvm);",
                        "\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))",
                        "\t\t\tkvm_gen_kvmclock_update(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {",
                        "\t\t\tr = kvm_guest_time_update(vcpu);",
                        "\t\t\tif (unlikely(r))",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))",
                        "\t\t\tkvm_mmu_sync_roots(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_LOAD_MMU_PGD, vcpu))",
                        "\t\t\tkvm_mmu_load_pgd(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu)) {",
                        "\t\t\tkvm_vcpu_flush_tlb_all(vcpu);",
                        "",
                        "\t\t\t/* Flushing all ASIDs flushes the current ASID... */",
                        "\t\t\tkvm_clear_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu))",
                        "\t\t\tkvm_vcpu_flush_tlb_current(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_HV_TLB_FLUSH, vcpu))",
                        "\t\t\tkvm_vcpu_flush_tlb_guest(vcpu);",
                        "",
                        "\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;",
                        "\t\t\tr = 0;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;",
                        "\t\t\tvcpu->mmio_needed = 0;",
                        "\t\t\tr = 0;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {",
                        "\t\t\t/* Page is swapped out. Do synthetic halt */",
                        "\t\t\tvcpu->arch.apf.halted = true;",
                        "\t\t\tr = 1;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))",
                        "\t\t\trecord_steal_time(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_SMI, vcpu))",
                        "\t\t\tprocess_smi(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))",
                        "\t\t\tprocess_nmi(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))",
                        "\t\t\tkvm_pmu_handle_event(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))",
                        "\t\t\tkvm_pmu_deliver_pmi(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {",
                        "\t\t\tBUG_ON(vcpu->arch.pending_ioapic_eoi > 255);",
                        "\t\t\tif (test_bit(vcpu->arch.pending_ioapic_eoi,",
                        "\t\t\t\t     vcpu->arch.ioapic_handled_vectors)) {",
                        "\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;",
                        "\t\t\t\tvcpu->run->eoi.vector =",
                        "\t\t\t\t\t\tvcpu->arch.pending_ioapic_eoi;",
                        "\t\t\t\tr = 0;",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))",
                        "\t\t\tvcpu_scan_ioapic(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))",
                        "\t\t\tvcpu_load_eoi_exitmap(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))",
                        "\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;",
                        "\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_CRASH;",
                        "\t\t\tr = 0;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;",
                        "\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_RESET;",
                        "\t\t\tr = 0;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_HV_EXIT, vcpu)) {",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;",
                        "\t\t\tvcpu->run->hyperv = vcpu->arch.hyperv.exit;",
                        "\t\t\tr = 0;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * KVM_REQ_HV_STIMER has to be processed after",
                        "\t\t * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers",
                        "\t\t * depend on the guest clock being up-to-date",
                        "\t\t */",
                        "\t\tif (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))",
                        "\t\t\tkvm_hv_process_stimers(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))",
                        "\t\t\tkvm_vcpu_update_apicv(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_APF_READY, vcpu))",
                        "\t\t\tkvm_check_async_pf_completion(vcpu);",
                        "\t}",
                        "",
                        "\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {",
                        "\t\t++vcpu->stat.req_event;",
                        "\t\tkvm_apic_accept_events(vcpu);",
                        "\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {",
                        "\t\t\tr = 1;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tinject_pending_event(vcpu, &req_immediate_exit);",
                        "\t\tif (req_int_win)",
                        "\t\t\tkvm_x86_ops.enable_irq_window(vcpu);",
                        "",
                        "\t\tif (kvm_lapic_enabled(vcpu)) {",
                        "\t\t\tupdate_cr8_intercept(vcpu);",
                        "\t\t\tkvm_lapic_sync_to_vapic(vcpu);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tr = kvm_mmu_reload(vcpu);",
                        "\tif (unlikely(r)) {",
                        "\t\tgoto cancel_injection;",
                        "\t}",
                        "",
                        "\tpreempt_disable();",
                        "",
                        "\tkvm_x86_ops.prepare_guest_switch(vcpu);",
                        "",
                        "\t/*",
                        "\t * Disable IRQs before setting IN_GUEST_MODE.  Posted interrupt",
                        "\t * IPI are then delayed after guest entry, which ensures that they",
                        "\t * result in virtual interrupt delivery.",
                        "\t */",
                        "\tlocal_irq_disable();",
                        "\tvcpu->mode = IN_GUEST_MODE;",
                        "",
                        "\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);",
                        "",
                        "\t/*",
                        "\t * 1) We should set ->mode before checking ->requests.  Please see",
                        "\t * the comment in kvm_vcpu_exiting_guest_mode().",
                        "\t *",
                        "\t * 2) For APICv, we should set ->mode before checking PID.ON. This",
                        "\t * pairs with the memory barrier implicit in pi_test_and_set_on",
                        "\t * (see vmx_deliver_posted_interrupt).",
                        "\t *",
                        "\t * 3) This also orders the write to mode from any reads to the page",
                        "\t * tables done while the VCPU is running.  Please see the comment",
                        "\t * in kvm_flush_remote_tlbs.",
                        "\t */",
                        "\tsmp_mb__after_srcu_read_unlock();",
                        "",
                        "\t/*",
                        "\t * This handles the case where a posted interrupt was",
                        "\t * notified with kvm_vcpu_kick.",
                        "\t */",
                        "\tif (kvm_lapic_enabled(vcpu) && vcpu->arch.apicv_active)",
                        "\t\tkvm_x86_ops.sync_pir_to_irr(vcpu);",
                        "",
                        "\tif (kvm_vcpu_exit_request(vcpu)) {",
                        "\t\tvcpu->mode = OUTSIDE_GUEST_MODE;",
                        "\t\tsmp_wmb();",
                        "\t\tlocal_irq_enable();",
                        "\t\tpreempt_enable();",
                        "\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);",
                        "\t\tr = 1;",
                        "\t\tgoto cancel_injection;",
                        "\t}",
                        "",
                        "\tif (req_immediate_exit) {",
                        "\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);",
                        "\t\tkvm_x86_ops.request_immediate_exit(vcpu);",
                        "\t}",
                        "",
                        "\ttrace_kvm_entry(vcpu->vcpu_id);",
                        "\tguest_enter_irqoff();",
                        "",
                        "\tfpregs_assert_state_consistent();",
                        "\tif (test_thread_flag(TIF_NEED_FPU_LOAD))",
                        "\t\tswitch_fpu_return();",
                        "",
                        "\tif (unlikely(vcpu->arch.switch_db_regs)) {",
                        "\t\tset_debugreg(0, 7);",
                        "\t\tset_debugreg(vcpu->arch.eff_db[0], 0);",
                        "\t\tset_debugreg(vcpu->arch.eff_db[1], 1);",
                        "\t\tset_debugreg(vcpu->arch.eff_db[2], 2);",
                        "\t\tset_debugreg(vcpu->arch.eff_db[3], 3);",
                        "\t\tset_debugreg(vcpu->arch.dr6, 6);",
                        "\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;",
                        "\t}",
                        "",
                        "\texit_fastpath = kvm_x86_ops.run(vcpu);",
                        "",
                        "\t/*",
                        "\t * Do this here before restoring debug registers on the host.  And",
                        "\t * since we do this before handling the vmexit, a DR access vmexit",
                        "\t * can (a) read the correct value of the debug registers, (b) set",
                        "\t * KVM_DEBUGREG_WONT_EXIT again.",
                        "\t */",
                        "\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {",
                        "\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);",
                        "\t\tkvm_x86_ops.sync_dirty_debug_regs(vcpu);",
                        "\t\tkvm_update_dr0123(vcpu);",
                        "\t\tkvm_update_dr7(vcpu);",
                        "\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * If the guest has used debug registers, at least dr7",
                        "\t * will be disabled while returning to the host.",
                        "\t * If we don't have active breakpoints in the host, we don't",
                        "\t * care about the messed up debug address registers. But if",
                        "\t * we have some of them active, restore the old state.",
                        "\t */",
                        "\tif (hw_breakpoint_active())",
                        "\t\thw_breakpoint_restore();",
                        "",
                        "\tvcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());",
                        "",
                        "\tvcpu->mode = OUTSIDE_GUEST_MODE;",
                        "\tsmp_wmb();",
                        "",
                        "\tkvm_x86_ops.handle_exit_irqoff(vcpu);",
                        "",
                        "\t/*",
                        "\t * Consume any pending interrupts, including the possible source of",
                        "\t * VM-Exit on SVM and any ticks that occur between VM-Exit and now.",
                        "\t * An instruction is required after local_irq_enable() to fully unblock",
                        "\t * interrupts on processors that implement an interrupt shadow, the",
                        "\t * stat.exits increment will do nicely.",
                        "\t */",
                        "\tkvm_before_interrupt(vcpu);",
                        "\tlocal_irq_enable();",
                        "\t++vcpu->stat.exits;",
                        "\tlocal_irq_disable();",
                        "\tkvm_after_interrupt(vcpu);",
                        "",
                        "\tguest_exit_irqoff();",
                        "\tif (lapic_in_kernel(vcpu)) {",
                        "\t\ts64 delta = vcpu->arch.apic->lapic_timer.advance_expire_delta;",
                        "\t\tif (delta != S64_MIN) {",
                        "\t\t\ttrace_kvm_wait_lapic_expire(vcpu->vcpu_id, delta);",
                        "\t\t\tvcpu->arch.apic->lapic_timer.advance_expire_delta = S64_MIN;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tlocal_irq_enable();",
                        "\tpreempt_enable();",
                        "",
                        "\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);",
                        "",
                        "\t/*",
                        "\t * Profile KVM exit RIPs:",
                        "\t */",
                        "\tif (unlikely(prof_on == KVM_PROFILING)) {",
                        "\t\tunsigned long rip = kvm_rip_read(vcpu);",
                        "\t\tprofile_hit(KVM_PROFILING, (void *)rip);",
                        "\t}",
                        "",
                        "\tif (unlikely(vcpu->arch.tsc_always_catchup))",
                        "\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);",
                        "",
                        "\tif (vcpu->arch.apic_attention)",
                        "\t\tkvm_lapic_sync_from_vapic(vcpu);",
                        "",
                        "\tr = kvm_x86_ops.handle_exit(vcpu, exit_fastpath);",
                        "\treturn r;",
                        "",
                        "cancel_injection:",
                        "\tif (req_immediate_exit)",
                        "\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);",
                        "\tkvm_x86_ops.cancel_injection(vcpu);",
                        "\tif (unlikely(vcpu->arch.apic_attention))",
                        "\t\tkvm_lapic_sync_from_vapic(vcpu);",
                        "out:",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 8314,
                    "highlight": 8437
                },
                {
                    "file": "arch/x86/kvm/x86.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/x86.c?id=7ae77150d94d#n8669",
                    "code": [
                        "static int vcpu_run(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tint r;",
                        "\tstruct kvm *kvm = vcpu->kvm;",
                        "",
                        "\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);",
                        "\tvcpu->arch.l1tf_flush_l1d = true;",
                        "",
                        "\tfor (;;) {",
                        "\t\tif (kvm_vcpu_running(vcpu)) {",
                        "\t\t\tr = vcpu_enter_guest(vcpu);",
                        "\t\t} else {",
                        "\t\t\tr = vcpu_block(kvm, vcpu);",
                        "\t\t}",
                        "",
                        "\t\tif (r <= 0)",
                        "\t\t\tbreak;",
                        "",
                        "\t\tkvm_clear_request(KVM_REQ_PENDING_TIMER, vcpu);",
                        "\t\tif (kvm_cpu_has_pending_timer(vcpu))",
                        "\t\t\tkvm_inject_pending_timer_irqs(vcpu);",
                        "",
                        "\t\tif (dm_request_for_irq_injection(vcpu) &&",
                        "\t\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu)) {",
                        "\t\t\tr = 0;",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;",
                        "\t\t\t++vcpu->stat.request_irq_exits;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\tif (signal_pending(current)) {",
                        "\t\t\tr = -EINTR;",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;",
                        "\t\t\t++vcpu->stat.signal_exits;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (need_resched()) {",
                        "\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);",
                        "\t\t\tcond_resched();",
                        "\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);",
                        "",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 8659,
                    "highlight": 8669
                },
                {
                    "file": "arch/x86/kvm/x86.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/x86.c?id=7ae77150d94d#n8890",
                    "code": [
                        "int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tstruct kvm_run *kvm_run = vcpu->run;",
                        "\tint r;",
                        "",
                        "\tvcpu_load(vcpu);",
                        "\tkvm_sigset_activate(vcpu);",
                        "\tkvm_load_guest_fpu(vcpu);",
                        "",
                        "\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {",
                        "\t\tif (kvm_run->immediate_exit) {",
                        "\t\t\tr = -EINTR;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tkvm_vcpu_block(vcpu);",
                        "\t\tkvm_apic_accept_events(vcpu);",
                        "\t\tkvm_clear_request(KVM_REQ_UNHALT, vcpu);",
                        "\t\tr = -EAGAIN;",
                        "\t\tif (signal_pending(current)) {",
                        "\t\t\tr = -EINTR;",
                        "\t\t\tkvm_run->exit_reason = KVM_EXIT_INTR;",
                        "\t\t\t++vcpu->stat.signal_exits;",
                        "\t\t}",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (kvm_run->kvm_valid_regs & ~KVM_SYNC_X86_VALID_FIELDS) {",
                        "\t\tr = -EINVAL;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (kvm_run->kvm_dirty_regs) {",
                        "\t\tr = sync_regs(vcpu);",
                        "\t\tif (r != 0)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\t/* re-sync apic's tpr */",
                        "\tif (!lapic_in_kernel(vcpu)) {",
                        "\t\tif (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {",
                        "\t\t\tr = -EINVAL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (unlikely(vcpu->arch.complete_userspace_io)) {",
                        "\t\tint (*cui)(struct kvm_vcpu *) = vcpu->arch.complete_userspace_io;",
                        "\t\tvcpu->arch.complete_userspace_io = NULL;",
                        "\t\tr = cui(vcpu);",
                        "\t\tif (r <= 0)",
                        "\t\t\tgoto out;",
                        "\t} else",
                        "\t\tWARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);",
                        "",
                        "\tif (kvm_run->immediate_exit)",
                        "\t\tr = -EINTR;",
                        "\telse",
                        "\t\tr = vcpu_run(vcpu);",
                        "",
                        "out:",
                        "\tkvm_put_guest_fpu(vcpu);",
                        "\tif (kvm_run->kvm_valid_regs)",
                        "\t\tstore_regs(vcpu);",
                        "\tpost_kvm_run_save(vcpu);",
                        "\tkvm_sigset_deactivate(vcpu);",
                        "",
                        "\tvcpu_put(vcpu);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 8833,
                    "highlight": 8890
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81040b17"
        },
        "1437": {
            "name": "kvm_arch_vcpu_ioctl_run",
            "parent_idx": 1434,
            "source_line": [
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n3163",
                    "code": [
                        "static long kvm_vcpu_ioctl(struct file *filp,",
                        "\t\t\t   unsigned int ioctl, unsigned long arg)",
                        "{",
                        "\tstruct kvm_vcpu *vcpu = filp->private_data;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint r;",
                        "\tstruct kvm_fpu *fpu = NULL;",
                        "\tstruct kvm_sregs *kvm_sregs = NULL;",
                        "",
                        "\tif (vcpu->kvm->mm != current->mm)",
                        "\t\treturn -EIO;",
                        "",
                        "\tif (unlikely(_IOC_TYPE(ioctl) != KVMIO))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\t/*",
                        "\t * Some architectures have vcpu ioctls that are asynchronous to vcpu",
                        "\t * execution; mutex_lock() would break them.",
                        "\t */",
                        "\tr = kvm_arch_vcpu_async_ioctl(filp, ioctl, arg);",
                        "\tif (r != -ENOIOCTLCMD)",
                        "\t\treturn r;",
                        "",
                        "\tif (mutex_lock_killable(&vcpu->mutex))",
                        "\t\treturn -EINTR;",
                        "\tswitch (ioctl) {",
                        "\tcase KVM_RUN: {",
                        "\t\tstruct pid *oldpid;",
                        "\t\tr = -EINVAL;",
                        "\t\tif (arg)",
                        "\t\t\tgoto out;",
                        "\t\toldpid = rcu_access_pointer(vcpu->pid);",
                        "\t\tif (unlikely(oldpid != task_pid(current))) {",
                        "\t\t\t/* The thread running this VCPU changed. */",
                        "\t\t\tstruct pid *newpid;",
                        "",
                        "\t\t\tr = kvm_arch_vcpu_run_pid_change(vcpu);",
                        "\t\t\tif (r)",
                        "\t\t\t\tbreak;",
                        "",
                        "\t\t\tnewpid = get_task_pid(current, PIDTYPE_PID);",
                        "\t\t\trcu_assign_pointer(vcpu->pid, newpid);",
                        "\t\t\tif (oldpid)",
                        "\t\t\t\tsynchronize_rcu();",
                        "\t\t\tput_pid(oldpid);",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_run(vcpu);",
                        "\t\ttrace_kvm_userspace_exit(vcpu->run->exit_reason, r);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_REGS: {",
                        "\t\tstruct kvm_regs *kvm_regs;",
                        "",
                        "\t\tr = -ENOMEM;",
                        "\t\tkvm_regs = kzalloc(sizeof(struct kvm_regs), GFP_KERNEL_ACCOUNT);",
                        "\t\tif (!kvm_regs)",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_regs(vcpu, kvm_regs);",
                        "\t\tif (r)",
                        "\t\t\tgoto out_free1;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, kvm_regs, sizeof(struct kvm_regs)))",
                        "\t\t\tgoto out_free1;",
                        "\t\tr = 0;",
                        "out_free1:",
                        "\t\tkfree(kvm_regs);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_REGS: {",
                        "\t\tstruct kvm_regs *kvm_regs;",
                        "",
                        "\t\tkvm_regs = memdup_user(argp, sizeof(*kvm_regs));",
                        "\t\tif (IS_ERR(kvm_regs)) {",
                        "\t\t\tr = PTR_ERR(kvm_regs);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_regs(vcpu, kvm_regs);",
                        "\t\tkfree(kvm_regs);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_SREGS: {",
                        "\t\tkvm_sregs = kzalloc(sizeof(struct kvm_sregs),",
                        "\t\t\t\t    GFP_KERNEL_ACCOUNT);",
                        "\t\tr = -ENOMEM;",
                        "\t\tif (!kvm_sregs)",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_sregs(vcpu, kvm_sregs);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, kvm_sregs, sizeof(struct kvm_sregs)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_SREGS: {",
                        "\t\tkvm_sregs = memdup_user(argp, sizeof(*kvm_sregs));",
                        "\t\tif (IS_ERR(kvm_sregs)) {",
                        "\t\t\tr = PTR_ERR(kvm_sregs);",
                        "\t\t\tkvm_sregs = NULL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_sregs(vcpu, kvm_sregs);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_MP_STATE: {",
                        "\t\tstruct kvm_mp_state mp_state;",
                        "",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &mp_state);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &mp_state, sizeof(mp_state)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_MP_STATE: {",
                        "\t\tstruct kvm_mp_state mp_state;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&mp_state, argp, sizeof(mp_state)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_mpstate(vcpu, &mp_state);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_TRANSLATE: {",
                        "\t\tstruct kvm_translation tr;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&tr, argp, sizeof(tr)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_translate(vcpu, &tr);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &tr, sizeof(tr)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_GUEST_DEBUG: {",
                        "\t\tstruct kvm_guest_debug dbg;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&dbg, argp, sizeof(dbg)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_guest_debug(vcpu, &dbg);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_SIGNAL_MASK: {",
                        "\t\tstruct kvm_signal_mask __user *sigmask_arg = argp;",
                        "\t\tstruct kvm_signal_mask kvm_sigmask;",
                        "\t\tsigset_t sigset, *p;",
                        "",
                        "\t\tp = NULL;",
                        "\t\tif (argp) {",
                        "\t\t\tr = -EFAULT;",
                        "\t\t\tif (copy_from_user(&kvm_sigmask, argp,",
                        "\t\t\t\t\t   sizeof(kvm_sigmask)))",
                        "\t\t\t\tgoto out;",
                        "\t\t\tr = -EINVAL;",
                        "\t\t\tif (kvm_sigmask.len != sizeof(sigset))",
                        "\t\t\t\tgoto out;",
                        "\t\t\tr = -EFAULT;",
                        "\t\t\tif (copy_from_user(&sigset, sigmask_arg->sigset,",
                        "\t\t\t\t\t   sizeof(sigset)))",
                        "\t\t\t\tgoto out;",
                        "\t\t\tp = &sigset;",
                        "\t\t}",
                        "\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, p);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_FPU: {",
                        "\t\tfpu = kzalloc(sizeof(struct kvm_fpu), GFP_KERNEL_ACCOUNT);",
                        "\t\tr = -ENOMEM;",
                        "\t\tif (!fpu)",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_fpu(vcpu, fpu);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, fpu, sizeof(struct kvm_fpu)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_FPU: {",
                        "\t\tfpu = memdup_user(argp, sizeof(*fpu));",
                        "\t\tif (IS_ERR(fpu)) {",
                        "\t\t\tr = PTR_ERR(fpu);",
                        "\t\t\tfpu = NULL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_fpu(vcpu, fpu);",
                        "\t\tbreak;",
                        "\t}",
                        "\tdefault:",
                        "\t\tr = kvm_arch_vcpu_ioctl(filp, ioctl, arg);",
                        "\t}",
                        "out:",
                        "\tmutex_unlock(&vcpu->mutex);",
                        "\tkfree(fpu);",
                        "\tkfree(kvm_sregs);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3117,
                    "highlight": 3163
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8101f1f7"
        },
        "1434": {
            "name": "kvm_vcpu_ioctl(indirect)",
            "parent_idx": 1411,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=7ae77150d94d#n47",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 29,
                    "highlight": 47
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=7ae77150d94d#n771",
                    "code": [
                        "int ksys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 757,
                    "highlight": 771
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81274858"
        },
        "1411": {
            "name": "ksys_ioctl",
            "parent_idx": 1409,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=7ae77150d94d#n780",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\treturn ksys_ioctl(fd, cmd, arg);",
                        "}"
                    ],
                    "start": 778,
                    "highlight": 780
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=7ae77150d94d#n778",
                    "code": [
                        "int ksys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\treturn ksys_ioctl(fd, cmd, arg);",
                        "}"
                    ],
                    "start": 757,
                    "highlight": 778
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8127489c"
        },
        "1409": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 1406,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7ae77150d94d#n295",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 282,
                    "highlight": 295
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81002849"
        },
        "1406": {
            "name": "do_syscall_64",
            "parent_idx": 1399,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=7ae77150d94d#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_ON\t\t\t/* return enables interrupts */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "1399": {
            "name": "184_syscall_9",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1477": {
            "name": "+0x13",
            "parent_idx": 1476,
            "source_line": [
                {
                    "file": "arch/x86/kvm/lapic.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/lapic.c?id=7ae77150d94d#n573",
                    "code": [
                        "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,",
                        "\t\t     struct dest_map *dest_map)",
                        "{",
                        "\tstruct kvm_lapic *apic = vcpu->arch.apic;",
                        "",
                        "\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,",
                        "\t\t\tirq->level, irq->trig_mode, dest_map);",
                        "}"
                    ],
                    "start": 568,
                    "highlight": 573
                }
            ],
            "ins_idx": 19,
            "addr": "0xffffffff81050683"
        },
        "1113": {
            "name": "+0x0",
            "parent_idx": 1112,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=7ae77150d94d#n2840",
                    "code": [
                        "\ttrace_kmem_cache_alloc(_RET_IP_, ret, s->object_size,",
                        "\t\t\t\ts->size, gfpflags);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2839,
                    "highlight": 2840
                }
            ],
            "ins_idx": 32,
            "addr": "0xffffffff81252990"
        },
        "1112": {
            "name": "kmem_cache_alloc",
            "parent_idx": 1111,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=7ae77150d94d#n659",
                    "code": [
                        "/*",
                        " * Shortcuts",
                        " */",
                        "static inline void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)",
                        "{",
                        "\treturn kmem_cache_alloc(k, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 654,
                    "highlight": 659
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n3041",
                    "code": [
                        "/*",
                        " * Creates some virtual cpus.  Good luck creating more than one.",
                        " */",
                        "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)",
                        "{",
                        "\tint r;",
                        "\tstruct kvm_vcpu *vcpu;",
                        "\tstruct page *page;",
                        "",
                        "\tif (id >= KVM_MAX_VCPU_ID)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm->created_vcpus == KVM_MAX_VCPUS) {",
                        "\t\tmutex_unlock(&kvm->lock);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tkvm->created_vcpus++;",
                        "\tmutex_unlock(&kvm->lock);",
                        "",
                        "\tr = kvm_arch_vcpu_precreate(kvm, id);",
                        "\tif (r)",
                        "\t\tgoto vcpu_decrement;",
                        "",
                        "\tvcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);",
                        "\tif (!vcpu) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_decrement;",
                        "\t}",
                        "",
                        "\tBUILD_BUG_ON(sizeof(struct kvm_run) > PAGE_SIZE);",
                        "\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);",
                        "\tif (!page) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_free;",
                        "\t}",
                        "\tvcpu->run = page_address(page);",
                        "",
                        "\tkvm_vcpu_init(vcpu, kvm, id);",
                        "",
                        "\tr = kvm_arch_vcpu_create(vcpu);",
                        "\tif (r)",
                        "\t\tgoto vcpu_free_run_page;",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm_get_vcpu_by_id(kvm, id)) {",
                        "\t\tr = -EEXIST;",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tvcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);",
                        "\tBUG_ON(kvm->vcpus[vcpu->vcpu_idx]);",
                        "",
                        "\t/* Now it's all set up, let userspace reach it */",
                        "\tkvm_get_kvm(kvm);",
                        "\tr = create_vcpu_fd(vcpu);",
                        "\tif (r < 0) {",
                        "\t\tkvm_put_kvm_no_destroy(kvm);",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tkvm->vcpus[vcpu->vcpu_idx] = vcpu;",
                        "",
                        "\t/*",
                        "\t * Pairs with smp_rmb() in kvm_get_vcpu.  Write kvm->vcpus",
                        "\t * before kvm->online_vcpu's incremented value.",
                        "\t */",
                        "\tsmp_wmb();",
                        "\tatomic_inc(&kvm->online_vcpus);",
                        "",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_arch_vcpu_postcreate(vcpu);",
                        "\tkvm_create_vcpu_debugfs(vcpu);",
                        "\treturn r;",
                        "",
                        "unlock_vcpu_destroy:",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_arch_vcpu_destroy(vcpu);",
                        "vcpu_free_run_page:",
                        "\tfree_page((unsigned long)vcpu->run);",
                        "vcpu_free:",
                        "\tkmem_cache_free(kvm_vcpu_cache, vcpu);",
                        "vcpu_decrement:",
                        "\tmutex_lock(&kvm->lock);",
                        "\tkvm->created_vcpus--;",
                        "\tmutex_unlock(&kvm->lock);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3016,
                    "highlight": 3041
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n3617",
                    "code": [
                        "static long kvm_vm_ioctl(struct file *filp,",
                        "\t\t\t   unsigned int ioctl, unsigned long arg)",
                        "{",
                        "\tstruct kvm *kvm = filp->private_data;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint r;",
                        "",
                        "\tif (kvm->mm != current->mm)",
                        "\t\treturn -EIO;",
                        "\tswitch (ioctl) {",
                        "\tcase KVM_CREATE_VCPU:",
                        "\t\tr = kvm_vm_ioctl_create_vcpu(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_ENABLE_CAP: {",
                        "\t\tstruct kvm_enable_cap cap;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cap, argp, sizeof(cap)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_USER_MEMORY_REGION: {",
                        "\t\tstruct kvm_userspace_memory_region kvm_userspace_mem;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&kvm_userspace_mem, argp,",
                        "\t\t\t\t\t\tsizeof(kvm_userspace_mem)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_DIRTY_LOG: {",
                        "\t\tstruct kvm_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT",
                        "\tcase KVM_CLEAR_DIRTY_LOG: {",
                        "\t\tstruct kvm_clear_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_KVM_MMIO",
                        "\tcase KVM_REGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_UNREGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "\tcase KVM_IRQFD: {",
                        "\t\tstruct kvm_irqfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_irqfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_IOEVENTFD: {",
                        "\t\tstruct kvm_ioeventfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_ioeventfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_HAVE_KVM_MSI",
                        "\tcase KVM_SIGNAL_MSI: {",
                        "\t\tstruct kvm_msi msi;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&msi, argp, sizeof(msi)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_send_userspace_msi(kvm, &msi);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef __KVM_HAVE_IRQ_LINE",
                        "\tcase KVM_IRQ_LINE_STATUS:",
                        "\tcase KVM_IRQ_LINE: {",
                        "\t\tstruct kvm_irq_level irq_event;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&irq_event, argp, sizeof(irq_event)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_irq_line(kvm, &irq_event,",
                        "\t\t\t\t\tioctl == KVM_IRQ_LINE_STATUS);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {",
                        "\t\t\tif (copy_to_user(argp, &irq_event, sizeof(irq_event)))",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING",
                        "\tcase KVM_SET_GSI_ROUTING: {",
                        "\t\tstruct kvm_irq_routing routing;",
                        "\t\tstruct kvm_irq_routing __user *urouting;",
                        "\t\tstruct kvm_irq_routing_entry *entries = NULL;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&routing, argp, sizeof(routing)))",
                        "\t\t\tgoto out;",
                        "\t\tr = -EINVAL;",
                        "\t\tif (!kvm_arch_can_set_irq_routing(kvm))",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr > KVM_MAX_IRQ_ROUTES)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.flags)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr) {",
                        "\t\t\tr = -ENOMEM;",
                        "\t\t\tentries = vmalloc(array_size(sizeof(*entries),",
                        "\t\t\t\t\t\t     routing.nr));",
                        "\t\t\tif (!entries)",
                        "\t\t\t\tgoto out;",
                        "\t\t\tr = -EFAULT;",
                        "\t\t\turouting = argp;",
                        "\t\t\tif (copy_from_user(entries, urouting->entries,",
                        "\t\t\t\t\t   routing.nr * sizeof(*entries)))",
                        "\t\t\t\tgoto out_free_irq_routing;",
                        "\t\t}",
                        "\t\tr = kvm_set_irq_routing(kvm, entries, routing.nr,",
                        "\t\t\t\t\trouting.flags);",
                        "out_free_irq_routing:",
                        "\t\tvfree(entries);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */",
                        "\tcase KVM_CREATE_DEVICE: {",
                        "\t\tstruct kvm_create_device cd;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cd, argp, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_ioctl_create_device(kvm, &cd);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &cd, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_CHECK_EXTENSION:",
                        "\t\tr = kvm_vm_ioctl_check_extension_generic(kvm, arg);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tr = kvm_arch_vm_ioctl(filp, ioctl, arg);",
                        "\t}",
                        "out:",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3606,
                    "highlight": 3617
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81025c44"
        },
        "1111": {
            "name": "kvm_vm_ioctl(indirect)",
            "parent_idx": 1110,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=7ae77150d94d#n47",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 29,
                    "highlight": 47
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=7ae77150d94d#n771",
                    "code": [
                        "int ksys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 757,
                    "highlight": 771
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81274858"
        },
        "1110": {
            "name": "ksys_ioctl",
            "parent_idx": 1109,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=7ae77150d94d#n780",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\treturn ksys_ioctl(fd, cmd, arg);",
                        "}"
                    ],
                    "start": 778,
                    "highlight": 780
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=7ae77150d94d#n778",
                    "code": [
                        "int ksys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\treturn ksys_ioctl(fd, cmd, arg);",
                        "}"
                    ],
                    "start": 757,
                    "highlight": 778
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8127489c"
        },
        "1109": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 1108,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7ae77150d94d#n295",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 282,
                    "highlight": 295
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81002849"
        },
        "1108": {
            "name": "do_syscall_64",
            "parent_idx": 1106,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=7ae77150d94d#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_ON\t\t\t/* return enables interrupts */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "1106": {
            "name": "145_syscall_7",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1475": {
            "name": "+0x1e8",
            "parent_idx": 1467,
            "source_line": [
                {
                    "file": "arch/x86/kvm/x86.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/x86.c?id=7ae77150d94d#n10580",
                    "code": [
                        "void kvm_arch_async_page_present(struct kvm_vcpu *vcpu,",
                        "\t\t\t\t struct kvm_async_pf *work)",
                        "{",
                        "\tstruct kvm_lapic_irq irq = {",
                        "\t\t.delivery_mode = APIC_DM_FIXED,",
                        "\t\t.vector = vcpu->arch.apf.vec",
                        "\t};",
                        "",
                        "\tif (work->wakeup_all)",
                        "\t\twork->arch.token = ~0; /* broadcast wakeup */",
                        "\telse",
                        "\t\tkvm_del_async_pf_gfn(vcpu, work->arch.gfn);",
                        "\ttrace_kvm_async_pf_ready(work->arch.token, work->cr2_or_gpa);",
                        "",
                        "\tif (kvm_pv_async_pf_enabled(vcpu) &&",
                        "\t    !apf_put_user_ready(vcpu, work->arch.token)) {",
                        "\t\tvcpu->arch.apf.pageready_pending = true;",
                        "\t\tkvm_apic_set_irq(vcpu, &irq, NULL);",
                        "\t}",
                        "",
                        "\tvcpu->arch.apf.halted = false;",
                        "\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;",
                        "}"
                    ],
                    "start": 10563,
                    "highlight": 10580
                }
            ],
            "ins_idx": 31,
            "addr": "0xffffffff810427a8"
        },
        "1468": {
            "name": "+0xb",
            "parent_idx": 1467,
            "source_line": [
                {
                    "file": "arch/x86/kvm/x86.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/x86.c?id=7ae77150d94d#n10565",
                    "code": [
                        "void kvm_arch_async_page_present(struct kvm_vcpu *vcpu,",
                        "\t\t\t\t struct kvm_async_pf *work)",
                        "{",
                        "\tstruct kvm_lapic_irq irq = {",
                        "\t\t.delivery_mode = APIC_DM_FIXED,",
                        "\t\t.vector = vcpu->arch.apf.vec",
                        "\t};",
                        "",
                        "\tif (work->wakeup_all)",
                        "\t\twork->arch.token = ~0; /* broadcast wakeup */",
                        "\telse",
                        "\t\tkvm_del_async_pf_gfn(vcpu, work->arch.gfn);",
                        "\ttrace_kvm_async_pf_ready(work->arch.token, work->cr2_or_gpa);",
                        "",
                        "\tif (kvm_pv_async_pf_enabled(vcpu) &&",
                        "\t    !apf_put_user_ready(vcpu, work->arch.token)) {",
                        "\t\tvcpu->arch.apf.pageready_pending = true;",
                        "\t\tkvm_apic_set_irq(vcpu, &irq, NULL);",
                        "\t}",
                        "",
                        "\tvcpu->arch.apf.halted = false;",
                        "\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;",
                        "}"
                    ],
                    "start": 10563,
                    "highlight": 10565
                }
            ],
            "ins_idx": 87,
            "addr": "0xffffffff810425cb"
        },
        "1466": {
            "name": "+0x89",
            "parent_idx": 1458,
            "source_line": [
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/async_pf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/async_pf.c?id=7ae77150d94d#n151",
                    "code": [
                        "void kvm_check_async_pf_completion(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tstruct kvm_async_pf *work;",
                        "",
                        "\twhile (!list_empty_careful(&vcpu->async_pf.done) &&",
                        "\t      kvm_arch_can_dequeue_async_page_present(vcpu)) {",
                        "\t\tspin_lock(&vcpu->async_pf.lock);",
                        "\t\twork = list_first_entry(&vcpu->async_pf.done, typeof(*work),",
                        "\t\t\t\t\t      link);",
                        "\t\tlist_del(&work->link);",
                        "\t\tspin_unlock(&vcpu->async_pf.lock);",
                        "",
                        "\t\tkvm_arch_async_page_ready(vcpu, work);",
                        "\t\tif (!IS_ENABLED(CONFIG_KVM_ASYNC_PF_SYNC))",
                        "\t\t\tkvm_arch_async_page_present(vcpu, work);",
                        "",
                        "\t\tlist_del(&work->queue);",
                        "\t\tvcpu->async_pf.queued--;",
                        "\t\tkmem_cache_free(async_pf_cache, work);",
                        "\t}",
                        "}"
                    ],
                    "start": 137,
                    "highlight": 151
                }
            ],
            "ins_idx": 103,
            "addr": "0xffffffff81029019"
        },
        "1459": {
            "name": "+0x2b",
            "parent_idx": 1458,
            "source_line": [
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/async_pf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/async_pf.c?id=7ae77150d94d#n138",
                    "code": [
                        "void kvm_check_async_pf_completion(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tstruct kvm_async_pf *work;",
                        "",
                        "\twhile (!list_empty_careful(&vcpu->async_pf.done) &&",
                        "\t      kvm_arch_can_dequeue_async_page_present(vcpu)) {",
                        "\t\tspin_lock(&vcpu->async_pf.lock);",
                        "\t\twork = list_first_entry(&vcpu->async_pf.done, typeof(*work),",
                        "\t\t\t\t\t      link);",
                        "\t\tlist_del(&work->link);",
                        "\t\tspin_unlock(&vcpu->async_pf.lock);",
                        "",
                        "\t\tkvm_arch_async_page_ready(vcpu, work);",
                        "\t\tif (!IS_ENABLED(CONFIG_KVM_ASYNC_PF_SYNC))",
                        "\t\t\tkvm_arch_async_page_present(vcpu, work);",
                        "",
                        "\t\tlist_del(&work->queue);",
                        "\t\tvcpu->async_pf.queued--;",
                        "\t\tkmem_cache_free(async_pf_cache, work);",
                        "\t}",
                        "}"
                    ],
                    "start": 137,
                    "highlight": 138
                }
            ],
            "ins_idx": 162,
            "addr": "0xffffffff81028fbb"
        },
        "1457": {
            "name": "+0x374",
            "parent_idx": 1437,
            "source_line": [
                {
                    "file": "arch/x86/kvm/x86.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/x86.c?id=7ae77150d94d#n8437",
                    "code": [
                        "/*",
                        " * Returns 1 to let vcpu_run() continue the guest execution loop without",
                        " * exiting to the userspace.  Otherwise, the value will be returned to the",
                        " * userspace.",
                        " */",
                        "static int vcpu_enter_guest(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tint r;",
                        "\tbool req_int_win =",
                        "\t\tdm_request_for_irq_injection(vcpu) &&",
                        "\t\tkvm_cpu_accept_dm_intr(vcpu);",
                        "\tfastpath_t exit_fastpath;",
                        "",
                        "\tbool req_immediate_exit = false;",
                        "",
                        "\tif (kvm_request_pending(vcpu)) {",
                        "\t\tif (kvm_check_request(KVM_REQ_GET_VMCS12_PAGES, vcpu)) {",
                        "\t\t\tif (unlikely(!kvm_x86_ops.nested_ops->get_vmcs12_pages(vcpu))) {",
                        "\t\t\t\tr = 0;",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))",
                        "\t\t\tkvm_mmu_unload(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))",
                        "\t\t\t__kvm_migrate_timers(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))",
                        "\t\t\tkvm_gen_update_masterclock(vcpu->kvm);",
                        "\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))",
                        "\t\t\tkvm_gen_kvmclock_update(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {",
                        "\t\t\tr = kvm_guest_time_update(vcpu);",
                        "\t\t\tif (unlikely(r))",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))",
                        "\t\t\tkvm_mmu_sync_roots(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_LOAD_MMU_PGD, vcpu))",
                        "\t\t\tkvm_mmu_load_pgd(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu)) {",
                        "\t\t\tkvm_vcpu_flush_tlb_all(vcpu);",
                        "",
                        "\t\t\t/* Flushing all ASIDs flushes the current ASID... */",
                        "\t\t\tkvm_clear_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu))",
                        "\t\t\tkvm_vcpu_flush_tlb_current(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_HV_TLB_FLUSH, vcpu))",
                        "\t\t\tkvm_vcpu_flush_tlb_guest(vcpu);",
                        "",
                        "\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;",
                        "\t\t\tr = 0;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;",
                        "\t\t\tvcpu->mmio_needed = 0;",
                        "\t\t\tr = 0;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {",
                        "\t\t\t/* Page is swapped out. Do synthetic halt */",
                        "\t\t\tvcpu->arch.apf.halted = true;",
                        "\t\t\tr = 1;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))",
                        "\t\t\trecord_steal_time(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_SMI, vcpu))",
                        "\t\t\tprocess_smi(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))",
                        "\t\t\tprocess_nmi(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))",
                        "\t\t\tkvm_pmu_handle_event(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))",
                        "\t\t\tkvm_pmu_deliver_pmi(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {",
                        "\t\t\tBUG_ON(vcpu->arch.pending_ioapic_eoi > 255);",
                        "\t\t\tif (test_bit(vcpu->arch.pending_ioapic_eoi,",
                        "\t\t\t\t     vcpu->arch.ioapic_handled_vectors)) {",
                        "\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;",
                        "\t\t\t\tvcpu->run->eoi.vector =",
                        "\t\t\t\t\t\tvcpu->arch.pending_ioapic_eoi;",
                        "\t\t\t\tr = 0;",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))",
                        "\t\t\tvcpu_scan_ioapic(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))",
                        "\t\t\tvcpu_load_eoi_exitmap(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))",
                        "\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;",
                        "\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_CRASH;",
                        "\t\t\tr = 0;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;",
                        "\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_RESET;",
                        "\t\t\tr = 0;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (kvm_check_request(KVM_REQ_HV_EXIT, vcpu)) {",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;",
                        "\t\t\tvcpu->run->hyperv = vcpu->arch.hyperv.exit;",
                        "\t\t\tr = 0;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * KVM_REQ_HV_STIMER has to be processed after",
                        "\t\t * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers",
                        "\t\t * depend on the guest clock being up-to-date",
                        "\t\t */",
                        "\t\tif (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))",
                        "\t\t\tkvm_hv_process_stimers(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))",
                        "\t\t\tkvm_vcpu_update_apicv(vcpu);",
                        "\t\tif (kvm_check_request(KVM_REQ_APF_READY, vcpu))",
                        "\t\t\tkvm_check_async_pf_completion(vcpu);",
                        "\t}",
                        "",
                        "\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {",
                        "\t\t++vcpu->stat.req_event;",
                        "\t\tkvm_apic_accept_events(vcpu);",
                        "\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {",
                        "\t\t\tr = 1;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tinject_pending_event(vcpu, &req_immediate_exit);",
                        "\t\tif (req_int_win)",
                        "\t\t\tkvm_x86_ops.enable_irq_window(vcpu);",
                        "",
                        "\t\tif (kvm_lapic_enabled(vcpu)) {",
                        "\t\t\tupdate_cr8_intercept(vcpu);",
                        "\t\t\tkvm_lapic_sync_to_vapic(vcpu);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tr = kvm_mmu_reload(vcpu);",
                        "\tif (unlikely(r)) {",
                        "\t\tgoto cancel_injection;",
                        "\t}",
                        "",
                        "\tpreempt_disable();",
                        "",
                        "\tkvm_x86_ops.prepare_guest_switch(vcpu);",
                        "",
                        "\t/*",
                        "\t * Disable IRQs before setting IN_GUEST_MODE.  Posted interrupt",
                        "\t * IPI are then delayed after guest entry, which ensures that they",
                        "\t * result in virtual interrupt delivery.",
                        "\t */",
                        "\tlocal_irq_disable();",
                        "\tvcpu->mode = IN_GUEST_MODE;",
                        "",
                        "\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);",
                        "",
                        "\t/*",
                        "\t * 1) We should set ->mode before checking ->requests.  Please see",
                        "\t * the comment in kvm_vcpu_exiting_guest_mode().",
                        "\t *",
                        "\t * 2) For APICv, we should set ->mode before checking PID.ON. This",
                        "\t * pairs with the memory barrier implicit in pi_test_and_set_on",
                        "\t * (see vmx_deliver_posted_interrupt).",
                        "\t *",
                        "\t * 3) This also orders the write to mode from any reads to the page",
                        "\t * tables done while the VCPU is running.  Please see the comment",
                        "\t * in kvm_flush_remote_tlbs.",
                        "\t */",
                        "\tsmp_mb__after_srcu_read_unlock();",
                        "",
                        "\t/*",
                        "\t * This handles the case where a posted interrupt was",
                        "\t * notified with kvm_vcpu_kick.",
                        "\t */",
                        "\tif (kvm_lapic_enabled(vcpu) && vcpu->arch.apicv_active)",
                        "\t\tkvm_x86_ops.sync_pir_to_irr(vcpu);",
                        "",
                        "\tif (kvm_vcpu_exit_request(vcpu)) {",
                        "\t\tvcpu->mode = OUTSIDE_GUEST_MODE;",
                        "\t\tsmp_wmb();",
                        "\t\tlocal_irq_enable();",
                        "\t\tpreempt_enable();",
                        "\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);",
                        "\t\tr = 1;",
                        "\t\tgoto cancel_injection;",
                        "\t}",
                        "",
                        "\tif (req_immediate_exit) {",
                        "\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);",
                        "\t\tkvm_x86_ops.request_immediate_exit(vcpu);",
                        "\t}",
                        "",
                        "\ttrace_kvm_entry(vcpu->vcpu_id);",
                        "\tguest_enter_irqoff();",
                        "",
                        "\tfpregs_assert_state_consistent();",
                        "\tif (test_thread_flag(TIF_NEED_FPU_LOAD))",
                        "\t\tswitch_fpu_return();",
                        "",
                        "\tif (unlikely(vcpu->arch.switch_db_regs)) {",
                        "\t\tset_debugreg(0, 7);",
                        "\t\tset_debugreg(vcpu->arch.eff_db[0], 0);",
                        "\t\tset_debugreg(vcpu->arch.eff_db[1], 1);",
                        "\t\tset_debugreg(vcpu->arch.eff_db[2], 2);",
                        "\t\tset_debugreg(vcpu->arch.eff_db[3], 3);",
                        "\t\tset_debugreg(vcpu->arch.dr6, 6);",
                        "\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;",
                        "\t}",
                        "",
                        "\texit_fastpath = kvm_x86_ops.run(vcpu);",
                        "",
                        "\t/*",
                        "\t * Do this here before restoring debug registers on the host.  And",
                        "\t * since we do this before handling the vmexit, a DR access vmexit",
                        "\t * can (a) read the correct value of the debug registers, (b) set",
                        "\t * KVM_DEBUGREG_WONT_EXIT again.",
                        "\t */",
                        "\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {",
                        "\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);",
                        "\t\tkvm_x86_ops.sync_dirty_debug_regs(vcpu);",
                        "\t\tkvm_update_dr0123(vcpu);",
                        "\t\tkvm_update_dr7(vcpu);",
                        "\t\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_RELOAD;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * If the guest has used debug registers, at least dr7",
                        "\t * will be disabled while returning to the host.",
                        "\t * If we don't have active breakpoints in the host, we don't",
                        "\t * care about the messed up debug address registers. But if",
                        "\t * we have some of them active, restore the old state.",
                        "\t */",
                        "\tif (hw_breakpoint_active())",
                        "\t\thw_breakpoint_restore();",
                        "",
                        "\tvcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());",
                        "",
                        "\tvcpu->mode = OUTSIDE_GUEST_MODE;",
                        "\tsmp_wmb();",
                        "",
                        "\tkvm_x86_ops.handle_exit_irqoff(vcpu);",
                        "",
                        "\t/*",
                        "\t * Consume any pending interrupts, including the possible source of",
                        "\t * VM-Exit on SVM and any ticks that occur between VM-Exit and now.",
                        "\t * An instruction is required after local_irq_enable() to fully unblock",
                        "\t * interrupts on processors that implement an interrupt shadow, the",
                        "\t * stat.exits increment will do nicely.",
                        "\t */",
                        "\tkvm_before_interrupt(vcpu);",
                        "\tlocal_irq_enable();",
                        "\t++vcpu->stat.exits;",
                        "\tlocal_irq_disable();",
                        "\tkvm_after_interrupt(vcpu);",
                        "",
                        "\tguest_exit_irqoff();",
                        "\tif (lapic_in_kernel(vcpu)) {",
                        "\t\ts64 delta = vcpu->arch.apic->lapic_timer.advance_expire_delta;",
                        "\t\tif (delta != S64_MIN) {",
                        "\t\t\ttrace_kvm_wait_lapic_expire(vcpu->vcpu_id, delta);",
                        "\t\t\tvcpu->arch.apic->lapic_timer.advance_expire_delta = S64_MIN;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tlocal_irq_enable();",
                        "\tpreempt_enable();",
                        "",
                        "\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);",
                        "",
                        "\t/*",
                        "\t * Profile KVM exit RIPs:",
                        "\t */",
                        "\tif (unlikely(prof_on == KVM_PROFILING)) {",
                        "\t\tunsigned long rip = kvm_rip_read(vcpu);",
                        "\t\tprofile_hit(KVM_PROFILING, (void *)rip);",
                        "\t}",
                        "",
                        "\tif (unlikely(vcpu->arch.tsc_always_catchup))",
                        "\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);",
                        "",
                        "\tif (vcpu->arch.apic_attention)",
                        "\t\tkvm_lapic_sync_from_vapic(vcpu);",
                        "",
                        "\tr = kvm_x86_ops.handle_exit(vcpu, exit_fastpath);",
                        "\treturn r;",
                        "",
                        "cancel_injection:",
                        "\tif (req_immediate_exit)",
                        "\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);",
                        "\tkvm_x86_ops.cancel_injection(vcpu);",
                        "\tif (unlikely(vcpu->arch.apic_attention))",
                        "\t\tkvm_lapic_sync_from_vapic(vcpu);",
                        "out:",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 8314,
                    "highlight": 8437
                },
                {
                    "file": "arch/x86/kvm/x86.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/x86.c?id=7ae77150d94d#n8669",
                    "code": [
                        "static int vcpu_run(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tint r;",
                        "\tstruct kvm *kvm = vcpu->kvm;",
                        "",
                        "\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);",
                        "\tvcpu->arch.l1tf_flush_l1d = true;",
                        "",
                        "\tfor (;;) {",
                        "\t\tif (kvm_vcpu_running(vcpu)) {",
                        "\t\t\tr = vcpu_enter_guest(vcpu);",
                        "\t\t} else {",
                        "\t\t\tr = vcpu_block(kvm, vcpu);",
                        "\t\t}",
                        "",
                        "\t\tif (r <= 0)",
                        "\t\t\tbreak;",
                        "",
                        "\t\tkvm_clear_request(KVM_REQ_PENDING_TIMER, vcpu);",
                        "\t\tif (kvm_cpu_has_pending_timer(vcpu))",
                        "\t\t\tkvm_inject_pending_timer_irqs(vcpu);",
                        "",
                        "\t\tif (dm_request_for_irq_injection(vcpu) &&",
                        "\t\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu)) {",
                        "\t\t\tr = 0;",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;",
                        "\t\t\t++vcpu->stat.request_irq_exits;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\tif (signal_pending(current)) {",
                        "\t\t\tr = -EINTR;",
                        "\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;",
                        "\t\t\t++vcpu->stat.signal_exits;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (need_resched()) {",
                        "\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);",
                        "\t\t\tcond_resched();",
                        "\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);",
                        "",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 8659,
                    "highlight": 8669
                },
                {
                    "file": "arch/x86/kvm/x86.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/x86.c?id=7ae77150d94d#n8890",
                    "code": [
                        "int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tstruct kvm_run *kvm_run = vcpu->run;",
                        "\tint r;",
                        "",
                        "\tvcpu_load(vcpu);",
                        "\tkvm_sigset_activate(vcpu);",
                        "\tkvm_load_guest_fpu(vcpu);",
                        "",
                        "\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {",
                        "\t\tif (kvm_run->immediate_exit) {",
                        "\t\t\tr = -EINTR;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tkvm_vcpu_block(vcpu);",
                        "\t\tkvm_apic_accept_events(vcpu);",
                        "\t\tkvm_clear_request(KVM_REQ_UNHALT, vcpu);",
                        "\t\tr = -EAGAIN;",
                        "\t\tif (signal_pending(current)) {",
                        "\t\t\tr = -EINTR;",
                        "\t\t\tkvm_run->exit_reason = KVM_EXIT_INTR;",
                        "\t\t\t++vcpu->stat.signal_exits;",
                        "\t\t}",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (kvm_run->kvm_valid_regs & ~KVM_SYNC_X86_VALID_FIELDS) {",
                        "\t\tr = -EINVAL;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (kvm_run->kvm_dirty_regs) {",
                        "\t\tr = sync_regs(vcpu);",
                        "\t\tif (r != 0)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\t/* re-sync apic's tpr */",
                        "\tif (!lapic_in_kernel(vcpu)) {",
                        "\t\tif (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {",
                        "\t\t\tr = -EINVAL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (unlikely(vcpu->arch.complete_userspace_io)) {",
                        "\t\tint (*cui)(struct kvm_vcpu *) = vcpu->arch.complete_userspace_io;",
                        "\t\tvcpu->arch.complete_userspace_io = NULL;",
                        "\t\tr = cui(vcpu);",
                        "\t\tif (r <= 0)",
                        "\t\t\tgoto out;",
                        "\t} else",
                        "\t\tWARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);",
                        "",
                        "\tif (kvm_run->immediate_exit)",
                        "\t\tr = -EINTR;",
                        "\telse",
                        "\t\tr = vcpu_run(vcpu);",
                        "",
                        "out:",
                        "\tkvm_put_guest_fpu(vcpu);",
                        "\tif (kvm_run->kvm_valid_regs)",
                        "\t\tstore_regs(vcpu);",
                        "\tpost_kvm_run_save(vcpu);",
                        "\tkvm_sigset_deactivate(vcpu);",
                        "",
                        "\tvcpu_put(vcpu);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 8833,
                    "highlight": 8890
                }
            ],
            "ins_idx": 181,
            "addr": "0xffffffff81040b14"
        },
        "1438": {
            "name": "+0x6",
            "parent_idx": 1437,
            "source_line": [
                {
                    "file": "arch/x86/kvm/x86.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/x86.c?id=7ae77150d94d#n8834",
                    "code": [
                        "int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tstruct kvm_run *kvm_run = vcpu->run;",
                        "\tint r;",
                        "",
                        "\tvcpu_load(vcpu);",
                        "\tkvm_sigset_activate(vcpu);",
                        "\tkvm_load_guest_fpu(vcpu);",
                        "",
                        "\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {",
                        "\t\tif (kvm_run->immediate_exit) {",
                        "\t\t\tr = -EINTR;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tkvm_vcpu_block(vcpu);",
                        "\t\tkvm_apic_accept_events(vcpu);",
                        "\t\tkvm_clear_request(KVM_REQ_UNHALT, vcpu);",
                        "\t\tr = -EAGAIN;",
                        "\t\tif (signal_pending(current)) {",
                        "\t\t\tr = -EINTR;",
                        "\t\t\tkvm_run->exit_reason = KVM_EXIT_INTR;",
                        "\t\t\t++vcpu->stat.signal_exits;",
                        "\t\t}",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (kvm_run->kvm_valid_regs & ~KVM_SYNC_X86_VALID_FIELDS) {",
                        "\t\tr = -EINVAL;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (kvm_run->kvm_dirty_regs) {",
                        "\t\tr = sync_regs(vcpu);",
                        "\t\tif (r != 0)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\t/* re-sync apic's tpr */",
                        "\tif (!lapic_in_kernel(vcpu)) {",
                        "\t\tif (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {",
                        "\t\t\tr = -EINVAL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (unlikely(vcpu->arch.complete_userspace_io)) {",
                        "\t\tint (*cui)(struct kvm_vcpu *) = vcpu->arch.complete_userspace_io;",
                        "\t\tvcpu->arch.complete_userspace_io = NULL;",
                        "\t\tr = cui(vcpu);",
                        "\t\tif (r <= 0)",
                        "\t\t\tgoto out;",
                        "\t} else",
                        "\t\tWARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);",
                        "",
                        "\tif (kvm_run->immediate_exit)",
                        "\t\tr = -EINTR;",
                        "\telse",
                        "\t\tr = vcpu_run(vcpu);",
                        "",
                        "out:",
                        "\tkvm_put_guest_fpu(vcpu);",
                        "\tif (kvm_run->kvm_valid_regs)",
                        "\t\tstore_regs(vcpu);",
                        "\tpost_kvm_run_save(vcpu);",
                        "\tkvm_sigset_deactivate(vcpu);",
                        "",
                        "\tvcpu_put(vcpu);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 8833,
                    "highlight": 8834
                }
            ],
            "ins_idx": 306,
            "addr": "0xffffffff810407a6"
        },
        "1436": {
            "name": "+0x204",
            "parent_idx": 1434,
            "source_line": [
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n3163",
                    "code": [
                        "static long kvm_vcpu_ioctl(struct file *filp,",
                        "\t\t\t   unsigned int ioctl, unsigned long arg)",
                        "{",
                        "\tstruct kvm_vcpu *vcpu = filp->private_data;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint r;",
                        "\tstruct kvm_fpu *fpu = NULL;",
                        "\tstruct kvm_sregs *kvm_sregs = NULL;",
                        "",
                        "\tif (vcpu->kvm->mm != current->mm)",
                        "\t\treturn -EIO;",
                        "",
                        "\tif (unlikely(_IOC_TYPE(ioctl) != KVMIO))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\t/*",
                        "\t * Some architectures have vcpu ioctls that are asynchronous to vcpu",
                        "\t * execution; mutex_lock() would break them.",
                        "\t */",
                        "\tr = kvm_arch_vcpu_async_ioctl(filp, ioctl, arg);",
                        "\tif (r != -ENOIOCTLCMD)",
                        "\t\treturn r;",
                        "",
                        "\tif (mutex_lock_killable(&vcpu->mutex))",
                        "\t\treturn -EINTR;",
                        "\tswitch (ioctl) {",
                        "\tcase KVM_RUN: {",
                        "\t\tstruct pid *oldpid;",
                        "\t\tr = -EINVAL;",
                        "\t\tif (arg)",
                        "\t\t\tgoto out;",
                        "\t\toldpid = rcu_access_pointer(vcpu->pid);",
                        "\t\tif (unlikely(oldpid != task_pid(current))) {",
                        "\t\t\t/* The thread running this VCPU changed. */",
                        "\t\t\tstruct pid *newpid;",
                        "",
                        "\t\t\tr = kvm_arch_vcpu_run_pid_change(vcpu);",
                        "\t\t\tif (r)",
                        "\t\t\t\tbreak;",
                        "",
                        "\t\t\tnewpid = get_task_pid(current, PIDTYPE_PID);",
                        "\t\t\trcu_assign_pointer(vcpu->pid, newpid);",
                        "\t\t\tif (oldpid)",
                        "\t\t\t\tsynchronize_rcu();",
                        "\t\t\tput_pid(oldpid);",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_run(vcpu);",
                        "\t\ttrace_kvm_userspace_exit(vcpu->run->exit_reason, r);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_REGS: {",
                        "\t\tstruct kvm_regs *kvm_regs;",
                        "",
                        "\t\tr = -ENOMEM;",
                        "\t\tkvm_regs = kzalloc(sizeof(struct kvm_regs), GFP_KERNEL_ACCOUNT);",
                        "\t\tif (!kvm_regs)",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_regs(vcpu, kvm_regs);",
                        "\t\tif (r)",
                        "\t\t\tgoto out_free1;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, kvm_regs, sizeof(struct kvm_regs)))",
                        "\t\t\tgoto out_free1;",
                        "\t\tr = 0;",
                        "out_free1:",
                        "\t\tkfree(kvm_regs);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_REGS: {",
                        "\t\tstruct kvm_regs *kvm_regs;",
                        "",
                        "\t\tkvm_regs = memdup_user(argp, sizeof(*kvm_regs));",
                        "\t\tif (IS_ERR(kvm_regs)) {",
                        "\t\t\tr = PTR_ERR(kvm_regs);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_regs(vcpu, kvm_regs);",
                        "\t\tkfree(kvm_regs);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_SREGS: {",
                        "\t\tkvm_sregs = kzalloc(sizeof(struct kvm_sregs),",
                        "\t\t\t\t    GFP_KERNEL_ACCOUNT);",
                        "\t\tr = -ENOMEM;",
                        "\t\tif (!kvm_sregs)",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_sregs(vcpu, kvm_sregs);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, kvm_sregs, sizeof(struct kvm_sregs)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_SREGS: {",
                        "\t\tkvm_sregs = memdup_user(argp, sizeof(*kvm_sregs));",
                        "\t\tif (IS_ERR(kvm_sregs)) {",
                        "\t\t\tr = PTR_ERR(kvm_sregs);",
                        "\t\t\tkvm_sregs = NULL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_sregs(vcpu, kvm_sregs);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_MP_STATE: {",
                        "\t\tstruct kvm_mp_state mp_state;",
                        "",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &mp_state);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &mp_state, sizeof(mp_state)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_MP_STATE: {",
                        "\t\tstruct kvm_mp_state mp_state;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&mp_state, argp, sizeof(mp_state)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_mpstate(vcpu, &mp_state);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_TRANSLATE: {",
                        "\t\tstruct kvm_translation tr;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&tr, argp, sizeof(tr)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_translate(vcpu, &tr);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &tr, sizeof(tr)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_GUEST_DEBUG: {",
                        "\t\tstruct kvm_guest_debug dbg;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&dbg, argp, sizeof(dbg)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_guest_debug(vcpu, &dbg);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_SIGNAL_MASK: {",
                        "\t\tstruct kvm_signal_mask __user *sigmask_arg = argp;",
                        "\t\tstruct kvm_signal_mask kvm_sigmask;",
                        "\t\tsigset_t sigset, *p;",
                        "",
                        "\t\tp = NULL;",
                        "\t\tif (argp) {",
                        "\t\t\tr = -EFAULT;",
                        "\t\t\tif (copy_from_user(&kvm_sigmask, argp,",
                        "\t\t\t\t\t   sizeof(kvm_sigmask)))",
                        "\t\t\t\tgoto out;",
                        "\t\t\tr = -EINVAL;",
                        "\t\t\tif (kvm_sigmask.len != sizeof(sigset))",
                        "\t\t\t\tgoto out;",
                        "\t\t\tr = -EFAULT;",
                        "\t\t\tif (copy_from_user(&sigset, sigmask_arg->sigset,",
                        "\t\t\t\t\t   sizeof(sigset)))",
                        "\t\t\t\tgoto out;",
                        "\t\t\tp = &sigset;",
                        "\t\t}",
                        "\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, p);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_FPU: {",
                        "\t\tfpu = kzalloc(sizeof(struct kvm_fpu), GFP_KERNEL_ACCOUNT);",
                        "\t\tr = -ENOMEM;",
                        "\t\tif (!fpu)",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_fpu(vcpu, fpu);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, fpu, sizeof(struct kvm_fpu)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_FPU: {",
                        "\t\tfpu = memdup_user(argp, sizeof(*fpu));",
                        "\t\tif (IS_ERR(fpu)) {",
                        "\t\t\tr = PTR_ERR(fpu);",
                        "\t\t\tfpu = NULL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_fpu(vcpu, fpu);",
                        "\t\tbreak;",
                        "\t}",
                        "\tdefault:",
                        "\t\tr = kvm_arch_vcpu_ioctl(filp, ioctl, arg);",
                        "\t}",
                        "out:",
                        "\tmutex_unlock(&vcpu->mutex);",
                        "\tkfree(fpu);",
                        "\tkfree(kvm_sregs);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3117,
                    "highlight": 3163
                }
            ],
            "ins_idx": 316,
            "addr": "0xffffffff8101f1f4"
        },
        "1435": {
            "name": "+0x11",
            "parent_idx": 1434,
            "source_line": [
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n3120",
                    "code": [
                        "static long kvm_vcpu_ioctl(struct file *filp,",
                        "\t\t\t   unsigned int ioctl, unsigned long arg)",
                        "{",
                        "\tstruct kvm_vcpu *vcpu = filp->private_data;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint r;",
                        "\tstruct kvm_fpu *fpu = NULL;",
                        "\tstruct kvm_sregs *kvm_sregs = NULL;",
                        "",
                        "\tif (vcpu->kvm->mm != current->mm)",
                        "\t\treturn -EIO;",
                        "",
                        "\tif (unlikely(_IOC_TYPE(ioctl) != KVMIO))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\t/*",
                        "\t * Some architectures have vcpu ioctls that are asynchronous to vcpu",
                        "\t * execution; mutex_lock() would break them.",
                        "\t */",
                        "\tr = kvm_arch_vcpu_async_ioctl(filp, ioctl, arg);",
                        "\tif (r != -ENOIOCTLCMD)",
                        "\t\treturn r;",
                        "",
                        "\tif (mutex_lock_killable(&vcpu->mutex))",
                        "\t\treturn -EINTR;",
                        "\tswitch (ioctl) {",
                        "\tcase KVM_RUN: {",
                        "\t\tstruct pid *oldpid;",
                        "\t\tr = -EINVAL;",
                        "\t\tif (arg)",
                        "\t\t\tgoto out;",
                        "\t\toldpid = rcu_access_pointer(vcpu->pid);",
                        "\t\tif (unlikely(oldpid != task_pid(current))) {",
                        "\t\t\t/* The thread running this VCPU changed. */",
                        "\t\t\tstruct pid *newpid;",
                        "",
                        "\t\t\tr = kvm_arch_vcpu_run_pid_change(vcpu);",
                        "\t\t\tif (r)",
                        "\t\t\t\tbreak;",
                        "",
                        "\t\t\tnewpid = get_task_pid(current, PIDTYPE_PID);",
                        "\t\t\trcu_assign_pointer(vcpu->pid, newpid);",
                        "\t\t\tif (oldpid)",
                        "\t\t\t\tsynchronize_rcu();",
                        "\t\t\tput_pid(oldpid);",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_run(vcpu);",
                        "\t\ttrace_kvm_userspace_exit(vcpu->run->exit_reason, r);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_REGS: {",
                        "\t\tstruct kvm_regs *kvm_regs;",
                        "",
                        "\t\tr = -ENOMEM;",
                        "\t\tkvm_regs = kzalloc(sizeof(struct kvm_regs), GFP_KERNEL_ACCOUNT);",
                        "\t\tif (!kvm_regs)",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_regs(vcpu, kvm_regs);",
                        "\t\tif (r)",
                        "\t\t\tgoto out_free1;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, kvm_regs, sizeof(struct kvm_regs)))",
                        "\t\t\tgoto out_free1;",
                        "\t\tr = 0;",
                        "out_free1:",
                        "\t\tkfree(kvm_regs);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_REGS: {",
                        "\t\tstruct kvm_regs *kvm_regs;",
                        "",
                        "\t\tkvm_regs = memdup_user(argp, sizeof(*kvm_regs));",
                        "\t\tif (IS_ERR(kvm_regs)) {",
                        "\t\t\tr = PTR_ERR(kvm_regs);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_regs(vcpu, kvm_regs);",
                        "\t\tkfree(kvm_regs);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_SREGS: {",
                        "\t\tkvm_sregs = kzalloc(sizeof(struct kvm_sregs),",
                        "\t\t\t\t    GFP_KERNEL_ACCOUNT);",
                        "\t\tr = -ENOMEM;",
                        "\t\tif (!kvm_sregs)",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_sregs(vcpu, kvm_sregs);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, kvm_sregs, sizeof(struct kvm_sregs)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_SREGS: {",
                        "\t\tkvm_sregs = memdup_user(argp, sizeof(*kvm_sregs));",
                        "\t\tif (IS_ERR(kvm_sregs)) {",
                        "\t\t\tr = PTR_ERR(kvm_sregs);",
                        "\t\t\tkvm_sregs = NULL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_sregs(vcpu, kvm_sregs);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_MP_STATE: {",
                        "\t\tstruct kvm_mp_state mp_state;",
                        "",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &mp_state);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &mp_state, sizeof(mp_state)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_MP_STATE: {",
                        "\t\tstruct kvm_mp_state mp_state;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&mp_state, argp, sizeof(mp_state)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_mpstate(vcpu, &mp_state);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_TRANSLATE: {",
                        "\t\tstruct kvm_translation tr;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&tr, argp, sizeof(tr)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_translate(vcpu, &tr);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &tr, sizeof(tr)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_GUEST_DEBUG: {",
                        "\t\tstruct kvm_guest_debug dbg;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&dbg, argp, sizeof(dbg)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_guest_debug(vcpu, &dbg);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_SIGNAL_MASK: {",
                        "\t\tstruct kvm_signal_mask __user *sigmask_arg = argp;",
                        "\t\tstruct kvm_signal_mask kvm_sigmask;",
                        "\t\tsigset_t sigset, *p;",
                        "",
                        "\t\tp = NULL;",
                        "\t\tif (argp) {",
                        "\t\t\tr = -EFAULT;",
                        "\t\t\tif (copy_from_user(&kvm_sigmask, argp,",
                        "\t\t\t\t\t   sizeof(kvm_sigmask)))",
                        "\t\t\t\tgoto out;",
                        "\t\t\tr = -EINVAL;",
                        "\t\t\tif (kvm_sigmask.len != sizeof(sigset))",
                        "\t\t\t\tgoto out;",
                        "\t\t\tr = -EFAULT;",
                        "\t\t\tif (copy_from_user(&sigset, sigmask_arg->sigset,",
                        "\t\t\t\t\t   sizeof(sigset)))",
                        "\t\t\t\tgoto out;",
                        "\t\t\tp = &sigset;",
                        "\t\t}",
                        "\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, p);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_FPU: {",
                        "\t\tfpu = kzalloc(sizeof(struct kvm_fpu), GFP_KERNEL_ACCOUNT);",
                        "\t\tr = -ENOMEM;",
                        "\t\tif (!fpu)",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_arch_vcpu_ioctl_get_fpu(vcpu, fpu);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, fpu, sizeof(struct kvm_fpu)))",
                        "\t\t\tgoto out;",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_FPU: {",
                        "\t\tfpu = memdup_user(argp, sizeof(*fpu));",
                        "\t\tif (IS_ERR(fpu)) {",
                        "\t\t\tr = PTR_ERR(fpu);",
                        "\t\t\tfpu = NULL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tr = kvm_arch_vcpu_ioctl_set_fpu(vcpu, fpu);",
                        "\t\tbreak;",
                        "\t}",
                        "\tdefault:",
                        "\t\tr = kvm_arch_vcpu_ioctl(filp, ioctl, arg);",
                        "\t}",
                        "out:",
                        "\tmutex_unlock(&vcpu->mutex);",
                        "\tkfree(fpu);",
                        "\tkfree(kvm_sregs);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3117,
                    "highlight": 3120
                }
            ],
            "ins_idx": 323,
            "addr": "0xffffffff8101f001"
        },
        "1274": {
            "name": "+0x88",
            "parent_idx": 1249,
            "source_line": [
                {
                    "file": "fs/anon_inodes.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/anon_inodes.c?id=7ae77150d94d#n98",
                    "code": [
                        "/**",
                        " * anon_inode_getfile - creates a new file instance by hooking it up to an",
                        " *                      anonymous inode, and a dentry that describe the \"class\"",
                        " *                      of the file",
                        " *",
                        " * @name:    [in]    name of the \"class\" of the new file",
                        " * @fops:    [in]    file operations for the new file",
                        " * @priv:    [in]    private data for the new file (will be file's private_data)",
                        " * @flags:   [in]    flags",
                        " *",
                        " * Creates a new file by hooking it on a single inode. This is useful for files",
                        " * that do not need to have a full-fledged inode in order to operate correctly.",
                        " * All the files created with anon_inode_getfile() will share a single inode,",
                        " * hence saving memory and avoiding code duplication for the file/inode/dentry",
                        " * setup.  Returns the newly created file* or an error pointer.",
                        " */",
                        "struct file *anon_inode_getfile(const char *name,",
                        "\t\t\t\tconst struct file_operations *fops,",
                        "\t\t\t\tvoid *priv, int flags)",
                        "{",
                        "\tstruct file *file;",
                        "",
                        "\tif (IS_ERR(anon_inode_inode))",
                        "\t\treturn ERR_PTR(-ENODEV);",
                        "",
                        "\tif (fops->owner && !try_module_get(fops->owner))",
                        "\t\treturn ERR_PTR(-ENOENT);",
                        "",
                        "\t/*",
                        "\t * We know the anon_inode inode count is always greater than zero,",
                        "\t * so ihold() is safe.",
                        "\t */",
                        "\tihold(anon_inode_inode);",
                        "\tfile = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,",
                        "\t\t\t\t flags & (O_ACCMODE | O_NONBLOCK), fops);",
                        "\tif (IS_ERR(file))",
                        "\t\tgoto err;",
                        "",
                        "\tfile->f_mapping = anon_inode_inode->i_mapping;",
                        "",
                        "\tfile->private_data = priv;",
                        "",
                        "\treturn file;",
                        "",
                        "err:",
                        "\tiput(anon_inode_inode);",
                        "\tmodule_put(fops->owner);",
                        "\treturn file;",
                        "}"
                    ],
                    "start": 58,
                    "highlight": 98
                },
                {
                    "file": "fs/anon_inodes.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/anon_inodes.c?id=7ae77150d94d#n74",
                    "code": [
                        "/**",
                        " * anon_inode_getfile - creates a new file instance by hooking it up to an",
                        " *                      anonymous inode, and a dentry that describe the \"class\"",
                        " *                      of the file",
                        " *",
                        " * @name:    [in]    name of the \"class\" of the new file",
                        " * @fops:    [in]    file operations for the new file",
                        " * @priv:    [in]    private data for the new file (will be file's private_data)",
                        " * @flags:   [in]    flags",
                        " *",
                        " * Creates a new file by hooking it on a single inode. This is useful for files",
                        " * that do not need to have a full-fledged inode in order to operate correctly.",
                        " * All the files created with anon_inode_getfile() will share a single inode,",
                        " * hence saving memory and avoiding code duplication for the file/inode/dentry",
                        " * setup.  Returns the newly created file* or an error pointer.",
                        " */",
                        "struct file *anon_inode_getfile(const char *name,",
                        "\t\t\t\tconst struct file_operations *fops,",
                        "\t\t\t\tvoid *priv, int flags)",
                        "{",
                        "\tstruct file *file;",
                        "",
                        "\tif (IS_ERR(anon_inode_inode))",
                        "\t\treturn ERR_PTR(-ENODEV);",
                        "",
                        "\tif (fops->owner && !try_module_get(fops->owner))",
                        "\t\treturn ERR_PTR(-ENOENT);",
                        "",
                        "\t/*",
                        "\t * We know the anon_inode inode count is always greater than zero,",
                        "\t * so ihold() is safe.",
                        "\t */",
                        "\tihold(anon_inode_inode);",
                        "\tfile = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,",
                        "\t\t\t\t flags & (O_ACCMODE | O_NONBLOCK), fops);",
                        "\tif (IS_ERR(file))",
                        "\t\tgoto err;",
                        "",
                        "\tfile->f_mapping = anon_inode_inode->i_mapping;",
                        "",
                        "\tfile->private_data = priv;",
                        "",
                        "\treturn file;",
                        "",
                        "err:",
                        "\tiput(anon_inode_inode);",
                        "\tmodule_put(fops->owner);",
                        "\treturn file;",
                        "}"
                    ],
                    "start": 58,
                    "highlight": 74
                }
            ],
            "ins_idx": 333,
            "addr": "0xffffffff812ac8d8"
        },
        "1249": {
            "name": "anon_inode_getfile",
            "parent_idx": 1170,
            "source_line": [
                {
                    "file": "fs/anon_inodes.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/anon_inodes.c?id=7ae77150d94d#n136",
                    "code": [
                        "/**",
                        " * anon_inode_getfd - creates a new file instance by hooking it up to an",
                        " *                    anonymous inode, and a dentry that describe the \"class\"",
                        " *                    of the file",
                        " *",
                        " * @name:    [in]    name of the \"class\" of the new file",
                        " * @fops:    [in]    file operations for the new file",
                        " * @priv:    [in]    private data for the new file (will be file's private_data)",
                        " * @flags:   [in]    flags",
                        " *",
                        " * Creates a new file by hooking it on a single inode. This is useful for files",
                        " * that do not need to have a full-fledged inode in order to operate correctly.",
                        " * All the files created with anon_inode_getfd() will share a single inode,",
                        " * hence saving memory and avoiding code duplication for the file/inode/dentry",
                        " * setup.  Returns new descriptor or an error code.",
                        " */",
                        "int anon_inode_getfd(const char *name, const struct file_operations *fops,",
                        "\t\t     void *priv, int flags)",
                        "{",
                        "\tint error, fd;",
                        "\tstruct file *file;",
                        "",
                        "\terror = get_unused_fd_flags(flags);",
                        "\tif (error < 0)",
                        "\t\treturn error;",
                        "\tfd = error;",
                        "",
                        "\tfile = anon_inode_getfile(name, fops, priv, flags);",
                        "\tif (IS_ERR(file)) {",
                        "\t\terror = PTR_ERR(file);",
                        "\t\tgoto err_put_unused_fd;",
                        "\t}",
                        "\tfd_install(fd, file);",
                        "",
                        "\treturn fd;",
                        "",
                        "err_put_unused_fd:",
                        "\tput_unused_fd(fd);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 109,
                    "highlight": 136
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812ac95f"
        },
        "1170": {
            "name": "anon_inode_getfd",
            "parent_idx": 1111,
            "source_line": [
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n2997",
                    "code": [
                        "/*",
                        " * Allocates an inode for the vcpu.",
                        " */",
                        "static int create_vcpu_fd(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tchar name[8 + 1 + ITOA_MAX_LEN + 1];",
                        "",
                        "\tsnprintf(name, sizeof(name), \"kvm-vcpu:%d\", vcpu->vcpu_id);",
                        "\treturn anon_inode_getfd(name, &kvm_vcpu_fops, vcpu, O_RDWR | O_CLOEXEC);",
                        "}"
                    ],
                    "start": 2989,
                    "highlight": 2997
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n3072",
                    "code": [
                        "/*",
                        " * Creates some virtual cpus.  Good luck creating more than one.",
                        " */",
                        "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)",
                        "{",
                        "\tint r;",
                        "\tstruct kvm_vcpu *vcpu;",
                        "\tstruct page *page;",
                        "",
                        "\tif (id >= KVM_MAX_VCPU_ID)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm->created_vcpus == KVM_MAX_VCPUS) {",
                        "\t\tmutex_unlock(&kvm->lock);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tkvm->created_vcpus++;",
                        "\tmutex_unlock(&kvm->lock);",
                        "",
                        "\tr = kvm_arch_vcpu_precreate(kvm, id);",
                        "\tif (r)",
                        "\t\tgoto vcpu_decrement;",
                        "",
                        "\tvcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);",
                        "\tif (!vcpu) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_decrement;",
                        "\t}",
                        "",
                        "\tBUILD_BUG_ON(sizeof(struct kvm_run) > PAGE_SIZE);",
                        "\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);",
                        "\tif (!page) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_free;",
                        "\t}",
                        "\tvcpu->run = page_address(page);",
                        "",
                        "\tkvm_vcpu_init(vcpu, kvm, id);",
                        "",
                        "\tr = kvm_arch_vcpu_create(vcpu);",
                        "\tif (r)",
                        "\t\tgoto vcpu_free_run_page;",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm_get_vcpu_by_id(kvm, id)) {",
                        "\t\tr = -EEXIST;",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tvcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);",
                        "\tBUG_ON(kvm->vcpus[vcpu->vcpu_idx]);",
                        "",
                        "\t/* Now it's all set up, let userspace reach it */",
                        "\tkvm_get_kvm(kvm);",
                        "\tr = create_vcpu_fd(vcpu);",
                        "\tif (r < 0) {",
                        "\t\tkvm_put_kvm_no_destroy(kvm);",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tkvm->vcpus[vcpu->vcpu_idx] = vcpu;",
                        "",
                        "\t/*",
                        "\t * Pairs with smp_rmb() in kvm_get_vcpu.  Write kvm->vcpus",
                        "\t * before kvm->online_vcpu's incremented value.",
                        "\t */",
                        "\tsmp_wmb();",
                        "\tatomic_inc(&kvm->online_vcpus);",
                        "",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_arch_vcpu_postcreate(vcpu);",
                        "\tkvm_create_vcpu_debugfs(vcpu);",
                        "\treturn r;",
                        "",
                        "unlock_vcpu_destroy:",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_arch_vcpu_destroy(vcpu);",
                        "vcpu_free_run_page:",
                        "\tfree_page((unsigned long)vcpu->run);",
                        "vcpu_free:",
                        "\tkmem_cache_free(kvm_vcpu_cache, vcpu);",
                        "vcpu_decrement:",
                        "\tmutex_lock(&kvm->lock);",
                        "\tkvm->created_vcpus--;",
                        "\tmutex_unlock(&kvm->lock);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3016,
                    "highlight": 3072
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n3617",
                    "code": [
                        "static long kvm_vm_ioctl(struct file *filp,",
                        "\t\t\t   unsigned int ioctl, unsigned long arg)",
                        "{",
                        "\tstruct kvm *kvm = filp->private_data;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint r;",
                        "",
                        "\tif (kvm->mm != current->mm)",
                        "\t\treturn -EIO;",
                        "\tswitch (ioctl) {",
                        "\tcase KVM_CREATE_VCPU:",
                        "\t\tr = kvm_vm_ioctl_create_vcpu(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_ENABLE_CAP: {",
                        "\t\tstruct kvm_enable_cap cap;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cap, argp, sizeof(cap)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_USER_MEMORY_REGION: {",
                        "\t\tstruct kvm_userspace_memory_region kvm_userspace_mem;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&kvm_userspace_mem, argp,",
                        "\t\t\t\t\t\tsizeof(kvm_userspace_mem)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_DIRTY_LOG: {",
                        "\t\tstruct kvm_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT",
                        "\tcase KVM_CLEAR_DIRTY_LOG: {",
                        "\t\tstruct kvm_clear_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_KVM_MMIO",
                        "\tcase KVM_REGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_UNREGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "\tcase KVM_IRQFD: {",
                        "\t\tstruct kvm_irqfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_irqfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_IOEVENTFD: {",
                        "\t\tstruct kvm_ioeventfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_ioeventfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_HAVE_KVM_MSI",
                        "\tcase KVM_SIGNAL_MSI: {",
                        "\t\tstruct kvm_msi msi;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&msi, argp, sizeof(msi)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_send_userspace_msi(kvm, &msi);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef __KVM_HAVE_IRQ_LINE",
                        "\tcase KVM_IRQ_LINE_STATUS:",
                        "\tcase KVM_IRQ_LINE: {",
                        "\t\tstruct kvm_irq_level irq_event;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&irq_event, argp, sizeof(irq_event)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_irq_line(kvm, &irq_event,",
                        "\t\t\t\t\tioctl == KVM_IRQ_LINE_STATUS);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {",
                        "\t\t\tif (copy_to_user(argp, &irq_event, sizeof(irq_event)))",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING",
                        "\tcase KVM_SET_GSI_ROUTING: {",
                        "\t\tstruct kvm_irq_routing routing;",
                        "\t\tstruct kvm_irq_routing __user *urouting;",
                        "\t\tstruct kvm_irq_routing_entry *entries = NULL;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&routing, argp, sizeof(routing)))",
                        "\t\t\tgoto out;",
                        "\t\tr = -EINVAL;",
                        "\t\tif (!kvm_arch_can_set_irq_routing(kvm))",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr > KVM_MAX_IRQ_ROUTES)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.flags)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr) {",
                        "\t\t\tr = -ENOMEM;",
                        "\t\t\tentries = vmalloc(array_size(sizeof(*entries),",
                        "\t\t\t\t\t\t     routing.nr));",
                        "\t\t\tif (!entries)",
                        "\t\t\t\tgoto out;",
                        "\t\t\tr = -EFAULT;",
                        "\t\t\turouting = argp;",
                        "\t\t\tif (copy_from_user(entries, urouting->entries,",
                        "\t\t\t\t\t   routing.nr * sizeof(*entries)))",
                        "\t\t\t\tgoto out_free_irq_routing;",
                        "\t\t}",
                        "\t\tr = kvm_set_irq_routing(kvm, entries, routing.nr,",
                        "\t\t\t\t\trouting.flags);",
                        "out_free_irq_routing:",
                        "\t\tvfree(entries);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */",
                        "\tcase KVM_CREATE_DEVICE: {",
                        "\t\tstruct kvm_create_device cd;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cd, argp, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_ioctl_create_device(kvm, &cd);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &cd, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_CHECK_EXTENSION:",
                        "\t\tr = kvm_vm_ioctl_check_extension_generic(kvm, arg);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tr = kvm_arch_vm_ioctl(filp, ioctl, arg);",
                        "\t}",
                        "out:",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3606,
                    "highlight": 3617
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81025e14"
        },
        "1252": {
            "name": "+0x27",
            "parent_idx": 1249,
            "source_line": [
                {
                    "file": "fs/anon_inodes.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/anon_inodes.c?id=7ae77150d94d#n83",
                    "code": [
                        "/**",
                        " * anon_inode_getfile - creates a new file instance by hooking it up to an",
                        " *                      anonymous inode, and a dentry that describe the \"class\"",
                        " *                      of the file",
                        " *",
                        " * @name:    [in]    name of the \"class\" of the new file",
                        " * @fops:    [in]    file operations for the new file",
                        " * @priv:    [in]    private data for the new file (will be file's private_data)",
                        " * @flags:   [in]    flags",
                        " *",
                        " * Creates a new file by hooking it on a single inode. This is useful for files",
                        " * that do not need to have a full-fledged inode in order to operate correctly.",
                        " * All the files created with anon_inode_getfile() will share a single inode,",
                        " * hence saving memory and avoiding code duplication for the file/inode/dentry",
                        " * setup.  Returns the newly created file* or an error pointer.",
                        " */",
                        "struct file *anon_inode_getfile(const char *name,",
                        "\t\t\t\tconst struct file_operations *fops,",
                        "\t\t\t\tvoid *priv, int flags)",
                        "{",
                        "\tstruct file *file;",
                        "",
                        "\tif (IS_ERR(anon_inode_inode))",
                        "\t\treturn ERR_PTR(-ENODEV);",
                        "",
                        "\tif (fops->owner && !try_module_get(fops->owner))",
                        "\t\treturn ERR_PTR(-ENOENT);",
                        "",
                        "\t/*",
                        "\t * We know the anon_inode inode count is always greater than zero,",
                        "\t * so ihold() is safe.",
                        "\t */",
                        "\tihold(anon_inode_inode);",
                        "\tfile = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,",
                        "\t\t\t\t flags & (O_ACCMODE | O_NONBLOCK), fops);",
                        "\tif (IS_ERR(file))",
                        "\t\tgoto err;",
                        "",
                        "\tfile->f_mapping = anon_inode_inode->i_mapping;",
                        "",
                        "\tfile->private_data = priv;",
                        "",
                        "\treturn file;",
                        "",
                        "err:",
                        "\tiput(anon_inode_inode);",
                        "\tmodule_put(fops->owner);",
                        "\treturn file;",
                        "}"
                    ],
                    "start": 58,
                    "highlight": 83
                }
            ],
            "ins_idx": 376,
            "addr": "0xffffffff812ac877"
        },
        "1248": {
            "name": "+0x2c",
            "parent_idx": 1170,
            "source_line": [
                {
                    "file": "fs/anon_inodes.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/anon_inodes.c?id=7ae77150d94d#n136",
                    "code": [
                        "/**",
                        " * anon_inode_getfd - creates a new file instance by hooking it up to an",
                        " *                    anonymous inode, and a dentry that describe the \"class\"",
                        " *                    of the file",
                        " *",
                        " * @name:    [in]    name of the \"class\" of the new file",
                        " * @fops:    [in]    file operations for the new file",
                        " * @priv:    [in]    private data for the new file (will be file's private_data)",
                        " * @flags:   [in]    flags",
                        " *",
                        " * Creates a new file by hooking it on a single inode. This is useful for files",
                        " * that do not need to have a full-fledged inode in order to operate correctly.",
                        " * All the files created with anon_inode_getfd() will share a single inode,",
                        " * hence saving memory and avoiding code duplication for the file/inode/dentry",
                        " * setup.  Returns new descriptor or an error code.",
                        " */",
                        "int anon_inode_getfd(const char *name, const struct file_operations *fops,",
                        "\t\t     void *priv, int flags)",
                        "{",
                        "\tint error, fd;",
                        "\tstruct file *file;",
                        "",
                        "\terror = get_unused_fd_flags(flags);",
                        "\tif (error < 0)",
                        "\t\treturn error;",
                        "\tfd = error;",
                        "",
                        "\tfile = anon_inode_getfile(name, fops, priv, flags);",
                        "\tif (IS_ERR(file)) {",
                        "\t\terror = PTR_ERR(file);",
                        "\t\tgoto err_put_unused_fd;",
                        "\t}",
                        "\tfd_install(fd, file);",
                        "",
                        "\treturn fd;",
                        "",
                        "err_put_unused_fd:",
                        "\tput_unused_fd(fd);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 109,
                    "highlight": 136
                }
            ],
            "ins_idx": 387,
            "addr": "0xffffffff812ac95c"
        },
        "1171": {
            "name": "+0x2",
            "parent_idx": 1170,
            "source_line": [
                {
                    "file": "fs/anon_inodes.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/anon_inodes.c?id=7ae77150d94d#n127",
                    "code": [
                        "/**",
                        " * anon_inode_getfd - creates a new file instance by hooking it up to an",
                        " *                    anonymous inode, and a dentry that describe the \"class\"",
                        " *                    of the file",
                        " *",
                        " * @name:    [in]    name of the \"class\" of the new file",
                        " * @fops:    [in]    file operations for the new file",
                        " * @priv:    [in]    private data for the new file (will be file's private_data)",
                        " * @flags:   [in]    flags",
                        " *",
                        " * Creates a new file by hooking it on a single inode. This is useful for files",
                        " * that do not need to have a full-fledged inode in order to operate correctly.",
                        " * All the files created with anon_inode_getfd() will share a single inode,",
                        " * hence saving memory and avoiding code duplication for the file/inode/dentry",
                        " * setup.  Returns new descriptor or an error code.",
                        " */",
                        "int anon_inode_getfd(const char *name, const struct file_operations *fops,",
                        "\t\t     void *priv, int flags)",
                        "{",
                        "\tint error, fd;",
                        "\tstruct file *file;",
                        "",
                        "\terror = get_unused_fd_flags(flags);",
                        "\tif (error < 0)",
                        "\t\treturn error;",
                        "\tfd = error;",
                        "",
                        "\tfile = anon_inode_getfile(name, fops, priv, flags);",
                        "\tif (IS_ERR(file)) {",
                        "\t\terror = PTR_ERR(file);",
                        "\t\tgoto err_put_unused_fd;",
                        "\t}",
                        "\tfd_install(fd, file);",
                        "",
                        "\treturn fd;",
                        "",
                        "err_put_unused_fd:",
                        "\tput_unused_fd(fd);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 109,
                    "highlight": 127
                }
            ],
            "ins_idx": 441,
            "addr": "0xffffffff812ac932"
        },
        "1169": {
            "name": "+0x9e2",
            "parent_idx": 1111,
            "source_line": [
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n2997",
                    "code": [
                        "/*",
                        " * Allocates an inode for the vcpu.",
                        " */",
                        "static int create_vcpu_fd(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tchar name[8 + 1 + ITOA_MAX_LEN + 1];",
                        "",
                        "\tsnprintf(name, sizeof(name), \"kvm-vcpu:%d\", vcpu->vcpu_id);",
                        "\treturn anon_inode_getfd(name, &kvm_vcpu_fops, vcpu, O_RDWR | O_CLOEXEC);",
                        "}"
                    ],
                    "start": 2989,
                    "highlight": 2997
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n3072",
                    "code": [
                        "/*",
                        " * Creates some virtual cpus.  Good luck creating more than one.",
                        " */",
                        "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)",
                        "{",
                        "\tint r;",
                        "\tstruct kvm_vcpu *vcpu;",
                        "\tstruct page *page;",
                        "",
                        "\tif (id >= KVM_MAX_VCPU_ID)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm->created_vcpus == KVM_MAX_VCPUS) {",
                        "\t\tmutex_unlock(&kvm->lock);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tkvm->created_vcpus++;",
                        "\tmutex_unlock(&kvm->lock);",
                        "",
                        "\tr = kvm_arch_vcpu_precreate(kvm, id);",
                        "\tif (r)",
                        "\t\tgoto vcpu_decrement;",
                        "",
                        "\tvcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);",
                        "\tif (!vcpu) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_decrement;",
                        "\t}",
                        "",
                        "\tBUILD_BUG_ON(sizeof(struct kvm_run) > PAGE_SIZE);",
                        "\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);",
                        "\tif (!page) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_free;",
                        "\t}",
                        "\tvcpu->run = page_address(page);",
                        "",
                        "\tkvm_vcpu_init(vcpu, kvm, id);",
                        "",
                        "\tr = kvm_arch_vcpu_create(vcpu);",
                        "\tif (r)",
                        "\t\tgoto vcpu_free_run_page;",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm_get_vcpu_by_id(kvm, id)) {",
                        "\t\tr = -EEXIST;",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tvcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);",
                        "\tBUG_ON(kvm->vcpus[vcpu->vcpu_idx]);",
                        "",
                        "\t/* Now it's all set up, let userspace reach it */",
                        "\tkvm_get_kvm(kvm);",
                        "\tr = create_vcpu_fd(vcpu);",
                        "\tif (r < 0) {",
                        "\t\tkvm_put_kvm_no_destroy(kvm);",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tkvm->vcpus[vcpu->vcpu_idx] = vcpu;",
                        "",
                        "\t/*",
                        "\t * Pairs with smp_rmb() in kvm_get_vcpu.  Write kvm->vcpus",
                        "\t * before kvm->online_vcpu's incremented value.",
                        "\t */",
                        "\tsmp_wmb();",
                        "\tatomic_inc(&kvm->online_vcpus);",
                        "",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_arch_vcpu_postcreate(vcpu);",
                        "\tkvm_create_vcpu_debugfs(vcpu);",
                        "\treturn r;",
                        "",
                        "unlock_vcpu_destroy:",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_arch_vcpu_destroy(vcpu);",
                        "vcpu_free_run_page:",
                        "\tfree_page((unsigned long)vcpu->run);",
                        "vcpu_free:",
                        "\tkmem_cache_free(kvm_vcpu_cache, vcpu);",
                        "vcpu_decrement:",
                        "\tmutex_lock(&kvm->lock);",
                        "\tkvm->created_vcpus--;",
                        "\tmutex_unlock(&kvm->lock);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3016,
                    "highlight": 3072
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n3617",
                    "code": [
                        "static long kvm_vm_ioctl(struct file *filp,",
                        "\t\t\t   unsigned int ioctl, unsigned long arg)",
                        "{",
                        "\tstruct kvm *kvm = filp->private_data;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint r;",
                        "",
                        "\tif (kvm->mm != current->mm)",
                        "\t\treturn -EIO;",
                        "\tswitch (ioctl) {",
                        "\tcase KVM_CREATE_VCPU:",
                        "\t\tr = kvm_vm_ioctl_create_vcpu(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_ENABLE_CAP: {",
                        "\t\tstruct kvm_enable_cap cap;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cap, argp, sizeof(cap)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_USER_MEMORY_REGION: {",
                        "\t\tstruct kvm_userspace_memory_region kvm_userspace_mem;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&kvm_userspace_mem, argp,",
                        "\t\t\t\t\t\tsizeof(kvm_userspace_mem)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_DIRTY_LOG: {",
                        "\t\tstruct kvm_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT",
                        "\tcase KVM_CLEAR_DIRTY_LOG: {",
                        "\t\tstruct kvm_clear_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_KVM_MMIO",
                        "\tcase KVM_REGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_UNREGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "\tcase KVM_IRQFD: {",
                        "\t\tstruct kvm_irqfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_irqfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_IOEVENTFD: {",
                        "\t\tstruct kvm_ioeventfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_ioeventfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_HAVE_KVM_MSI",
                        "\tcase KVM_SIGNAL_MSI: {",
                        "\t\tstruct kvm_msi msi;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&msi, argp, sizeof(msi)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_send_userspace_msi(kvm, &msi);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef __KVM_HAVE_IRQ_LINE",
                        "\tcase KVM_IRQ_LINE_STATUS:",
                        "\tcase KVM_IRQ_LINE: {",
                        "\t\tstruct kvm_irq_level irq_event;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&irq_event, argp, sizeof(irq_event)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_irq_line(kvm, &irq_event,",
                        "\t\t\t\t\tioctl == KVM_IRQ_LINE_STATUS);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {",
                        "\t\t\tif (copy_to_user(argp, &irq_event, sizeof(irq_event)))",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING",
                        "\tcase KVM_SET_GSI_ROUTING: {",
                        "\t\tstruct kvm_irq_routing routing;",
                        "\t\tstruct kvm_irq_routing __user *urouting;",
                        "\t\tstruct kvm_irq_routing_entry *entries = NULL;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&routing, argp, sizeof(routing)))",
                        "\t\t\tgoto out;",
                        "\t\tr = -EINVAL;",
                        "\t\tif (!kvm_arch_can_set_irq_routing(kvm))",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr > KVM_MAX_IRQ_ROUTES)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.flags)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr) {",
                        "\t\t\tr = -ENOMEM;",
                        "\t\t\tentries = vmalloc(array_size(sizeof(*entries),",
                        "\t\t\t\t\t\t     routing.nr));",
                        "\t\t\tif (!entries)",
                        "\t\t\t\tgoto out;",
                        "\t\t\tr = -EFAULT;",
                        "\t\t\turouting = argp;",
                        "\t\t\tif (copy_from_user(entries, urouting->entries,",
                        "\t\t\t\t\t   routing.nr * sizeof(*entries)))",
                        "\t\t\t\tgoto out_free_irq_routing;",
                        "\t\t}",
                        "\t\tr = kvm_set_irq_routing(kvm, entries, routing.nr,",
                        "\t\t\t\t\trouting.flags);",
                        "out_free_irq_routing:",
                        "\t\tvfree(entries);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */",
                        "\tcase KVM_CREATE_DEVICE: {",
                        "\t\tstruct kvm_create_device cd;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cd, argp, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_ioctl_create_device(kvm, &cd);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &cd, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_CHECK_EXTENSION:",
                        "\t\tr = kvm_vm_ioctl_check_extension_generic(kvm, arg);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tr = kvm_arch_vm_ioctl(filp, ioctl, arg);",
                        "\t}",
                        "out:",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3606,
                    "highlight": 3617
                }
            ],
            "ins_idx": 465,
            "addr": "0xffffffff81025e02"
        },
        "1114": {
            "name": "+0x829",
            "parent_idx": 1111,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=7ae77150d94d#n659",
                    "code": [
                        "/*",
                        " * Shortcuts",
                        " */",
                        "static inline void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)",
                        "{",
                        "\treturn kmem_cache_alloc(k, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 654,
                    "highlight": 659
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n3041",
                    "code": [
                        "/*",
                        " * Creates some virtual cpus.  Good luck creating more than one.",
                        " */",
                        "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)",
                        "{",
                        "\tint r;",
                        "\tstruct kvm_vcpu *vcpu;",
                        "\tstruct page *page;",
                        "",
                        "\tif (id >= KVM_MAX_VCPU_ID)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm->created_vcpus == KVM_MAX_VCPUS) {",
                        "\t\tmutex_unlock(&kvm->lock);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tkvm->created_vcpus++;",
                        "\tmutex_unlock(&kvm->lock);",
                        "",
                        "\tr = kvm_arch_vcpu_precreate(kvm, id);",
                        "\tif (r)",
                        "\t\tgoto vcpu_decrement;",
                        "",
                        "\tvcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);",
                        "\tif (!vcpu) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_decrement;",
                        "\t}",
                        "",
                        "\tBUILD_BUG_ON(sizeof(struct kvm_run) > PAGE_SIZE);",
                        "\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);",
                        "\tif (!page) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_free;",
                        "\t}",
                        "\tvcpu->run = page_address(page);",
                        "",
                        "\tkvm_vcpu_init(vcpu, kvm, id);",
                        "",
                        "\tr = kvm_arch_vcpu_create(vcpu);",
                        "\tif (r)",
                        "\t\tgoto vcpu_free_run_page;",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm_get_vcpu_by_id(kvm, id)) {",
                        "\t\tr = -EEXIST;",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tvcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);",
                        "\tBUG_ON(kvm->vcpus[vcpu->vcpu_idx]);",
                        "",
                        "\t/* Now it's all set up, let userspace reach it */",
                        "\tkvm_get_kvm(kvm);",
                        "\tr = create_vcpu_fd(vcpu);",
                        "\tif (r < 0) {",
                        "\t\tkvm_put_kvm_no_destroy(kvm);",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tkvm->vcpus[vcpu->vcpu_idx] = vcpu;",
                        "",
                        "\t/*",
                        "\t * Pairs with smp_rmb() in kvm_get_vcpu.  Write kvm->vcpus",
                        "\t * before kvm->online_vcpu's incremented value.",
                        "\t */",
                        "\tsmp_wmb();",
                        "\tatomic_inc(&kvm->online_vcpus);",
                        "",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_arch_vcpu_postcreate(vcpu);",
                        "\tkvm_create_vcpu_debugfs(vcpu);",
                        "\treturn r;",
                        "",
                        "unlock_vcpu_destroy:",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_arch_vcpu_destroy(vcpu);",
                        "vcpu_free_run_page:",
                        "\tfree_page((unsigned long)vcpu->run);",
                        "vcpu_free:",
                        "\tkmem_cache_free(kvm_vcpu_cache, vcpu);",
                        "vcpu_decrement:",
                        "\tmutex_lock(&kvm->lock);",
                        "\tkvm->created_vcpus--;",
                        "\tmutex_unlock(&kvm->lock);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3016,
                    "highlight": 3041
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=7ae77150d94d#n3617",
                    "code": [
                        "static long kvm_vm_ioctl(struct file *filp,",
                        "\t\t\t   unsigned int ioctl, unsigned long arg)",
                        "{",
                        "\tstruct kvm *kvm = filp->private_data;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint r;",
                        "",
                        "\tif (kvm->mm != current->mm)",
                        "\t\treturn -EIO;",
                        "\tswitch (ioctl) {",
                        "\tcase KVM_CREATE_VCPU:",
                        "\t\tr = kvm_vm_ioctl_create_vcpu(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_ENABLE_CAP: {",
                        "\t\tstruct kvm_enable_cap cap;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cap, argp, sizeof(cap)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_USER_MEMORY_REGION: {",
                        "\t\tstruct kvm_userspace_memory_region kvm_userspace_mem;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&kvm_userspace_mem, argp,",
                        "\t\t\t\t\t\tsizeof(kvm_userspace_mem)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_DIRTY_LOG: {",
                        "\t\tstruct kvm_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT",
                        "\tcase KVM_CLEAR_DIRTY_LOG: {",
                        "\t\tstruct kvm_clear_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_KVM_MMIO",
                        "\tcase KVM_REGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_UNREGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "\tcase KVM_IRQFD: {",
                        "\t\tstruct kvm_irqfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_irqfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_IOEVENTFD: {",
                        "\t\tstruct kvm_ioeventfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_ioeventfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_HAVE_KVM_MSI",
                        "\tcase KVM_SIGNAL_MSI: {",
                        "\t\tstruct kvm_msi msi;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&msi, argp, sizeof(msi)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_send_userspace_msi(kvm, &msi);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef __KVM_HAVE_IRQ_LINE",
                        "\tcase KVM_IRQ_LINE_STATUS:",
                        "\tcase KVM_IRQ_LINE: {",
                        "\t\tstruct kvm_irq_level irq_event;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&irq_event, argp, sizeof(irq_event)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_irq_line(kvm, &irq_event,",
                        "\t\t\t\t\tioctl == KVM_IRQ_LINE_STATUS);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {",
                        "\t\t\tif (copy_to_user(argp, &irq_event, sizeof(irq_event)))",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING",
                        "\tcase KVM_SET_GSI_ROUTING: {",
                        "\t\tstruct kvm_irq_routing routing;",
                        "\t\tstruct kvm_irq_routing __user *urouting;",
                        "\t\tstruct kvm_irq_routing_entry *entries = NULL;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&routing, argp, sizeof(routing)))",
                        "\t\t\tgoto out;",
                        "\t\tr = -EINVAL;",
                        "\t\tif (!kvm_arch_can_set_irq_routing(kvm))",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr > KVM_MAX_IRQ_ROUTES)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.flags)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr) {",
                        "\t\t\tr = -ENOMEM;",
                        "\t\t\tentries = vmalloc(array_size(sizeof(*entries),",
                        "\t\t\t\t\t\t     routing.nr));",
                        "\t\t\tif (!entries)",
                        "\t\t\t\tgoto out;",
                        "\t\t\tr = -EFAULT;",
                        "\t\t\turouting = argp;",
                        "\t\t\tif (copy_from_user(entries, urouting->entries,",
                        "\t\t\t\t\t   routing.nr * sizeof(*entries)))",
                        "\t\t\t\tgoto out_free_irq_routing;",
                        "\t\t}",
                        "\t\tr = kvm_set_irq_routing(kvm, entries, routing.nr,",
                        "\t\t\t\t\trouting.flags);",
                        "out_free_irq_routing:",
                        "\t\tvfree(entries);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */",
                        "\tcase KVM_CREATE_DEVICE: {",
                        "\t\tstruct kvm_create_device cd;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cd, argp, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_ioctl_create_device(kvm, &cd);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &cd, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_CHECK_EXTENSION:",
                        "\t\tr = kvm_vm_ioctl_check_extension_generic(kvm, arg);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tr = kvm_arch_vm_ioctl(filp, ioctl, arg);",
                        "\t}",
                        "out:",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3606,
                    "highlight": 3617
                }
            ],
            "ins_idx": 689,
            "addr": "0xffffffff81025c49"
        }
    },
    "ins": {
        "8": {
            "name": "mov r14, qword ptr [rdi + 0x98]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x98",
            "call_idx": 1478,
            "inputs": [
                2548,
                2549
            ],
            "outputs": [
                2550
            ]
        },
        "19": {
            "name": "mov rdi, qword ptr [rdi + 0x2f8]",
            "desc": "Heap Use Before Initialization",
            "call_idx": 1477,
            "inputs": [
                2545,
                2546
            ],
            "outputs": [
                2547
            ]
        },
        "32": {
            "name": "push r15",
            "desc": "Source of base address MEMALLOC 0x0",
            "call_idx": 1113,
            "inputs": [],
            "outputs": [
                1930
            ]
        },
        "31": {
            "name": "mov rdi, rbx",
            "desc": "",
            "call_idx": 1475,
            "inputs": [
                2543
            ],
            "outputs": [
                2544
            ]
        },
        "87": {
            "name": "mov rbx, rdi",
            "desc": "",
            "call_idx": 1468,
            "inputs": [
                2533
            ],
            "outputs": [
                2534
            ]
        },
        "103": {
            "name": "mov rdi, rbp",
            "desc": "",
            "call_idx": 1466,
            "inputs": [
                2531
            ],
            "outputs": [
                2532
            ]
        },
        "162": {
            "name": "mov rbp, rdi",
            "desc": "",
            "call_idx": 1459,
            "inputs": [
                2521
            ],
            "outputs": [
                2522
            ]
        },
        "181": {
            "name": "mov rdi, r15",
            "desc": "",
            "call_idx": 1457,
            "inputs": [
                2519
            ],
            "outputs": [
                2520
            ]
        },
        "306": {
            "name": "mov r15, rdi",
            "desc": "",
            "call_idx": 1438,
            "inputs": [
                2493
            ],
            "outputs": [
                2494
            ]
        },
        "316": {
            "name": "mov rdi, r14",
            "desc": "",
            "call_idx": 1436,
            "inputs": [
                2491
            ],
            "outputs": [
                2492
            ]
        },
        "323": {
            "name": "mov r14, qword ptr [rdi + 0xc8]",
            "desc": "",
            "call_idx": 1435,
            "inputs": [
                2488,
                2489
            ],
            "outputs": [
                2490
            ]
        },
        "333": {
            "name": "mov qword ptr [rax + 0xc8], r13",
            "desc": "",
            "call_idx": 1274,
            "inputs": [
                2217,
                2218
            ],
            "outputs": [
                2219
            ]
        },
        "376": {
            "name": "mov r13, rdx",
            "desc": "",
            "call_idx": 1252,
            "inputs": [
                2186
            ],
            "outputs": [
                2187
            ]
        },
        "387": {
            "name": "mov rdx, r15",
            "desc": "",
            "call_idx": 1248,
            "inputs": [
                2180
            ],
            "outputs": [
                2181
            ]
        },
        "441": {
            "name": "mov r15, rdx",
            "desc": "",
            "call_idx": 1171,
            "inputs": [
                2007
            ],
            "outputs": [
                2008
            ]
        },
        "465": {
            "name": "mov rdx, r15",
            "desc": "",
            "call_idx": 1169,
            "inputs": [
                2005
            ],
            "outputs": [
                2006
            ]
        },
        "689": {
            "name": "mov r15, rax",
            "desc": "",
            "call_idx": 1114,
            "inputs": [
                1931
            ],
            "outputs": [
                1932
            ]
        }
    },
    "data": {
        "2548": {
            "name": "RDI",
            "ins_idx": 8,
            "value": "0x0",
            "sources": []
        },
        "2549": {
            "name": "[0x98]",
            "ins_idx": 8,
            "value": "0x0",
            "sources": []
        },
        "2550": {
            "name": "R14",
            "ins_idx": 8,
            "value": "0x0",
            "sources": []
        },
        "2545": {
            "name": "RDI",
            "ins_idx": 19,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2546": {
            "name": "[0xffff8882358a82f8]",
            "ins_idx": 19,
            "value": "0x0",
            "sources": []
        },
        "2547": {
            "name": "RDI",
            "ins_idx": 19,
            "value": "0x0",
            "sources": [
                2548
            ]
        },
        "1930": {
            "name": "RAX",
            "ins_idx": 32,
            "value": "0xffff8882358a8000",
            "sources": [
                1931
            ]
        },
        "2543": {
            "name": "RBX",
            "ins_idx": 31,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2544": {
            "name": "RDI",
            "ins_idx": 31,
            "value": "0xffff8882358a8000",
            "sources": [
                2545
            ]
        },
        "2533": {
            "name": "RDI",
            "ins_idx": 87,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2534": {
            "name": "RBX",
            "ins_idx": 87,
            "value": "0xffff8882358a8000",
            "sources": [
                2543
            ]
        },
        "2531": {
            "name": "RBP",
            "ins_idx": 103,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2532": {
            "name": "RDI",
            "ins_idx": 103,
            "value": "0xffff8882358a8000",
            "sources": [
                2533
            ]
        },
        "2521": {
            "name": "RDI",
            "ins_idx": 162,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2522": {
            "name": "RBP",
            "ins_idx": 162,
            "value": "0xffff8882358a8000",
            "sources": [
                2531
            ]
        },
        "2519": {
            "name": "R15",
            "ins_idx": 181,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2520": {
            "name": "RDI",
            "ins_idx": 181,
            "value": "0xffff8882358a8000",
            "sources": [
                2521
            ]
        },
        "2493": {
            "name": "RDI",
            "ins_idx": 306,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2494": {
            "name": "R15",
            "ins_idx": 306,
            "value": "0xffff8882358a8000",
            "sources": [
                2519
            ]
        },
        "2491": {
            "name": "R14",
            "ins_idx": 316,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2492": {
            "name": "RDI",
            "ins_idx": 316,
            "value": "0xffff8882358a8000",
            "sources": [
                2493
            ]
        },
        "2488": {
            "name": "RDI",
            "ins_idx": 323,
            "value": "0xffff888235830500",
            "sources": []
        },
        "2489": {
            "name": "[0xffff8882358305c8]",
            "ins_idx": 323,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2490": {
            "name": "R14",
            "ins_idx": 323,
            "value": "0xffff8882358a8000",
            "sources": [
                2491
            ]
        },
        "2217": {
            "name": "RAX",
            "ins_idx": 333,
            "value": "0xffff888235830500",
            "sources": []
        },
        "2218": {
            "name": "R13",
            "ins_idx": 333,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2219": {
            "name": "[0xffff8882358305c8]",
            "ins_idx": 333,
            "value": "0xffff8882358a8000",
            "sources": [
                2489
            ]
        },
        "2186": {
            "name": "RDX",
            "ins_idx": 376,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2187": {
            "name": "R13",
            "ins_idx": 376,
            "value": "0xffff8882358a8000",
            "sources": [
                2218
            ]
        },
        "2180": {
            "name": "R15",
            "ins_idx": 387,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2181": {
            "name": "RDX",
            "ins_idx": 387,
            "value": "0xffff8882358a8000",
            "sources": [
                2186
            ]
        },
        "2007": {
            "name": "RDX",
            "ins_idx": 441,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2008": {
            "name": "R15",
            "ins_idx": 441,
            "value": "0xffff8882358a8000",
            "sources": [
                2180
            ]
        },
        "2005": {
            "name": "R15",
            "ins_idx": 465,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "2006": {
            "name": "RDX",
            "ins_idx": 465,
            "value": "0xffff8882358a8000",
            "sources": [
                2007
            ]
        },
        "1931": {
            "name": "RAX",
            "ins_idx": 689,
            "value": "0xffff8882358a8000",
            "sources": []
        },
        "1932": {
            "name": "R15",
            "ins_idx": 689,
            "value": "0xffff8882358a8000",
            "sources": [
                2005
            ]
        }
    },
    "chain": {
        "8": [
            19
        ],
        "19": [
            32,
            31
        ],
        "31": [
            87
        ],
        "87": [
            103
        ],
        "103": [
            162
        ],
        "162": [
            181
        ],
        "181": [
            306
        ],
        "306": [
            316
        ],
        "316": [
            323
        ],
        "323": [
            333
        ],
        "333": [
            376
        ],
        "376": [
            387
        ],
        "387": [
            441
        ],
        "441": [
            465
        ],
        "465": [
            689
        ],
        "689": [
            32
        ]
    }
}