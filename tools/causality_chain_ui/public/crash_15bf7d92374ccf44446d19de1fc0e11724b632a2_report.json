{
    "report": "https://syzkaller.appspot.com/bug?id=15bf7d92374ccf44446d19de1fc0e11724b632a2",
    "title": "general protection fault in gfs2_withdraw",
    "call": {
        "18874": {
            "name": "+0x42",
            "parent_idx": 18865,
            "source_line": [
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n97",
                    "code": [
                        "static void signal_our_withdraw(struct gfs2_sbd *sdp)",
                        "{",
                        "\tstruct gfs2_glock *gl = sdp->sd_live_gh.gh_gl;",
                        "\tstruct inode *inode = sdp->sd_jdesc->jd_inode;",
                        "\tstruct gfs2_inode *ip = GFS2_I(inode);",
                        "\tu64 no_formal_ino = ip->i_no_formal_ino;",
                        "\tint ret = 0;",
                        "\tint tries;",
                        "",
                        "\tif (test_bit(SDF_NORECOVERY, &sdp->sd_flags))",
                        "\t\treturn;",
                        "",
                        "\t/* Prevent any glock dq until withdraw recovery is complete */",
                        "\tset_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags);",
                        "\t/*",
                        "\t * Don't tell dlm we're bailing until we have no more buffers in the",
                        "\t * wind. If journal had an IO error, the log code should just purge",
                        "\t * the outstanding buffers rather than submitting new IO. Making the",
                        "\t * file system read-only will flush the journal, etc.",
                        "\t *",
                        "\t * During a normal unmount, gfs2_make_fs_ro calls gfs2_log_shutdown",
                        "\t * which clears SDF_JOURNAL_LIVE. In a withdraw, we must not write",
                        "\t * any UNMOUNT log header, so we can't call gfs2_log_shutdown, and",
                        "\t * therefore we need to clear SDF_JOURNAL_LIVE manually.",
                        "\t */",
                        "\tclear_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags);",
                        "\tif (!sb_rdonly(sdp->sd_vfs))",
                        "\t\tret = gfs2_make_fs_ro(sdp);",
                        "",
                        "\tif (sdp->sd_lockstruct.ls_ops->lm_lock == NULL) { /* lock_nolock */",
                        "\t\tif (!ret)",
                        "\t\t\tret = -EIO;",
                        "\t\tclear_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags);",
                        "\t\tgoto skip_recovery;",
                        "\t}",
                        "\t/*",
                        "\t * Drop the glock for our journal so another node can recover it.",
                        "\t */",
                        "\tif (gfs2_holder_initialized(&sdp->sd_journal_gh)) {",
                        "\t\tgfs2_glock_dq_wait(&sdp->sd_journal_gh);",
                        "\t\tgfs2_holder_uninit(&sdp->sd_journal_gh);",
                        "\t}",
                        "\tsdp->sd_jinode_gh.gh_flags |= GL_NOCACHE;",
                        "\tgfs2_glock_dq(&sdp->sd_jinode_gh);",
                        "\tif (test_bit(SDF_FS_FROZEN, &sdp->sd_flags)) {",
                        "\t\t/* Make sure gfs2_unfreeze works if partially-frozen */",
                        "\t\tflush_workqueue(gfs2_freeze_wq);",
                        "\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);",
                        "\t\tthaw_super(sdp->sd_vfs);",
                        "\t} else {",
                        "\t\twait_on_bit(&gl->gl_flags, GLF_DEMOTE, TASK_UNINTERRUPTIBLE);",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * holder_uninit to force glock_put, to force dlm to let go",
                        "\t */",
                        "\tgfs2_holder_uninit(&sdp->sd_jinode_gh);",
                        "",
                        "\t/*",
                        "\t * Note: We need to be careful here:",
                        "\t * Our iput of jd_inode will evict it. The evict will dequeue its",
                        "\t * glock, but the glock dq will wait for the withdraw unless we have",
                        "\t * exception code in glock_dq.",
                        "\t */",
                        "\tiput(inode);",
                        "\t/*",
                        "\t * Wait until the journal inode's glock is freed. This allows try locks",
                        "\t * on other nodes to be successful, otherwise we remain the owner of",
                        "\t * the glock as far as dlm is concerned.",
                        "\t */",
                        "\tif (gl->gl_ops->go_free) {",
                        "\t\tset_bit(GLF_FREEING, &gl->gl_flags);",
                        "\t\twait_on_bit(&gl->gl_flags, GLF_FREEING, TASK_UNINTERRUPTIBLE);",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Dequeue the \"live\" glock, but keep a reference so it's never freed.",
                        "\t */",
                        "\tgfs2_glock_hold(gl);",
                        "\tgfs2_glock_dq_wait(&sdp->sd_live_gh);",
                        "\t/*",
                        "\t * We enqueue the \"live\" glock in EX so that all other nodes",
                        "\t * get a demote request and act on it. We don't really want the",
                        "\t * lock in EX, so we send a \"try\" lock with 1CB to produce a callback.",
                        "\t */",
                        "\tfs_warn(sdp, \"Requesting recovery of jid %d.\\n\",",
                        "\t\tsdp->sd_lockstruct.ls_jid);",
                        "\tgfs2_holder_reinit(LM_ST_EXCLUSIVE, LM_FLAG_TRY_1CB | LM_FLAG_NOEXP,",
                        "\t\t\t   &sdp->sd_live_gh);",
                        "\tmsleep(GL_GLOCK_MAX_HOLD);",
                        "\t/*",
                        "\t * This will likely fail in a cluster, but succeed standalone:",
                        "\t */",
                        "\tret = gfs2_glock_nq(&sdp->sd_live_gh);",
                        "",
                        "\t/*",
                        "\t * If we actually got the \"live\" lock in EX mode, there are no other",
                        "\t * nodes available to replay our journal. So we try to replay it",
                        "\t * ourselves. We hold the \"live\" glock to prevent other mounters",
                        "\t * during recovery, then just dequeue it and reacquire it in our",
                        "\t * normal SH mode. Just in case the problem that caused us to",
                        "\t * withdraw prevents us from recovering our journal (e.g. io errors",
                        "\t * and such) we still check if the journal is clean before proceeding",
                        "\t * but we may wait forever until another mounter does the recovery.",
                        "\t */",
                        "\tif (ret == 0) {",
                        "\t\tfs_warn(sdp, \"No other mounters found. Trying to recover our \"",
                        "\t\t\t\"own journal jid %d.\\n\", sdp->sd_lockstruct.ls_jid);",
                        "\t\tif (gfs2_recover_journal(sdp->sd_jdesc, 1))",
                        "\t\t\tfs_warn(sdp, \"Unable to recover our journal jid %d.\\n\",",
                        "\t\t\t\tsdp->sd_lockstruct.ls_jid);",
                        "\t\tgfs2_glock_dq_wait(&sdp->sd_live_gh);",
                        "\t\tgfs2_holder_reinit(LM_ST_SHARED, LM_FLAG_NOEXP | GL_EXACT,",
                        "\t\t\t\t   &sdp->sd_live_gh);",
                        "\t\tgfs2_glock_nq(&sdp->sd_live_gh);",
                        "\t}",
                        "",
                        "\tgfs2_glock_queue_put(gl); /* drop the extra reference we acquired */",
                        "\tclear_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags);",
                        "",
                        "\t/*",
                        "\t * At this point our journal is evicted, so we need to get a new inode",
                        "\t * for it. Once done, we need to call gfs2_find_jhead which",
                        "\t * calls gfs2_map_journal_extents to map it for us again.",
                        "\t *",
                        "\t * Note that we don't really want it to look up a FREE block. The",
                        "\t * GFS2_BLKST_FREE simply overrides a block check in gfs2_inode_lookup",
                        "\t * which would otherwise fail because it requires grabbing an rgrp",
                        "\t * glock, which would fail with -EIO because we're withdrawing.",
                        "\t */",
                        "\tinode = gfs2_inode_lookup(sdp->sd_vfs, DT_UNKNOWN,",
                        "\t\t\t\t  sdp->sd_jdesc->jd_no_addr, no_formal_ino,",
                        "\t\t\t\t  GFS2_BLKST_FREE);",
                        "\tif (IS_ERR(inode)) {",
                        "\t\tfs_warn(sdp, \"Reprocessing of jid %d failed with %ld.\\n\",",
                        "\t\t\tsdp->sd_lockstruct.ls_jid, PTR_ERR(inode));",
                        "\t\tgoto skip_recovery;",
                        "\t}",
                        "\tsdp->sd_jdesc->jd_inode = inode;",
                        "",
                        "\t/*",
                        "\t * Now wait until recovery is complete.",
                        "\t */",
                        "\tfor (tries = 0; tries < 10; tries++) {",
                        "\t\tret = check_journal_clean(sdp, sdp->sd_jdesc, false);",
                        "\t\tif (!ret)",
                        "\t\t\tbreak;",
                        "\t\tmsleep(HZ);",
                        "\t\tfs_warn(sdp, \"Waiting for journal recovery jid %d.\\n\",",
                        "\t\t\tsdp->sd_lockstruct.ls_jid);",
                        "\t}",
                        "skip_recovery:",
                        "\tif (!ret)",
                        "\t\tfs_warn(sdp, \"Journal recovery complete for jid %d.\\n\",",
                        "\t\t\tsdp->sd_lockstruct.ls_jid);",
                        "\telse",
                        "\t\tfs_warn(sdp, \"Journal recovery skipped for %d until next \"",
                        "\t\t\t\"mount.\\n\", sdp->sd_lockstruct.ls_jid);",
                        "\tfs_warn(sdp, \"Glock dequeues delayed: %lu\\n\", sdp->sd_glock_dqs_held);",
                        "\tsdp->sd_glock_dqs_held = 0;",
                        "\twake_up_bit(&sdp->sd_flags, SDF_WITHDRAW_RECOVERY);",
                        "}"
                    ],
                    "start": 94,
                    "highlight": 97
                },
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n294",
                    "code": [
                        "int gfs2_withdraw(struct gfs2_sbd *sdp)",
                        "{",
                        "\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;",
                        "\tconst struct lm_lockops *lm = ls->ls_ops;",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&",
                        "\t    test_and_set_bit(SDF_WITHDRAWN, &sdp->sd_flags)) {",
                        "\t\tif (!test_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags))",
                        "\t\t\treturn -1;",
                        "",
                        "\t\twait_on_bit(&sdp->sd_flags, SDF_WITHDRAW_IN_PROG,",
                        "\t\t\t    TASK_UNINTERRUPTIBLE);",
                        "\t\treturn -1;",
                        "\t}",
                        "",
                        "\tset_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags);",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {",
                        "\t\tfs_err(sdp, \"about to withdraw this file system\\n\");",
                        "\t\tBUG_ON(sdp->sd_args.ar_debug);",
                        "",
                        "\t\tsignal_our_withdraw(sdp);",
                        "",
                        "\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);",
                        "",
                        "\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))",
                        "\t\t\twait_for_completion(&sdp->sd_wdack);",
                        "",
                        "\t\tif (lm->lm_unmount) {",
                        "\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");",
                        "\t\t\tlm->lm_unmount(sdp);",
                        "\t\t}",
                        "\t\tset_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags);",
                        "\t\tfs_err(sdp, \"File system withdrawn\\n\");",
                        "\t\tdump_stack();",
                        "\t\tclear_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags);",
                        "\t\tsmp_mb__after_atomic();",
                        "\t\twake_up_bit(&sdp->sd_flags, SDF_WITHDRAW_IN_PROG);",
                        "\t}",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)",
                        "\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);",
                        "",
                        "\treturn -1;",
                        "}"
                    ],
                    "start": 273,
                    "highlight": 294
                }
            ],
            "ins_idx": 694,
            "addr": "0xffffffff81392145"
        },
        "18865": {
            "name": "gfs2_withdraw",
            "parent_idx": 18841,
            "source_line": [
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n450",
                    "code": [
                        "int gfs2_meta_check_ii(struct gfs2_sbd *sdp, struct buffer_head *bh,",
                        "\t\t       const char *type, const char *function, char *file,",
                        "\t\t       unsigned int line)",
                        "{",
                        "\tint me;",
                        "",
                        "\tgfs2_lm(sdp,",
                        "\t\t\"fatal: invalid metadata block\\n\"",
                        "\t\t\"  bh = %llu (%s)\\n\"",
                        "\t\t\"  function = %s, file = %s, line = %u\\n\",",
                        "\t\t(unsigned long long)bh->b_blocknr, type,",
                        "\t\tfunction, file, line);",
                        "\tme = gfs2_withdraw(sdp);",
                        "\treturn (me) ? -1 : -2;",
                        "}"
                    ],
                    "start": 438,
                    "highlight": 450
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81391f95"
        },
        "18841": {
            "name": "gfs2_meta_check_ii",
            "parent_idx": 18832,
            "source_line": [
                {
                    "file": "fs/gfs2/util.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.h?id=549738f15da0e5a00275977623be199fbbf7df50#n126",
                    "code": [
                        "static inline int gfs2_metatype_check_i(struct gfs2_sbd *sdp,",
                        "\t\t\t\t\tstruct buffer_head *bh,",
                        "\t\t\t\t\tu16 type,",
                        "\t\t\t\t\tconst char *function,",
                        "\t\t\t\t\tchar *file, unsigned int line)",
                        "{",
                        "\tstruct gfs2_meta_header *mh = (struct gfs2_meta_header *)bh->b_data;",
                        "\tu32 magic = be32_to_cpu(mh->mh_magic);",
                        "\tu16 t = be32_to_cpu(mh->mh_type);",
                        "\tif (unlikely(magic != GFS2_MAGIC))",
                        "\t\treturn gfs2_meta_check_ii(sdp, bh, \"magic number\", function,",
                        "\t\t\t\t\t  file, line);",
                        "        if (unlikely(t != type))",
                        "\t\treturn gfs2_metatype_check_ii(sdp, bh, type, t, function,",
                        "\t\t\t\t\t      file, line);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 116,
                    "highlight": 126
                },
                {
                    "file": "fs/gfs2/meta_io.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/meta_io.c?id=549738f15da0e5a00275977623be199fbbf7df50#n417",
                    "code": [
                        "int gfs2_meta_indirect_buffer(struct gfs2_inode *ip, int height, u64 num,",
                        "\t\t\t      struct buffer_head **bhp)",
                        "{",
                        "\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);",
                        "\tstruct gfs2_glock *gl = ip->i_gl;",
                        "\tstruct buffer_head *bh;",
                        "\tint ret = 0;",
                        "\tu32 mtype = height ? GFS2_METATYPE_IN : GFS2_METATYPE_DI;",
                        "\tint rahead = 0;",
                        "",
                        "\tif (num == ip->i_no_addr)",
                        "\t\trahead = ip->i_rahead;",
                        "",
                        "\tret = gfs2_meta_read(gl, num, DIO_WAIT, rahead, &bh);",
                        "\tif (ret == 0 && gfs2_metatype_check(sdp, bh, mtype)) {",
                        "\t\tbrelse(bh);",
                        "\t\tret = -EIO;",
                        "\t} else {",
                        "\t\t*bhp = bh;",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 403,
                    "highlight": 417
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8137a2da"
        },
        "18832": {
            "name": "gfs2_meta_indirect_buffer",
            "parent_idx": 18831,
            "source_line": [
                {
                    "file": "fs/gfs2/meta_io.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/meta_io.h?id=549738f15da0e5a00275977623be199fbbf7df50#n70",
                    "code": [
                        "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,",
                        "\t\t\t\t\t struct buffer_head **bhp)",
                        "{",
                        "\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);",
                        "}"
                    ],
                    "start": 67,
                    "highlight": 70
                },
                {
                    "file": "fs/gfs2/glops.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glops.c?id=549738f15da0e5a00275977623be199fbbf7df50#n438",
                    "code": [
                        "int gfs2_inode_refresh(struct gfs2_inode *ip)",
                        "{",
                        "\tstruct buffer_head *dibh;",
                        "\tint error;",
                        "",
                        "\terror = gfs2_meta_inode_buffer(ip, &dibh);",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "\terror = gfs2_dinode_in(ip, dibh->b_data);",
                        "\tbrelse(dibh);",
                        "\tclear_bit(GIF_INVALID, &ip->i_flags);",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 433,
                    "highlight": 438
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81374ad7"
        },
        "18831": {
            "name": "gfs2_inode_refresh",
            "parent_idx": 18827,
            "source_line": [
                {
                    "file": "fs/gfs2/glops.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glops.c?id=549738f15da0e5a00275977623be199fbbf7df50#n468",
                    "code": [
                        "static int inode_go_lock(struct gfs2_holder *gh)",
                        "{",
                        "\tstruct gfs2_glock *gl = gh->gh_gl;",
                        "\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;",
                        "\tstruct gfs2_inode *ip = gl->gl_object;",
                        "\tint error = 0;",
                        "",
                        "\tif (!ip || (gh->gh_flags & GL_SKIP))",
                        "\t\treturn 0;",
                        "",
                        "\tif (test_bit(GIF_INVALID, &ip->i_flags)) {",
                        "\t\terror = gfs2_inode_refresh(ip);",
                        "\t\tif (error)",
                        "\t\t\treturn error;",
                        "\t}",
                        "",
                        "\tif (gh->gh_state != LM_ST_DEFERRED)",
                        "\t\tinode_dio_wait(&ip->i_inode);",
                        "",
                        "\tif ((ip->i_diskflags & GFS2_DIF_TRUNC_IN_PROG) &&",
                        "\t    (gl->gl_state == LM_ST_EXCLUSIVE) &&",
                        "\t    (gh->gh_state == LM_ST_EXCLUSIVE)) {",
                        "\t\tspin_lock(&sdp->sd_trunc_lock);",
                        "\t\tif (list_empty(&ip->i_trunc_list))",
                        "\t\t\tlist_add(&ip->i_trunc_list, &sdp->sd_trunc_list);",
                        "\t\tspin_unlock(&sdp->sd_trunc_lock);",
                        "\t\twake_up(&sdp->sd_quota_wait);",
                        "\t\treturn 1;",
                        "\t}",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 457,
                    "highlight": 468
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81374d51"
        },
        "18827": {
            "name": "inode_go_lock(indirect)",
            "parent_idx": 18823,
            "source_line": [
                {
                    "file": "fs/gfs2/glock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=549738f15da0e5a00275977623be199fbbf7df50#n390",
                    "code": [
                        "static int do_promote(struct gfs2_glock *gl)",
                        "__releases(&gl->gl_lockref.lock)",
                        "__acquires(&gl->gl_lockref.lock)",
                        "{",
                        "\tconst struct gfs2_glock_operations *glops = gl->gl_ops;",
                        "\tstruct gfs2_holder *gh, *tmp;",
                        "\tint ret;",
                        "",
                        "restart:",
                        "\tlist_for_each_entry_safe(gh, tmp, &gl->gl_holders, gh_list) {",
                        "\t\tif (test_bit(HIF_HOLDER, &gh->gh_iflags))",
                        "\t\t\tcontinue;",
                        "\t\tif (may_grant(gl, gh)) {",
                        "\t\t\tif (gh->gh_list.prev == &gl->gl_holders &&",
                        "\t\t\t    glops->go_lock) {",
                        "\t\t\t\tspin_unlock(&gl->gl_lockref.lock);",
                        "\t\t\t\t/* FIXME: eliminate this eventually */",
                        "\t\t\t\tret = glops->go_lock(gh);",
                        "\t\t\t\tspin_lock(&gl->gl_lockref.lock);",
                        "\t\t\t\tif (ret) {",
                        "\t\t\t\t\tif (ret == 1)",
                        "\t\t\t\t\t\treturn 2;",
                        "\t\t\t\t\tgh->gh_error = ret;",
                        "\t\t\t\t\tlist_del_init(&gh->gh_list);",
                        "\t\t\t\t\ttrace_gfs2_glock_queue(gh, 0);",
                        "\t\t\t\t\tgfs2_holder_wake(gh);",
                        "\t\t\t\t\tgoto restart;",
                        "\t\t\t\t}",
                        "\t\t\t\tset_bit(HIF_HOLDER, &gh->gh_iflags);",
                        "\t\t\t\ttrace_gfs2_promote(gh, 1);",
                        "\t\t\t\tgfs2_holder_wake(gh);",
                        "\t\t\t\tgoto restart;",
                        "\t\t\t}",
                        "\t\t\tset_bit(HIF_HOLDER, &gh->gh_iflags);",
                        "\t\t\ttrace_gfs2_promote(gh, 0);",
                        "\t\t\tgfs2_holder_wake(gh);",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t\tif (gh->gh_list.prev == &gl->gl_holders)",
                        "\t\t\treturn 1;",
                        "\t\tdo_error(gl, 0);",
                        "\t\tbreak;",
                        "\t}",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 373,
                    "highlight": 390
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8136f5bf"
        },
        "18823": {
            "name": "do_promote",
            "parent_idx": 18820,
            "source_line": [
                {
                    "file": "fs/gfs2/glock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=549738f15da0e5a00275977623be199fbbf7df50#n560",
                    "code": [
                        "static void finish_xmote(struct gfs2_glock *gl, unsigned int ret)",
                        "{",
                        "\tconst struct gfs2_glock_operations *glops = gl->gl_ops;",
                        "\tstruct gfs2_holder *gh;",
                        "\tunsigned state = ret & LM_OUT_ST_MASK;",
                        "\tint rv;",
                        "",
                        "\tspin_lock(&gl->gl_lockref.lock);",
                        "\ttrace_gfs2_glock_state_change(gl, state);",
                        "\tstate_change(gl, state);",
                        "\tgh = find_first_waiter(gl);",
                        "",
                        "\t/* Demote to UN request arrived during demote to SH or DF */",
                        "\tif (test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags) &&",
                        "\t    state != LM_ST_UNLOCKED && gl->gl_demote_state == LM_ST_UNLOCKED)",
                        "\t\tgl->gl_target = LM_ST_UNLOCKED;",
                        "",
                        "\t/* Check for state != intended state */",
                        "\tif (unlikely(state != gl->gl_target)) {",
                        "\t\tif (gh && !test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags)) {",
                        "\t\t\t/* move to back of queue and try next entry */",
                        "\t\t\tif (ret & LM_OUT_CANCELED) {",
                        "\t\t\t\tif ((gh->gh_flags & LM_FLAG_PRIORITY) == 0)",
                        "\t\t\t\t\tlist_move_tail(&gh->gh_list, &gl->gl_holders);",
                        "\t\t\t\tgh = find_first_waiter(gl);",
                        "\t\t\t\tgl->gl_target = gh->gh_state;",
                        "\t\t\t\tgoto retry;",
                        "\t\t\t}",
                        "\t\t\t/* Some error or failed \"try lock\" - report it */",
                        "\t\t\tif ((ret & LM_OUT_ERROR) ||",
                        "\t\t\t    (gh->gh_flags & (LM_FLAG_TRY | LM_FLAG_TRY_1CB))) {",
                        "\t\t\t\tgl->gl_target = gl->gl_state;",
                        "\t\t\t\tdo_error(gl, ret);",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tswitch(state) {",
                        "\t\t/* Unlocked due to conversion deadlock, try again */",
                        "\t\tcase LM_ST_UNLOCKED:",
                        "retry:",
                        "\t\t\tdo_xmote(gl, gh, gl->gl_target);",
                        "\t\t\tbreak;",
                        "\t\t/* Conversion fails, unlock and try again */",
                        "\t\tcase LM_ST_SHARED:",
                        "\t\tcase LM_ST_DEFERRED:",
                        "\t\t\tdo_xmote(gl, gh, LM_ST_UNLOCKED);",
                        "\t\t\tbreak;",
                        "\t\tdefault: /* Everything else */",
                        "\t\t\tfs_err(gl->gl_name.ln_sbd, \"wanted %u got %u\\n\",",
                        "\t\t\t       gl->gl_target, state);",
                        "\t\t\tGLOCK_BUG_ON(gl, 1);",
                        "\t\t}",
                        "\t\tspin_unlock(&gl->gl_lockref.lock);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* Fast path - we got what we asked for */",
                        "\tif (test_and_clear_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags))",
                        "\t\tgfs2_demote_wake(gl);",
                        "\tif (state != LM_ST_UNLOCKED) {",
                        "\t\tif (glops->go_xmote_bh) {",
                        "\t\t\tspin_unlock(&gl->gl_lockref.lock);",
                        "\t\t\trv = glops->go_xmote_bh(gl, gh);",
                        "\t\t\tspin_lock(&gl->gl_lockref.lock);",
                        "\t\t\tif (rv) {",
                        "\t\t\t\tdo_error(gl, rv);",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\trv = do_promote(gl);",
                        "\t\tif (rv == 2)",
                        "\t\t\tgoto out_locked;",
                        "\t}",
                        "out:",
                        "\tclear_bit(GLF_LOCK, &gl->gl_flags);",
                        "out_locked:",
                        "\tspin_unlock(&gl->gl_lockref.lock);",
                        "}"
                    ],
                    "start": 491,
                    "highlight": 560
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81372f23"
        },
        "18820": {
            "name": "finish_xmote",
            "parent_idx": 18800,
            "source_line": [
                {
                    "file": "fs/gfs2/glock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=549738f15da0e5a00275977623be199fbbf7df50#n686",
                    "code": [
                        "static void do_xmote(struct gfs2_glock *gl, struct gfs2_holder *gh, unsigned int target)",
                        "__releases(&gl->gl_lockref.lock)",
                        "__acquires(&gl->gl_lockref.lock)",
                        "{",
                        "\tconst struct gfs2_glock_operations *glops = gl->gl_ops;",
                        "\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;",
                        "\tunsigned int lck_flags = (unsigned int)(gh ? gh->gh_flags : 0);",
                        "\tint ret;",
                        "",
                        "\tif (target != LM_ST_UNLOCKED && glock_blocked_by_withdraw(gl) &&",
                        "\t    gh && !(gh->gh_flags & LM_FLAG_NOEXP))",
                        "\t\treturn;",
                        "\tlck_flags &= (LM_FLAG_TRY | LM_FLAG_TRY_1CB | LM_FLAG_NOEXP |",
                        "\t\t      LM_FLAG_PRIORITY);",
                        "\tGLOCK_BUG_ON(gl, gl->gl_state == target);",
                        "\tGLOCK_BUG_ON(gl, gl->gl_state == gl->gl_target);",
                        "\tif ((target == LM_ST_UNLOCKED || target == LM_ST_DEFERRED) &&",
                        "\t    glops->go_inval) {",
                        "\t\t/*",
                        "\t\t * If another process is already doing the invalidate, let that",
                        "\t\t * finish first.  The glock state machine will get back to this",
                        "\t\t * holder again later.",
                        "\t\t */",
                        "\t\tif (test_and_set_bit(GLF_INVALIDATE_IN_PROGRESS,",
                        "\t\t\t\t     &gl->gl_flags))",
                        "\t\t\treturn;",
                        "\t\tdo_error(gl, 0); /* Fail queued try locks */",
                        "\t}",
                        "\tgl->gl_req = target;",
                        "\tset_bit(GLF_BLOCKING, &gl->gl_flags);",
                        "\tif ((gl->gl_req == LM_ST_UNLOCKED) ||",
                        "\t    (gl->gl_state == LM_ST_EXCLUSIVE) ||",
                        "\t    (lck_flags & (LM_FLAG_TRY|LM_FLAG_TRY_1CB)))",
                        "\t\tclear_bit(GLF_BLOCKING, &gl->gl_flags);",
                        "\tspin_unlock(&gl->gl_lockref.lock);",
                        "\tif (glops->go_sync) {",
                        "\t\tret = glops->go_sync(gl);",
                        "\t\t/* If we had a problem syncing (due to io errors or whatever,",
                        "\t\t * we should not invalidate the metadata or tell dlm to",
                        "\t\t * release the glock to other nodes.",
                        "\t\t */",
                        "\t\tif (ret) {",
                        "\t\t\tif (cmpxchg(&sdp->sd_log_error, 0, ret)) {",
                        "\t\t\t\tfs_err(sdp, \"Error %d syncing glock \\n\", ret);",
                        "\t\t\t\tgfs2_dump_glock(NULL, gl, true);",
                        "\t\t\t}",
                        "\t\t\tgoto skip_inval;",
                        "\t\t}",
                        "\t}",
                        "\tif (test_bit(GLF_INVALIDATE_IN_PROGRESS, &gl->gl_flags)) {",
                        "\t\t/*",
                        "\t\t * The call to go_sync should have cleared out the ail list.",
                        "\t\t * If there are still items, we have a problem. We ought to",
                        "\t\t * withdraw, but we can't because the withdraw code also uses",
                        "\t\t * glocks. Warn about the error, dump the glock, then fall",
                        "\t\t * through and wait for logd to do the withdraw for us.",
                        "\t\t */",
                        "\t\tif ((atomic_read(&gl->gl_ail_count) != 0) &&",
                        "\t\t    (!cmpxchg(&sdp->sd_log_error, 0, -EIO))) {",
                        "\t\t\tgfs2_glock_assert_warn(gl,",
                        "\t\t\t\t\t       !atomic_read(&gl->gl_ail_count));",
                        "\t\t\tgfs2_dump_glock(NULL, gl, true);",
                        "\t\t}",
                        "\t\tglops->go_inval(gl, target == LM_ST_DEFERRED ? 0 : DIO_METADATA);",
                        "\t\tclear_bit(GLF_INVALIDATE_IN_PROGRESS, &gl->gl_flags);",
                        "\t}",
                        "",
                        "skip_inval:",
                        "\tgfs2_glock_hold(gl);",
                        "\t/*",
                        "\t * Check for an error encountered since we called go_sync and go_inval.",
                        "\t * If so, we can't withdraw from the glock code because the withdraw",
                        "\t * code itself uses glocks (see function signal_our_withdraw) to",
                        "\t * change the mount to read-only. Most importantly, we must not call",
                        "\t * dlm to unlock the glock until the journal is in a known good state",
                        "\t * (after journal replay) otherwise other nodes may use the object",
                        "\t * (rgrp or dinode) and then later, journal replay will corrupt the",
                        "\t * file system. The best we can do here is wait for the logd daemon",
                        "\t * to see sd_log_error and withdraw, and in the meantime, requeue the",
                        "\t * work for later.",
                        "\t *",
                        "\t * However, if we're just unlocking the lock (say, for unmount, when",
                        "\t * gfs2_gl_hash_clear calls clear_glock) and recovery is complete",
                        "\t * then it's okay to tell dlm to unlock it.",
                        "\t */",
                        "\tif (unlikely(sdp->sd_log_error && !gfs2_withdrawn(sdp)))",
                        "\t\tgfs2_withdraw_delayed(sdp);",
                        "\tif (glock_blocked_by_withdraw(gl)) {",
                        "\t\tif (target != LM_ST_UNLOCKED ||",
                        "\t\t    test_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags)) {",
                        "\t\t\tgfs2_glock_queue_work(gl, GL_GLOCK_DFT_HOLD);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (sdp->sd_lockstruct.ls_ops->lm_lock)\t{",
                        "\t\t/* lock_dlm */",
                        "\t\tret = sdp->sd_lockstruct.ls_ops->lm_lock(gl, target, lck_flags);",
                        "\t\tif (ret == -EINVAL && gl->gl_target == LM_ST_UNLOCKED &&",
                        "\t\t    target == LM_ST_UNLOCKED &&",
                        "\t\t    test_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags)) {",
                        "\t\t\tfinish_xmote(gl, target);",
                        "\t\t\tgfs2_glock_queue_work(gl, 0);",
                        "\t\t} else if (ret) {",
                        "\t\t\tfs_err(sdp, \"lm_lock ret %d\\n\", ret);",
                        "\t\t\tGLOCK_BUG_ON(gl, !gfs2_withdrawn(sdp));",
                        "\t\t}",
                        "\t} else { /* lock_nolock */",
                        "\t\tfinish_xmote(gl, target);",
                        "\t\tgfs2_glock_queue_work(gl, 0);",
                        "\t}",
                        "out:",
                        "\tspin_lock(&gl->gl_lockref.lock);",
                        "}"
                    ],
                    "start": 578,
                    "highlight": 686
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81372d2b"
        },
        "18800": {
            "name": "run_queue",
            "parent_idx": 18793,
            "source_line": [
                {
                    "file": "fs/gfs2/glock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=549738f15da0e5a00275977623be199fbbf7df50#n1410",
                    "code": [
                        "int gfs2_glock_nq(struct gfs2_holder *gh)",
                        "{",
                        "\tstruct gfs2_glock *gl = gh->gh_gl;",
                        "\tint error = 0;",
                        "",
                        "\tif (glock_blocked_by_withdraw(gl) && !(gh->gh_flags & LM_FLAG_NOEXP))",
                        "\t\treturn -EIO;",
                        "",
                        "\tif (test_bit(GLF_LRU, &gl->gl_flags))",
                        "\t\tgfs2_glock_remove_from_lru(gl);",
                        "",
                        "\tspin_lock(&gl->gl_lockref.lock);",
                        "\tadd_to_queue(gh);",
                        "\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&",
                        "\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {",
                        "\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);",
                        "\t\tgl->gl_lockref.count++;",
                        "\t\t__gfs2_glock_queue_work(gl, 0);",
                        "\t}",
                        "\trun_queue(gl, 1);",
                        "\tspin_unlock(&gl->gl_lockref.lock);",
                        "",
                        "\tif (!(gh->gh_flags & GL_ASYNC))",
                        "\t\terror = gfs2_glock_wait(gh);",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 1391,
                    "highlight": 1410
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81373604"
        },
        "18793": {
            "name": "gfs2_glock_nq",
            "parent_idx": 18783,
            "source_line": [
                {
                    "file": "fs/gfs2/glock.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.h?id=549738f15da0e5a00275977623be199fbbf7df50#n238",
                    "code": [
                        "static inline int gfs2_glock_nq_init(struct gfs2_glock *gl,",
                        "\t\t\t\t     unsigned int state, u16 flags,",
                        "\t\t\t\t     struct gfs2_holder *gh)",
                        "{",
                        "\tint error;",
                        "",
                        "\tgfs2_holder_init(gl, state, flags, gh);",
                        "",
                        "\terror = gfs2_glock_nq(gh);",
                        "\tif (error)",
                        "\t\tgfs2_holder_uninit(gh);",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 230,
                    "highlight": 238
                },
                {
                    "file": "fs/gfs2/inode.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/inode.c?id=549738f15da0e5a00275977623be199fbbf7df50#n317",
                    "code": [
                        "struct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,",
                        "\t\t\t   int is_root)",
                        "{",
                        "\tstruct super_block *sb = dir->i_sb;",
                        "\tstruct gfs2_inode *dip = GFS2_I(dir);",
                        "\tstruct gfs2_holder d_gh;",
                        "\tint error = 0;",
                        "\tstruct inode *inode = NULL;",
                        "",
                        "\tgfs2_holder_mark_uninitialized(&d_gh);",
                        "\tif (!name->len || name->len > GFS2_FNAMESIZE)",
                        "\t\treturn ERR_PTR(-ENAMETOOLONG);",
                        "",
                        "\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||",
                        "\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&",
                        "\t     dir == d_inode(sb->s_root))) {",
                        "\t\tigrab(dir);",
                        "\t\treturn dir;",
                        "\t}",
                        "",
                        "\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {",
                        "\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);",
                        "\t\tif (error)",
                        "\t\t\treturn ERR_PTR(error);",
                        "\t}",
                        "",
                        "\tif (!is_root) {",
                        "\t\terror = gfs2_permission(dir, MAY_EXEC);",
                        "\t\tif (error)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tinode = gfs2_dir_search(dir, name, false);",
                        "\tif (IS_ERR(inode))",
                        "\t\terror = PTR_ERR(inode);",
                        "out:",
                        "\tif (gfs2_holder_initialized(&d_gh))",
                        "\t\tgfs2_glock_dq_uninit(&d_gh);",
                        "\tif (error == -ENOENT)",
                        "\t\treturn NULL;",
                        "\treturn inode ? inode : ERR_PTR(error);",
                        "}"
                    ],
                    "start": 296,
                    "highlight": 317
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8138301b"
        },
        "18783": {
            "name": "gfs2_lookupi",
            "parent_idx": 18780,
            "source_line": [
                {
                    "file": "fs/gfs2/inode.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/inode.c?id=549738f15da0e5a00275977623be199fbbf7df50#n268",
                    "code": [
                        "struct inode *gfs2_lookup_simple(struct inode *dip, const char *name)",
                        "{",
                        "\tstruct qstr qstr;",
                        "\tstruct inode *inode;",
                        "\tgfs2_str2qstr(&qstr, name);",
                        "\tinode = gfs2_lookupi(dip, &qstr, 1);",
                        "\t/* gfs2_lookupi has inconsistent callers: vfs",
                        "\t * related routines expect NULL for no entry found,",
                        "\t * gfs2_lookup_simple callers expect ENOENT",
                        "\t * and do not check for NULL.",
                        "\t */",
                        "\tif (inode == NULL)",
                        "\t\treturn ERR_PTR(-ENOENT);",
                        "\telse",
                        "\t\treturn inode;",
                        "}"
                    ],
                    "start": 263,
                    "highlight": 268
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8138309e"
        },
        "18780": {
            "name": "gfs2_lookup_simple",
            "parent_idx": 18776,
            "source_line": [
                {
                    "file": "fs/gfs2/ops_fstype.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=549738f15da0e5a00275977623be199fbbf7df50#n620",
                    "code": [
                        "static int init_journal(struct gfs2_sbd *sdp, int undo)",
                        "{",
                        "\tstruct inode *master = d_inode(sdp->sd_master_dir);",
                        "\tstruct gfs2_holder ji_gh;",
                        "\tstruct gfs2_inode *ip;",
                        "\tint jindex = 1;",
                        "\tint error = 0;",
                        "",
                        "\tif (undo) {",
                        "\t\tjindex = 0;",
                        "\t\tgoto fail_jinode_gh;",
                        "\t}",
                        "",
                        "\tsdp->sd_jindex = gfs2_lookup_simple(master, \"jindex\");",
                        "\tif (IS_ERR(sdp->sd_jindex)) {",
                        "\t\tfs_err(sdp, \"can't lookup journal index: %d\\n\", error);",
                        "\t\treturn PTR_ERR(sdp->sd_jindex);",
                        "\t}",
                        "",
                        "\t/* Load in the journal index special file */",
                        "",
                        "\terror = gfs2_jindex_hold(sdp, &ji_gh);",
                        "\tif (error) {",
                        "\t\tfs_err(sdp, \"can't read journal index: %d\\n\", error);",
                        "\t\tgoto fail;",
                        "\t}",
                        "",
                        "\terror = -EUSERS;",
                        "\tif (!gfs2_jindex_size(sdp)) {",
                        "\t\tfs_err(sdp, \"no journals!\\n\");",
                        "\t\tgoto fail_jindex;",
                        "\t}",
                        "",
                        "\tatomic_set(&sdp->sd_log_blks_needed, 0);",
                        "\tif (sdp->sd_args.ar_spectator) {",
                        "\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, 0);",
                        "\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);",
                        "\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);",
                        "\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);",
                        "\t} else {",
                        "\t\tif (sdp->sd_lockstruct.ls_jid >= gfs2_jindex_size(sdp)) {",
                        "\t\t\tfs_err(sdp, \"can't mount journal #%u\\n\",",
                        "\t\t\t       sdp->sd_lockstruct.ls_jid);",
                        "\t\t\tfs_err(sdp, \"there are only %u journals (0 - %u)\\n\",",
                        "\t\t\t       gfs2_jindex_size(sdp),",
                        "\t\t\t       gfs2_jindex_size(sdp) - 1);",
                        "\t\t\tgoto fail_jindex;",
                        "\t\t}",
                        "\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, sdp->sd_lockstruct.ls_jid);",
                        "",
                        "\t\terror = gfs2_glock_nq_num(sdp, sdp->sd_lockstruct.ls_jid,",
                        "\t\t\t\t\t  &gfs2_journal_glops,",
                        "\t\t\t\t\t  LM_ST_EXCLUSIVE,",
                        "\t\t\t\t\t  LM_FLAG_NOEXP | GL_NOCACHE,",
                        "\t\t\t\t\t  &sdp->sd_journal_gh);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"can't acquire journal glock: %d\\n\", error);",
                        "\t\t\tgoto fail_jindex;",
                        "\t\t}",
                        "",
                        "\t\tip = GFS2_I(sdp->sd_jdesc->jd_inode);",
                        "\t\tsdp->sd_jinode_gl = ip->i_gl;",
                        "\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,",
                        "\t\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT | GL_NOCACHE,",
                        "\t\t\t\t\t   &sdp->sd_jinode_gh);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"can't acquire journal inode glock: %d\\n\",",
                        "\t\t\t       error);",
                        "\t\t\tgoto fail_journal_gh;",
                        "\t\t}",
                        "",
                        "\t\terror = gfs2_jdesc_check(sdp->sd_jdesc);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"my journal (%u) is bad: %d\\n\",",
                        "\t\t\t       sdp->sd_jdesc->jd_jid, error);",
                        "\t\t\tgoto fail_jinode_gh;",
                        "\t\t}",
                        "\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);",
                        "\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);",
                        "\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);",
                        "",
                        "\t\t/* Map the extents for this journal's blocks */",
                        "\t\tgfs2_map_journal_extents(sdp, sdp->sd_jdesc);",
                        "\t}",
                        "\ttrace_gfs2_log_blocks(sdp, atomic_read(&sdp->sd_log_blks_free));",
                        "",
                        "\tif (sdp->sd_lockstruct.ls_first) {",
                        "\t\tunsigned int x;",
                        "\t\tfor (x = 0; x < sdp->sd_journals; x++) {",
                        "\t\t\tstruct gfs2_jdesc *jd = gfs2_jdesc_find(sdp, x);",
                        "",
                        "\t\t\tif (sdp->sd_args.ar_spectator) {",
                        "\t\t\t\terror = check_journal_clean(sdp, jd, true);",
                        "\t\t\t\tif (error)",
                        "\t\t\t\t\tgoto fail_jinode_gh;",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "\t\t\terror = gfs2_recover_journal(jd, true);",
                        "\t\t\tif (error) {",
                        "\t\t\t\tfs_err(sdp, \"error recovering journal %u: %d\\n\",",
                        "\t\t\t\t       x, error);",
                        "\t\t\t\tgoto fail_jinode_gh;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tgfs2_others_may_mount(sdp);",
                        "\t} else if (!sdp->sd_args.ar_spectator) {",
                        "\t\terror = gfs2_recover_journal(sdp->sd_jdesc, true);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"error recovering my journal: %d\\n\", error);",
                        "\t\t\tgoto fail_jinode_gh;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tsdp->sd_log_idle = 1;",
                        "\tset_bit(SDF_JOURNAL_CHECKED, &sdp->sd_flags);",
                        "\tgfs2_glock_dq_uninit(&ji_gh);",
                        "\tjindex = 0;",
                        "\tINIT_WORK(&sdp->sd_freeze_work, gfs2_freeze_func);",
                        "\treturn 0;",
                        "",
                        "fail_jinode_gh:",
                        "\t/* A withdraw may have done dq/uninit so now we need to check it */",
                        "\tif (!sdp->sd_args.ar_spectator &&",
                        "\t    gfs2_holder_initialized(&sdp->sd_jinode_gh))",
                        "\t\tgfs2_glock_dq_uninit(&sdp->sd_jinode_gh);",
                        "fail_journal_gh:",
                        "\tif (!sdp->sd_args.ar_spectator &&",
                        "\t    gfs2_holder_initialized(&sdp->sd_journal_gh))",
                        "\t\tgfs2_glock_dq_uninit(&sdp->sd_journal_gh);",
                        "fail_jindex:",
                        "\tgfs2_jindex_free(sdp);",
                        "\tif (jindex)",
                        "\t\tgfs2_glock_dq_uninit(&ji_gh);",
                        "fail:",
                        "\tiput(sdp->sd_jindex);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 607,
                    "highlight": 620
                },
                {
                    "file": "fs/gfs2/ops_fstype.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=549738f15da0e5a00275977623be199fbbf7df50#n756",
                    "code": [
                        "static int init_inodes(struct gfs2_sbd *sdp, int undo)",
                        "{",
                        "\tint error = 0;",
                        "\tstruct inode *master = d_inode(sdp->sd_master_dir);",
                        "",
                        "\tif (undo)",
                        "\t\tgoto fail_qinode;",
                        "",
                        "\terror = init_journal(sdp, undo);",
                        "\tcomplete_all(&sdp->sd_journal_ready);",
                        "\tif (error)",
                        "\t\tgoto fail;",
                        "",
                        "\t/* Read in the master statfs inode */",
                        "\tsdp->sd_statfs_inode = gfs2_lookup_simple(master, \"statfs\");",
                        "\tif (IS_ERR(sdp->sd_statfs_inode)) {",
                        "\t\terror = PTR_ERR(sdp->sd_statfs_inode);",
                        "\t\tfs_err(sdp, \"can't read in statfs inode: %d\\n\", error);",
                        "\t\tgoto fail_journal;",
                        "\t}",
                        "",
                        "\t/* Read in the resource index inode */",
                        "\tsdp->sd_rindex = gfs2_lookup_simple(master, \"rindex\");",
                        "\tif (IS_ERR(sdp->sd_rindex)) {",
                        "\t\terror = PTR_ERR(sdp->sd_rindex);",
                        "\t\tfs_err(sdp, \"can't get resource index inode: %d\\n\", error);",
                        "\t\tgoto fail_statfs;",
                        "\t}",
                        "\tsdp->sd_rindex_uptodate = 0;",
                        "",
                        "\t/* Read in the quota inode */",
                        "\tsdp->sd_quota_inode = gfs2_lookup_simple(master, \"quota\");",
                        "\tif (IS_ERR(sdp->sd_quota_inode)) {",
                        "\t\terror = PTR_ERR(sdp->sd_quota_inode);",
                        "\t\tfs_err(sdp, \"can't get quota file inode: %d\\n\", error);",
                        "\t\tgoto fail_rindex;",
                        "\t}",
                        "\t/*",
                        "\t * i_rwsem on quota files is special. Since this inode is hidden system",
                        "\t * file, we are safe to define locking ourselves.",
                        "\t */",
                        "\tlockdep_set_class(&sdp->sd_quota_inode->i_rwsem,",
                        "\t\t\t  &gfs2_quota_imutex_key);",
                        "",
                        "\terror = gfs2_rindex_update(sdp);",
                        "\tif (error)",
                        "\t\tgoto fail_qinode;",
                        "",
                        "\treturn 0;",
                        "",
                        "fail_qinode:",
                        "\tiput(sdp->sd_quota_inode);",
                        "fail_rindex:",
                        "\tgfs2_clear_rgrpd(sdp);",
                        "\tiput(sdp->sd_rindex);",
                        "fail_statfs:",
                        "\tiput(sdp->sd_statfs_inode);",
                        "fail_journal:",
                        "\tinit_journal(sdp, UNDO);",
                        "fail:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 748,
                    "highlight": 756
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8137ec39"
        },
        "18776": {
            "name": "init_inodes",
            "parent_idx": 18232,
            "source_line": [
                {
                    "file": "fs/gfs2/ops_fstype.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=549738f15da0e5a00275977623be199fbbf7df50#n1125",
                    "code": [
                        "/**",
                        " * gfs2_fill_super - Read in superblock",
                        " * @sb: The VFS superblock",
                        " * @args: Mount options",
                        " * @silent: Don't complain if it's not a GFS2 filesystem",
                        " *",
                        " * Returns: -errno",
                        " */",
                        "static int gfs2_fill_super(struct super_block *sb, struct fs_context *fc)",
                        "{",
                        "\tstruct gfs2_args *args = fc->fs_private;",
                        "\tint silent = fc->sb_flags & SB_SILENT;",
                        "\tstruct gfs2_sbd *sdp;",
                        "\tstruct gfs2_holder mount_gh;",
                        "\tint error;",
                        "",
                        "\tsdp = init_sbd(sb);",
                        "\tif (!sdp) {",
                        "\t\tpr_warn(\"can't alloc struct gfs2_sbd\\n\");",
                        "\t\treturn -ENOMEM;",
                        "\t}",
                        "\tsdp->sd_args = *args;",
                        "",
                        "\tif (sdp->sd_args.ar_spectator) {",
                        "                sb->s_flags |= SB_RDONLY;",
                        "\t\tset_bit(SDF_RORECOVERY, &sdp->sd_flags);",
                        "\t}",
                        "\tif (sdp->sd_args.ar_posix_acl)",
                        "\t\tsb->s_flags |= SB_POSIXACL;",
                        "\tif (sdp->sd_args.ar_nobarrier)",
                        "\t\tset_bit(SDF_NOBARRIERS, &sdp->sd_flags);",
                        "",
                        "\tsb->s_flags |= SB_NOSEC;",
                        "\tsb->s_magic = GFS2_MAGIC;",
                        "\tsb->s_op = &gfs2_super_ops;",
                        "\tsb->s_d_op = &gfs2_dops;",
                        "\tsb->s_export_op = &gfs2_export_ops;",
                        "\tsb->s_xattr = gfs2_xattr_handlers;",
                        "\tsb->s_qcop = &gfs2_quotactl_ops;",
                        "\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;",
                        "\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;",
                        "\tsb->s_time_gran = 1;",
                        "\tsb->s_maxbytes = MAX_LFS_FILESIZE;",
                        "",
                        "\t/* Set up the buffer cache and fill in some fake block size values",
                        "\t   to allow us to read-in the on-disk superblock. */",
                        "\tsdp->sd_sb.sb_bsize = sb_min_blocksize(sb, GFS2_BASIC_BLOCK);",
                        "\tsdp->sd_sb.sb_bsize_shift = sb->s_blocksize_bits;",
                        "\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -",
                        "                               GFS2_BASIC_BLOCK_SHIFT;",
                        "\tsdp->sd_fsb2bb = BIT(sdp->sd_fsb2bb_shift);",
                        "",
                        "\tsdp->sd_tune.gt_logd_secs = sdp->sd_args.ar_commit;",
                        "\tsdp->sd_tune.gt_quota_quantum = sdp->sd_args.ar_quota_quantum;",
                        "\tif (sdp->sd_args.ar_statfs_quantum) {",
                        "\t\tsdp->sd_tune.gt_statfs_slow = 0;",
                        "\t\tsdp->sd_tune.gt_statfs_quantum = sdp->sd_args.ar_statfs_quantum;",
                        "\t} else {",
                        "\t\tsdp->sd_tune.gt_statfs_slow = 1;",
                        "\t\tsdp->sd_tune.gt_statfs_quantum = 30;",
                        "\t}",
                        "",
                        "\terror = init_names(sdp, silent);",
                        "\tif (error) {",
                        "\t\t/* In this case, we haven't initialized sysfs, so we have to",
                        "\t\t   manually free the sdp. */",
                        "\t\tfree_sbd(sdp);",
                        "\t\tsb->s_fs_info = NULL;",
                        "\t\treturn error;",
                        "\t}",
                        "",
                        "\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s\", sdp->sd_table_name);",
                        "",
                        "\terror = gfs2_sys_fs_add(sdp);",
                        "\t/*",
                        "\t * If we hit an error here, gfs2_sys_fs_add will have called function",
                        "\t * kobject_put which causes the sysfs usage count to go to zero, which",
                        "\t * causes sysfs to call function gfs2_sbd_release, which frees sdp.",
                        "\t * Subsequent error paths here will call gfs2_sys_fs_del, which also",
                        "\t * kobject_put to free sdp.",
                        "\t */",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "\tgfs2_create_debugfs_file(sdp);",
                        "",
                        "\terror = gfs2_lm_mount(sdp, silent);",
                        "\tif (error)",
                        "\t\tgoto fail_debug;",
                        "",
                        "\terror = init_locking(sdp, &mount_gh, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_lm;",
                        "",
                        "\terror = init_sb(sdp, silent);",
                        "\tif (error)",
                        "\t\tgoto fail_locking;",
                        "",
                        "\terror = wait_on_journal(sdp);",
                        "\tif (error)",
                        "\t\tgoto fail_sb;",
                        "",
                        "\t/*",
                        "\t * If user space has failed to join the cluster or some similar",
                        "\t * failure has occurred, then the journal id will contain a",
                        "\t * negative (error) number. This will then be returned to the",
                        "\t * caller (of the mount syscall). We do this even for spectator",
                        "\t * mounts (which just write a jid of 0 to indicate \"ok\" even though",
                        "\t * the jid is unused in the spectator case)",
                        "\t */",
                        "\tif (sdp->sd_lockstruct.ls_jid < 0) {",
                        "\t\terror = sdp->sd_lockstruct.ls_jid;",
                        "\t\tsdp->sd_lockstruct.ls_jid = 0;",
                        "\t\tgoto fail_sb;",
                        "\t}",
                        "",
                        "\tif (sdp->sd_args.ar_spectator)",
                        "\t\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s.s\",",
                        "\t\t\t sdp->sd_table_name);",
                        "\telse",
                        "\t\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s.%u\",",
                        "\t\t\t sdp->sd_table_name, sdp->sd_lockstruct.ls_jid);",
                        "",
                        "\terror = init_inodes(sdp, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_sb;",
                        "",
                        "\terror = init_per_node(sdp, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_inodes;",
                        "",
                        "\terror = gfs2_statfs_init(sdp);",
                        "\tif (error) {",
                        "\t\tfs_err(sdp, \"can't initialize statfs subsystem: %d\\n\", error);",
                        "\t\tgoto fail_per_node;",
                        "\t}",
                        "",
                        "\tif (sb_rdonly(sb)) {",
                        "\t\tstruct gfs2_holder freeze_gh;",
                        "",
                        "\t\terror = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED,",
                        "\t\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT,",
                        "\t\t\t\t\t   &freeze_gh);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"can't make FS RO: %d\\n\", error);",
                        "\t\t\tgoto fail_per_node;",
                        "\t\t}",
                        "\t\tgfs2_glock_dq_uninit(&freeze_gh);",
                        "\t} else {",
                        "\t\terror = gfs2_make_fs_rw(sdp);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"can't make FS RW: %d\\n\", error);",
                        "\t\t\tgoto fail_per_node;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tgfs2_glock_dq_uninit(&mount_gh);",
                        "\tgfs2_online_uevent(sdp);",
                        "\treturn 0;",
                        "",
                        "fail_per_node:",
                        "\tinit_per_node(sdp, UNDO);",
                        "fail_inodes:",
                        "\tinit_inodes(sdp, UNDO);",
                        "fail_sb:",
                        "\tif (sdp->sd_root_dir)",
                        "\t\tdput(sdp->sd_root_dir);",
                        "\tif (sdp->sd_master_dir)",
                        "\t\tdput(sdp->sd_master_dir);",
                        "\tif (sb->s_root)",
                        "\t\tdput(sb->s_root);",
                        "\tsb->s_root = NULL;",
                        "fail_locking:",
                        "\tinit_locking(sdp, &mount_gh, UNDO);",
                        "fail_lm:",
                        "\tcomplete_all(&sdp->sd_journal_ready);",
                        "\tgfs2_gl_hash_clear(sdp);",
                        "\tgfs2_lm_unmount(sdp);",
                        "fail_debug:",
                        "\tgfs2_delete_debugfs_file(sdp);",
                        "\t/* gfs2_sys_fs_del must be the last thing we do, since it causes",
                        "\t * sysfs to call function gfs2_sbd_release, which frees sdp. */",
                        "\tgfs2_sys_fs_del(sdp);",
                        "\tsb->s_fs_info = NULL;",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 1002,
                    "highlight": 1125
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8137ff18"
        },
        "18232": {
            "name": "gfs2_fill_super(indirect)",
            "parent_idx": 18178,
            "source_line": [
                {
                    "file": "fs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/super.c?id=549738f15da0e5a00275977623be199fbbf7df50#n1342",
                    "code": [
                        "/**",
                        " * get_tree_bdev - Get a superblock based on a single block device",
                        " * @fc: The filesystem context holding the parameters",
                        " * @fill_super: Helper to initialise a new superblock",
                        " */",
                        "int get_tree_bdev(struct fs_context *fc,",
                        "\t\tint (*fill_super)(struct super_block *,",
                        "\t\t\t\t  struct fs_context *))",
                        "{",
                        "\tstruct block_device *bdev;",
                        "\tstruct super_block *s;",
                        "\tfmode_t mode = FMODE_READ | FMODE_EXCL;",
                        "\tint error = 0;",
                        "",
                        "\tif (!(fc->sb_flags & SB_RDONLY))",
                        "\t\tmode |= FMODE_WRITE;",
                        "",
                        "\tif (!fc->source)",
                        "\t\treturn invalf(fc, \"No source specified\");",
                        "",
                        "\tbdev = blkdev_get_by_path(fc->source, mode, fc->fs_type);",
                        "\tif (IS_ERR(bdev)) {",
                        "\t\terrorf(fc, \"%s: Can't open blockdev\", fc->source);",
                        "\t\treturn PTR_ERR(bdev);",
                        "\t}",
                        "",
                        "\t/* Once the superblock is inserted into the list by sget_fc(), s_umount",
                        "\t * will protect the lockfs code from trying to start a snapshot while",
                        "\t * we are mounting",
                        "\t */",
                        "\tmutex_lock(&bdev->bd_fsfreeze_mutex);",
                        "\tif (bdev->bd_fsfreeze_count > 0) {",
                        "\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);",
                        "\t\twarnf(fc, \"%pg: Can't mount, blockdev is frozen\", bdev);",
                        "\t\tblkdev_put(bdev, mode);",
                        "\t\treturn -EBUSY;",
                        "\t}",
                        "",
                        "\tfc->sb_flags |= SB_NOSEC;",
                        "\tfc->sget_key = bdev;",
                        "\ts = sget_fc(fc, test_bdev_super_fc, set_bdev_super_fc);",
                        "\tmutex_unlock(&bdev->bd_fsfreeze_mutex);",
                        "\tif (IS_ERR(s)) {",
                        "\t\tblkdev_put(bdev, mode);",
                        "\t\treturn PTR_ERR(s);",
                        "\t}",
                        "",
                        "\tif (s->s_root) {",
                        "\t\t/* Don't summarily change the RO/RW state. */",
                        "\t\tif ((fc->sb_flags ^ s->s_flags) & SB_RDONLY) {",
                        "\t\t\twarnf(fc, \"%pg: Can't mount, would change RO state\", bdev);",
                        "\t\t\tdeactivate_locked_super(s);",
                        "\t\t\tblkdev_put(bdev, mode);",
                        "\t\t\treturn -EBUSY;",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * s_umount nests inside bd_mutex during",
                        "\t\t * __invalidate_device().  blkdev_put() acquires",
                        "\t\t * bd_mutex and can't be called under s_umount.  Drop",
                        "\t\t * s_umount temporarily.  This is safe as we're",
                        "\t\t * holding an active reference.",
                        "\t\t */",
                        "\t\tup_write(&s->s_umount);",
                        "\t\tblkdev_put(bdev, mode);",
                        "\t\tdown_write(&s->s_umount);",
                        "\t} else {",
                        "\t\ts->s_mode = mode;",
                        "\t\tsnprintf(s->s_id, sizeof(s->s_id), \"%pg\", bdev);",
                        "\t\tsb_set_blocksize(s, block_size(bdev));",
                        "\t\terror = fill_super(s, fc);",
                        "\t\tif (error) {",
                        "\t\t\tdeactivate_locked_super(s);",
                        "\t\t\treturn error;",
                        "\t\t}",
                        "",
                        "\t\ts->s_flags |= SB_ACTIVE;",
                        "\t\tbdev->bd_super = s;",
                        "\t}",
                        "",
                        "\tBUG_ON(fc->root);",
                        "\tfc->root = dget(s->s_root);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1272,
                    "highlight": 1342
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811ec691"
        },
        "18178": {
            "name": "get_tree_bdev",
            "parent_idx": 18177,
            "source_line": [
                {
                    "file": "fs/gfs2/ops_fstype.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=549738f15da0e5a00275977623be199fbbf7df50#n1201",
                    "code": [
                        "/**",
                        " * gfs2_get_tree - Get the GFS2 superblock and root directory",
                        " * @fc: The filesystem context",
                        " *",
                        " * Returns: 0 or -errno on error",
                        " */",
                        "static int gfs2_get_tree(struct fs_context *fc)",
                        "{",
                        "\tstruct gfs2_args *args = fc->fs_private;",
                        "\tstruct gfs2_sbd *sdp;",
                        "\tint error;",
                        "",
                        "\terror = get_tree_bdev(fc, gfs2_fill_super);",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "\tsdp = fc->root->d_sb->s_fs_info;",
                        "\tdput(fc->root);",
                        "\tif (args->ar_meta)",
                        "\t\tfc->root = dget(sdp->sd_master_dir);",
                        "\telse",
                        "\t\tfc->root = dget(sdp->sd_root_dir);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1189,
                    "highlight": 1201
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8137dd14"
        },
        "18177": {
            "name": "gfs2_get_tree(indirect)",
            "parent_idx": 18176,
            "source_line": [
                {
                    "file": "fs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/super.c?id=549738f15da0e5a00275977623be199fbbf7df50#n1547",
                    "code": [
                        "/**",
                        " * vfs_get_tree - Get the mountable root",
                        " * @fc: The superblock configuration context.",
                        " *",
                        " * The filesystem is invoked to get or create a superblock which can then later",
                        " * be used for mounting.  The filesystem places a pointer to the root to be",
                        " * used for mounting in @fc->root.",
                        " */",
                        "int vfs_get_tree(struct fs_context *fc)",
                        "{",
                        "\tstruct super_block *sb;",
                        "\tint error;",
                        "",
                        "\tif (fc->root)",
                        "\t\treturn -EBUSY;",
                        "",
                        "\t/* Get the mountable root in fc->root, with a ref on the root and a ref",
                        "\t * on the superblock.",
                        "\t */",
                        "\terror = fc->ops->get_tree(fc);",
                        "\tif (error < 0)",
                        "\t\treturn error;",
                        "",
                        "\tif (!fc->root) {",
                        "\t\tpr_err(\"Filesystem %s get_tree() didn't set fc->root\\n\",",
                        "\t\t       fc->fs_type->name);",
                        "\t\t/* We don't know what the locking state of the superblock is -",
                        "\t\t * if there is a superblock.",
                        "\t\t */",
                        "\t\tBUG();",
                        "\t}",
                        "",
                        "\tsb = fc->root->d_sb;",
                        "\tWARN_ON(!sb->s_bdi);",
                        "",
                        "\t/*",
                        "\t * Write barrier is for super_cache_count(). We place it before setting",
                        "\t * SB_BORN as the data dependency between the two functions is the",
                        "\t * superblock structure contents that we just set up, not the SB_BORN",
                        "\t * flag.",
                        "\t */",
                        "\tsmp_wmb();",
                        "\tsb->s_flags |= SB_BORN;",
                        "",
                        "\terror = security_sb_set_mnt_opts(sb, fc->security, 0, NULL);",
                        "\tif (unlikely(error)) {",
                        "\t\tfc_drop_locked(fc);",
                        "\t\treturn error;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * filesystems should never set s_maxbytes larger than MAX_LFS_FILESIZE",
                        "\t * but s_maxbytes was an unsigned long long for many releases. Throw",
                        "\t * this warning for a little while to try and catch filesystems that",
                        "\t * violate this rule.",
                        "\t */",
                        "\tWARN((sb->s_maxbytes < 0), \"%s set sb->s_maxbytes to \"",
                        "\t\t\"negative value (%lld)\\n\", fc->fs_type->name, sb->s_maxbytes);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1528,
                    "highlight": 1547
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811eb18b"
        },
        "18176": {
            "name": "vfs_get_tree",
            "parent_idx": 18175,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=549738f15da0e5a00275977623be199fbbf7df50#n2875",
                    "code": [
                        "/*",
                        " * create a new mount for userspace and request it to be added into the",
                        " * namespace's tree",
                        " */",
                        "static int do_new_mount(struct path *path, const char *fstype, int sb_flags,",
                        "\t\t\tint mnt_flags, const char *name, void *data)",
                        "{",
                        "\tstruct file_system_type *type;",
                        "\tstruct fs_context *fc;",
                        "\tconst char *subtype = NULL;",
                        "\tint err = 0;",
                        "",
                        "\tif (!fstype)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\ttype = get_fs_type(fstype);",
                        "\tif (!type)",
                        "\t\treturn -ENODEV;",
                        "",
                        "\tif (type->fs_flags & FS_HAS_SUBTYPE) {",
                        "\t\tsubtype = strchr(fstype, '.');",
                        "\t\tif (subtype) {",
                        "\t\t\tsubtype++;",
                        "\t\t\tif (!*subtype) {",
                        "\t\t\t\tput_filesystem(type);",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tfc = fs_context_for_mount(type, sb_flags);",
                        "\tput_filesystem(type);",
                        "\tif (IS_ERR(fc))",
                        "\t\treturn PTR_ERR(fc);",
                        "",
                        "\tif (subtype)",
                        "\t\terr = vfs_parse_fs_string(fc, \"subtype\",",
                        "\t\t\t\t\t  subtype, strlen(subtype));",
                        "\tif (!err && name)",
                        "\t\terr = vfs_parse_fs_string(fc, \"source\", name, strlen(name));",
                        "\tif (!err)",
                        "\t\terr = parse_monolithic_mount_data(fc, data);",
                        "\tif (!err && !mount_capable(fc))",
                        "\t\terr = -EPERM;",
                        "\tif (!err)",
                        "\t\terr = vfs_get_tree(fc);",
                        "\tif (!err)",
                        "\t\terr = do_new_mount_fc(fc, path, mnt_flags);",
                        "",
                        "\tput_fs_context(fc);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2830,
                    "highlight": 2875
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=549738f15da0e5a00275977623be199fbbf7df50#n3192",
                    "code": [
                        "/*",
                        " * Flags is a 32-bit value that allows up to 31 non-fs dependent flags to",
                        " * be given to the mount() call (ie: read-only, no-dev, no-suid etc).",
                        " *",
                        " * data is a (void *) that can point to any structure up to",
                        " * PAGE_SIZE-1 bytes, which can contain arbitrary fs-dependent",
                        " * information (or be NULL).",
                        " *",
                        " * Pre-0.97 versions of mount() didn't have a flags word.",
                        " * When the flags word was introduced its top half was required",
                        " * to have the magic value 0xC0ED, and this remained so until 2.4.0-test9.",
                        " * Therefore, if this magic number is present, it carries no information",
                        " * and must be discarded.",
                        " */",
                        "int path_mount(const char *dev_name, struct path *path,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tunsigned int mnt_flags = 0, sb_flags;",
                        "\tint ret;",
                        "",
                        "\t/* Discard magic */",
                        "\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)",
                        "\t\tflags &= ~MS_MGC_MSK;",
                        "",
                        "\t/* Basic sanity checks */",
                        "\tif (data_page)",
                        "\t\t((char *)data_page)[PAGE_SIZE - 1] = 0;",
                        "",
                        "\tif (flags & MS_NOUSER)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tret = security_sb_mount(dev_name, path, type_page, flags, data_page);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tif (!may_mount())",
                        "\t\treturn -EPERM;",
                        "\tif ((flags & SB_MANDLOCK) && !may_mandlock())",
                        "\t\treturn -EPERM;",
                        "",
                        "\t/* Default to relatime unless overriden */",
                        "\tif (!(flags & MS_NOATIME))",
                        "\t\tmnt_flags |= MNT_RELATIME;",
                        "",
                        "\t/* Separate the per-mountpoint flags */",
                        "\tif (flags & MS_NOSUID)",
                        "\t\tmnt_flags |= MNT_NOSUID;",
                        "\tif (flags & MS_NODEV)",
                        "\t\tmnt_flags |= MNT_NODEV;",
                        "\tif (flags & MS_NOEXEC)",
                        "\t\tmnt_flags |= MNT_NOEXEC;",
                        "\tif (flags & MS_NOATIME)",
                        "\t\tmnt_flags |= MNT_NOATIME;",
                        "\tif (flags & MS_NODIRATIME)",
                        "\t\tmnt_flags |= MNT_NODIRATIME;",
                        "\tif (flags & MS_STRICTATIME)",
                        "\t\tmnt_flags &= ~(MNT_RELATIME | MNT_NOATIME);",
                        "\tif (flags & MS_RDONLY)",
                        "\t\tmnt_flags |= MNT_READONLY;",
                        "",
                        "\t/* The default atime for remount is preservation */",
                        "\tif ((flags & MS_REMOUNT) &&",
                        "\t    ((flags & (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |",
                        "\t\t       MS_STRICTATIME)) == 0)) {",
                        "\t\tmnt_flags &= ~MNT_ATIME_MASK;",
                        "\t\tmnt_flags |= path->mnt->mnt_flags & MNT_ATIME_MASK;",
                        "\t}",
                        "",
                        "\tsb_flags = flags & (SB_RDONLY |",
                        "\t\t\t    SB_SYNCHRONOUS |",
                        "\t\t\t    SB_MANDLOCK |",
                        "\t\t\t    SB_DIRSYNC |",
                        "\t\t\t    SB_SILENT |",
                        "\t\t\t    SB_POSIXACL |",
                        "\t\t\t    SB_LAZYTIME |",
                        "\t\t\t    SB_I_VERSION);",
                        "",
                        "\tif ((flags & (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND))",
                        "\t\treturn do_reconfigure_mnt(path, mnt_flags);",
                        "\tif (flags & MS_REMOUNT)",
                        "\t\treturn do_remount(path, flags, sb_flags, mnt_flags, data_page);",
                        "\tif (flags & MS_BIND)",
                        "\t\treturn do_loopback(path, dev_name, flags & MS_REC);",
                        "\tif (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))",
                        "\t\treturn do_change_type(path, flags);",
                        "\tif (flags & MS_MOVE)",
                        "\t\treturn do_move_mount_old(path, dev_name);",
                        "",
                        "\treturn do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,",
                        "\t\t\t    data_page);",
                        "}"
                    ],
                    "start": 3105,
                    "highlight": 3192
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812106bf"
        },
        "18175": {
            "name": "path_mount",
            "parent_idx": 18156,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=549738f15da0e5a00275977623be199fbbf7df50#n3205",
                    "code": [
                        "long do_mount(const char *dev_name, const char __user *dir_name,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tstruct path path;",
                        "\tint ret;",
                        "",
                        "\tret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &path);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tret = path_mount(dev_name, &path, type_page, flags, data_page);",
                        "\tpath_put(&path);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3196,
                    "highlight": 3205
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=549738f15da0e5a00275977623be199fbbf7df50#n3413",
                    "code": [
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3390,
                    "highlight": 3413
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=549738f15da0e5a00275977623be199fbbf7df50#n3390",
                    "code": [
                        "struct dentry *mount_subtree(struct vfsmount *m, const char *name)",
                        "{",
                        "\tstruct mount *mnt = real_mount(m);",
                        "\tstruct mnt_namespace *ns;",
                        "\tstruct super_block *s;",
                        "\tstruct path path;",
                        "\tint err;",
                        "",
                        "\tns = alloc_mnt_ns(&init_user_ns, true);",
                        "\tif (IS_ERR(ns)) {",
                        "\t\tmntput(m);",
                        "\t\treturn ERR_CAST(ns);",
                        "\t}",
                        "\tmnt->mnt_ns = ns;",
                        "\tns->root = mnt;",
                        "\tns->mounts++;",
                        "\tlist_add(&mnt->mnt_list, &ns->list);",
                        "",
                        "\terr = vfs_path_lookup(m->mnt_root, m,",
                        "\t\t\tname, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);",
                        "",
                        "\tput_mnt_ns(ns);",
                        "",
                        "\tif (err)",
                        "\t\treturn ERR_PTR(err);",
                        "",
                        "\t/* trade a vfsmount reference for active sb one */",
                        "\ts = path.mnt->mnt_sb;",
                        "\tatomic_inc(&s->s_active);",
                        "\tmntput(path.mnt);",
                        "\t/* lock the sucker */",
                        "\tdown_write(&s->s_umount);",
                        "\t/* ... and return the root of (sub)tree on it */",
                        "\treturn path.dentry;",
                        "}",
                        "EXPORT_SYMBOL(mount_subtree);",
                        "",
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3353,
                    "highlight": 3390
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81210f29"
        },
        "18156": {
            "name": "__x64_sys_mount(indirect)",
            "parent_idx": 18155,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=549738f15da0e5a00275977623be199fbbf7df50#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b7e5ee"
        },
        "18155": {
            "name": "do_syscall_64",
            "parent_idx": 18154,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=549738f15da0e5a00275977623be199fbbf7df50#n118",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 118
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "18154": {
            "name": "3183_syscall_2340",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "18873": {
            "name": "+0x34",
            "parent_idx": 18865,
            "source_line": [
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n97",
                    "code": [
                        "static void signal_our_withdraw(struct gfs2_sbd *sdp)",
                        "{",
                        "\tstruct gfs2_glock *gl = sdp->sd_live_gh.gh_gl;",
                        "\tstruct inode *inode = sdp->sd_jdesc->jd_inode;",
                        "\tstruct gfs2_inode *ip = GFS2_I(inode);",
                        "\tu64 no_formal_ino = ip->i_no_formal_ino;",
                        "\tint ret = 0;",
                        "\tint tries;",
                        "",
                        "\tif (test_bit(SDF_NORECOVERY, &sdp->sd_flags))",
                        "\t\treturn;",
                        "",
                        "\t/* Prevent any glock dq until withdraw recovery is complete */",
                        "\tset_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags);",
                        "\t/*",
                        "\t * Don't tell dlm we're bailing until we have no more buffers in the",
                        "\t * wind. If journal had an IO error, the log code should just purge",
                        "\t * the outstanding buffers rather than submitting new IO. Making the",
                        "\t * file system read-only will flush the journal, etc.",
                        "\t *",
                        "\t * During a normal unmount, gfs2_make_fs_ro calls gfs2_log_shutdown",
                        "\t * which clears SDF_JOURNAL_LIVE. In a withdraw, we must not write",
                        "\t * any UNMOUNT log header, so we can't call gfs2_log_shutdown, and",
                        "\t * therefore we need to clear SDF_JOURNAL_LIVE manually.",
                        "\t */",
                        "\tclear_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags);",
                        "\tif (!sb_rdonly(sdp->sd_vfs))",
                        "\t\tret = gfs2_make_fs_ro(sdp);",
                        "",
                        "\tif (sdp->sd_lockstruct.ls_ops->lm_lock == NULL) { /* lock_nolock */",
                        "\t\tif (!ret)",
                        "\t\t\tret = -EIO;",
                        "\t\tclear_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags);",
                        "\t\tgoto skip_recovery;",
                        "\t}",
                        "\t/*",
                        "\t * Drop the glock for our journal so another node can recover it.",
                        "\t */",
                        "\tif (gfs2_holder_initialized(&sdp->sd_journal_gh)) {",
                        "\t\tgfs2_glock_dq_wait(&sdp->sd_journal_gh);",
                        "\t\tgfs2_holder_uninit(&sdp->sd_journal_gh);",
                        "\t}",
                        "\tsdp->sd_jinode_gh.gh_flags |= GL_NOCACHE;",
                        "\tgfs2_glock_dq(&sdp->sd_jinode_gh);",
                        "\tif (test_bit(SDF_FS_FROZEN, &sdp->sd_flags)) {",
                        "\t\t/* Make sure gfs2_unfreeze works if partially-frozen */",
                        "\t\tflush_workqueue(gfs2_freeze_wq);",
                        "\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);",
                        "\t\tthaw_super(sdp->sd_vfs);",
                        "\t} else {",
                        "\t\twait_on_bit(&gl->gl_flags, GLF_DEMOTE, TASK_UNINTERRUPTIBLE);",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * holder_uninit to force glock_put, to force dlm to let go",
                        "\t */",
                        "\tgfs2_holder_uninit(&sdp->sd_jinode_gh);",
                        "",
                        "\t/*",
                        "\t * Note: We need to be careful here:",
                        "\t * Our iput of jd_inode will evict it. The evict will dequeue its",
                        "\t * glock, but the glock dq will wait for the withdraw unless we have",
                        "\t * exception code in glock_dq.",
                        "\t */",
                        "\tiput(inode);",
                        "\t/*",
                        "\t * Wait until the journal inode's glock is freed. This allows try locks",
                        "\t * on other nodes to be successful, otherwise we remain the owner of",
                        "\t * the glock as far as dlm is concerned.",
                        "\t */",
                        "\tif (gl->gl_ops->go_free) {",
                        "\t\tset_bit(GLF_FREEING, &gl->gl_flags);",
                        "\t\twait_on_bit(&gl->gl_flags, GLF_FREEING, TASK_UNINTERRUPTIBLE);",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Dequeue the \"live\" glock, but keep a reference so it's never freed.",
                        "\t */",
                        "\tgfs2_glock_hold(gl);",
                        "\tgfs2_glock_dq_wait(&sdp->sd_live_gh);",
                        "\t/*",
                        "\t * We enqueue the \"live\" glock in EX so that all other nodes",
                        "\t * get a demote request and act on it. We don't really want the",
                        "\t * lock in EX, so we send a \"try\" lock with 1CB to produce a callback.",
                        "\t */",
                        "\tfs_warn(sdp, \"Requesting recovery of jid %d.\\n\",",
                        "\t\tsdp->sd_lockstruct.ls_jid);",
                        "\tgfs2_holder_reinit(LM_ST_EXCLUSIVE, LM_FLAG_TRY_1CB | LM_FLAG_NOEXP,",
                        "\t\t\t   &sdp->sd_live_gh);",
                        "\tmsleep(GL_GLOCK_MAX_HOLD);",
                        "\t/*",
                        "\t * This will likely fail in a cluster, but succeed standalone:",
                        "\t */",
                        "\tret = gfs2_glock_nq(&sdp->sd_live_gh);",
                        "",
                        "\t/*",
                        "\t * If we actually got the \"live\" lock in EX mode, there are no other",
                        "\t * nodes available to replay our journal. So we try to replay it",
                        "\t * ourselves. We hold the \"live\" glock to prevent other mounters",
                        "\t * during recovery, then just dequeue it and reacquire it in our",
                        "\t * normal SH mode. Just in case the problem that caused us to",
                        "\t * withdraw prevents us from recovering our journal (e.g. io errors",
                        "\t * and such) we still check if the journal is clean before proceeding",
                        "\t * but we may wait forever until another mounter does the recovery.",
                        "\t */",
                        "\tif (ret == 0) {",
                        "\t\tfs_warn(sdp, \"No other mounters found. Trying to recover our \"",
                        "\t\t\t\"own journal jid %d.\\n\", sdp->sd_lockstruct.ls_jid);",
                        "\t\tif (gfs2_recover_journal(sdp->sd_jdesc, 1))",
                        "\t\t\tfs_warn(sdp, \"Unable to recover our journal jid %d.\\n\",",
                        "\t\t\t\tsdp->sd_lockstruct.ls_jid);",
                        "\t\tgfs2_glock_dq_wait(&sdp->sd_live_gh);",
                        "\t\tgfs2_holder_reinit(LM_ST_SHARED, LM_FLAG_NOEXP | GL_EXACT,",
                        "\t\t\t\t   &sdp->sd_live_gh);",
                        "\t\tgfs2_glock_nq(&sdp->sd_live_gh);",
                        "\t}",
                        "",
                        "\tgfs2_glock_queue_put(gl); /* drop the extra reference we acquired */",
                        "\tclear_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags);",
                        "",
                        "\t/*",
                        "\t * At this point our journal is evicted, so we need to get a new inode",
                        "\t * for it. Once done, we need to call gfs2_find_jhead which",
                        "\t * calls gfs2_map_journal_extents to map it for us again.",
                        "\t *",
                        "\t * Note that we don't really want it to look up a FREE block. The",
                        "\t * GFS2_BLKST_FREE simply overrides a block check in gfs2_inode_lookup",
                        "\t * which would otherwise fail because it requires grabbing an rgrp",
                        "\t * glock, which would fail with -EIO because we're withdrawing.",
                        "\t */",
                        "\tinode = gfs2_inode_lookup(sdp->sd_vfs, DT_UNKNOWN,",
                        "\t\t\t\t  sdp->sd_jdesc->jd_no_addr, no_formal_ino,",
                        "\t\t\t\t  GFS2_BLKST_FREE);",
                        "\tif (IS_ERR(inode)) {",
                        "\t\tfs_warn(sdp, \"Reprocessing of jid %d failed with %ld.\\n\",",
                        "\t\t\tsdp->sd_lockstruct.ls_jid, PTR_ERR(inode));",
                        "\t\tgoto skip_recovery;",
                        "\t}",
                        "\tsdp->sd_jdesc->jd_inode = inode;",
                        "",
                        "\t/*",
                        "\t * Now wait until recovery is complete.",
                        "\t */",
                        "\tfor (tries = 0; tries < 10; tries++) {",
                        "\t\tret = check_journal_clean(sdp, sdp->sd_jdesc, false);",
                        "\t\tif (!ret)",
                        "\t\t\tbreak;",
                        "\t\tmsleep(HZ);",
                        "\t\tfs_warn(sdp, \"Waiting for journal recovery jid %d.\\n\",",
                        "\t\t\tsdp->sd_lockstruct.ls_jid);",
                        "\t}",
                        "skip_recovery:",
                        "\tif (!ret)",
                        "\t\tfs_warn(sdp, \"Journal recovery complete for jid %d.\\n\",",
                        "\t\t\tsdp->sd_lockstruct.ls_jid);",
                        "\telse",
                        "\t\tfs_warn(sdp, \"Journal recovery skipped for %d until next \"",
                        "\t\t\t\"mount.\\n\", sdp->sd_lockstruct.ls_jid);",
                        "\tfs_warn(sdp, \"Glock dequeues delayed: %lu\\n\", sdp->sd_glock_dqs_held);",
                        "\tsdp->sd_glock_dqs_held = 0;",
                        "\twake_up_bit(&sdp->sd_flags, SDF_WITHDRAW_RECOVERY);",
                        "}"
                    ],
                    "start": 94,
                    "highlight": 97
                },
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n294",
                    "code": [
                        "int gfs2_withdraw(struct gfs2_sbd *sdp)",
                        "{",
                        "\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;",
                        "\tconst struct lm_lockops *lm = ls->ls_ops;",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&",
                        "\t    test_and_set_bit(SDF_WITHDRAWN, &sdp->sd_flags)) {",
                        "\t\tif (!test_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags))",
                        "\t\t\treturn -1;",
                        "",
                        "\t\twait_on_bit(&sdp->sd_flags, SDF_WITHDRAW_IN_PROG,",
                        "\t\t\t    TASK_UNINTERRUPTIBLE);",
                        "\t\treturn -1;",
                        "\t}",
                        "",
                        "\tset_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags);",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {",
                        "\t\tfs_err(sdp, \"about to withdraw this file system\\n\");",
                        "\t\tBUG_ON(sdp->sd_args.ar_debug);",
                        "",
                        "\t\tsignal_our_withdraw(sdp);",
                        "",
                        "\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);",
                        "",
                        "\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))",
                        "\t\t\twait_for_completion(&sdp->sd_wdack);",
                        "",
                        "\t\tif (lm->lm_unmount) {",
                        "\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");",
                        "\t\t\tlm->lm_unmount(sdp);",
                        "\t\t}",
                        "\t\tset_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags);",
                        "\t\tfs_err(sdp, \"File system withdrawn\\n\");",
                        "\t\tdump_stack();",
                        "\t\tclear_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags);",
                        "\t\tsmp_mb__after_atomic();",
                        "\t\twake_up_bit(&sdp->sd_flags, SDF_WITHDRAW_IN_PROG);",
                        "\t}",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)",
                        "\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);",
                        "",
                        "\treturn -1;",
                        "}"
                    ],
                    "start": 273,
                    "highlight": 294
                }
            ],
            "ins_idx": 1422,
            "addr": "0xffffffff81392137"
        },
        "18236": {
            "name": "+0xd2",
            "parent_idx": 18235,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=549738f15da0e5a00275977623be199fbbf7df50#n2927",
                    "code": [
                        "#ifdef CONFIG_NUMA",
                        "void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)",
                        "{",
                        "\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);",
                        "",
                        "\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,",
                        "\t\t\t\t    s->object_size, s->size, gfpflags, node);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2921,
                    "highlight": 2927
                }
            ],
            "ins_idx": 2147,
            "addr": "0xffffffff811dbe82"
        },
        "18235": {
            "name": "kmem_cache_alloc_trace",
            "parent_idx": 18232,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=549738f15da0e5a00275977623be199fbbf7df50#n554",
                    "code": [
                        "/**",
                        " * kmalloc - allocate memory",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate.",
                        " *",
                        " * kmalloc is the normal method of allocating memory",
                        " * for objects smaller than page size in the kernel.",
                        " *",
                        " * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN",
                        " * bytes. For @size of power of two bytes, the alignment is also guaranteed",
                        " * to be at least to the size.",
                        " *",
                        " * The @flags argument may be one of the GFP flags defined at",
                        " * include/linux/gfp.h and described at",
                        " * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`",
                        " *",
                        " * The recommended usage of the @flags is described at",
                        " * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`",
                        " *",
                        " * Below is a brief outline of the most useful GFP flags",
                        " *",
                        " * %GFP_KERNEL",
                        " *\tAllocate normal kernel ram. May sleep.",
                        " *",
                        " * %GFP_NOWAIT",
                        " *\tAllocation will not sleep.",
                        " *",
                        " * %GFP_ATOMIC",
                        " *\tAllocation will not sleep.  May use emergency pools.",
                        " *",
                        " * %GFP_HIGHUSER",
                        " *\tAllocate memory from high memory on behalf of user.",
                        " *",
                        " * Also it is possible to set different flags by OR'ing",
                        " * in one or more of the following additional @flags:",
                        " *",
                        " * %__GFP_HIGH",
                        " *\tThis allocation has high priority and may use emergency pools.",
                        " *",
                        " * %__GFP_NOFAIL",
                        " *\tIndicate that this allocation is in no way allowed to fail",
                        " *\t(think twice before using).",
                        " *",
                        " * %__GFP_NORETRY",
                        " *\tIf memory is not immediately available,",
                        " *\tthen give up at once.",
                        " *",
                        " * %__GFP_NOWARN",
                        " *\tIf allocation fails, don't issue any warnings.",
                        " *",
                        " * %__GFP_RETRY_MAYFAIL",
                        " *\tTry really hard to succeed the allocation but fail",
                        " *\teventually.",
                        " */",
                        "static __always_inline void *kmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\tif (__builtin_constant_p(size)) {",
                        "#ifndef CONFIG_SLOB",
                        "\t\tunsigned int index;",
                        "#endif",
                        "\t\tif (size > KMALLOC_MAX_CACHE_SIZE)",
                        "\t\t\treturn kmalloc_large(size, flags);",
                        "#ifndef CONFIG_SLOB",
                        "\t\tindex = kmalloc_index(size);",
                        "",
                        "\t\tif (!index)",
                        "\t\t\treturn ZERO_SIZE_PTR;",
                        "",
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 486,
                    "highlight": 554
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=549738f15da0e5a00275977623be199fbbf7df50#n666",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 659,
                    "highlight": 666
                },
                {
                    "file": "fs/gfs2/ops_fstype.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=549738f15da0e5a00275977623be199fbbf7df50#n77",
                    "code": [
                        "static struct gfs2_sbd *init_sbd(struct super_block *sb)",
                        "{",
                        "\tstruct gfs2_sbd *sdp;",
                        "\tstruct address_space *mapping;",
                        "",
                        "\tsdp = kzalloc(sizeof(struct gfs2_sbd), GFP_KERNEL);",
                        "\tif (!sdp)",
                        "\t\treturn NULL;",
                        "",
                        "\tsdp->sd_vfs = sb;",
                        "\tsdp->sd_lkstats = alloc_percpu(struct gfs2_pcpu_lkstats);",
                        "\tif (!sdp->sd_lkstats)",
                        "\t\tgoto fail;",
                        "\tsb->s_fs_info = sdp;",
                        "",
                        "\tset_bit(SDF_NOJOURNALID, &sdp->sd_flags);",
                        "\tgfs2_tune_init(&sdp->sd_tune);",
                        "",
                        "\tinit_waitqueue_head(&sdp->sd_glock_wait);",
                        "\tinit_waitqueue_head(&sdp->sd_async_glock_wait);",
                        "\tatomic_set(&sdp->sd_glock_disposal, 0);",
                        "\tinit_completion(&sdp->sd_locking_init);",
                        "\tinit_completion(&sdp->sd_wdack);",
                        "\tspin_lock_init(&sdp->sd_statfs_spin);",
                        "",
                        "\tspin_lock_init(&sdp->sd_rindex_spin);",
                        "\tsdp->sd_rindex_tree.rb_node = NULL;",
                        "",
                        "\tINIT_LIST_HEAD(&sdp->sd_jindex_list);",
                        "\tspin_lock_init(&sdp->sd_jindex_spin);",
                        "\tmutex_init(&sdp->sd_jindex_mutex);",
                        "\tinit_completion(&sdp->sd_journal_ready);",
                        "",
                        "\tINIT_LIST_HEAD(&sdp->sd_quota_list);",
                        "\tmutex_init(&sdp->sd_quota_mutex);",
                        "\tmutex_init(&sdp->sd_quota_sync_mutex);",
                        "\tinit_waitqueue_head(&sdp->sd_quota_wait);",
                        "\tINIT_LIST_HEAD(&sdp->sd_trunc_list);",
                        "\tspin_lock_init(&sdp->sd_trunc_lock);",
                        "\tspin_lock_init(&sdp->sd_bitmap_lock);",
                        "",
                        "\tmapping = &sdp->sd_aspace;",
                        "",
                        "\taddress_space_init_once(mapping);",
                        "\tmapping->a_ops = &gfs2_rgrp_aops;",
                        "\tmapping->host = sb->s_bdev->bd_inode;",
                        "\tmapping->flags = 0;",
                        "\tmapping_set_gfp_mask(mapping, GFP_NOFS);",
                        "\tmapping->private_data = NULL;",
                        "\tmapping->writeback_index = 0;",
                        "",
                        "\tspin_lock_init(&sdp->sd_log_lock);",
                        "\tatomic_set(&sdp->sd_log_pinned, 0);",
                        "\tINIT_LIST_HEAD(&sdp->sd_log_revokes);",
                        "\tINIT_LIST_HEAD(&sdp->sd_log_ordered);",
                        "\tspin_lock_init(&sdp->sd_ordered_lock);",
                        "",
                        "\tinit_waitqueue_head(&sdp->sd_log_waitq);",
                        "\tinit_waitqueue_head(&sdp->sd_logd_waitq);",
                        "\tspin_lock_init(&sdp->sd_ail_lock);",
                        "\tINIT_LIST_HEAD(&sdp->sd_ail1_list);",
                        "\tINIT_LIST_HEAD(&sdp->sd_ail2_list);",
                        "",
                        "\tinit_rwsem(&sdp->sd_log_flush_lock);",
                        "\tatomic_set(&sdp->sd_log_in_flight, 0);",
                        "\tatomic_set(&sdp->sd_reserving_log, 0);",
                        "\tinit_waitqueue_head(&sdp->sd_reserving_log_wait);",
                        "\tinit_waitqueue_head(&sdp->sd_log_flush_wait);",
                        "\tatomic_set(&sdp->sd_freeze_state, SFS_UNFROZEN);",
                        "\tmutex_init(&sdp->sd_freeze_mutex);",
                        "",
                        "\treturn sdp;",
                        "",
                        "fail:",
                        "\tfree_sbd(sdp);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 72,
                    "highlight": 77
                },
                {
                    "file": "fs/gfs2/ops_fstype.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=549738f15da0e5a00275977623be199fbbf7df50#n1018",
                    "code": [
                        "/**",
                        " * gfs2_fill_super - Read in superblock",
                        " * @sb: The VFS superblock",
                        " * @args: Mount options",
                        " * @silent: Don't complain if it's not a GFS2 filesystem",
                        " *",
                        " * Returns: -errno",
                        " */",
                        "static int gfs2_fill_super(struct super_block *sb, struct fs_context *fc)",
                        "{",
                        "\tstruct gfs2_args *args = fc->fs_private;",
                        "\tint silent = fc->sb_flags & SB_SILENT;",
                        "\tstruct gfs2_sbd *sdp;",
                        "\tstruct gfs2_holder mount_gh;",
                        "\tint error;",
                        "",
                        "\tsdp = init_sbd(sb);",
                        "\tif (!sdp) {",
                        "\t\tpr_warn(\"can't alloc struct gfs2_sbd\\n\");",
                        "\t\treturn -ENOMEM;",
                        "\t}",
                        "\tsdp->sd_args = *args;",
                        "",
                        "\tif (sdp->sd_args.ar_spectator) {",
                        "                sb->s_flags |= SB_RDONLY;",
                        "\t\tset_bit(SDF_RORECOVERY, &sdp->sd_flags);",
                        "\t}",
                        "\tif (sdp->sd_args.ar_posix_acl)",
                        "\t\tsb->s_flags |= SB_POSIXACL;",
                        "\tif (sdp->sd_args.ar_nobarrier)",
                        "\t\tset_bit(SDF_NOBARRIERS, &sdp->sd_flags);",
                        "",
                        "\tsb->s_flags |= SB_NOSEC;",
                        "\tsb->s_magic = GFS2_MAGIC;",
                        "\tsb->s_op = &gfs2_super_ops;",
                        "\tsb->s_d_op = &gfs2_dops;",
                        "\tsb->s_export_op = &gfs2_export_ops;",
                        "\tsb->s_xattr = gfs2_xattr_handlers;",
                        "\tsb->s_qcop = &gfs2_quotactl_ops;",
                        "\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;",
                        "\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;",
                        "\tsb->s_time_gran = 1;",
                        "\tsb->s_maxbytes = MAX_LFS_FILESIZE;",
                        "",
                        "\t/* Set up the buffer cache and fill in some fake block size values",
                        "\t   to allow us to read-in the on-disk superblock. */",
                        "\tsdp->sd_sb.sb_bsize = sb_min_blocksize(sb, GFS2_BASIC_BLOCK);",
                        "\tsdp->sd_sb.sb_bsize_shift = sb->s_blocksize_bits;",
                        "\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -",
                        "                               GFS2_BASIC_BLOCK_SHIFT;",
                        "\tsdp->sd_fsb2bb = BIT(sdp->sd_fsb2bb_shift);",
                        "",
                        "\tsdp->sd_tune.gt_logd_secs = sdp->sd_args.ar_commit;",
                        "\tsdp->sd_tune.gt_quota_quantum = sdp->sd_args.ar_quota_quantum;",
                        "\tif (sdp->sd_args.ar_statfs_quantum) {",
                        "\t\tsdp->sd_tune.gt_statfs_slow = 0;",
                        "\t\tsdp->sd_tune.gt_statfs_quantum = sdp->sd_args.ar_statfs_quantum;",
                        "\t} else {",
                        "\t\tsdp->sd_tune.gt_statfs_slow = 1;",
                        "\t\tsdp->sd_tune.gt_statfs_quantum = 30;",
                        "\t}",
                        "",
                        "\terror = init_names(sdp, silent);",
                        "\tif (error) {",
                        "\t\t/* In this case, we haven't initialized sysfs, so we have to",
                        "\t\t   manually free the sdp. */",
                        "\t\tfree_sbd(sdp);",
                        "\t\tsb->s_fs_info = NULL;",
                        "\t\treturn error;",
                        "\t}",
                        "",
                        "\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s\", sdp->sd_table_name);",
                        "",
                        "\terror = gfs2_sys_fs_add(sdp);",
                        "\t/*",
                        "\t * If we hit an error here, gfs2_sys_fs_add will have called function",
                        "\t * kobject_put which causes the sysfs usage count to go to zero, which",
                        "\t * causes sysfs to call function gfs2_sbd_release, which frees sdp.",
                        "\t * Subsequent error paths here will call gfs2_sys_fs_del, which also",
                        "\t * kobject_put to free sdp.",
                        "\t */",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "\tgfs2_create_debugfs_file(sdp);",
                        "",
                        "\terror = gfs2_lm_mount(sdp, silent);",
                        "\tif (error)",
                        "\t\tgoto fail_debug;",
                        "",
                        "\terror = init_locking(sdp, &mount_gh, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_lm;",
                        "",
                        "\terror = init_sb(sdp, silent);",
                        "\tif (error)",
                        "\t\tgoto fail_locking;",
                        "",
                        "\terror = wait_on_journal(sdp);",
                        "\tif (error)",
                        "\t\tgoto fail_sb;",
                        "",
                        "\t/*",
                        "\t * If user space has failed to join the cluster or some similar",
                        "\t * failure has occurred, then the journal id will contain a",
                        "\t * negative (error) number. This will then be returned to the",
                        "\t * caller (of the mount syscall). We do this even for spectator",
                        "\t * mounts (which just write a jid of 0 to indicate \"ok\" even though",
                        "\t * the jid is unused in the spectator case)",
                        "\t */",
                        "\tif (sdp->sd_lockstruct.ls_jid < 0) {",
                        "\t\terror = sdp->sd_lockstruct.ls_jid;",
                        "\t\tsdp->sd_lockstruct.ls_jid = 0;",
                        "\t\tgoto fail_sb;",
                        "\t}",
                        "",
                        "\tif (sdp->sd_args.ar_spectator)",
                        "\t\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s.s\",",
                        "\t\t\t sdp->sd_table_name);",
                        "\telse",
                        "\t\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s.%u\",",
                        "\t\t\t sdp->sd_table_name, sdp->sd_lockstruct.ls_jid);",
                        "",
                        "\terror = init_inodes(sdp, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_sb;",
                        "",
                        "\terror = init_per_node(sdp, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_inodes;",
                        "",
                        "\terror = gfs2_statfs_init(sdp);",
                        "\tif (error) {",
                        "\t\tfs_err(sdp, \"can't initialize statfs subsystem: %d\\n\", error);",
                        "\t\tgoto fail_per_node;",
                        "\t}",
                        "",
                        "\tif (sb_rdonly(sb)) {",
                        "\t\tstruct gfs2_holder freeze_gh;",
                        "",
                        "\t\terror = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED,",
                        "\t\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT,",
                        "\t\t\t\t\t   &freeze_gh);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"can't make FS RO: %d\\n\", error);",
                        "\t\t\tgoto fail_per_node;",
                        "\t\t}",
                        "\t\tgfs2_glock_dq_uninit(&freeze_gh);",
                        "\t} else {",
                        "\t\terror = gfs2_make_fs_rw(sdp);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"can't make FS RW: %d\\n\", error);",
                        "\t\t\tgoto fail_per_node;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tgfs2_glock_dq_uninit(&mount_gh);",
                        "\tgfs2_online_uevent(sdp);",
                        "\treturn 0;",
                        "",
                        "fail_per_node:",
                        "\tinit_per_node(sdp, UNDO);",
                        "fail_inodes:",
                        "\tinit_inodes(sdp, UNDO);",
                        "fail_sb:",
                        "\tif (sdp->sd_root_dir)",
                        "\t\tdput(sdp->sd_root_dir);",
                        "\tif (sdp->sd_master_dir)",
                        "\t\tdput(sdp->sd_master_dir);",
                        "\tif (sb->s_root)",
                        "\t\tdput(sb->s_root);",
                        "\tsb->s_root = NULL;",
                        "fail_locking:",
                        "\tinit_locking(sdp, &mount_gh, UNDO);",
                        "fail_lm:",
                        "\tcomplete_all(&sdp->sd_journal_ready);",
                        "\tgfs2_gl_hash_clear(sdp);",
                        "\tgfs2_lm_unmount(sdp);",
                        "fail_debug:",
                        "\tgfs2_delete_debugfs_file(sdp);",
                        "\t/* gfs2_sys_fs_del must be the last thing we do, since it causes",
                        "\t * sysfs to call function gfs2_sbd_release, which frees sdp. */",
                        "\tgfs2_sys_fs_del(sdp);",
                        "\tsb->s_fs_info = NULL;",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 1002,
                    "highlight": 1018
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8137f74b"
        },
        "18872": {
            "name": "+0xbb",
            "parent_idx": 18868,
            "source_line": [
                {
                    "file": "kernel/printk/printk.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/printk/printk.c?id=549738f15da0e5a00275977623be199fbbf7df50#n2036",
                    "code": [
                        "asmlinkage int vprintk_emit(int facility, int level,",
                        "\t\t\t    const char *dict, size_t dictlen,",
                        "\t\t\t    const char *fmt, va_list args)",
                        "{",
                        "\tint printed_len;",
                        "\tbool in_sched = false, pending_output;",
                        "\tunsigned long flags;",
                        "\tu64 curr_log_seq;",
                        "",
                        "\t/* Suppress unimportant messages after panic happens */",
                        "\tif (unlikely(suppress_printk))",
                        "\t\treturn 0;",
                        "",
                        "\tif (level == LOGLEVEL_SCHED) {",
                        "\t\tlevel = LOGLEVEL_DEFAULT;",
                        "\t\tin_sched = true;",
                        "\t}",
                        "",
                        "\tboot_delay_msec(level);",
                        "\tprintk_delay();",
                        "",
                        "\t/* This stops the holder of console_sem just where we want him */",
                        "\tlogbuf_lock_irqsave(flags);",
                        "\tcurr_log_seq = log_next_seq;",
                        "\tprinted_len = vprintk_store(facility, level, dict, dictlen, fmt, args);",
                        "\tpending_output = (curr_log_seq != log_next_seq);",
                        "\tlogbuf_unlock_irqrestore(flags);",
                        "",
                        "\t/* If called from the scheduler, we can not call up(). */",
                        "\tif (!in_sched && pending_output) {",
                        "\t\t/*",
                        "\t\t * Disable preemption to avoid being preempted while holding",
                        "\t\t * console_sem which would prevent anyone from printing to",
                        "\t\t * console",
                        "\t\t */",
                        "\t\tpreempt_disable();",
                        "\t\t/*",
                        "\t\t * Try to acquire and then immediately release the console",
                        "\t\t * semaphore.  The release will print out buffers and wake up",
                        "\t\t * /dev/kmsg and syslog() users.",
                        "\t\t */",
                        "\t\tif (console_trylock_spinning())",
                        "\t\t\tconsole_unlock();",
                        "\t\tpreempt_enable();",
                        "\t}",
                        "",
                        "\tif (pending_output)",
                        "\t\twake_up_klogd();",
                        "\treturn printed_len;",
                        "}"
                    ],
                    "start": 1987,
                    "highlight": 2036
                }
            ],
            "ins_idx": 2146,
            "addr": "0xffffffff810c072b"
        },
        "18868": {
            "name": "vprintk_func",
            "parent_idx": 18867,
            "source_line": [
                {
                    "file": "kernel/printk/printk.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/printk/printk.c?id=549738f15da0e5a00275977623be199fbbf7df50#n2078",
                    "code": [
                        "/**",
                        " * printk - print a kernel message",
                        " * @fmt: format string",
                        " *",
                        " * This is printk(). It can be called from any context. We want it to work.",
                        " *",
                        " * We try to grab the console_lock. If we succeed, it's easy - we log the",
                        " * output and call the console drivers.  If we fail to get the semaphore, we",
                        " * place the output into the log buffer and return. The current holder of",
                        " * the console_sem will notice the new output in console_unlock(); and will",
                        " * send it to the consoles before releasing the lock.",
                        " *",
                        " * One effect of this deferred printing is that code which calls printk() and",
                        " * then changes console_loglevel may break. This is because console_loglevel",
                        " * is inspected when the actual printing occurs.",
                        " *",
                        " * See also:",
                        " * printf(3)",
                        " *",
                        " * See the vsnprintf() documentation for format string extensions over C99.",
                        " */",
                        "asmlinkage __visible int printk(const char *fmt, ...)",
                        "{",
                        "\tva_list args;",
                        "\tint r;",
                        "",
                        "\tva_start(args, fmt);",
                        "\tr = vprintk_func(fmt, args);",
                        "\tva_end(args);",
                        "",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 2051,
                    "highlight": 2078
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff810c0ef7"
        },
        "18867": {
            "name": "printk",
            "parent_idx": 18865,
            "source_line": [
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n291",
                    "code": [
                        "int gfs2_withdraw(struct gfs2_sbd *sdp)",
                        "{",
                        "\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;",
                        "\tconst struct lm_lockops *lm = ls->ls_ops;",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&",
                        "\t    test_and_set_bit(SDF_WITHDRAWN, &sdp->sd_flags)) {",
                        "\t\tif (!test_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags))",
                        "\t\t\treturn -1;",
                        "",
                        "\t\twait_on_bit(&sdp->sd_flags, SDF_WITHDRAW_IN_PROG,",
                        "\t\t\t    TASK_UNINTERRUPTIBLE);",
                        "\t\treturn -1;",
                        "\t}",
                        "",
                        "\tset_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags);",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {",
                        "\t\tfs_err(sdp, \"about to withdraw this file system\\n\");",
                        "\t\tBUG_ON(sdp->sd_args.ar_debug);",
                        "",
                        "\t\tsignal_our_withdraw(sdp);",
                        "",
                        "\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);",
                        "",
                        "\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))",
                        "\t\t\twait_for_completion(&sdp->sd_wdack);",
                        "",
                        "\t\tif (lm->lm_unmount) {",
                        "\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");",
                        "\t\t\tlm->lm_unmount(sdp);",
                        "\t\t}",
                        "\t\tset_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags);",
                        "\t\tfs_err(sdp, \"File system withdrawn\\n\");",
                        "\t\tdump_stack();",
                        "\t\tclear_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags);",
                        "\t\tsmp_mb__after_atomic();",
                        "\t\twake_up_bit(&sdp->sd_flags, SDF_WITHDRAW_IN_PROG);",
                        "\t}",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)",
                        "\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);",
                        "",
                        "\treturn -1;",
                        "}"
                    ],
                    "start": 273,
                    "highlight": 291
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81392114"
        },
        "18870": {
            "name": "+0x9",
            "parent_idx": 18868,
            "source_line": [
                {
                    "file": "kernel/printk/printk.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/printk/printk.c?id=549738f15da0e5a00275977623be199fbbf7df50#n1990",
                    "code": [
                        "asmlinkage int vprintk_emit(int facility, int level,",
                        "\t\t\t    const char *dict, size_t dictlen,",
                        "\t\t\t    const char *fmt, va_list args)",
                        "{",
                        "\tint printed_len;",
                        "\tbool in_sched = false, pending_output;",
                        "\tunsigned long flags;",
                        "\tu64 curr_log_seq;",
                        "",
                        "\t/* Suppress unimportant messages after panic happens */",
                        "\tif (unlikely(suppress_printk))",
                        "\t\treturn 0;",
                        "",
                        "\tif (level == LOGLEVEL_SCHED) {",
                        "\t\tlevel = LOGLEVEL_DEFAULT;",
                        "\t\tin_sched = true;",
                        "\t}",
                        "",
                        "\tboot_delay_msec(level);",
                        "\tprintk_delay();",
                        "",
                        "\t/* This stops the holder of console_sem just where we want him */",
                        "\tlogbuf_lock_irqsave(flags);",
                        "\tcurr_log_seq = log_next_seq;",
                        "\tprinted_len = vprintk_store(facility, level, dict, dictlen, fmt, args);",
                        "\tpending_output = (curr_log_seq != log_next_seq);",
                        "\tlogbuf_unlock_irqrestore(flags);",
                        "",
                        "\t/* If called from the scheduler, we can not call up(). */",
                        "\tif (!in_sched && pending_output) {",
                        "\t\t/*",
                        "\t\t * Disable preemption to avoid being preempted while holding",
                        "\t\t * console_sem which would prevent anyone from printing to",
                        "\t\t * console",
                        "\t\t */",
                        "\t\tpreempt_disable();",
                        "\t\t/*",
                        "\t\t * Try to acquire and then immediately release the console",
                        "\t\t * semaphore.  The release will print out buffers and wake up",
                        "\t\t * /dev/kmsg and syslog() users.",
                        "\t\t */",
                        "\t\tif (console_trylock_spinning())",
                        "\t\t\tconsole_unlock();",
                        "\t\tpreempt_enable();",
                        "\t}",
                        "",
                        "\tif (pending_output)",
                        "\t\twake_up_klogd();",
                        "\treturn printed_len;",
                        "}"
                    ],
                    "start": 1987,
                    "highlight": 1990
                }
            ],
            "ins_idx": 2926,
            "addr": "0xffffffff810c0679"
        },
        "18866": {
            "name": "+0xe",
            "parent_idx": 18865,
            "source_line": [
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n274",
                    "code": [
                        "int gfs2_withdraw(struct gfs2_sbd *sdp)",
                        "{",
                        "\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;",
                        "\tconst struct lm_lockops *lm = ls->ls_ops;",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&",
                        "\t    test_and_set_bit(SDF_WITHDRAWN, &sdp->sd_flags)) {",
                        "\t\tif (!test_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags))",
                        "\t\t\treturn -1;",
                        "",
                        "\t\twait_on_bit(&sdp->sd_flags, SDF_WITHDRAW_IN_PROG,",
                        "\t\t\t    TASK_UNINTERRUPTIBLE);",
                        "\t\treturn -1;",
                        "\t}",
                        "",
                        "\tset_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags);",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {",
                        "\t\tfs_err(sdp, \"about to withdraw this file system\\n\");",
                        "\t\tBUG_ON(sdp->sd_args.ar_debug);",
                        "",
                        "\t\tsignal_our_withdraw(sdp);",
                        "",
                        "\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);",
                        "",
                        "\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))",
                        "\t\t\twait_for_completion(&sdp->sd_wdack);",
                        "",
                        "\t\tif (lm->lm_unmount) {",
                        "\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");",
                        "\t\t\tlm->lm_unmount(sdp);",
                        "\t\t}",
                        "\t\tset_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags);",
                        "\t\tfs_err(sdp, \"File system withdrawn\\n\");",
                        "\t\tdump_stack();",
                        "\t\tclear_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags);",
                        "\t\tsmp_mb__after_atomic();",
                        "\t\twake_up_bit(&sdp->sd_flags, SDF_WITHDRAW_IN_PROG);",
                        "\t}",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)",
                        "\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);",
                        "",
                        "\treturn -1;",
                        "}"
                    ],
                    "start": 273,
                    "highlight": 274
                }
            ],
            "ins_idx": 3712,
            "addr": "0xffffffff81391d1e"
        },
        "18864": {
            "name": "+0x22",
            "parent_idx": 18841,
            "source_line": [
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n450",
                    "code": [
                        "int gfs2_meta_check_ii(struct gfs2_sbd *sdp, struct buffer_head *bh,",
                        "\t\t       const char *type, const char *function, char *file,",
                        "\t\t       unsigned int line)",
                        "{",
                        "\tint me;",
                        "",
                        "\tgfs2_lm(sdp,",
                        "\t\t\"fatal: invalid metadata block\\n\"",
                        "\t\t\"  bh = %llu (%s)\\n\"",
                        "\t\t\"  function = %s, file = %s, line = %u\\n\",",
                        "\t\t(unsigned long long)bh->b_blocknr, type,",
                        "\t\tfunction, file, line);",
                        "\tme = gfs2_withdraw(sdp);",
                        "\treturn (me) ? -1 : -2;",
                        "}"
                    ],
                    "start": 438,
                    "highlight": 450
                }
            ],
            "ins_idx": 4785,
            "addr": "0xffffffff81391f92"
        },
        "18863": {
            "name": "+0x55",
            "parent_idx": 18844,
            "source_line": [
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n271",
                    "code": [
                        "void gfs2_lm(struct gfs2_sbd *sdp, const char *fmt, ...)",
                        "{",
                        "\tstruct va_format vaf;",
                        "\tva_list args;",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&",
                        "\t    test_bit(SDF_WITHDRAWN, &sdp->sd_flags))",
                        "\t\treturn;",
                        "",
                        "\tva_start(args, fmt);",
                        "\tvaf.fmt = fmt;",
                        "\tvaf.va = &args;",
                        "\tfs_err(sdp, \"%pV\", &vaf);",
                        "\tva_end(args);",
                        "}"
                    ],
                    "start": 257,
                    "highlight": 271
                }
            ],
            "ins_idx": 6026,
            "addr": "0xffffffff81391d05"
        },
        "18844": {
            "name": "gfs2_lm",
            "parent_idx": 18841,
            "source_line": [
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n444",
                    "code": [
                        "int gfs2_meta_check_ii(struct gfs2_sbd *sdp, struct buffer_head *bh,",
                        "\t\t       const char *type, const char *function, char *file,",
                        "\t\t       unsigned int line)",
                        "{",
                        "\tint me;",
                        "",
                        "\tgfs2_lm(sdp,",
                        "\t\t\"fatal: invalid metadata block\\n\"",
                        "\t\t\"  bh = %llu (%s)\\n\"",
                        "\t\t\"  function = %s, file = %s, line = %u\\n\",",
                        "\t\t(unsigned long long)bh->b_blocknr, type,",
                        "\t\tfunction, file, line);",
                        "\tme = gfs2_withdraw(sdp);",
                        "\treturn (me) ? -1 : -2;",
                        "}"
                    ],
                    "start": 438,
                    "highlight": 444
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81391f8d"
        },
        "18846": {
            "name": "+0x0",
            "parent_idx": 18844,
            "source_line": [
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n258",
                    "code": [
                        "void gfs2_lm(struct gfs2_sbd *sdp, const char *fmt, ...)",
                        "{",
                        "\tstruct va_format vaf;",
                        "\tva_list args;",
                        "",
                        "\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&",
                        "\t    test_bit(SDF_WITHDRAWN, &sdp->sd_flags))",
                        "\t\treturn;",
                        "",
                        "\tva_start(args, fmt);",
                        "\tvaf.fmt = fmt;",
                        "\tvaf.va = &args;",
                        "\tfs_err(sdp, \"%pV\", &vaf);",
                        "\tva_end(args);",
                        "}"
                    ],
                    "start": 257,
                    "highlight": 258
                }
            ],
            "ins_idx": 6744,
            "addr": "0xffffffff81391cb0"
        },
        "18842": {
            "name": "+0x8",
            "parent_idx": 18841,
            "source_line": [
                {
                    "file": "fs/gfs2/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.c?id=549738f15da0e5a00275977623be199fbbf7df50#n441",
                    "code": [
                        "int gfs2_meta_check_ii(struct gfs2_sbd *sdp, struct buffer_head *bh,",
                        "\t\t       const char *type, const char *function, char *file,",
                        "\t\t       unsigned int line)",
                        "{",
                        "\tint me;",
                        "",
                        "\tgfs2_lm(sdp,",
                        "\t\t\"fatal: invalid metadata block\\n\"",
                        "\t\t\"  bh = %llu (%s)\\n\"",
                        "\t\t\"  function = %s, file = %s, line = %u\\n\",",
                        "\t\t(unsigned long long)bh->b_blocknr, type,",
                        "\t\tfunction, file, line);",
                        "\tme = gfs2_withdraw(sdp);",
                        "\treturn (me) ? -1 : -2;",
                        "}"
                    ],
                    "start": 438,
                    "highlight": 441
                }
            ],
            "ins_idx": 7404,
            "addr": "0xffffffff81391f78"
        },
        "18840": {
            "name": "+0x107",
            "parent_idx": 18832,
            "source_line": [
                {
                    "file": "fs/gfs2/util.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/util.h?id=549738f15da0e5a00275977623be199fbbf7df50#n126",
                    "code": [
                        "static inline int gfs2_metatype_check_i(struct gfs2_sbd *sdp,",
                        "\t\t\t\t\tstruct buffer_head *bh,",
                        "\t\t\t\t\tu16 type,",
                        "\t\t\t\t\tconst char *function,",
                        "\t\t\t\t\tchar *file, unsigned int line)",
                        "{",
                        "\tstruct gfs2_meta_header *mh = (struct gfs2_meta_header *)bh->b_data;",
                        "\tu32 magic = be32_to_cpu(mh->mh_magic);",
                        "\tu16 t = be32_to_cpu(mh->mh_type);",
                        "\tif (unlikely(magic != GFS2_MAGIC))",
                        "\t\treturn gfs2_meta_check_ii(sdp, bh, \"magic number\", function,",
                        "\t\t\t\t\t  file, line);",
                        "        if (unlikely(t != type))",
                        "\t\treturn gfs2_metatype_check_ii(sdp, bh, type, t, function,",
                        "\t\t\t\t\t      file, line);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 116,
                    "highlight": 126
                },
                {
                    "file": "fs/gfs2/meta_io.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/meta_io.c?id=549738f15da0e5a00275977623be199fbbf7df50#n417",
                    "code": [
                        "int gfs2_meta_indirect_buffer(struct gfs2_inode *ip, int height, u64 num,",
                        "\t\t\t      struct buffer_head **bhp)",
                        "{",
                        "\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);",
                        "\tstruct gfs2_glock *gl = ip->i_gl;",
                        "\tstruct buffer_head *bh;",
                        "\tint ret = 0;",
                        "\tu32 mtype = height ? GFS2_METATYPE_IN : GFS2_METATYPE_DI;",
                        "\tint rahead = 0;",
                        "",
                        "\tif (num == ip->i_no_addr)",
                        "\t\trahead = ip->i_rahead;",
                        "",
                        "\tret = gfs2_meta_read(gl, num, DIO_WAIT, rahead, &bh);",
                        "\tif (ret == 0 && gfs2_metatype_check(sdp, bh, mtype)) {",
                        "\t\tbrelse(bh);",
                        "\t\tret = -EIO;",
                        "\t} else {",
                        "\t\t*bhp = bh;",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 403,
                    "highlight": 417
                }
            ],
            "ins_idx": 7995,
            "addr": "0xffffffff8137a2d7"
        },
        "18834": {
            "name": "+0x3c",
            "parent_idx": 18832,
            "source_line": [
                {
                    "file": "fs/gfs2/incore.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/incore.h?id=549738f15da0e5a00275977623be199fbbf7df50#n444",
                    "code": [
                        "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)",
                        "{",
                        "\treturn inode->i_sb->s_fs_info;",
                        "}"
                    ],
                    "start": 442,
                    "highlight": 444
                },
                {
                    "file": "fs/gfs2/meta_io.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/meta_io.c?id=549738f15da0e5a00275977623be199fbbf7df50#n406",
                    "code": [
                        "int gfs2_meta_indirect_buffer(struct gfs2_inode *ip, int height, u64 num,",
                        "\t\t\t      struct buffer_head **bhp)",
                        "{",
                        "\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);",
                        "\tstruct gfs2_glock *gl = ip->i_gl;",
                        "\tstruct buffer_head *bh;",
                        "\tint ret = 0;",
                        "\tu32 mtype = height ? GFS2_METATYPE_IN : GFS2_METATYPE_DI;",
                        "\tint rahead = 0;",
                        "",
                        "\tif (num == ip->i_no_addr)",
                        "\t\trahead = ip->i_rahead;",
                        "",
                        "\tret = gfs2_meta_read(gl, num, DIO_WAIT, rahead, &bh);",
                        "\tif (ret == 0 && gfs2_metatype_check(sdp, bh, mtype)) {",
                        "\t\tbrelse(bh);",
                        "\t\tret = -EIO;",
                        "\t} else {",
                        "\t\t*bhp = bh;",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 403,
                    "highlight": 406
                }
            ],
            "ins_idx": 9855,
            "addr": "0xffffffff8137a20c"
        },
        "18239": {
            "name": "+0x7f",
            "parent_idx": 18232,
            "source_line": [
                {
                    "file": "fs/gfs2/ops_fstype.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=549738f15da0e5a00275977623be199fbbf7df50#n85",
                    "code": [
                        "static struct gfs2_sbd *init_sbd(struct super_block *sb)",
                        "{",
                        "\tstruct gfs2_sbd *sdp;",
                        "\tstruct address_space *mapping;",
                        "",
                        "\tsdp = kzalloc(sizeof(struct gfs2_sbd), GFP_KERNEL);",
                        "\tif (!sdp)",
                        "\t\treturn NULL;",
                        "",
                        "\tsdp->sd_vfs = sb;",
                        "\tsdp->sd_lkstats = alloc_percpu(struct gfs2_pcpu_lkstats);",
                        "\tif (!sdp->sd_lkstats)",
                        "\t\tgoto fail;",
                        "\tsb->s_fs_info = sdp;",
                        "",
                        "\tset_bit(SDF_NOJOURNALID, &sdp->sd_flags);",
                        "\tgfs2_tune_init(&sdp->sd_tune);",
                        "",
                        "\tinit_waitqueue_head(&sdp->sd_glock_wait);",
                        "\tinit_waitqueue_head(&sdp->sd_async_glock_wait);",
                        "\tatomic_set(&sdp->sd_glock_disposal, 0);",
                        "\tinit_completion(&sdp->sd_locking_init);",
                        "\tinit_completion(&sdp->sd_wdack);",
                        "\tspin_lock_init(&sdp->sd_statfs_spin);",
                        "",
                        "\tspin_lock_init(&sdp->sd_rindex_spin);",
                        "\tsdp->sd_rindex_tree.rb_node = NULL;",
                        "",
                        "\tINIT_LIST_HEAD(&sdp->sd_jindex_list);",
                        "\tspin_lock_init(&sdp->sd_jindex_spin);",
                        "\tmutex_init(&sdp->sd_jindex_mutex);",
                        "\tinit_completion(&sdp->sd_journal_ready);",
                        "",
                        "\tINIT_LIST_HEAD(&sdp->sd_quota_list);",
                        "\tmutex_init(&sdp->sd_quota_mutex);",
                        "\tmutex_init(&sdp->sd_quota_sync_mutex);",
                        "\tinit_waitqueue_head(&sdp->sd_quota_wait);",
                        "\tINIT_LIST_HEAD(&sdp->sd_trunc_list);",
                        "\tspin_lock_init(&sdp->sd_trunc_lock);",
                        "\tspin_lock_init(&sdp->sd_bitmap_lock);",
                        "",
                        "\tmapping = &sdp->sd_aspace;",
                        "",
                        "\taddress_space_init_once(mapping);",
                        "\tmapping->a_ops = &gfs2_rgrp_aops;",
                        "\tmapping->host = sb->s_bdev->bd_inode;",
                        "\tmapping->flags = 0;",
                        "\tmapping_set_gfp_mask(mapping, GFP_NOFS);",
                        "\tmapping->private_data = NULL;",
                        "\tmapping->writeback_index = 0;",
                        "",
                        "\tspin_lock_init(&sdp->sd_log_lock);",
                        "\tatomic_set(&sdp->sd_log_pinned, 0);",
                        "\tINIT_LIST_HEAD(&sdp->sd_log_revokes);",
                        "\tINIT_LIST_HEAD(&sdp->sd_log_ordered);",
                        "\tspin_lock_init(&sdp->sd_ordered_lock);",
                        "",
                        "\tinit_waitqueue_head(&sdp->sd_log_waitq);",
                        "\tinit_waitqueue_head(&sdp->sd_logd_waitq);",
                        "\tspin_lock_init(&sdp->sd_ail_lock);",
                        "\tINIT_LIST_HEAD(&sdp->sd_ail1_list);",
                        "\tINIT_LIST_HEAD(&sdp->sd_ail2_list);",
                        "",
                        "\tinit_rwsem(&sdp->sd_log_flush_lock);",
                        "\tatomic_set(&sdp->sd_log_in_flight, 0);",
                        "\tatomic_set(&sdp->sd_reserving_log, 0);",
                        "\tinit_waitqueue_head(&sdp->sd_reserving_log_wait);",
                        "\tinit_waitqueue_head(&sdp->sd_log_flush_wait);",
                        "\tatomic_set(&sdp->sd_freeze_state, SFS_UNFROZEN);",
                        "\tmutex_init(&sdp->sd_freeze_mutex);",
                        "",
                        "\treturn sdp;",
                        "",
                        "fail:",
                        "\tfree_sbd(sdp);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 72,
                    "highlight": 85
                },
                {
                    "file": "fs/gfs2/ops_fstype.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=549738f15da0e5a00275977623be199fbbf7df50#n1018",
                    "code": [
                        "/**",
                        " * gfs2_fill_super - Read in superblock",
                        " * @sb: The VFS superblock",
                        " * @args: Mount options",
                        " * @silent: Don't complain if it's not a GFS2 filesystem",
                        " *",
                        " * Returns: -errno",
                        " */",
                        "static int gfs2_fill_super(struct super_block *sb, struct fs_context *fc)",
                        "{",
                        "\tstruct gfs2_args *args = fc->fs_private;",
                        "\tint silent = fc->sb_flags & SB_SILENT;",
                        "\tstruct gfs2_sbd *sdp;",
                        "\tstruct gfs2_holder mount_gh;",
                        "\tint error;",
                        "",
                        "\tsdp = init_sbd(sb);",
                        "\tif (!sdp) {",
                        "\t\tpr_warn(\"can't alloc struct gfs2_sbd\\n\");",
                        "\t\treturn -ENOMEM;",
                        "\t}",
                        "\tsdp->sd_args = *args;",
                        "",
                        "\tif (sdp->sd_args.ar_spectator) {",
                        "                sb->s_flags |= SB_RDONLY;",
                        "\t\tset_bit(SDF_RORECOVERY, &sdp->sd_flags);",
                        "\t}",
                        "\tif (sdp->sd_args.ar_posix_acl)",
                        "\t\tsb->s_flags |= SB_POSIXACL;",
                        "\tif (sdp->sd_args.ar_nobarrier)",
                        "\t\tset_bit(SDF_NOBARRIERS, &sdp->sd_flags);",
                        "",
                        "\tsb->s_flags |= SB_NOSEC;",
                        "\tsb->s_magic = GFS2_MAGIC;",
                        "\tsb->s_op = &gfs2_super_ops;",
                        "\tsb->s_d_op = &gfs2_dops;",
                        "\tsb->s_export_op = &gfs2_export_ops;",
                        "\tsb->s_xattr = gfs2_xattr_handlers;",
                        "\tsb->s_qcop = &gfs2_quotactl_ops;",
                        "\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;",
                        "\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;",
                        "\tsb->s_time_gran = 1;",
                        "\tsb->s_maxbytes = MAX_LFS_FILESIZE;",
                        "",
                        "\t/* Set up the buffer cache and fill in some fake block size values",
                        "\t   to allow us to read-in the on-disk superblock. */",
                        "\tsdp->sd_sb.sb_bsize = sb_min_blocksize(sb, GFS2_BASIC_BLOCK);",
                        "\tsdp->sd_sb.sb_bsize_shift = sb->s_blocksize_bits;",
                        "\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -",
                        "                               GFS2_BASIC_BLOCK_SHIFT;",
                        "\tsdp->sd_fsb2bb = BIT(sdp->sd_fsb2bb_shift);",
                        "",
                        "\tsdp->sd_tune.gt_logd_secs = sdp->sd_args.ar_commit;",
                        "\tsdp->sd_tune.gt_quota_quantum = sdp->sd_args.ar_quota_quantum;",
                        "\tif (sdp->sd_args.ar_statfs_quantum) {",
                        "\t\tsdp->sd_tune.gt_statfs_slow = 0;",
                        "\t\tsdp->sd_tune.gt_statfs_quantum = sdp->sd_args.ar_statfs_quantum;",
                        "\t} else {",
                        "\t\tsdp->sd_tune.gt_statfs_slow = 1;",
                        "\t\tsdp->sd_tune.gt_statfs_quantum = 30;",
                        "\t}",
                        "",
                        "\terror = init_names(sdp, silent);",
                        "\tif (error) {",
                        "\t\t/* In this case, we haven't initialized sysfs, so we have to",
                        "\t\t   manually free the sdp. */",
                        "\t\tfree_sbd(sdp);",
                        "\t\tsb->s_fs_info = NULL;",
                        "\t\treturn error;",
                        "\t}",
                        "",
                        "\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s\", sdp->sd_table_name);",
                        "",
                        "\terror = gfs2_sys_fs_add(sdp);",
                        "\t/*",
                        "\t * If we hit an error here, gfs2_sys_fs_add will have called function",
                        "\t * kobject_put which causes the sysfs usage count to go to zero, which",
                        "\t * causes sysfs to call function gfs2_sbd_release, which frees sdp.",
                        "\t * Subsequent error paths here will call gfs2_sys_fs_del, which also",
                        "\t * kobject_put to free sdp.",
                        "\t */",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "\tgfs2_create_debugfs_file(sdp);",
                        "",
                        "\terror = gfs2_lm_mount(sdp, silent);",
                        "\tif (error)",
                        "\t\tgoto fail_debug;",
                        "",
                        "\terror = init_locking(sdp, &mount_gh, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_lm;",
                        "",
                        "\terror = init_sb(sdp, silent);",
                        "\tif (error)",
                        "\t\tgoto fail_locking;",
                        "",
                        "\terror = wait_on_journal(sdp);",
                        "\tif (error)",
                        "\t\tgoto fail_sb;",
                        "",
                        "\t/*",
                        "\t * If user space has failed to join the cluster or some similar",
                        "\t * failure has occurred, then the journal id will contain a",
                        "\t * negative (error) number. This will then be returned to the",
                        "\t * caller (of the mount syscall). We do this even for spectator",
                        "\t * mounts (which just write a jid of 0 to indicate \"ok\" even though",
                        "\t * the jid is unused in the spectator case)",
                        "\t */",
                        "\tif (sdp->sd_lockstruct.ls_jid < 0) {",
                        "\t\terror = sdp->sd_lockstruct.ls_jid;",
                        "\t\tsdp->sd_lockstruct.ls_jid = 0;",
                        "\t\tgoto fail_sb;",
                        "\t}",
                        "",
                        "\tif (sdp->sd_args.ar_spectator)",
                        "\t\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s.s\",",
                        "\t\t\t sdp->sd_table_name);",
                        "\telse",
                        "\t\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s.%u\",",
                        "\t\t\t sdp->sd_table_name, sdp->sd_lockstruct.ls_jid);",
                        "",
                        "\terror = init_inodes(sdp, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_sb;",
                        "",
                        "\terror = init_per_node(sdp, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_inodes;",
                        "",
                        "\terror = gfs2_statfs_init(sdp);",
                        "\tif (error) {",
                        "\t\tfs_err(sdp, \"can't initialize statfs subsystem: %d\\n\", error);",
                        "\t\tgoto fail_per_node;",
                        "\t}",
                        "",
                        "\tif (sb_rdonly(sb)) {",
                        "\t\tstruct gfs2_holder freeze_gh;",
                        "",
                        "\t\terror = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED,",
                        "\t\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT,",
                        "\t\t\t\t\t   &freeze_gh);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"can't make FS RO: %d\\n\", error);",
                        "\t\t\tgoto fail_per_node;",
                        "\t\t}",
                        "\t\tgfs2_glock_dq_uninit(&freeze_gh);",
                        "\t} else {",
                        "\t\terror = gfs2_make_fs_rw(sdp);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"can't make FS RW: %d\\n\", error);",
                        "\t\t\tgoto fail_per_node;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tgfs2_glock_dq_uninit(&mount_gh);",
                        "\tgfs2_online_uevent(sdp);",
                        "\treturn 0;",
                        "",
                        "fail_per_node:",
                        "\tinit_per_node(sdp, UNDO);",
                        "fail_inodes:",
                        "\tinit_inodes(sdp, UNDO);",
                        "fail_sb:",
                        "\tif (sdp->sd_root_dir)",
                        "\t\tdput(sdp->sd_root_dir);",
                        "\tif (sdp->sd_master_dir)",
                        "\t\tdput(sdp->sd_master_dir);",
                        "\tif (sb->s_root)",
                        "\t\tdput(sb->s_root);",
                        "\tsb->s_root = NULL;",
                        "fail_locking:",
                        "\tinit_locking(sdp, &mount_gh, UNDO);",
                        "fail_lm:",
                        "\tcomplete_all(&sdp->sd_journal_ready);",
                        "\tgfs2_gl_hash_clear(sdp);",
                        "\tgfs2_lm_unmount(sdp);",
                        "fail_debug:",
                        "\tgfs2_delete_debugfs_file(sdp);",
                        "\t/* gfs2_sys_fs_del must be the last thing we do, since it causes",
                        "\t * sysfs to call function gfs2_sbd_release, which frees sdp. */",
                        "\tgfs2_sys_fs_del(sdp);",
                        "\tsb->s_fs_info = NULL;",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 1002,
                    "highlight": 1018
                }
            ],
            "ins_idx": 10352,
            "addr": "0xffffffff8137f77f"
        },
        "18238": {
            "name": "+0x66",
            "parent_idx": 18232,
            "source_line": [
                {
                    "file": "fs/gfs2/ops_fstype.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=549738f15da0e5a00275977623be199fbbf7df50#n82",
                    "code": [
                        "static struct gfs2_sbd *init_sbd(struct super_block *sb)",
                        "{",
                        "\tstruct gfs2_sbd *sdp;",
                        "\tstruct address_space *mapping;",
                        "",
                        "\tsdp = kzalloc(sizeof(struct gfs2_sbd), GFP_KERNEL);",
                        "\tif (!sdp)",
                        "\t\treturn NULL;",
                        "",
                        "\tsdp->sd_vfs = sb;",
                        "\tsdp->sd_lkstats = alloc_percpu(struct gfs2_pcpu_lkstats);",
                        "\tif (!sdp->sd_lkstats)",
                        "\t\tgoto fail;",
                        "\tsb->s_fs_info = sdp;",
                        "",
                        "\tset_bit(SDF_NOJOURNALID, &sdp->sd_flags);",
                        "\tgfs2_tune_init(&sdp->sd_tune);",
                        "",
                        "\tinit_waitqueue_head(&sdp->sd_glock_wait);",
                        "\tinit_waitqueue_head(&sdp->sd_async_glock_wait);",
                        "\tatomic_set(&sdp->sd_glock_disposal, 0);",
                        "\tinit_completion(&sdp->sd_locking_init);",
                        "\tinit_completion(&sdp->sd_wdack);",
                        "\tspin_lock_init(&sdp->sd_statfs_spin);",
                        "",
                        "\tspin_lock_init(&sdp->sd_rindex_spin);",
                        "\tsdp->sd_rindex_tree.rb_node = NULL;",
                        "",
                        "\tINIT_LIST_HEAD(&sdp->sd_jindex_list);",
                        "\tspin_lock_init(&sdp->sd_jindex_spin);",
                        "\tmutex_init(&sdp->sd_jindex_mutex);",
                        "\tinit_completion(&sdp->sd_journal_ready);",
                        "",
                        "\tINIT_LIST_HEAD(&sdp->sd_quota_list);",
                        "\tmutex_init(&sdp->sd_quota_mutex);",
                        "\tmutex_init(&sdp->sd_quota_sync_mutex);",
                        "\tinit_waitqueue_head(&sdp->sd_quota_wait);",
                        "\tINIT_LIST_HEAD(&sdp->sd_trunc_list);",
                        "\tspin_lock_init(&sdp->sd_trunc_lock);",
                        "\tspin_lock_init(&sdp->sd_bitmap_lock);",
                        "",
                        "\tmapping = &sdp->sd_aspace;",
                        "",
                        "\taddress_space_init_once(mapping);",
                        "\tmapping->a_ops = &gfs2_rgrp_aops;",
                        "\tmapping->host = sb->s_bdev->bd_inode;",
                        "\tmapping->flags = 0;",
                        "\tmapping_set_gfp_mask(mapping, GFP_NOFS);",
                        "\tmapping->private_data = NULL;",
                        "\tmapping->writeback_index = 0;",
                        "",
                        "\tspin_lock_init(&sdp->sd_log_lock);",
                        "\tatomic_set(&sdp->sd_log_pinned, 0);",
                        "\tINIT_LIST_HEAD(&sdp->sd_log_revokes);",
                        "\tINIT_LIST_HEAD(&sdp->sd_log_ordered);",
                        "\tspin_lock_init(&sdp->sd_ordered_lock);",
                        "",
                        "\tinit_waitqueue_head(&sdp->sd_log_waitq);",
                        "\tinit_waitqueue_head(&sdp->sd_logd_waitq);",
                        "\tspin_lock_init(&sdp->sd_ail_lock);",
                        "\tINIT_LIST_HEAD(&sdp->sd_ail1_list);",
                        "\tINIT_LIST_HEAD(&sdp->sd_ail2_list);",
                        "",
                        "\tinit_rwsem(&sdp->sd_log_flush_lock);",
                        "\tatomic_set(&sdp->sd_log_in_flight, 0);",
                        "\tatomic_set(&sdp->sd_reserving_log, 0);",
                        "\tinit_waitqueue_head(&sdp->sd_reserving_log_wait);",
                        "\tinit_waitqueue_head(&sdp->sd_log_flush_wait);",
                        "\tatomic_set(&sdp->sd_freeze_state, SFS_UNFROZEN);",
                        "\tmutex_init(&sdp->sd_freeze_mutex);",
                        "",
                        "\treturn sdp;",
                        "",
                        "fail:",
                        "\tfree_sbd(sdp);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 72,
                    "highlight": 82
                },
                {
                    "file": "fs/gfs2/ops_fstype.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=549738f15da0e5a00275977623be199fbbf7df50#n1018",
                    "code": [
                        "/**",
                        " * gfs2_fill_super - Read in superblock",
                        " * @sb: The VFS superblock",
                        " * @args: Mount options",
                        " * @silent: Don't complain if it's not a GFS2 filesystem",
                        " *",
                        " * Returns: -errno",
                        " */",
                        "static int gfs2_fill_super(struct super_block *sb, struct fs_context *fc)",
                        "{",
                        "\tstruct gfs2_args *args = fc->fs_private;",
                        "\tint silent = fc->sb_flags & SB_SILENT;",
                        "\tstruct gfs2_sbd *sdp;",
                        "\tstruct gfs2_holder mount_gh;",
                        "\tint error;",
                        "",
                        "\tsdp = init_sbd(sb);",
                        "\tif (!sdp) {",
                        "\t\tpr_warn(\"can't alloc struct gfs2_sbd\\n\");",
                        "\t\treturn -ENOMEM;",
                        "\t}",
                        "\tsdp->sd_args = *args;",
                        "",
                        "\tif (sdp->sd_args.ar_spectator) {",
                        "                sb->s_flags |= SB_RDONLY;",
                        "\t\tset_bit(SDF_RORECOVERY, &sdp->sd_flags);",
                        "\t}",
                        "\tif (sdp->sd_args.ar_posix_acl)",
                        "\t\tsb->s_flags |= SB_POSIXACL;",
                        "\tif (sdp->sd_args.ar_nobarrier)",
                        "\t\tset_bit(SDF_NOBARRIERS, &sdp->sd_flags);",
                        "",
                        "\tsb->s_flags |= SB_NOSEC;",
                        "\tsb->s_magic = GFS2_MAGIC;",
                        "\tsb->s_op = &gfs2_super_ops;",
                        "\tsb->s_d_op = &gfs2_dops;",
                        "\tsb->s_export_op = &gfs2_export_ops;",
                        "\tsb->s_xattr = gfs2_xattr_handlers;",
                        "\tsb->s_qcop = &gfs2_quotactl_ops;",
                        "\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;",
                        "\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;",
                        "\tsb->s_time_gran = 1;",
                        "\tsb->s_maxbytes = MAX_LFS_FILESIZE;",
                        "",
                        "\t/* Set up the buffer cache and fill in some fake block size values",
                        "\t   to allow us to read-in the on-disk superblock. */",
                        "\tsdp->sd_sb.sb_bsize = sb_min_blocksize(sb, GFS2_BASIC_BLOCK);",
                        "\tsdp->sd_sb.sb_bsize_shift = sb->s_blocksize_bits;",
                        "\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -",
                        "                               GFS2_BASIC_BLOCK_SHIFT;",
                        "\tsdp->sd_fsb2bb = BIT(sdp->sd_fsb2bb_shift);",
                        "",
                        "\tsdp->sd_tune.gt_logd_secs = sdp->sd_args.ar_commit;",
                        "\tsdp->sd_tune.gt_quota_quantum = sdp->sd_args.ar_quota_quantum;",
                        "\tif (sdp->sd_args.ar_statfs_quantum) {",
                        "\t\tsdp->sd_tune.gt_statfs_slow = 0;",
                        "\t\tsdp->sd_tune.gt_statfs_quantum = sdp->sd_args.ar_statfs_quantum;",
                        "\t} else {",
                        "\t\tsdp->sd_tune.gt_statfs_slow = 1;",
                        "\t\tsdp->sd_tune.gt_statfs_quantum = 30;",
                        "\t}",
                        "",
                        "\terror = init_names(sdp, silent);",
                        "\tif (error) {",
                        "\t\t/* In this case, we haven't initialized sysfs, so we have to",
                        "\t\t   manually free the sdp. */",
                        "\t\tfree_sbd(sdp);",
                        "\t\tsb->s_fs_info = NULL;",
                        "\t\treturn error;",
                        "\t}",
                        "",
                        "\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s\", sdp->sd_table_name);",
                        "",
                        "\terror = gfs2_sys_fs_add(sdp);",
                        "\t/*",
                        "\t * If we hit an error here, gfs2_sys_fs_add will have called function",
                        "\t * kobject_put which causes the sysfs usage count to go to zero, which",
                        "\t * causes sysfs to call function gfs2_sbd_release, which frees sdp.",
                        "\t * Subsequent error paths here will call gfs2_sys_fs_del, which also",
                        "\t * kobject_put to free sdp.",
                        "\t */",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "\tgfs2_create_debugfs_file(sdp);",
                        "",
                        "\terror = gfs2_lm_mount(sdp, silent);",
                        "\tif (error)",
                        "\t\tgoto fail_debug;",
                        "",
                        "\terror = init_locking(sdp, &mount_gh, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_lm;",
                        "",
                        "\terror = init_sb(sdp, silent);",
                        "\tif (error)",
                        "\t\tgoto fail_locking;",
                        "",
                        "\terror = wait_on_journal(sdp);",
                        "\tif (error)",
                        "\t\tgoto fail_sb;",
                        "",
                        "\t/*",
                        "\t * If user space has failed to join the cluster or some similar",
                        "\t * failure has occurred, then the journal id will contain a",
                        "\t * negative (error) number. This will then be returned to the",
                        "\t * caller (of the mount syscall). We do this even for spectator",
                        "\t * mounts (which just write a jid of 0 to indicate \"ok\" even though",
                        "\t * the jid is unused in the spectator case)",
                        "\t */",
                        "\tif (sdp->sd_lockstruct.ls_jid < 0) {",
                        "\t\terror = sdp->sd_lockstruct.ls_jid;",
                        "\t\tsdp->sd_lockstruct.ls_jid = 0;",
                        "\t\tgoto fail_sb;",
                        "\t}",
                        "",
                        "\tif (sdp->sd_args.ar_spectator)",
                        "\t\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s.s\",",
                        "\t\t\t sdp->sd_table_name);",
                        "\telse",
                        "\t\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s.%u\",",
                        "\t\t\t sdp->sd_table_name, sdp->sd_lockstruct.ls_jid);",
                        "",
                        "\terror = init_inodes(sdp, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_sb;",
                        "",
                        "\terror = init_per_node(sdp, DO);",
                        "\tif (error)",
                        "\t\tgoto fail_inodes;",
                        "",
                        "\terror = gfs2_statfs_init(sdp);",
                        "\tif (error) {",
                        "\t\tfs_err(sdp, \"can't initialize statfs subsystem: %d\\n\", error);",
                        "\t\tgoto fail_per_node;",
                        "\t}",
                        "",
                        "\tif (sb_rdonly(sb)) {",
                        "\t\tstruct gfs2_holder freeze_gh;",
                        "",
                        "\t\terror = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED,",
                        "\t\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT,",
                        "\t\t\t\t\t   &freeze_gh);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"can't make FS RO: %d\\n\", error);",
                        "\t\t\tgoto fail_per_node;",
                        "\t\t}",
                        "\t\tgfs2_glock_dq_uninit(&freeze_gh);",
                        "\t} else {",
                        "\t\terror = gfs2_make_fs_rw(sdp);",
                        "\t\tif (error) {",
                        "\t\t\tfs_err(sdp, \"can't make FS RW: %d\\n\", error);",
                        "\t\t\tgoto fail_per_node;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tgfs2_glock_dq_uninit(&mount_gh);",
                        "\tgfs2_online_uevent(sdp);",
                        "\treturn 0;",
                        "",
                        "fail_per_node:",
                        "\tinit_per_node(sdp, UNDO);",
                        "fail_inodes:",
                        "\tinit_inodes(sdp, UNDO);",
                        "fail_sb:",
                        "\tif (sdp->sd_root_dir)",
                        "\t\tdput(sdp->sd_root_dir);",
                        "\tif (sdp->sd_master_dir)",
                        "\t\tdput(sdp->sd_master_dir);",
                        "\tif (sb->s_root)",
                        "\t\tdput(sb->s_root);",
                        "\tsb->s_root = NULL;",
                        "fail_locking:",
                        "\tinit_locking(sdp, &mount_gh, UNDO);",
                        "fail_lm:",
                        "\tcomplete_all(&sdp->sd_journal_ready);",
                        "\tgfs2_gl_hash_clear(sdp);",
                        "\tgfs2_lm_unmount(sdp);",
                        "fail_debug:",
                        "\tgfs2_delete_debugfs_file(sdp);",
                        "\t/* gfs2_sys_fs_del must be the last thing we do, since it causes",
                        "\t * sysfs to call function gfs2_sbd_release, which frees sdp. */",
                        "\tgfs2_sys_fs_del(sdp);",
                        "\tsb->s_fs_info = NULL;",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 1002,
                    "highlight": 1018
                }
            ],
            "ins_idx": 10843,
            "addr": "0xffffffff8137f766"
        }
    },
    "ins": {
        "694": {
            "name": "mov rax, qword ptr [rax + 0x48]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x48",
            "call_idx": 18874,
            "inputs": [
                33954,
                33955
            ],
            "outputs": [
                33956
            ]
        },
        "1422": {
            "name": "mov rax, qword ptr [rbx + 0x588]",
            "desc": "Heap Use Before Initialization",
            "call_idx": 18873,
            "inputs": [
                33951,
                33952
            ],
            "outputs": [
                33953
            ]
        },
        "2147": {
            "name": "ret ",
            "desc": "Source of base address MEMALLOC 0x0",
            "call_idx": 18236,
            "inputs": [],
            "outputs": [
                32902
            ]
        },
        "2146": {
            "name": "pop rbx",
            "desc": "",
            "call_idx": 18872,
            "inputs": [
                33948,
                33949
            ],
            "outputs": [
                33950
            ]
        },
        "2926": {
            "name": "push rbx",
            "desc": "",
            "call_idx": 18870,
            "inputs": [
                33944,
                33945
            ],
            "outputs": [
                33946
            ]
        },
        "3712": {
            "name": "mov rbx, rdi",
            "desc": "",
            "call_idx": 18866,
            "inputs": [
                33941
            ],
            "outputs": [
                33942
            ]
        },
        "4785": {
            "name": "mov rdi, rbp",
            "desc": "",
            "call_idx": 18864,
            "inputs": [
                33939
            ],
            "outputs": [
                33940
            ]
        },
        "6026": {
            "name": "leave ",
            "desc": "",
            "call_idx": 18863,
            "inputs": [
                33936,
                33937
            ],
            "outputs": [
                33938
            ]
        },
        "6744": {
            "name": "push rbp",
            "desc": "",
            "call_idx": 18846,
            "inputs": [
                33905,
                33906
            ],
            "outputs": [
                33907
            ]
        },
        "7404": {
            "name": "mov rbp, rdi",
            "desc": "",
            "call_idx": 18842,
            "inputs": [
                33901
            ],
            "outputs": [
                33902
            ]
        },
        "7995": {
            "name": "mov rdi, rbp",
            "desc": "",
            "call_idx": 18840,
            "inputs": [
                33899
            ],
            "outputs": [
                33900
            ]
        },
        "9855": {
            "name": "mov rbp, qword ptr [rax + 0x370]",
            "desc": "",
            "call_idx": 18834,
            "inputs": [
                33888,
                33889
            ],
            "outputs": [
                33890
            ]
        },
        "10352": {
            "name": "mov qword ptr [rbx + 0x370], rbp",
            "desc": "",
            "call_idx": 18239,
            "inputs": [
                32908,
                32909
            ],
            "outputs": [
                32910
            ]
        },
        "10843": {
            "name": "mov rbp, rax",
            "desc": "",
            "call_idx": 18238,
            "inputs": [
                32906
            ],
            "outputs": [
                32907
            ]
        }
    },
    "data": {
        "33954": {
            "name": "RAX",
            "ins_idx": 694,
            "value": "0x0",
            "sources": []
        },
        "33955": {
            "name": "[0x48]",
            "ins_idx": 694,
            "value": "0x0",
            "sources": []
        },
        "33956": {
            "name": "RAX",
            "ins_idx": 694,
            "value": "0x0",
            "sources": []
        },
        "33951": {
            "name": "RBX",
            "ins_idx": 1422,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "33952": {
            "name": "[0xffff888235f81588]",
            "ins_idx": 1422,
            "value": "0x0",
            "sources": []
        },
        "33953": {
            "name": "RAX",
            "ins_idx": 1422,
            "value": "0x0",
            "sources": [
                33954
            ]
        },
        "32902": {
            "name": "RAX",
            "ins_idx": 2147,
            "value": "0xffff888235f81000",
            "sources": [
                32906
            ]
        },
        "33948": {
            "name": "RSP",
            "ins_idx": 2146,
            "value": "0xffffc90000293940",
            "sources": []
        },
        "33949": {
            "name": "[0xffffc90000293940]",
            "ins_idx": 2146,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "33950": {
            "name": "RBX",
            "ins_idx": 2146,
            "value": "0xffff888235f81000",
            "sources": [
                33951
            ]
        },
        "33944": {
            "name": "RSP",
            "ins_idx": 2926,
            "value": "0xffffc90000293948",
            "sources": []
        },
        "33945": {
            "name": "RBX",
            "ins_idx": 2926,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "33946": {
            "name": "[0xffffc90000293940]",
            "ins_idx": 2926,
            "value": "0xffff888235f81000",
            "sources": [
                33949
            ]
        },
        "33941": {
            "name": "RDI",
            "ins_idx": 3712,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "33942": {
            "name": "RBX",
            "ins_idx": 3712,
            "value": "0xffff888235f81000",
            "sources": [
                33945
            ]
        },
        "33939": {
            "name": "RBP",
            "ins_idx": 4785,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "33940": {
            "name": "RDI",
            "ins_idx": 4785,
            "value": "0xffff888235f81000",
            "sources": [
                33941
            ]
        },
        "33936": {
            "name": "RBP",
            "ins_idx": 6026,
            "value": "0xffffc90000293a10",
            "sources": []
        },
        "33937": {
            "name": "[0xffffc90000293a10]",
            "ins_idx": 6026,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "33938": {
            "name": "RBP",
            "ins_idx": 6026,
            "value": "0xffff888235f81000",
            "sources": [
                33939
            ]
        },
        "33905": {
            "name": "RSP",
            "ins_idx": 6744,
            "value": "0xffffc90000293a18",
            "sources": []
        },
        "33906": {
            "name": "RBP",
            "ins_idx": 6744,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "33907": {
            "name": "[0xffffc90000293a10]",
            "ins_idx": 6744,
            "value": "0xffff888235f81000",
            "sources": [
                33937
            ]
        },
        "33901": {
            "name": "RDI",
            "ins_idx": 7404,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "33902": {
            "name": "RBP",
            "ins_idx": 7404,
            "value": "0xffff888235f81000",
            "sources": [
                33906
            ]
        },
        "33899": {
            "name": "RBP",
            "ins_idx": 7995,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "33900": {
            "name": "RDI",
            "ins_idx": 7995,
            "value": "0xffff888235f81000",
            "sources": [
                33901
            ]
        },
        "33888": {
            "name": "RAX",
            "ins_idx": 9855,
            "value": "0xffff8882342bd000",
            "sources": []
        },
        "33889": {
            "name": "[0xffff8882342bd370]",
            "ins_idx": 9855,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "33890": {
            "name": "RBP",
            "ins_idx": 9855,
            "value": "0xffff888235f81000",
            "sources": [
                33899
            ]
        },
        "32908": {
            "name": "RBX",
            "ins_idx": 10352,
            "value": "0xffff8882342bd000",
            "sources": []
        },
        "32909": {
            "name": "RBP",
            "ins_idx": 10352,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "32910": {
            "name": "[0xffff8882342bd370]",
            "ins_idx": 10352,
            "value": "0xffff888235f81000",
            "sources": [
                33889
            ]
        },
        "32906": {
            "name": "RAX",
            "ins_idx": 10843,
            "value": "0xffff888235f81000",
            "sources": []
        },
        "32907": {
            "name": "RBP",
            "ins_idx": 10843,
            "value": "0xffff888235f81000",
            "sources": [
                32909
            ]
        }
    },
    "chain": {
        "694": [
            1422
        ],
        "1422": [
            2147,
            2146
        ],
        "2146": [
            2926
        ],
        "2926": [
            3712
        ],
        "3712": [
            4785
        ],
        "4785": [
            6026
        ],
        "6026": [
            6744
        ],
        "6744": [
            7404
        ],
        "7404": [
            7995
        ],
        "7995": [
            9855
        ],
        "9855": [
            10352
        ],
        "10352": [
            10843
        ],
        "10843": [
            2147
        ]
    }
}