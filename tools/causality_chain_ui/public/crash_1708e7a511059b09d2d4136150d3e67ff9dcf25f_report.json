{
    "report": "https://syzkaller.appspot.com/bug?id=1708e7a511059b09d2d4136150d3e67ff9dcf25f",
    "title": "KASAN: slab-out-of-bounds Write in decode_data",
    "call": {
        "37793": {
            "name": "+0x6f",
            "parent_idx": 37788,
            "source_line": [
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n844",
                    "code": [
                        "static void decode_data(struct sixpack *sp, unsigned char inbyte)",
                        "{",
                        "\tunsigned char *buf;",
                        "",
                        "\tif (sp->rx_count != 3) {",
                        "\t\tsp->raw_buf[sp->rx_count++] = inbyte;",
                        "",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\tbuf = sp->raw_buf;",
                        "\tsp->cooked_buf[sp->rx_count_cooked++] =",
                        "\t\tbuf[0] | ((buf[1] << 2) & 0xc0);",
                        "\tsp->cooked_buf[sp->rx_count_cooked++] =",
                        "\t\t(buf[1] & 0x0f) | ((buf[2] << 2) & 0xf0);",
                        "\tsp->cooked_buf[sp->rx_count_cooked++] =",
                        "\t\t(buf[2] & 0x03) | (inbyte << 2);",
                        "\tsp->rx_count = 0;",
                        "}"
                    ],
                    "start": 832,
                    "highlight": 844
                }
            ],
            "ins_idx": 119,
            "addr": "0xffffffff81bbee0f"
        },
        "37788": {
            "name": "decode_data",
            "parent_idx": 31548,
            "source_line": [
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n965",
                    "code": [
                        "static void",
                        "sixpack_decode(struct sixpack *sp, const unsigned char *pre_rbuff, int count)",
                        "{",
                        "\tunsigned char inbyte;",
                        "\tint count1;",
                        "",
                        "\tfor (count1 = 0; count1 < count; count1++) {",
                        "\t\tinbyte = pre_rbuff[count1];",
                        "\t\tif (inbyte == SIXP_FOUND_TNC) {",
                        "\t\t\ttnc_set_sync_state(sp, TNC_IN_SYNC);",
                        "\t\t\tdel_timer(&sp->resync_t);",
                        "\t\t}",
                        "\t\tif ((inbyte & SIXP_PRIO_CMD_MASK) != 0)",
                        "\t\t\tdecode_prio_command(sp, inbyte);",
                        "\t\telse if ((inbyte & SIXP_STD_CMD_MASK) != 0)",
                        "\t\t\tdecode_std_command(sp, inbyte);",
                        "\t\telse if ((sp->status & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK)",
                        "\t\t\tdecode_data(sp, inbyte);",
                        "\t}",
                        "}"
                    ],
                    "start": 951,
                    "highlight": 965
                },
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n968",
                    "code": [
                        "static void",
                        "sixpack_decode(struct sixpack *sp, const unsigned char *pre_rbuff, int count)",
                        "{",
                        "\tunsigned char inbyte;",
                        "\tint count1;",
                        "",
                        "\tfor (count1 = 0; count1 < count; count1++) {",
                        "\t\tinbyte = pre_rbuff[count1];",
                        "\t\tif (inbyte == SIXP_FOUND_TNC) {",
                        "\t\t\ttnc_set_sync_state(sp, TNC_IN_SYNC);",
                        "\t\t\tdel_timer(&sp->resync_t);",
                        "\t\t}",
                        "\t\tif ((inbyte & SIXP_PRIO_CMD_MASK) != 0)",
                        "\t\t\tdecode_prio_command(sp, inbyte);",
                        "\t\telse if ((inbyte & SIXP_STD_CMD_MASK) != 0)",
                        "\t\t\tdecode_std_command(sp, inbyte);",
                        "\t\telse if ((sp->status & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK)",
                        "\t\t\tdecode_data(sp, inbyte);",
                        "\t}",
                        "}"
                    ],
                    "start": 951,
                    "highlight": 968
                },
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n458",
                    "code": [
                        "/*",
                        " * Handle the 'receiver data ready' interrupt.",
                        " * This function is called by the tty module in the kernel when",
                        " * a block of 6pack data has been received, which can now be decapsulated",
                        " * and sent on to some IP layer for further processing.",
                        " */",
                        "static void sixpack_receive_buf(struct tty_struct *tty,",
                        "\tconst unsigned char *cp, char *fp, int count)",
                        "{",
                        "\tstruct sixpack *sp;",
                        "\tint count1;",
                        "",
                        "\tif (!count)",
                        "\t\treturn;",
                        "",
                        "\tsp = sp_get(tty);",
                        "\tif (!sp)",
                        "\t\treturn;",
                        "",
                        "\t/* Read the characters out of the buffer */",
                        "\tcount1 = count;",
                        "\twhile (count) {",
                        "\t\tcount--;",
                        "\t\tif (fp && *fp++) {",
                        "\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))",
                        "\t\t\t\tsp->dev->stats.rx_errors++;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t}",
                        "\tsixpack_decode(sp, cp, count1);",
                        "",
                        "\tsp_put(sp);",
                        "\ttty_unthrottle(tty);",
                        "}"
                    ],
                    "start": 429,
                    "highlight": 458
                },
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n435",
                    "code": [
                        "/*",
                        " * Handle the 'receiver data ready' interrupt.",
                        " * This function is called by the tty module in the kernel when",
                        " * a block of 6pack data has been received, which can now be decapsulated",
                        " * and sent on to some IP layer for further processing.",
                        " */",
                        "static void sixpack_receive_buf(struct tty_struct *tty,",
                        "\tconst unsigned char *cp, char *fp, int count)",
                        "{",
                        "\tstruct sixpack *sp;",
                        "\tint count1;",
                        "",
                        "\tif (!count)",
                        "\t\treturn;",
                        "",
                        "\tsp = sp_get(tty);",
                        "\tif (!sp)",
                        "\t\treturn;",
                        "",
                        "\t/* Read the characters out of the buffer */",
                        "\tcount1 = count;",
                        "\twhile (count) {",
                        "\t\tcount--;",
                        "\t\tif (fp && *fp++) {",
                        "\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))",
                        "\t\t\t\tsp->dev->stats.rx_errors++;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t}",
                        "\tsixpack_decode(sp, cp, count1);",
                        "",
                        "\tsp_put(sp);",
                        "\ttty_unthrottle(tty);",
                        "}"
                    ],
                    "start": 429,
                    "highlight": 435
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81bc0af7"
        },
        "31548": {
            "name": "sixpack_receive_buf(indirect)",
            "parent_idx": 31542,
            "source_line": [
                {
                    "file": "drivers/tty/tty_buffer.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_buffer.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n465",
                    "code": [
                        "/**",
                        " *\ttty_ldisc_receive_buf\t\t-\tforward data to line discipline",
                        " *\t@ld:\tline discipline to process input",
                        " *\t@p:\tchar buffer",
                        " *\t@f:\tTTY_* flags buffer",
                        " *\t@count:\tnumber of bytes to process",
                        " *",
                        " *\tCallers other than flush_to_ldisc() need to exclude the kworker",
                        " *\tfrom concurrent use of the line discipline, see paste_selection().",
                        " *",
                        " *\tReturns the number of bytes processed",
                        " */",
                        "int tty_ldisc_receive_buf(struct tty_ldisc *ld, const unsigned char *p,",
                        "\t\t\t  char *f, int count)",
                        "{",
                        "\tif (ld->ops->receive_buf2)",
                        "\t\tcount = ld->ops->receive_buf2(ld->tty, p, f, count);",
                        "\telse {",
                        "\t\tcount = min_t(int, count, ld->tty->receive_room);",
                        "\t\tif (count && ld->ops->receive_buf)",
                        "\t\t\tld->ops->receive_buf(ld->tty, p, f, count);",
                        "\t}",
                        "\treturn count;",
                        "}"
                    ],
                    "start": 445,
                    "highlight": 465
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8179c83c"
        },
        "31542": {
            "name": "tty_ldisc_receive_buf",
            "parent_idx": 31524,
            "source_line": [
                {
                    "file": "drivers/tty/tty_port.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_port.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n38",
                    "code": [
                        "static int tty_port_default_receive_buf(struct tty_port *port,",
                        "\t\t\t\t\tconst unsigned char *p,",
                        "\t\t\t\t\tconst unsigned char *f, size_t count)",
                        "{",
                        "\tint ret;",
                        "\tstruct tty_struct *tty;",
                        "\tstruct tty_ldisc *disc;",
                        "",
                        "\ttty = READ_ONCE(port->itty);",
                        "\tif (!tty)",
                        "\t\treturn 0;",
                        "",
                        "\tdisc = tty_ldisc_ref(tty);",
                        "\tif (!disc)",
                        "\t\treturn 0;",
                        "",
                        "\tret = tty_ldisc_receive_buf(disc, p, (char *)f, count);",
                        "",
                        "\ttty_ldisc_deref(disc);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 22,
                    "highlight": 38
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8179d7f5"
        },
        "31524": {
            "name": "tty_port_default_receive_buf(indirect)",
            "parent_idx": 15028,
            "source_line": [
                {
                    "file": "drivers/tty/tty_buffer.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_buffer.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n481",
                    "code": [
                        "\tn = port->client_ops->receive_buf(port, p, f, count);",
                        "\tif (n > 0)",
                        "\t\tmemset(p, 0, n);",
                        "\treturn n;",
                        "}"
                    ],
                    "start": 481,
                    "highlight": 481
                },
                {
                    "file": "drivers/tty/tty_buffer.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_buffer.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n533",
                    "code": [
                        "static void flush_to_ldisc(struct work_struct *work)",
                        "{",
                        "\tstruct tty_port *port = container_of(work, struct tty_port, buf.work);",
                        "\tstruct tty_bufhead *buf = &port->buf;",
                        "",
                        "\tmutex_lock(&buf->lock);",
                        "",
                        "\twhile (1) {",
                        "\t\tstruct tty_buffer *head = buf->head;",
                        "\t\tstruct tty_buffer *next;",
                        "\t\tint count;",
                        "",
                        "\t\t/* Ldisc or user is trying to gain exclusive access */",
                        "\t\tif (atomic_read(&buf->priority))",
                        "\t\t\tbreak;",
                        "",
                        "\t\t/* paired w/ release in __tty_buffer_request_room();",
                        "\t\t * ensures commit value read is not stale if the head",
                        "\t\t * is advancing to the next buffer",
                        "\t\t */",
                        "\t\tnext = smp_load_acquire(&head->next);",
                        "\t\t/* paired w/ release in __tty_buffer_request_room() or in",
                        "\t\t * tty_buffer_flush(); ensures we see the committed buffer data",
                        "\t\t */",
                        "\t\tcount = smp_load_acquire(&head->commit) - head->read;",
                        "\t\tif (!count) {",
                        "\t\t\tif (next == NULL)",
                        "\t\t\t\tbreak;",
                        "\t\t\tbuf->head = next;",
                        "\t\t\ttty_buffer_free(port, head);",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "",
                        "\t\tcount = receive_buf(port, head, count);",
                        "\t\tif (!count)",
                        "\t\t\tbreak;",
                        "\t\thead->read += count;",
                        "\t}",
                        "",
                        "\tmutex_unlock(&buf->lock);",
                        "",
                        "}"
                    ],
                    "start": 500,
                    "highlight": 533
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8179cfa8"
        },
        "15028": {
            "name": "flush_to_ldisc(indirect)",
            "parent_idx": 15025,
            "source_line": [
                {
                    "file": "kernel/workqueue.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/workqueue.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n2280",
                    "code": [
                        "/**",
                        " * process_one_work - process single work",
                        " * @worker: self",
                        " * @work: work to process",
                        " *",
                        " * Process @work.  This function contains all the logics necessary to",
                        " * process a single work including synchronization against and",
                        " * interaction with other workers on the same cpu, queueing and",
                        " * flushing.  As long as context requirement is met, any worker can",
                        " * call this function to process a work.",
                        " *",
                        " * CONTEXT:",
                        " * spin_lock_irq(pool->lock) which is released and regrabbed.",
                        " */",
                        "static void process_one_work(struct worker *worker, struct work_struct *work)",
                        "__releases(&pool->lock)",
                        "__acquires(&pool->lock)",
                        "{",
                        "\tstruct pool_workqueue *pwq = get_work_pwq(work);",
                        "\tstruct worker_pool *pool = worker->pool;",
                        "\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;",
                        "\tint work_color;",
                        "\tstruct worker *collision;",
                        "#ifdef CONFIG_LOCKDEP",
                        "\t/*",
                        "\t * It is permissible to free the struct work_struct from",
                        "\t * inside the function that is called from it, this we need to",
                        "\t * take into account for lockdep too.  To avoid bogus \"held",
                        "\t * lock freed\" warnings as well as problems when looking into",
                        "\t * work->lockdep_map, make a copy and use that here.",
                        "\t */",
                        "\tstruct lockdep_map lockdep_map;",
                        "",
                        "\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);",
                        "#endif",
                        "\t/* ensure we're on the correct CPU */",
                        "\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&",
                        "\t\t     raw_smp_processor_id() != pool->cpu);",
                        "",
                        "\t/*",
                        "\t * A single work shouldn't be executed concurrently by",
                        "\t * multiple workers on a single cpu.  Check whether anyone is",
                        "\t * already processing the work.  If so, defer the work to the",
                        "\t * currently executing one.",
                        "\t */",
                        "\tcollision = find_worker_executing_work(pool, work);",
                        "\tif (unlikely(collision)) {",
                        "\t\tmove_linked_works(work, &collision->scheduled, NULL);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* claim and dequeue */",
                        "\tdebug_work_deactivate(work);",
                        "\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);",
                        "\tworker->current_work = work;",
                        "\tworker->current_func = work->func;",
                        "\tworker->current_pwq = pwq;",
                        "\twork_color = get_work_color(work);",
                        "",
                        "\t/*",
                        "\t * Record wq name for cmdline and debug reporting, may get",
                        "\t * overridden through set_worker_desc().",
                        "\t */",
                        "\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);",
                        "",
                        "\tlist_del_init(&work->entry);",
                        "",
                        "\t/*",
                        "\t * CPU intensive works don't participate in concurrency management.",
                        "\t * They're the scheduler's responsibility.  This takes @worker out",
                        "\t * of concurrency management and the next code block will chain",
                        "\t * execution of the pending work items.",
                        "\t */",
                        "\tif (unlikely(cpu_intensive))",
                        "\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);",
                        "",
                        "\t/*",
                        "\t * Wake up another worker if necessary.  The condition is always",
                        "\t * false for normal per-cpu workers since nr_running would always",
                        "\t * be >= 1 at this point.  This is used to chain execution of the",
                        "\t * pending work items for WORKER_NOT_RUNNING workers such as the",
                        "\t * UNBOUND and CPU_INTENSIVE ones.",
                        "\t */",
                        "\tif (need_more_worker(pool))",
                        "\t\twake_up_worker(pool);",
                        "",
                        "\t/*",
                        "\t * Record the last pool and clear PENDING which should be the last",
                        "\t * update to @work.  Also, do this inside @pool->lock so that",
                        "\t * PENDING and queued state changes happen together while IRQ is",
                        "\t * disabled.",
                        "\t */",
                        "\tset_work_pool_and_clear_pending(work, pool->id);",
                        "",
                        "\tspin_unlock_irq(&pool->lock);",
                        "",
                        "\tlock_map_acquire(&pwq->wq->lockdep_map);",
                        "\tlock_map_acquire(&lockdep_map);",
                        "\t/*",
                        "\t * Strictly speaking we should mark the invariant state without holding",
                        "\t * any locks, that is, before these two lock_map_acquire()'s.",
                        "\t *",
                        "\t * However, that would result in:",
                        "\t *",
                        "\t *   A(W1)",
                        "\t *   WFC(C)",
                        "\t *\t\tA(W1)",
                        "\t *\t\tC(C)",
                        "\t *",
                        "\t * Which would create W1->C->W1 dependencies, even though there is no",
                        "\t * actual deadlock possible. There are two solutions, using a",
                        "\t * read-recursive acquire on the work(queue) 'locks', but this will then",
                        "\t * hit the lockdep limitation on recursive locks, or simply discard",
                        "\t * these locks.",
                        "\t *",
                        "\t * AFAICT there is no possible deadlock scenario between the",
                        "\t * flush_work() and complete() primitives (except for single-threaded",
                        "\t * workqueues), so hiding them isn't a problem.",
                        "\t */",
                        "\tlockdep_invariant_state(true);",
                        "\ttrace_workqueue_execute_start(work);",
                        "\tworker->current_func(work);",
                        "\t/*",
                        "\t * While we must be careful to not use \"work\" after this, the trace",
                        "\t * point will only record its address.",
                        "\t */",
                        "\ttrace_workqueue_execute_end(work);",
                        "\tlock_map_release(&lockdep_map);",
                        "\tlock_map_release(&pwq->wq->lockdep_map);",
                        "",
                        "\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {",
                        "\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"",
                        "\t\t       \"     last function: %ps\\n\",",
                        "\t\t       current->comm, preempt_count(), task_pid_nr(current),",
                        "\t\t       worker->current_func);",
                        "\t\tdebug_show_held_locks(current);",
                        "\t\tdump_stack();",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * The following prevents a kworker from hogging CPU on !PREEMPT",
                        "\t * kernels, where a requeueing work item waiting for something to",
                        "\t * happen could deadlock with stop_machine as such work item could",
                        "\t * indefinitely requeue itself while all other CPUs are trapped in",
                        "\t * stop_machine. At the same time, report a quiescent RCU state so",
                        "\t * the same condition doesn't freeze RCU.",
                        "\t */",
                        "\tcond_resched();",
                        "",
                        "\tspin_lock_irq(&pool->lock);",
                        "",
                        "\t/* clear cpu intensive status */",
                        "\tif (unlikely(cpu_intensive))",
                        "\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);",
                        "",
                        "\t/* tag the worker for identification in schedule() */",
                        "\tworker->last_func = worker->current_func;",
                        "",
                        "\t/* we're done with it, release */",
                        "\thash_del(&worker->hentry);",
                        "\tworker->current_work = NULL;",
                        "\tworker->current_func = NULL;",
                        "\tworker->current_pwq = NULL;",
                        "\tpwq_dec_nr_in_flight(pwq, work_color);",
                        "}"
                    ],
                    "start": 2143,
                    "highlight": 2280
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff810d7255"
        },
        "15025": {
            "name": "1079_work_109",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "37789": {
            "name": "+0xa",
            "parent_idx": 37788,
            "source_line": [
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n832",
                    "code": [
                        "static void decode_data(struct sixpack *sp, unsigned char inbyte)",
                        "{",
                        "\tunsigned char *buf;",
                        "",
                        "\tif (sp->rx_count != 3) {",
                        "\t\tsp->raw_buf[sp->rx_count++] = inbyte;",
                        "",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\tbuf = sp->raw_buf;",
                        "\tsp->cooked_buf[sp->rx_count_cooked++] =",
                        "\t\tbuf[0] | ((buf[1] << 2) & 0xc0);",
                        "\tsp->cooked_buf[sp->rx_count_cooked++] =",
                        "\t\t(buf[1] & 0x0f) | ((buf[2] << 2) & 0xf0);",
                        "\tsp->cooked_buf[sp->rx_count_cooked++] =",
                        "\t\t(buf[2] & 0x03) | (inbyte << 2);",
                        "\tsp->rx_count = 0;",
                        "}"
                    ],
                    "start": 832,
                    "highlight": 832
                }
            ],
            "ins_idx": 240,
            "addr": "0xffffffff81bbedaa"
        },
        "37787": {
            "name": "+0x694",
            "parent_idx": 31548,
            "source_line": [
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n965",
                    "code": [
                        "static void",
                        "sixpack_decode(struct sixpack *sp, const unsigned char *pre_rbuff, int count)",
                        "{",
                        "\tunsigned char inbyte;",
                        "\tint count1;",
                        "",
                        "\tfor (count1 = 0; count1 < count; count1++) {",
                        "\t\tinbyte = pre_rbuff[count1];",
                        "\t\tif (inbyte == SIXP_FOUND_TNC) {",
                        "\t\t\ttnc_set_sync_state(sp, TNC_IN_SYNC);",
                        "\t\t\tdel_timer(&sp->resync_t);",
                        "\t\t}",
                        "\t\tif ((inbyte & SIXP_PRIO_CMD_MASK) != 0)",
                        "\t\t\tdecode_prio_command(sp, inbyte);",
                        "\t\telse if ((inbyte & SIXP_STD_CMD_MASK) != 0)",
                        "\t\t\tdecode_std_command(sp, inbyte);",
                        "\t\telse if ((sp->status & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK)",
                        "\t\t\tdecode_data(sp, inbyte);",
                        "\t}",
                        "}"
                    ],
                    "start": 951,
                    "highlight": 965
                },
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n968",
                    "code": [
                        "static void",
                        "sixpack_decode(struct sixpack *sp, const unsigned char *pre_rbuff, int count)",
                        "{",
                        "\tunsigned char inbyte;",
                        "\tint count1;",
                        "",
                        "\tfor (count1 = 0; count1 < count; count1++) {",
                        "\t\tinbyte = pre_rbuff[count1];",
                        "\t\tif (inbyte == SIXP_FOUND_TNC) {",
                        "\t\t\ttnc_set_sync_state(sp, TNC_IN_SYNC);",
                        "\t\t\tdel_timer(&sp->resync_t);",
                        "\t\t}",
                        "\t\tif ((inbyte & SIXP_PRIO_CMD_MASK) != 0)",
                        "\t\t\tdecode_prio_command(sp, inbyte);",
                        "\t\telse if ((inbyte & SIXP_STD_CMD_MASK) != 0)",
                        "\t\t\tdecode_std_command(sp, inbyte);",
                        "\t\telse if ((sp->status & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK)",
                        "\t\t\tdecode_data(sp, inbyte);",
                        "\t}",
                        "}"
                    ],
                    "start": 951,
                    "highlight": 968
                },
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n458",
                    "code": [
                        "/*",
                        " * Handle the 'receiver data ready' interrupt.",
                        " * This function is called by the tty module in the kernel when",
                        " * a block of 6pack data has been received, which can now be decapsulated",
                        " * and sent on to some IP layer for further processing.",
                        " */",
                        "static void sixpack_receive_buf(struct tty_struct *tty,",
                        "\tconst unsigned char *cp, char *fp, int count)",
                        "{",
                        "\tstruct sixpack *sp;",
                        "\tint count1;",
                        "",
                        "\tif (!count)",
                        "\t\treturn;",
                        "",
                        "\tsp = sp_get(tty);",
                        "\tif (!sp)",
                        "\t\treturn;",
                        "",
                        "\t/* Read the characters out of the buffer */",
                        "\tcount1 = count;",
                        "\twhile (count) {",
                        "\t\tcount--;",
                        "\t\tif (fp && *fp++) {",
                        "\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))",
                        "\t\t\t\tsp->dev->stats.rx_errors++;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t}",
                        "\tsixpack_decode(sp, cp, count1);",
                        "",
                        "\tsp_put(sp);",
                        "\ttty_unthrottle(tty);",
                        "}"
                    ],
                    "start": 429,
                    "highlight": 458
                },
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n435",
                    "code": [
                        "/*",
                        " * Handle the 'receiver data ready' interrupt.",
                        " * This function is called by the tty module in the kernel when",
                        " * a block of 6pack data has been received, which can now be decapsulated",
                        " * and sent on to some IP layer for further processing.",
                        " */",
                        "static void sixpack_receive_buf(struct tty_struct *tty,",
                        "\tconst unsigned char *cp, char *fp, int count)",
                        "{",
                        "\tstruct sixpack *sp;",
                        "\tint count1;",
                        "",
                        "\tif (!count)",
                        "\t\treturn;",
                        "",
                        "\tsp = sp_get(tty);",
                        "\tif (!sp)",
                        "\t\treturn;",
                        "",
                        "\t/* Read the characters out of the buffer */",
                        "\tcount1 = count;",
                        "\twhile (count) {",
                        "\t\tcount--;",
                        "\t\tif (fp && *fp++) {",
                        "\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))",
                        "\t\t\t\tsp->dev->stats.rx_errors++;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t}",
                        "\tsixpack_decode(sp, cp, count1);",
                        "",
                        "\tsp_put(sp);",
                        "\ttty_unthrottle(tty);",
                        "}"
                    ],
                    "start": 429,
                    "highlight": 435
                }
            ],
            "ins_idx": 365,
            "addr": "0xffffffff81bc0af4"
        },
        "31556": {
            "name": "+0x35",
            "parent_idx": 31548,
            "source_line": [
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n444",
                    "code": [
                        "/*",
                        " * Handle the 'receiver data ready' interrupt.",
                        " * This function is called by the tty module in the kernel when",
                        " * a block of 6pack data has been received, which can now be decapsulated",
                        " * and sent on to some IP layer for further processing.",
                        " */",
                        "static void sixpack_receive_buf(struct tty_struct *tty,",
                        "\tconst unsigned char *cp, char *fp, int count)",
                        "{",
                        "\tstruct sixpack *sp;",
                        "\tint count1;",
                        "",
                        "\tif (!count)",
                        "\t\treturn;",
                        "",
                        "\tsp = sp_get(tty);",
                        "\tif (!sp)",
                        "\t\treturn;",
                        "",
                        "\t/* Read the characters out of the buffer */",
                        "\tcount1 = count;",
                        "\twhile (count) {",
                        "\t\tcount--;",
                        "\t\tif (fp && *fp++) {",
                        "\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))",
                        "\t\t\t\tsp->dev->stats.rx_errors++;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t}",
                        "\tsixpack_decode(sp, cp, count1);",
                        "",
                        "\tsp_put(sp);",
                        "\ttty_unthrottle(tty);",
                        "}"
                    ],
                    "start": 429,
                    "highlight": 444
                },
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n435",
                    "code": [
                        "/*",
                        " * Handle the 'receiver data ready' interrupt.",
                        " * This function is called by the tty module in the kernel when",
                        " * a block of 6pack data has been received, which can now be decapsulated",
                        " * and sent on to some IP layer for further processing.",
                        " */",
                        "static void sixpack_receive_buf(struct tty_struct *tty,",
                        "\tconst unsigned char *cp, char *fp, int count)",
                        "{",
                        "\tstruct sixpack *sp;",
                        "\tint count1;",
                        "",
                        "\tif (!count)",
                        "\t\treturn;",
                        "",
                        "\tsp = sp_get(tty);",
                        "\tif (!sp)",
                        "\t\treturn;",
                        "",
                        "\t/* Read the characters out of the buffer */",
                        "\tcount1 = count;",
                        "\twhile (count) {",
                        "\t\tcount--;",
                        "\t\tif (fp && *fp++) {",
                        "\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))",
                        "\t\t\t\tsp->dev->stats.rx_errors++;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t}",
                        "\tsixpack_decode(sp, cp, count1);",
                        "",
                        "\tsp_put(sp);",
                        "\ttty_unthrottle(tty);",
                        "}"
                    ],
                    "start": 429,
                    "highlight": 435
                }
            ],
            "ins_idx": 16277,
            "addr": "0xffffffff81bc0495"
        },
        "31554": {
            "name": "+0x79",
            "parent_idx": 31551,
            "source_line": [
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n388",
                    "code": [
                        "static struct sixpack *sp_get(struct tty_struct *tty)",
                        "{",
                        "\tstruct sixpack *sp;",
                        "",
                        "\tread_lock(&disc_data_lock);",
                        "\tsp = tty->disc_data;",
                        "\tif (sp)",
                        "\t\trefcount_inc(&sp->refcnt);",
                        "\tread_unlock(&disc_data_lock);",
                        "",
                        "\treturn sp;",
                        "}"
                    ],
                    "start": 377,
                    "highlight": 388
                }
            ],
            "ins_idx": 16282,
            "addr": "0xffffffff81bbf0f9"
        },
        "31551": {
            "name": "sp_get",
            "parent_idx": 31548,
            "source_line": [
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n444",
                    "code": [
                        "/*",
                        " * Handle the 'receiver data ready' interrupt.",
                        " * This function is called by the tty module in the kernel when",
                        " * a block of 6pack data has been received, which can now be decapsulated",
                        " * and sent on to some IP layer for further processing.",
                        " */",
                        "static void sixpack_receive_buf(struct tty_struct *tty,",
                        "\tconst unsigned char *cp, char *fp, int count)",
                        "{",
                        "\tstruct sixpack *sp;",
                        "\tint count1;",
                        "",
                        "\tif (!count)",
                        "\t\treturn;",
                        "",
                        "\tsp = sp_get(tty);",
                        "\tif (!sp)",
                        "\t\treturn;",
                        "",
                        "\t/* Read the characters out of the buffer */",
                        "\tcount1 = count;",
                        "\twhile (count) {",
                        "\t\tcount--;",
                        "\t\tif (fp && *fp++) {",
                        "\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))",
                        "\t\t\t\tsp->dev->stats.rx_errors++;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t}",
                        "\tsixpack_decode(sp, cp, count1);",
                        "",
                        "\tsp_put(sp);",
                        "\ttty_unthrottle(tty);",
                        "}"
                    ],
                    "start": 429,
                    "highlight": 444
                },
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n435",
                    "code": [
                        "/*",
                        " * Handle the 'receiver data ready' interrupt.",
                        " * This function is called by the tty module in the kernel when",
                        " * a block of 6pack data has been received, which can now be decapsulated",
                        " * and sent on to some IP layer for further processing.",
                        " */",
                        "static void sixpack_receive_buf(struct tty_struct *tty,",
                        "\tconst unsigned char *cp, char *fp, int count)",
                        "{",
                        "\tstruct sixpack *sp;",
                        "\tint count1;",
                        "",
                        "\tif (!count)",
                        "\t\treturn;",
                        "",
                        "\tsp = sp_get(tty);",
                        "\tif (!sp)",
                        "\t\treturn;",
                        "",
                        "\t/* Read the characters out of the buffer */",
                        "\tcount1 = count;",
                        "\twhile (count) {",
                        "\t\tcount--;",
                        "\t\tif (fp && *fp++) {",
                        "\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))",
                        "\t\t\t\tsp->dev->stats.rx_errors++;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t}",
                        "\tsixpack_decode(sp, cp, count1);",
                        "",
                        "\tsp_put(sp);",
                        "\ttty_unthrottle(tty);",
                        "}"
                    ],
                    "start": 429,
                    "highlight": 435
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81bc0490"
        },
        "31553": {
            "name": "+0x1f",
            "parent_idx": 31551,
            "source_line": [
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n382",
                    "code": [
                        "static struct sixpack *sp_get(struct tty_struct *tty)",
                        "{",
                        "\tstruct sixpack *sp;",
                        "",
                        "\tread_lock(&disc_data_lock);",
                        "\tsp = tty->disc_data;",
                        "\tif (sp)",
                        "\t\trefcount_inc(&sp->refcnt);",
                        "\tread_unlock(&disc_data_lock);",
                        "",
                        "\treturn sp;",
                        "}"
                    ],
                    "start": 377,
                    "highlight": 382
                }
            ],
            "ins_idx": 16288,
            "addr": "0xffffffff81bbf09f"
        },
        "3982": {
            "name": "+0x3b2",
            "parent_idx": 3873,
            "source_line": [
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n624",
                    "code": [
                        "/*",
                        " * Open the high-level part of the 6pack channel.",
                        " * This function is called by the TTY module when the",
                        " * 6pack line discipline is called for.  Because we are",
                        " * sure the tty line exists, we only have to link it to",
                        " * a free 6pcack channel...",
                        " */",
                        "static int sixpack_open(struct tty_struct *tty)",
                        "{",
                        "\tchar *rbuff = NULL, *xbuff = NULL;",
                        "\tstruct net_device *dev;",
                        "\tstruct sixpack *sp;",
                        "\tunsigned long len;",
                        "\tint err = 0;",
                        "",
                        "\tif (!capable(CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "\tif (tty->ops->write == NULL)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tdev = alloc_netdev(sizeof(struct sixpack), \"sp%d\", NET_NAME_UNKNOWN,",
                        "\t\t\t   sp_setup);",
                        "\tif (!dev) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tsp = netdev_priv(dev);",
                        "\tsp->dev = dev;",
                        "",
                        "\tspin_lock_init(&sp->lock);",
                        "\trefcount_set(&sp->refcnt, 1);",
                        "\tinit_completion(&sp->dead);",
                        "",
                        "\t/* !!! length of the buffers. MTU is IP MTU, not PACLEN!  */",
                        "",
                        "\tlen = dev->mtu * 2;",
                        "",
                        "\trbuff = kmalloc(len + 4, GFP_KERNEL);",
                        "\txbuff = kmalloc(len + 4, GFP_KERNEL);",
                        "",
                        "\tif (rbuff == NULL || xbuff == NULL) {",
                        "\t\terr = -ENOBUFS;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "",
                        "\tspin_lock_bh(&sp->lock);",
                        "",
                        "\tsp->tty = tty;",
                        "",
                        "\tsp->rbuff\t= rbuff;",
                        "\tsp->xbuff\t= xbuff;",
                        "",
                        "\tsp->mtu\t\t= AX25_MTU + 73;",
                        "\tsp->buffsize\t= len;",
                        "\tsp->rcount\t= 0;",
                        "\tsp->rx_count\t= 0;",
                        "\tsp->rx_count_cooked = 0;",
                        "\tsp->xleft\t= 0;",
                        "",
                        "\tsp->flags\t= 0;\t\t/* Clear ESCAPE & ERROR flags */",
                        "",
                        "\tsp->duplex\t= 0;",
                        "\tsp->tx_delay    = SIXP_TXDELAY;",
                        "\tsp->persistence = SIXP_PERSIST;",
                        "\tsp->slottime    = SIXP_SLOTTIME;",
                        "\tsp->led_state   = 0x60;",
                        "\tsp->status      = 1;",
                        "\tsp->status1     = 1;",
                        "\tsp->status2     = 0;",
                        "\tsp->tx_enable   = 0;",
                        "",
                        "\tnetif_start_queue(dev);",
                        "",
                        "\ttimer_setup(&sp->tx_t, sp_xmit_on_air, 0);",
                        "",
                        "\ttimer_setup(&sp->resync_t, resync_tnc, 0);",
                        "",
                        "\tspin_unlock_bh(&sp->lock);",
                        "",
                        "\t/* Done.  We have linked the TTY line to a channel. */",
                        "\ttty->disc_data = sp;",
                        "\ttty->receive_room = 65536;",
                        "",
                        "\t/* Now we're ready to register. */",
                        "\terr = register_netdev(dev);",
                        "\tif (err)",
                        "\t\tgoto out_free;",
                        "",
                        "\ttnc_init(sp);",
                        "",
                        "\treturn 0;",
                        "",
                        "out_free:",
                        "\tkfree(xbuff);",
                        "\tkfree(rbuff);",
                        "",
                        "\tfree_netdev(dev);",
                        "",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 543,
                    "highlight": 624
                }
            ],
            "ins_idx": 16294,
            "addr": "0xffffffff81bc0332"
        },
        "3873": {
            "name": "sixpack_open(indirect)",
            "parent_idx": 3869,
            "source_line": [
                {
                    "file": "drivers/tty/tty_ldisc.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_ldisc.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n464",
                    "code": [
                        "static int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)",
                        "{",
                        "\tWARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &tty->flags));",
                        "\tif (ld->ops->open) {",
                        "\t\tint ret;",
                        "                /* BTM here locks versus a hangup event */",
                        "\t\tret = ld->ops->open(tty);",
                        "\t\tif (ret)",
                        "\t\t\tclear_bit(TTY_LDISC_OPEN, &tty->flags);",
                        "",
                        "\t\ttty_ldisc_debug(tty, \"%p: opened\\n\", ld);",
                        "\t\treturn ret;",
                        "\t}",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 458,
                    "highlight": 464
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8179ba00"
        },
        "3869": {
            "name": "tty_ldisc_open",
            "parent_idx": 3736,
            "source_line": [
                {
                    "file": "drivers/tty/tty_ldisc.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_ldisc.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n591",
                    "code": [
                        "int tty_set_ldisc(struct tty_struct *tty, int disc)",
                        "{",
                        "\tint retval;",
                        "\tstruct tty_ldisc *old_ldisc, *new_ldisc;",
                        "",
                        "\tnew_ldisc = tty_ldisc_get(tty, disc);",
                        "\tif (IS_ERR(new_ldisc))",
                        "\t\treturn PTR_ERR(new_ldisc);",
                        "",
                        "\ttty_lock(tty);",
                        "\tretval = tty_ldisc_lock(tty, 5 * HZ);",
                        "\tif (retval)",
                        "\t\tgoto err;",
                        "",
                        "\tif (!tty->ldisc) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\t/* Check the no-op case */",
                        "\tif (tty->ldisc->ops->num == disc)",
                        "\t\tgoto out;",
                        "",
                        "\tif (test_bit(TTY_HUPPED, &tty->flags)) {",
                        "\t\t/* We were raced by hangup */",
                        "\t\tretval = -EIO;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\told_ldisc = tty->ldisc;",
                        "",
                        "\t/* Shutdown the old discipline. */",
                        "\ttty_ldisc_close(tty, old_ldisc);",
                        "",
                        "\t/* Now set up the new line discipline. */",
                        "\ttty->ldisc = new_ldisc;",
                        "\ttty_set_termios_ldisc(tty, disc);",
                        "",
                        "\tretval = tty_ldisc_open(tty, new_ldisc);",
                        "\tif (retval < 0) {",
                        "\t\t/* Back to the old one or N_TTY if we can't */",
                        "\t\ttty_ldisc_put(new_ldisc);",
                        "\t\ttty_ldisc_restore(tty, old_ldisc);",
                        "\t}",
                        "",
                        "\tif (tty->ldisc->ops->num != old_ldisc->ops->num && tty->ops->set_ldisc) {",
                        "\t\tdown_read(&tty->termios_rwsem);",
                        "\t\ttty->ops->set_ldisc(tty);",
                        "\t\tup_read(&tty->termios_rwsem);",
                        "\t}",
                        "",
                        "\t/* At this point we hold a reference to the new ldisc and a",
                        "\t   reference to the old ldisc, or we hold two references to",
                        "\t   the old ldisc (if it was restored as part of error cleanup",
                        "\t   above). In either case, releasing a single reference from",
                        "\t   the old ldisc is correct. */",
                        "\tnew_ldisc = old_ldisc;",
                        "out:",
                        "\ttty_ldisc_unlock(tty);",
                        "",
                        "\t/* Restart the work queue in case no characters kick it off. Safe if",
                        "\t   already running */",
                        "\ttty_buffer_restart_work(tty->port);",
                        "err:",
                        "\ttty_ldisc_put(new_ldisc);\t/* drop the extra reference */",
                        "\ttty_unlock(tty);",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 553,
                    "highlight": 591
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8179c132"
        },
        "3736": {
            "name": "tty_set_ldisc",
            "parent_idx": 3726,
            "source_line": [
                {
                    "file": "drivers/tty/tty_io.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_io.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n2337",
                    "code": [
                        "static int tiocsetd(struct tty_struct *tty, int __user *p)",
                        "{",
                        "\tint disc;",
                        "\tint ret;",
                        "",
                        "\tif (get_user(disc, p))",
                        "\t\treturn -EFAULT;",
                        "",
                        "\tret = tty_set_ldisc(tty, disc);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2329,
                    "highlight": 2337
                },
                {
                    "file": "drivers/tty/tty_io.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_io.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n2597",
                    "code": [
                        "/*",
                        " * Split this up, as gcc can choke on it otherwise..",
                        " */",
                        "long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tstruct tty_struct *tty = file_tty(file);",
                        "\tstruct tty_struct *real_tty;",
                        "\tvoid __user *p = (void __user *)arg;",
                        "\tint retval;",
                        "\tstruct tty_ldisc *ld;",
                        "",
                        "\tif (tty_paranoia_check(tty, file_inode(file), \"tty_ioctl\"))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\treal_tty = tty_pair_get_tty(tty);",
                        "",
                        "\t/*",
                        "\t * Factor out some common prep work",
                        "\t */",
                        "\tswitch (cmd) {",
                        "\tcase TIOCSETD:",
                        "\tcase TIOCSBRK:",
                        "\tcase TIOCCBRK:",
                        "\tcase TCSBRK:",
                        "\tcase TCSBRKP:",
                        "\t\tretval = tty_check_change(tty);",
                        "\t\tif (retval)",
                        "\t\t\treturn retval;",
                        "\t\tif (cmd != TIOCCBRK) {",
                        "\t\t\ttty_wait_until_sent(tty, 0);",
                        "\t\t\tif (signal_pending(current))",
                        "\t\t\t\treturn -EINTR;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t *\tNow do the stuff.",
                        "\t */",
                        "\tswitch (cmd) {",
                        "\tcase TIOCSTI:",
                        "\t\treturn tiocsti(tty, p);",
                        "\tcase TIOCGWINSZ:",
                        "\t\treturn tiocgwinsz(real_tty, p);",
                        "\tcase TIOCSWINSZ:",
                        "\t\treturn tiocswinsz(real_tty, p);",
                        "\tcase TIOCCONS:",
                        "\t\treturn real_tty != tty ? -EINVAL : tioccons(file);",
                        "\tcase TIOCEXCL:",
                        "\t\tset_bit(TTY_EXCLUSIVE, &tty->flags);",
                        "\t\treturn 0;",
                        "\tcase TIOCNXCL:",
                        "\t\tclear_bit(TTY_EXCLUSIVE, &tty->flags);",
                        "\t\treturn 0;",
                        "\tcase TIOCGEXCL:",
                        "\t{",
                        "\t\tint excl = test_bit(TTY_EXCLUSIVE, &tty->flags);",
                        "\t\treturn put_user(excl, (int __user *)p);",
                        "\t}",
                        "\tcase TIOCGETD:",
                        "\t\treturn tiocgetd(tty, p);",
                        "\tcase TIOCSETD:",
                        "\t\treturn tiocsetd(tty, p);",
                        "\tcase TIOCVHANGUP:",
                        "\t\tif (!capable(CAP_SYS_ADMIN))",
                        "\t\t\treturn -EPERM;",
                        "\t\ttty_vhangup(tty);",
                        "\t\treturn 0;",
                        "\tcase TIOCGDEV:",
                        "\t{",
                        "\t\tunsigned int ret = new_encode_dev(tty_devnum(real_tty));",
                        "\t\treturn put_user(ret, (unsigned int __user *)p);",
                        "\t}",
                        "\t/*",
                        "\t * Break handling",
                        "\t */",
                        "\tcase TIOCSBRK:\t/* Turn break on, unconditionally */",
                        "\t\tif (tty->ops->break_ctl)",
                        "\t\t\treturn tty->ops->break_ctl(tty, -1);",
                        "\t\treturn 0;",
                        "\tcase TIOCCBRK:\t/* Turn break off, unconditionally */",
                        "\t\tif (tty->ops->break_ctl)",
                        "\t\t\treturn tty->ops->break_ctl(tty, 0);",
                        "\t\treturn 0;",
                        "\tcase TCSBRK:   /* SVID version: non-zero arg --> no break */",
                        "\t\t/* non-zero arg means wait for all output data",
                        "\t\t * to be sent (performed above) but don't send break.",
                        "\t\t * This is used by the tcdrain() termios function.",
                        "\t\t */",
                        "\t\tif (!arg)",
                        "\t\t\treturn send_break(tty, 250);",
                        "\t\treturn 0;",
                        "\tcase TCSBRKP:\t/* support for POSIX tcsendbreak() */",
                        "\t\treturn send_break(tty, arg ? arg*100 : 250);",
                        "",
                        "\tcase TIOCMGET:",
                        "\t\treturn tty_tiocmget(tty, p);",
                        "\tcase TIOCMSET:",
                        "\tcase TIOCMBIC:",
                        "\tcase TIOCMBIS:",
                        "\t\treturn tty_tiocmset(tty, cmd, p);",
                        "\tcase TIOCGICOUNT:",
                        "\t\treturn tty_tiocgicount(tty, p);",
                        "\tcase TCFLSH:",
                        "\t\tswitch (arg) {",
                        "\t\tcase TCIFLUSH:",
                        "\t\tcase TCIOFLUSH:",
                        "\t\t/* flush tty buffer and allow ldisc to process ioctl */",
                        "\t\t\ttty_buffer_flush(tty, NULL);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\tcase TIOCSSERIAL:",
                        "\t\treturn tty_tiocsserial(tty, p);",
                        "\tcase TIOCGSERIAL:",
                        "\t\treturn tty_tiocgserial(tty, p);",
                        "\tcase TIOCGPTPEER:",
                        "\t\t/* Special because the struct file is needed */",
                        "\t\treturn ptm_open_peer(file, tty, (int)arg);",
                        "\tdefault:",
                        "\t\tretval = tty_jobctrl_ioctl(tty, real_tty, file, cmd, arg);",
                        "\t\tif (retval != -ENOIOCTLCMD)",
                        "\t\t\treturn retval;",
                        "\t}",
                        "\tif (tty->ops->ioctl) {",
                        "\t\tretval = tty->ops->ioctl(tty, cmd, arg);",
                        "\t\tif (retval != -ENOIOCTLCMD)",
                        "\t\t\treturn retval;",
                        "\t}",
                        "\tld = tty_ldisc_ref_wait(tty);",
                        "\tif (!ld)",
                        "\t\treturn hung_up_tty_ioctl(file, cmd, arg);",
                        "\tretval = -EINVAL;",
                        "\tif (ld->ops->ioctl) {",
                        "\t\tretval = ld->ops->ioctl(tty, file, cmd, arg);",
                        "\t\tif (retval == -ENOIOCTLCMD)",
                        "\t\t\tretval = -ENOTTY;",
                        "\t}",
                        "\ttty_ldisc_deref(ld);",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 2535,
                    "highlight": 2597
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81790aeb"
        },
        "3726": {
            "name": "tty_ioctl(indirect)",
            "parent_idx": 3723,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n47",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 29,
                    "highlight": 47
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n545",
                    "code": [
                        "static int file_ioctl(struct file *filp, unsigned int cmd,",
                        "\t\tunsigned long arg)",
                        "{",
                        "\tstruct inode *inode = file_inode(filp);",
                        "\tint __user *p = (int __user *)arg;",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIBMAP:",
                        "\t\treturn ioctl_fibmap(filp, p);",
                        "\tcase FIONREAD:",
                        "\t\treturn put_user(i_size_read(inode) - filp->f_pos, p);",
                        "\tcase FS_IOC_RESVSP:",
                        "\tcase FS_IOC_RESVSP64:",
                        "\t\treturn ioctl_preallocate(filp, 0, p);",
                        "\tcase FS_IOC_UNRESVSP:",
                        "\tcase FS_IOC_UNRESVSP64:",
                        "\t\treturn ioctl_preallocate(filp, FALLOC_FL_PUNCH_HOLE, p);",
                        "\tcase FS_IOC_ZERO_RANGE:",
                        "\t\treturn ioctl_preallocate(filp, FALLOC_FL_ZERO_RANGE, p);",
                        "\t}",
                        "",
                        "\treturn vfs_ioctl(filp, cmd, arg);",
                        "}"
                    ],
                    "start": 524,
                    "highlight": 545
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n732",
                    "code": [
                        "/*",
                        " * When you add any new common ioctls to the switches above and below",
                        " * please update compat_sys_ioctl() too.",
                        " *",
                        " * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.",
                        " * It's just a simple helper for sys_ioctl and compat_sys_ioctl.",
                        " */",
                        "int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,",
                        "\t     unsigned long arg)",
                        "{",
                        "\tint error = 0;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tstruct inode *inode = file_inode(filp);",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIOCLEX:",
                        "\t\tset_close_on_exec(fd, 1);",
                        "\t\tbreak;",
                        "",
                        "\tcase FIONCLEX:",
                        "\t\tset_close_on_exec(fd, 0);",
                        "\t\tbreak;",
                        "",
                        "\tcase FIONBIO:",
                        "\t\terror = ioctl_fionbio(filp, argp);",
                        "\t\tbreak;",
                        "",
                        "\tcase FIOASYNC:",
                        "\t\terror = ioctl_fioasync(fd, filp, argp);",
                        "\t\tbreak;",
                        "",
                        "\tcase FIOQSIZE:",
                        "\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||",
                        "\t\t    S_ISLNK(inode->i_mode)) {",
                        "\t\t\tloff_t res = inode_get_bytes(inode);",
                        "\t\t\terror = copy_to_user(argp, &res, sizeof(res)) ?",
                        "\t\t\t\t\t-EFAULT : 0;",
                        "\t\t} else",
                        "\t\t\terror = -ENOTTY;",
                        "\t\tbreak;",
                        "",
                        "\tcase FIFREEZE:",
                        "\t\terror = ioctl_fsfreeze(filp);",
                        "\t\tbreak;",
                        "",
                        "\tcase FITHAW:",
                        "\t\terror = ioctl_fsthaw(filp);",
                        "\t\tbreak;",
                        "",
                        "\tcase FS_IOC_FIEMAP:",
                        "\t\treturn ioctl_fiemap(filp, argp);",
                        "",
                        "\tcase FIGETBSZ:",
                        "\t\t/* anon_bdev filesystems may not have a block size */",
                        "\t\tif (!inode->i_sb->s_blocksize)",
                        "\t\t\treturn -EINVAL;",
                        "\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
                        "",
                        "\tcase FICLONE:",
                        "\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);",
                        "",
                        "\tcase FICLONERANGE:",
                        "\t\treturn ioctl_file_clone_range(filp, argp);",
                        "",
                        "\tcase FIDEDUPERANGE:",
                        "\t\treturn ioctl_file_dedupe_range(filp, argp);",
                        "",
                        "\tdefault:",
                        "\t\tif (S_ISREG(inode->i_mode))",
                        "\t\t\terror = file_ioctl(filp, cmd, arg);",
                        "\t\telse",
                        "\t\t\terror = vfs_ioctl(filp, cmd, arg);",
                        "\t\tbreak;",
                        "\t}",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 663,
                    "highlight": 732
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8132b8b8"
        },
        "3723": {
            "name": "do_vfs_ioctl",
            "parent_idx": 3698,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n749",
                    "code": [
                        "int ksys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error;",
                        "\tstruct fd f = fdget(fd);",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (!error)",
                        "\t\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 740,
                    "highlight": 749
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8132bcb4"
        },
        "3698": {
            "name": "ksys_ioctl",
            "parent_idx": 3695,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n756",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\treturn ksys_ioctl(fd, cmd, arg);",
                        "}"
                    ],
                    "start": 754,
                    "highlight": 756
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n754",
                    "code": [
                        "int ksys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error;",
                        "\tstruct fd f = fdget(fd);",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (!error)",
                        "\t\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\treturn ksys_ioctl(fd, cmd, arg);",
                        "}"
                    ],
                    "start": 740,
                    "highlight": 754
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8132bd23"
        },
        "3695": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 3692,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n294",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 281,
                    "highlight": 294
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81003eb5"
        },
        "3692": {
            "name": "do_syscall_64",
            "parent_idx": 3685,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "3685": {
            "name": "200_syscall_8",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "3931": {
            "name": "+0xcb",
            "parent_idx": 3873,
            "source_line": [
                {
                    "file": "./include/linux/netdevice.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/netdevice.h?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n2200",
                    "code": [
                        "/**",
                        " *\tnetdev_priv - access network device private data",
                        " *\t@dev: network device",
                        " *",
                        " * Get network device private data",
                        " */",
                        "static inline void *netdev_priv(const struct net_device *dev)",
                        "{",
                        "\treturn (char *)dev + ALIGN(sizeof(struct net_device), NETDEV_ALIGN);",
                        "}"
                    ],
                    "start": 2192,
                    "highlight": 2200
                },
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n570",
                    "code": [
                        "/*",
                        " * Open the high-level part of the 6pack channel.",
                        " * This function is called by the TTY module when the",
                        " * 6pack line discipline is called for.  Because we are",
                        " * sure the tty line exists, we only have to link it to",
                        " * a free 6pcack channel...",
                        " */",
                        "static int sixpack_open(struct tty_struct *tty)",
                        "{",
                        "\tchar *rbuff = NULL, *xbuff = NULL;",
                        "\tstruct net_device *dev;",
                        "\tstruct sixpack *sp;",
                        "\tunsigned long len;",
                        "\tint err = 0;",
                        "",
                        "\tif (!capable(CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "\tif (tty->ops->write == NULL)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tdev = alloc_netdev(sizeof(struct sixpack), \"sp%d\", NET_NAME_UNKNOWN,",
                        "\t\t\t   sp_setup);",
                        "\tif (!dev) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tsp = netdev_priv(dev);",
                        "\tsp->dev = dev;",
                        "",
                        "\tspin_lock_init(&sp->lock);",
                        "\trefcount_set(&sp->refcnt, 1);",
                        "\tinit_completion(&sp->dead);",
                        "",
                        "\t/* !!! length of the buffers. MTU is IP MTU, not PACLEN!  */",
                        "",
                        "\tlen = dev->mtu * 2;",
                        "",
                        "\trbuff = kmalloc(len + 4, GFP_KERNEL);",
                        "\txbuff = kmalloc(len + 4, GFP_KERNEL);",
                        "",
                        "\tif (rbuff == NULL || xbuff == NULL) {",
                        "\t\terr = -ENOBUFS;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "",
                        "\tspin_lock_bh(&sp->lock);",
                        "",
                        "\tsp->tty = tty;",
                        "",
                        "\tsp->rbuff\t= rbuff;",
                        "\tsp->xbuff\t= xbuff;",
                        "",
                        "\tsp->mtu\t\t= AX25_MTU + 73;",
                        "\tsp->buffsize\t= len;",
                        "\tsp->rcount\t= 0;",
                        "\tsp->rx_count\t= 0;",
                        "\tsp->rx_count_cooked = 0;",
                        "\tsp->xleft\t= 0;",
                        "",
                        "\tsp->flags\t= 0;\t\t/* Clear ESCAPE & ERROR flags */",
                        "",
                        "\tsp->duplex\t= 0;",
                        "\tsp->tx_delay    = SIXP_TXDELAY;",
                        "\tsp->persistence = SIXP_PERSIST;",
                        "\tsp->slottime    = SIXP_SLOTTIME;",
                        "\tsp->led_state   = 0x60;",
                        "\tsp->status      = 1;",
                        "\tsp->status1     = 1;",
                        "\tsp->status2     = 0;",
                        "\tsp->tx_enable   = 0;",
                        "",
                        "\tnetif_start_queue(dev);",
                        "",
                        "\ttimer_setup(&sp->tx_t, sp_xmit_on_air, 0);",
                        "",
                        "\ttimer_setup(&sp->resync_t, resync_tnc, 0);",
                        "",
                        "\tspin_unlock_bh(&sp->lock);",
                        "",
                        "\t/* Done.  We have linked the TTY line to a channel. */",
                        "\ttty->disc_data = sp;",
                        "\ttty->receive_room = 65536;",
                        "",
                        "\t/* Now we're ready to register. */",
                        "\terr = register_netdev(dev);",
                        "\tif (err)",
                        "\t\tgoto out_free;",
                        "",
                        "\ttnc_init(sp);",
                        "",
                        "\treturn 0;",
                        "",
                        "out_free:",
                        "\tkfree(xbuff);",
                        "\tkfree(rbuff);",
                        "",
                        "\tfree_netdev(dev);",
                        "",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 543,
                    "highlight": 570
                }
            ],
            "ins_idx": 16343,
            "addr": "0xffffffff81bc004b"
        },
        "3928": {
            "name": "+0x521",
            "parent_idx": 3882,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n9804",
                    "code": [
                        "/**",
                        " * alloc_netdev_mqs - allocate network device",
                        " * @sizeof_priv: size of private data to allocate space for",
                        " * @name: device name format string",
                        " * @name_assign_type: origin of device name",
                        " * @setup: callback to initialize device",
                        " * @txqs: the number of TX subqueues to allocate",
                        " * @rxqs: the number of RX subqueues to allocate",
                        " *",
                        " * Allocates a struct net_device with private data area for driver use",
                        " * and performs basic initialization.  Also allocates subqueue structs",
                        " * for each queue on the device.",
                        " */",
                        "struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,",
                        "\t\tunsigned char name_assign_type,",
                        "\t\tvoid (*setup)(struct net_device *),",
                        "\t\tunsigned int txqs, unsigned int rxqs)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tunsigned int alloc_size;",
                        "\tstruct net_device *p;",
                        "",
                        "\tBUG_ON(strlen(name) >= sizeof(dev->name));",
                        "",
                        "\tif (txqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\tif (rxqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero RX queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\talloc_size = sizeof(struct net_device);",
                        "\tif (sizeof_priv) {",
                        "\t\t/* ensure 32-byte alignment of private area */",
                        "\t\talloc_size = ALIGN(alloc_size, NETDEV_ALIGN);",
                        "\t\talloc_size += sizeof_priv;",
                        "\t}",
                        "\t/* ensure 32-byte alignment of whole construct */",
                        "\talloc_size += NETDEV_ALIGN - 1;",
                        "",
                        "\tp = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);",
                        "\tif (!p)",
                        "\t\treturn NULL;",
                        "",
                        "\tdev = PTR_ALIGN(p, NETDEV_ALIGN);",
                        "\tdev->padded = (char *)dev - (char *)p;",
                        "",
                        "\tdev->pcpu_refcnt = alloc_percpu(int);",
                        "\tif (!dev->pcpu_refcnt)",
                        "\t\tgoto free_dev;",
                        "",
                        "\tif (dev_addr_init(dev))",
                        "\t\tgoto free_pcpu;",
                        "",
                        "\tdev_mc_init(dev);",
                        "\tdev_uc_init(dev);",
                        "",
                        "\tdev_net_set(dev, &init_net);",
                        "",
                        "\tnetdev_register_lockdep_key(dev);",
                        "",
                        "\tdev->gso_max_size = GSO_MAX_SIZE;",
                        "\tdev->gso_max_segs = GSO_MAX_SEGS;",
                        "\tdev->upper_level = 1;",
                        "\tdev->lower_level = 1;",
                        "",
                        "\tINIT_LIST_HEAD(&dev->napi_list);",
                        "\tINIT_LIST_HEAD(&dev->unreg_list);",
                        "\tINIT_LIST_HEAD(&dev->close_list);",
                        "\tINIT_LIST_HEAD(&dev->link_watch_list);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.upper);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.lower);",
                        "\tINIT_LIST_HEAD(&dev->ptype_all);",
                        "\tINIT_LIST_HEAD(&dev->ptype_specific);",
                        "#ifdef CONFIG_NET_SCHED",
                        "\thash_init(dev->qdisc_hash);",
                        "#endif",
                        "\tdev->priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;",
                        "\tsetup(dev);",
                        "",
                        "\tif (!dev->tx_queue_len) {",
                        "\t\tdev->priv_flags |= IFF_NO_QUEUE;",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t}",
                        "",
                        "\tdev->num_tx_queues = txqs;",
                        "\tdev->real_num_tx_queues = txqs;",
                        "\tif (netif_alloc_netdev_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tdev->num_rx_queues = rxqs;",
                        "\tdev->real_num_rx_queues = rxqs;",
                        "\tif (netif_alloc_rx_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tstrcpy(dev->name, name);",
                        "\tdev->name_assign_type = name_assign_type;",
                        "\tdev->group = INIT_NETDEV_GROUP;",
                        "\tif (!dev->ethtool_ops)",
                        "\t\tdev->ethtool_ops = &default_ethtool_ops;",
                        "",
                        "\tnf_hook_ingress_init(dev);",
                        "",
                        "\treturn dev;",
                        "",
                        "free_all:",
                        "\tfree_netdev(dev);",
                        "\treturn NULL;",
                        "",
                        "free_pcpu:",
                        "\tfree_percpu(dev->pcpu_refcnt);",
                        "free_dev:",
                        "\tnetdev_freemem(dev);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 9687,
                    "highlight": 9804
                }
            ],
            "ins_idx": 11054,
            "addr": "0xffffffff81e09851"
        },
        "3882": {
            "name": "alloc_netdev_mqs",
            "parent_idx": 3873,
            "source_line": [
                {
                    "file": "drivers/net/hamradio/6pack.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/hamradio/6pack.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n563",
                    "code": [
                        "/*",
                        " * Open the high-level part of the 6pack channel.",
                        " * This function is called by the TTY module when the",
                        " * 6pack line discipline is called for.  Because we are",
                        " * sure the tty line exists, we only have to link it to",
                        " * a free 6pcack channel...",
                        " */",
                        "static int sixpack_open(struct tty_struct *tty)",
                        "{",
                        "\tchar *rbuff = NULL, *xbuff = NULL;",
                        "\tstruct net_device *dev;",
                        "\tstruct sixpack *sp;",
                        "\tunsigned long len;",
                        "\tint err = 0;",
                        "",
                        "\tif (!capable(CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "\tif (tty->ops->write == NULL)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tdev = alloc_netdev(sizeof(struct sixpack), \"sp%d\", NET_NAME_UNKNOWN,",
                        "\t\t\t   sp_setup);",
                        "\tif (!dev) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tsp = netdev_priv(dev);",
                        "\tsp->dev = dev;",
                        "",
                        "\tspin_lock_init(&sp->lock);",
                        "\trefcount_set(&sp->refcnt, 1);",
                        "\tinit_completion(&sp->dead);",
                        "",
                        "\t/* !!! length of the buffers. MTU is IP MTU, not PACLEN!  */",
                        "",
                        "\tlen = dev->mtu * 2;",
                        "",
                        "\trbuff = kmalloc(len + 4, GFP_KERNEL);",
                        "\txbuff = kmalloc(len + 4, GFP_KERNEL);",
                        "",
                        "\tif (rbuff == NULL || xbuff == NULL) {",
                        "\t\terr = -ENOBUFS;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "",
                        "\tspin_lock_bh(&sp->lock);",
                        "",
                        "\tsp->tty = tty;",
                        "",
                        "\tsp->rbuff\t= rbuff;",
                        "\tsp->xbuff\t= xbuff;",
                        "",
                        "\tsp->mtu\t\t= AX25_MTU + 73;",
                        "\tsp->buffsize\t= len;",
                        "\tsp->rcount\t= 0;",
                        "\tsp->rx_count\t= 0;",
                        "\tsp->rx_count_cooked = 0;",
                        "\tsp->xleft\t= 0;",
                        "",
                        "\tsp->flags\t= 0;\t\t/* Clear ESCAPE & ERROR flags */",
                        "",
                        "\tsp->duplex\t= 0;",
                        "\tsp->tx_delay    = SIXP_TXDELAY;",
                        "\tsp->persistence = SIXP_PERSIST;",
                        "\tsp->slottime    = SIXP_SLOTTIME;",
                        "\tsp->led_state   = 0x60;",
                        "\tsp->status      = 1;",
                        "\tsp->status1     = 1;",
                        "\tsp->status2     = 0;",
                        "\tsp->tx_enable   = 0;",
                        "",
                        "\tnetif_start_queue(dev);",
                        "",
                        "\ttimer_setup(&sp->tx_t, sp_xmit_on_air, 0);",
                        "",
                        "\ttimer_setup(&sp->resync_t, resync_tnc, 0);",
                        "",
                        "\tspin_unlock_bh(&sp->lock);",
                        "",
                        "\t/* Done.  We have linked the TTY line to a channel. */",
                        "\ttty->disc_data = sp;",
                        "\ttty->receive_room = 65536;",
                        "",
                        "\t/* Now we're ready to register. */",
                        "\terr = register_netdev(dev);",
                        "\tif (err)",
                        "\t\tgoto out_free;",
                        "",
                        "\ttnc_init(sp);",
                        "",
                        "\treturn 0;",
                        "",
                        "out_free:",
                        "\tkfree(xbuff);",
                        "\tkfree(rbuff);",
                        "",
                        "\tfree_netdev(dev);",
                        "",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 543,
                    "highlight": 563
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81bc003a"
        },
        "3926": {
            "name": "+0x50a",
            "parent_idx": 3882,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n9793",
                    "code": [
                        "/**",
                        " * alloc_netdev_mqs - allocate network device",
                        " * @sizeof_priv: size of private data to allocate space for",
                        " * @name: device name format string",
                        " * @name_assign_type: origin of device name",
                        " * @setup: callback to initialize device",
                        " * @txqs: the number of TX subqueues to allocate",
                        " * @rxqs: the number of RX subqueues to allocate",
                        " *",
                        " * Allocates a struct net_device with private data area for driver use",
                        " * and performs basic initialization.  Also allocates subqueue structs",
                        " * for each queue on the device.",
                        " */",
                        "struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,",
                        "\t\tunsigned char name_assign_type,",
                        "\t\tvoid (*setup)(struct net_device *),",
                        "\t\tunsigned int txqs, unsigned int rxqs)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tunsigned int alloc_size;",
                        "\tstruct net_device *p;",
                        "",
                        "\tBUG_ON(strlen(name) >= sizeof(dev->name));",
                        "",
                        "\tif (txqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\tif (rxqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero RX queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\talloc_size = sizeof(struct net_device);",
                        "\tif (sizeof_priv) {",
                        "\t\t/* ensure 32-byte alignment of private area */",
                        "\t\talloc_size = ALIGN(alloc_size, NETDEV_ALIGN);",
                        "\t\talloc_size += sizeof_priv;",
                        "\t}",
                        "\t/* ensure 32-byte alignment of whole construct */",
                        "\talloc_size += NETDEV_ALIGN - 1;",
                        "",
                        "\tp = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);",
                        "\tif (!p)",
                        "\t\treturn NULL;",
                        "",
                        "\tdev = PTR_ALIGN(p, NETDEV_ALIGN);",
                        "\tdev->padded = (char *)dev - (char *)p;",
                        "",
                        "\tdev->pcpu_refcnt = alloc_percpu(int);",
                        "\tif (!dev->pcpu_refcnt)",
                        "\t\tgoto free_dev;",
                        "",
                        "\tif (dev_addr_init(dev))",
                        "\t\tgoto free_pcpu;",
                        "",
                        "\tdev_mc_init(dev);",
                        "\tdev_uc_init(dev);",
                        "",
                        "\tdev_net_set(dev, &init_net);",
                        "",
                        "\tnetdev_register_lockdep_key(dev);",
                        "",
                        "\tdev->gso_max_size = GSO_MAX_SIZE;",
                        "\tdev->gso_max_segs = GSO_MAX_SEGS;",
                        "\tdev->upper_level = 1;",
                        "\tdev->lower_level = 1;",
                        "",
                        "\tINIT_LIST_HEAD(&dev->napi_list);",
                        "\tINIT_LIST_HEAD(&dev->unreg_list);",
                        "\tINIT_LIST_HEAD(&dev->close_list);",
                        "\tINIT_LIST_HEAD(&dev->link_watch_list);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.upper);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.lower);",
                        "\tINIT_LIST_HEAD(&dev->ptype_all);",
                        "\tINIT_LIST_HEAD(&dev->ptype_specific);",
                        "#ifdef CONFIG_NET_SCHED",
                        "\thash_init(dev->qdisc_hash);",
                        "#endif",
                        "\tdev->priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;",
                        "\tsetup(dev);",
                        "",
                        "\tif (!dev->tx_queue_len) {",
                        "\t\tdev->priv_flags |= IFF_NO_QUEUE;",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t}",
                        "",
                        "\tdev->num_tx_queues = txqs;",
                        "\tdev->real_num_tx_queues = txqs;",
                        "\tif (netif_alloc_netdev_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tdev->num_rx_queues = rxqs;",
                        "\tdev->real_num_rx_queues = rxqs;",
                        "\tif (netif_alloc_rx_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tstrcpy(dev->name, name);",
                        "\tdev->name_assign_type = name_assign_type;",
                        "\tdev->group = INIT_NETDEV_GROUP;",
                        "\tif (!dev->ethtool_ops)",
                        "\t\tdev->ethtool_ops = &default_ethtool_ops;",
                        "",
                        "\tnf_hook_ingress_init(dev);",
                        "",
                        "\treturn dev;",
                        "",
                        "free_all:",
                        "\tfree_netdev(dev);",
                        "\treturn NULL;",
                        "",
                        "free_pcpu:",
                        "\tfree_percpu(dev->pcpu_refcnt);",
                        "free_dev:",
                        "\tnetdev_freemem(dev);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 9687,
                    "highlight": 9793
                }
            ],
            "ins_idx": 11159,
            "addr": "0xffffffff81e0983a"
        },
        "3890": {
            "name": "+0x6a",
            "parent_idx": 3882,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n9734",
                    "code": [
                        "/**",
                        " * alloc_netdev_mqs - allocate network device",
                        " * @sizeof_priv: size of private data to allocate space for",
                        " * @name: device name format string",
                        " * @name_assign_type: origin of device name",
                        " * @setup: callback to initialize device",
                        " * @txqs: the number of TX subqueues to allocate",
                        " * @rxqs: the number of RX subqueues to allocate",
                        " *",
                        " * Allocates a struct net_device with private data area for driver use",
                        " * and performs basic initialization.  Also allocates subqueue structs",
                        " * for each queue on the device.",
                        " */",
                        "struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,",
                        "\t\tunsigned char name_assign_type,",
                        "\t\tvoid (*setup)(struct net_device *),",
                        "\t\tunsigned int txqs, unsigned int rxqs)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tunsigned int alloc_size;",
                        "\tstruct net_device *p;",
                        "",
                        "\tBUG_ON(strlen(name) >= sizeof(dev->name));",
                        "",
                        "\tif (txqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\tif (rxqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero RX queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\talloc_size = sizeof(struct net_device);",
                        "\tif (sizeof_priv) {",
                        "\t\t/* ensure 32-byte alignment of private area */",
                        "\t\talloc_size = ALIGN(alloc_size, NETDEV_ALIGN);",
                        "\t\talloc_size += sizeof_priv;",
                        "\t}",
                        "\t/* ensure 32-byte alignment of whole construct */",
                        "\talloc_size += NETDEV_ALIGN - 1;",
                        "",
                        "\tp = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);",
                        "\tif (!p)",
                        "\t\treturn NULL;",
                        "",
                        "\tdev = PTR_ALIGN(p, NETDEV_ALIGN);",
                        "\tdev->padded = (char *)dev - (char *)p;",
                        "",
                        "\tdev->pcpu_refcnt = alloc_percpu(int);",
                        "\tif (!dev->pcpu_refcnt)",
                        "\t\tgoto free_dev;",
                        "",
                        "\tif (dev_addr_init(dev))",
                        "\t\tgoto free_pcpu;",
                        "",
                        "\tdev_mc_init(dev);",
                        "\tdev_uc_init(dev);",
                        "",
                        "\tdev_net_set(dev, &init_net);",
                        "",
                        "\tnetdev_register_lockdep_key(dev);",
                        "",
                        "\tdev->gso_max_size = GSO_MAX_SIZE;",
                        "\tdev->gso_max_segs = GSO_MAX_SEGS;",
                        "\tdev->upper_level = 1;",
                        "\tdev->lower_level = 1;",
                        "",
                        "\tINIT_LIST_HEAD(&dev->napi_list);",
                        "\tINIT_LIST_HEAD(&dev->unreg_list);",
                        "\tINIT_LIST_HEAD(&dev->close_list);",
                        "\tINIT_LIST_HEAD(&dev->link_watch_list);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.upper);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.lower);",
                        "\tINIT_LIST_HEAD(&dev->ptype_all);",
                        "\tINIT_LIST_HEAD(&dev->ptype_specific);",
                        "#ifdef CONFIG_NET_SCHED",
                        "\thash_init(dev->qdisc_hash);",
                        "#endif",
                        "\tdev->priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;",
                        "\tsetup(dev);",
                        "",
                        "\tif (!dev->tx_queue_len) {",
                        "\t\tdev->priv_flags |= IFF_NO_QUEUE;",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t}",
                        "",
                        "\tdev->num_tx_queues = txqs;",
                        "\tdev->real_num_tx_queues = txqs;",
                        "\tif (netif_alloc_netdev_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tdev->num_rx_queues = rxqs;",
                        "\tdev->real_num_rx_queues = rxqs;",
                        "\tif (netif_alloc_rx_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tstrcpy(dev->name, name);",
                        "\tdev->name_assign_type = name_assign_type;",
                        "\tdev->group = INIT_NETDEV_GROUP;",
                        "\tif (!dev->ethtool_ops)",
                        "\t\tdev->ethtool_ops = &default_ethtool_ops;",
                        "",
                        "\tnf_hook_ingress_init(dev);",
                        "",
                        "\treturn dev;",
                        "",
                        "free_all:",
                        "\tfree_netdev(dev);",
                        "\treturn NULL;",
                        "",
                        "free_pcpu:",
                        "\tfree_percpu(dev->pcpu_refcnt);",
                        "free_dev:",
                        "\tnetdev_freemem(dev);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 9687,
                    "highlight": 9734
                }
            ],
            "ins_idx": 12209,
            "addr": "0xffffffff81e0939a"
        },
        "3889": {
            "name": "+0x66",
            "parent_idx": 3882,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n9734",
                    "code": [
                        "/**",
                        " * alloc_netdev_mqs - allocate network device",
                        " * @sizeof_priv: size of private data to allocate space for",
                        " * @name: device name format string",
                        " * @name_assign_type: origin of device name",
                        " * @setup: callback to initialize device",
                        " * @txqs: the number of TX subqueues to allocate",
                        " * @rxqs: the number of RX subqueues to allocate",
                        " *",
                        " * Allocates a struct net_device with private data area for driver use",
                        " * and performs basic initialization.  Also allocates subqueue structs",
                        " * for each queue on the device.",
                        " */",
                        "struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,",
                        "\t\tunsigned char name_assign_type,",
                        "\t\tvoid (*setup)(struct net_device *),",
                        "\t\tunsigned int txqs, unsigned int rxqs)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tunsigned int alloc_size;",
                        "\tstruct net_device *p;",
                        "",
                        "\tBUG_ON(strlen(name) >= sizeof(dev->name));",
                        "",
                        "\tif (txqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\tif (rxqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero RX queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\talloc_size = sizeof(struct net_device);",
                        "\tif (sizeof_priv) {",
                        "\t\t/* ensure 32-byte alignment of private area */",
                        "\t\talloc_size = ALIGN(alloc_size, NETDEV_ALIGN);",
                        "\t\talloc_size += sizeof_priv;",
                        "\t}",
                        "\t/* ensure 32-byte alignment of whole construct */",
                        "\talloc_size += NETDEV_ALIGN - 1;",
                        "",
                        "\tp = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);",
                        "\tif (!p)",
                        "\t\treturn NULL;",
                        "",
                        "\tdev = PTR_ALIGN(p, NETDEV_ALIGN);",
                        "\tdev->padded = (char *)dev - (char *)p;",
                        "",
                        "\tdev->pcpu_refcnt = alloc_percpu(int);",
                        "\tif (!dev->pcpu_refcnt)",
                        "\t\tgoto free_dev;",
                        "",
                        "\tif (dev_addr_init(dev))",
                        "\t\tgoto free_pcpu;",
                        "",
                        "\tdev_mc_init(dev);",
                        "\tdev_uc_init(dev);",
                        "",
                        "\tdev_net_set(dev, &init_net);",
                        "",
                        "\tnetdev_register_lockdep_key(dev);",
                        "",
                        "\tdev->gso_max_size = GSO_MAX_SIZE;",
                        "\tdev->gso_max_segs = GSO_MAX_SEGS;",
                        "\tdev->upper_level = 1;",
                        "\tdev->lower_level = 1;",
                        "",
                        "\tINIT_LIST_HEAD(&dev->napi_list);",
                        "\tINIT_LIST_HEAD(&dev->unreg_list);",
                        "\tINIT_LIST_HEAD(&dev->close_list);",
                        "\tINIT_LIST_HEAD(&dev->link_watch_list);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.upper);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.lower);",
                        "\tINIT_LIST_HEAD(&dev->ptype_all);",
                        "\tINIT_LIST_HEAD(&dev->ptype_specific);",
                        "#ifdef CONFIG_NET_SCHED",
                        "\thash_init(dev->qdisc_hash);",
                        "#endif",
                        "\tdev->priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;",
                        "\tsetup(dev);",
                        "",
                        "\tif (!dev->tx_queue_len) {",
                        "\t\tdev->priv_flags |= IFF_NO_QUEUE;",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t}",
                        "",
                        "\tdev->num_tx_queues = txqs;",
                        "\tdev->real_num_tx_queues = txqs;",
                        "\tif (netif_alloc_netdev_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tdev->num_rx_queues = rxqs;",
                        "\tdev->real_num_rx_queues = rxqs;",
                        "\tif (netif_alloc_rx_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tstrcpy(dev->name, name);",
                        "\tdev->name_assign_type = name_assign_type;",
                        "\tdev->group = INIT_NETDEV_GROUP;",
                        "\tif (!dev->ethtool_ops)",
                        "\t\tdev->ethtool_ops = &default_ethtool_ops;",
                        "",
                        "\tnf_hook_ingress_init(dev);",
                        "",
                        "\treturn dev;",
                        "",
                        "free_all:",
                        "\tfree_netdev(dev);",
                        "\treturn NULL;",
                        "",
                        "free_pcpu:",
                        "\tfree_percpu(dev->pcpu_refcnt);",
                        "free_dev:",
                        "\tnetdev_freemem(dev);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 9687,
                    "highlight": 9734
                }
            ],
            "ins_idx": 12262,
            "addr": "0xffffffff81e09396"
        },
        "3888": {
            "name": "+0x54",
            "parent_idx": 3887,
            "source_line": [
                {
                    "file": "mm/kasan/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/kasan/common.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n74",
                    "code": [
                        "static inline depot_stack_handle_t save_stack(gfp_t flags)",
                        "{",
                        "\tunsigned long entries[KASAN_STACK_DEPTH];",
                        "\tunsigned int nr_entries;",
                        "",
                        "\tnr_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 0);",
                        "\tnr_entries = filter_irq_stacks(entries, nr_entries);",
                        "\treturn stack_depot_save(entries, nr_entries, flags);",
                        "}"
                    ],
                    "start": 66,
                    "highlight": 74
                }
            ],
            "ins_idx": 3166,
            "addr": "0xffffffff812f83d4"
        },
        "3887": {
            "name": "kvmalloc_node",
            "parent_idx": 3882,
            "source_line": [
                {
                    "file": "./include/linux/mm.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/mm.h?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n655",
                    "code": [
                        "extern void *kvmalloc_node(size_t size, gfp_t flags, int node);",
                        "static inline void *kvmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kvmalloc_node(size, flags, NUMA_NO_NODE);",
                        "}"
                    ],
                    "start": 652,
                    "highlight": 655
                },
                {
                    "file": "./include/linux/mm.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/mm.h?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n663",
                    "code": [
                        "extern void *kvmalloc_node(size_t size, gfp_t flags, int node);",
                        "static inline void *kvmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kvmalloc_node(size, flags, NUMA_NO_NODE);",
                        "}",
                        "static inline void *kvzalloc_node(size_t size, gfp_t flags, int node)",
                        "{",
                        "\treturn kvmalloc_node(size, flags | __GFP_ZERO, node);",
                        "}",
                        "static inline void *kvzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kvmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 652,
                    "highlight": 663
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=63de37476ebd1e9bab6a9e17186dc5aa1da9ea99#n9730",
                    "code": [
                        "/**",
                        " * alloc_netdev_mqs - allocate network device",
                        " * @sizeof_priv: size of private data to allocate space for",
                        " * @name: device name format string",
                        " * @name_assign_type: origin of device name",
                        " * @setup: callback to initialize device",
                        " * @txqs: the number of TX subqueues to allocate",
                        " * @rxqs: the number of RX subqueues to allocate",
                        " *",
                        " * Allocates a struct net_device with private data area for driver use",
                        " * and performs basic initialization.  Also allocates subqueue structs",
                        " * for each queue on the device.",
                        " */",
                        "struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,",
                        "\t\tunsigned char name_assign_type,",
                        "\t\tvoid (*setup)(struct net_device *),",
                        "\t\tunsigned int txqs, unsigned int rxqs)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tunsigned int alloc_size;",
                        "\tstruct net_device *p;",
                        "",
                        "\tBUG_ON(strlen(name) >= sizeof(dev->name));",
                        "",
                        "\tif (txqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\tif (rxqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero RX queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\talloc_size = sizeof(struct net_device);",
                        "\tif (sizeof_priv) {",
                        "\t\t/* ensure 32-byte alignment of private area */",
                        "\t\talloc_size = ALIGN(alloc_size, NETDEV_ALIGN);",
                        "\t\talloc_size += sizeof_priv;",
                        "\t}",
                        "\t/* ensure 32-byte alignment of whole construct */",
                        "\talloc_size += NETDEV_ALIGN - 1;",
                        "",
                        "\tp = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);",
                        "\tif (!p)",
                        "\t\treturn NULL;",
                        "",
                        "\tdev = PTR_ALIGN(p, NETDEV_ALIGN);",
                        "\tdev->padded = (char *)dev - (char *)p;",
                        "",
                        "\tdev->pcpu_refcnt = alloc_percpu(int);",
                        "\tif (!dev->pcpu_refcnt)",
                        "\t\tgoto free_dev;",
                        "",
                        "\tif (dev_addr_init(dev))",
                        "\t\tgoto free_pcpu;",
                        "",
                        "\tdev_mc_init(dev);",
                        "\tdev_uc_init(dev);",
                        "",
                        "\tdev_net_set(dev, &init_net);",
                        "",
                        "\tnetdev_register_lockdep_key(dev);",
                        "",
                        "\tdev->gso_max_size = GSO_MAX_SIZE;",
                        "\tdev->gso_max_segs = GSO_MAX_SEGS;",
                        "\tdev->upper_level = 1;",
                        "\tdev->lower_level = 1;",
                        "",
                        "\tINIT_LIST_HEAD(&dev->napi_list);",
                        "\tINIT_LIST_HEAD(&dev->unreg_list);",
                        "\tINIT_LIST_HEAD(&dev->close_list);",
                        "\tINIT_LIST_HEAD(&dev->link_watch_list);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.upper);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.lower);",
                        "\tINIT_LIST_HEAD(&dev->ptype_all);",
                        "\tINIT_LIST_HEAD(&dev->ptype_specific);",
                        "#ifdef CONFIG_NET_SCHED",
                        "\thash_init(dev->qdisc_hash);",
                        "#endif",
                        "\tdev->priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;",
                        "\tsetup(dev);",
                        "",
                        "\tif (!dev->tx_queue_len) {",
                        "\t\tdev->priv_flags |= IFF_NO_QUEUE;",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t}",
                        "",
                        "\tdev->num_tx_queues = txqs;",
                        "\tdev->real_num_tx_queues = txqs;",
                        "\tif (netif_alloc_netdev_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tdev->num_rx_queues = rxqs;",
                        "\tdev->real_num_rx_queues = rxqs;",
                        "\tif (netif_alloc_rx_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tstrcpy(dev->name, name);",
                        "\tdev->name_assign_type = name_assign_type;",
                        "\tdev->group = INIT_NETDEV_GROUP;",
                        "\tif (!dev->ethtool_ops)",
                        "\t\tdev->ethtool_ops = &default_ethtool_ops;",
                        "",
                        "\tnf_hook_ingress_init(dev);",
                        "",
                        "\treturn dev;",
                        "",
                        "free_all:",
                        "\tfree_netdev(dev);",
                        "\treturn NULL;",
                        "",
                        "free_pcpu:",
                        "\tfree_percpu(dev->pcpu_refcnt);",
                        "free_dev:",
                        "\tnetdev_freemem(dev);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 9687,
                    "highlight": 9730
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e09385"
        }
    },
    "ins": {
        "119": {
            "name": "mov byte ptr [rbx + r13 + 0x38], dl",
            "desc": "Invalid Memory Access\nOut of Bound Access.",
            "call_idx": 37793,
            "inputs": [
                73546,
                73547,
                73548
            ],
            "outputs": [
                73549
            ]
        },
        "240": {
            "name": "mov rbx, rdi",
            "desc": "",
            "call_idx": 37789,
            "inputs": [
                73540
            ],
            "outputs": [
                73541
            ]
        },
        "365": {
            "name": "mov rdi, rbp",
            "desc": "",
            "call_idx": 37787,
            "inputs": [
                73538
            ],
            "outputs": [
                73539
            ]
        },
        "16277": {
            "name": "mov rbp, rax",
            "desc": "",
            "call_idx": 31556,
            "inputs": [
                61009
            ],
            "outputs": [
                61010
            ]
        },
        "16282": {
            "name": "mov rax, r12",
            "desc": "",
            "call_idx": 31554,
            "inputs": [
                61006
            ],
            "outputs": [
                61007
            ]
        },
        "16288": {
            "name": "mov r12, qword ptr [r12 + 0x258]",
            "desc": "",
            "call_idx": 31553,
            "inputs": [
                61003,
                61004
            ],
            "outputs": [
                61005
            ]
        },
        "16294": {
            "name": "mov qword ptr [rbx + 0x258], r14",
            "desc": "",
            "call_idx": 3982,
            "inputs": [
                7631,
                7632
            ],
            "outputs": [
                7633
            ]
        },
        "16343": {
            "name": "lea r14, qword ptr [rax + 0x840]",
            "desc": "",
            "call_idx": 3931,
            "inputs": [
                7539
            ],
            "outputs": [
                7540
            ]
        },
        "11054": {
            "name": "mov rax, r15",
            "desc": "",
            "call_idx": 3928,
            "inputs": [
                7532
            ],
            "outputs": [
                7533
            ]
        },
        "11159": {
            "name": "mov r15, rbp",
            "desc": "",
            "call_idx": 3926,
            "inputs": [
                7529
            ],
            "outputs": [
                7530
            ]
        },
        "12209": {
            "name": "and rbp, 0xffffffffffffffe0",
            "desc": "",
            "call_idx": 3890,
            "inputs": [
                7471
            ],
            "outputs": [
                7472
            ]
        },
        "12262": {
            "name": "lea rbp, qword ptr [rax + 0x1f]",
            "desc": "",
            "call_idx": 3889,
            "inputs": [
                7469
            ],
            "outputs": [
                7470
            ]
        },
        "3166": {
            "name": "ret ",
            "desc": "",
            "call_idx": 3888,
            "inputs": [],
            "outputs": [
                7468
            ]
        }
    },
    "data": {
        "73546": {
            "name": "R13",
            "ins_idx": 119,
            "value": "0x496",
            "sources": []
        },
        "73547": {
            "name": "RBX",
            "ins_idx": 119,
            "value": "0xffff8881e78ec840",
            "sources": []
        },
        "73548": {
            "name": "RDX",
            "ins_idx": 119,
            "value": "0x7",
            "sources": []
        },
        "73549": {
            "name": "[0xffff8881e78ecd0e]",
            "ins_idx": 119,
            "value": "0x7",
            "sources": []
        },
        "73540": {
            "name": "RDI",
            "ins_idx": 240,
            "value": "0xffff8881e78ec840",
            "sources": []
        },
        "73541": {
            "name": "RBX",
            "ins_idx": 240,
            "value": "0xffff8881e78ec840",
            "sources": [
                73547
            ]
        },
        "73538": {
            "name": "RBP",
            "ins_idx": 365,
            "value": "0xffff8881e78ec840",
            "sources": []
        },
        "73539": {
            "name": "RDI",
            "ins_idx": 365,
            "value": "0xffff8881e78ec840",
            "sources": [
                73540
            ]
        },
        "61009": {
            "name": "RAX",
            "ins_idx": 16277,
            "value": "0xffff8881e78ec840",
            "sources": []
        },
        "61010": {
            "name": "RBP",
            "ins_idx": 16277,
            "value": "0xffff8881e78ec840",
            "sources": [
                73538
            ]
        },
        "61006": {
            "name": "R12",
            "ins_idx": 16282,
            "value": "0xffff8881e78ec840",
            "sources": []
        },
        "61007": {
            "name": "RAX",
            "ins_idx": 16282,
            "value": "0xffff8881e78ec840",
            "sources": [
                61009
            ]
        },
        "61003": {
            "name": "R12",
            "ins_idx": 16288,
            "value": "0xffff8881f29ce000",
            "sources": []
        },
        "61004": {
            "name": "[0xffff8881f29ce258]",
            "ins_idx": 16288,
            "value": "0xffff8881e78ec840",
            "sources": []
        },
        "61005": {
            "name": "R12",
            "ins_idx": 16288,
            "value": "0xffff8881e78ec840",
            "sources": [
                61006
            ]
        },
        "7631": {
            "name": "RBX",
            "ins_idx": 16294,
            "value": "0xffff8881f29ce000",
            "sources": []
        },
        "7632": {
            "name": "R14",
            "ins_idx": 16294,
            "value": "0xffff8881e78ec840",
            "sources": []
        },
        "7633": {
            "name": "[0xffff8881f29ce258]",
            "ins_idx": 16294,
            "value": "0xffff8881e78ec840",
            "sources": [
                61004
            ]
        },
        "7539": {
            "name": "RAX",
            "ins_idx": 16343,
            "value": "0xffff8881e78ec000",
            "sources": []
        },
        "7540": {
            "name": "R14",
            "ins_idx": 16343,
            "value": "0xffff8881e78ec840",
            "sources": [
                7632
            ]
        },
        "7532": {
            "name": "R15",
            "ins_idx": 11054,
            "value": "0xffff8881e78ec000",
            "sources": []
        },
        "7533": {
            "name": "RAX",
            "ins_idx": 11054,
            "value": "0xffff8881e78ec000",
            "sources": [
                7539
            ]
        },
        "7529": {
            "name": "RBP",
            "ins_idx": 11159,
            "value": "0xffff8881e78ec000",
            "sources": []
        },
        "7530": {
            "name": "R15",
            "ins_idx": 11159,
            "value": "0xffff8881e78ec000",
            "sources": [
                7532
            ]
        },
        "7471": {
            "name": "RBP",
            "ins_idx": 12209,
            "value": "0xffff8881e78ec01f",
            "sources": []
        },
        "7472": {
            "name": "RBP",
            "ins_idx": 12209,
            "value": "0xffff8881e78ec000",
            "sources": [
                7529
            ]
        },
        "7469": {
            "name": "RAX",
            "ins_idx": 12262,
            "value": "0xffff8881e78ec000",
            "sources": []
        },
        "7470": {
            "name": "RBP",
            "ins_idx": 12262,
            "value": "0xffff8881e78ec01f",
            "sources": [
                7471
            ]
        },
        "7468": {
            "name": "RAX",
            "ins_idx": 3166,
            "value": "0xffff8881e78ec000",
            "sources": [
                7469
            ]
        }
    },
    "chain": {
        "119": [
            240
        ],
        "240": [
            365
        ],
        "365": [
            16277
        ],
        "16277": [
            16282
        ],
        "16282": [
            16288
        ],
        "16288": [
            16294
        ],
        "16294": [
            16343
        ],
        "16343": [
            11054
        ],
        "11054": [
            11159
        ],
        "11159": [
            12209
        ],
        "12209": [
            12262
        ],
        "12262": [
            3166
        ]
    }
}