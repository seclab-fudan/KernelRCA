{
    "report": "https://syzkaller.appspot.com/bug?id=396fb46bd515837eaf6e5f542a3829f67757471a",
    "title": "general protection fault in blk_mq_run_hw_queues",
    "call": {
        "7603": {
            "name": "+0x9a",
            "parent_idx": 7584,
            "source_line": [
                {
                    "file": "block/blk-mq.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/block/blk-mq.h?id=dbe69e43372212527abf48609aba7fc39a6daa27#n96",
                    "code": [
                        "/*",
                        " * blk_mq_map_queue_type() - map (hctx_type,cpu) to hardware queue",
                        " * @q: request queue",
                        " * @type: the hctx type index",
                        " * @cpu: CPU",
                        " */",
                        "static inline struct blk_mq_hw_ctx *blk_mq_map_queue_type(struct request_queue *q,",
                        "\t\t\t\t\t\t\t  enum hctx_type type,",
                        "\t\t\t\t\t\t\t  unsigned int cpu)",
                        "{",
                        "\treturn q->queue_hw_ctx[q->tag_set->map[type].mq_map[cpu]];",
                        "}"
                    ],
                    "start": 86,
                    "highlight": 96
                },
                {
                    "file": "block/blk-mq.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/block/blk-mq.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n1663",
                    "code": [
                        "/*",
                        " * Return prefered queue to dispatch from (if any) for non-mq aware IO",
                        " * scheduler.",
                        " */",
                        "static struct blk_mq_hw_ctx *blk_mq_get_sq_hctx(struct request_queue *q)",
                        "{",
                        "\tstruct blk_mq_hw_ctx *hctx;",
                        "",
                        "\t/*",
                        "\t * If the IO scheduler does not respect hardware queues when",
                        "\t * dispatching, we just don't bother with multiple HW queues and",
                        "\t * dispatch from hctx for the current CPU since running multiple queues",
                        "\t * just causes lock contention inside the scheduler and pointless cache",
                        "\t * bouncing.",
                        "\t */",
                        "\thctx = blk_mq_map_queue_type(q, HCTX_TYPE_DEFAULT,",
                        "\t\t\t\t     raw_smp_processor_id());",
                        "\tif (!blk_mq_hctx_stopped(hctx))",
                        "\t\treturn hctx;",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 1648,
                    "highlight": 1663
                },
                {
                    "file": "block/blk-mq.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/block/blk-mq.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n1682",
                    "code": [
                        "/**",
                        " * blk_mq_run_hw_queues - Run all hardware queues in a request queue.",
                        " * @q: Pointer to the request queue to run.",
                        " * @async: If we want to run the queue asynchronously.",
                        " */",
                        "void blk_mq_run_hw_queues(struct request_queue *q, bool async)",
                        "{",
                        "\tstruct blk_mq_hw_ctx *hctx, *sq_hctx;",
                        "\tint i;",
                        "",
                        "\tsq_hctx = NULL;",
                        "\tif (blk_mq_has_sqsched(q))",
                        "\t\tsq_hctx = blk_mq_get_sq_hctx(q);",
                        "\tqueue_for_each_hw_ctx(q, hctx, i) {",
                        "\t\tif (blk_mq_hctx_stopped(hctx))",
                        "\t\t\tcontinue;",
                        "\t\t/*",
                        "\t\t * Dispatch from this hctx either if there's no hctx preferred",
                        "\t\t * by IO scheduler or if it has requests that bypass the",
                        "\t\t * scheduler.",
                        "\t\t */",
                        "\t\tif (!sq_hctx || sq_hctx == hctx ||",
                        "\t\t    !list_empty_careful(&hctx->dispatch))",
                        "\t\t\tblk_mq_run_hw_queue(hctx, async);",
                        "\t}",
                        "}"
                    ],
                    "start": 1670,
                    "highlight": 1682
                }
            ],
            "ins_idx": 88,
            "addr": "0xffffffff813dfd3a"
        },
        "7584": {
            "name": "blk_freeze_queue_start",
            "parent_idx": 7583,
            "source_line": [
                {
                    "file": "block/blk-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/block/blk-core.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n353",
                    "code": [
                        "void blk_set_queue_dying(struct request_queue *q)",
                        "{",
                        "\tblk_queue_flag_set(QUEUE_FLAG_DYING, q);",
                        "",
                        "\t/*",
                        "\t * When queue DYING flag is set, we need to block new req",
                        "\t * entering queue, so we call blk_freeze_queue_start() to",
                        "\t * prevent I/O from crossing blk_queue_enter().",
                        "\t */",
                        "\tblk_freeze_queue_start(q);",
                        "",
                        "\tif (queue_is_mq(q))",
                        "\t\tblk_mq_wake_waiters(q);",
                        "",
                        "\t/* Make blk_queue_enter() reexamine the DYING flag. */",
                        "\twake_up_all(&q->mq_freeze_wq);",
                        "}"
                    ],
                    "start": 344,
                    "highlight": 353
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff813d4e99"
        },
        "7583": {
            "name": "blk_set_queue_dying",
            "parent_idx": 7575,
            "source_line": [
                {
                    "file": "block/blk-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/block/blk-core.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n380",
                    "code": [
                        "/**",
                        " * blk_cleanup_queue - shutdown a request queue",
                        " * @q: request queue to shutdown",
                        " *",
                        " * Mark @q DYING, drain all pending requests, mark @q DEAD, destroy and",
                        " * put it.  All future requests will be failed immediately with -ENODEV.",
                        " *",
                        " * Context: can sleep",
                        " */",
                        "void blk_cleanup_queue(struct request_queue *q)",
                        "{",
                        "\t/* cannot be called from atomic context */",
                        "\tmight_sleep();",
                        "",
                        "\tWARN_ON_ONCE(blk_queue_registered(q));",
                        "",
                        "\t/* mark @q DYING, no new request or merges will be allowed afterwards */",
                        "\tblk_set_queue_dying(q);",
                        "",
                        "\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, q);",
                        "\tblk_queue_flag_set(QUEUE_FLAG_NOXMERGES, q);",
                        "",
                        "\t/*",
                        "\t * Drain all requests queued before DYING marking. Set DEAD flag to",
                        "\t * prevent that blk_mq_run_hw_queues() accesses the hardware queues",
                        "\t * after draining finished.",
                        "\t */",
                        "\tblk_freeze_queue(q);",
                        "",
                        "\trq_qos_exit(q);",
                        "",
                        "\tblk_queue_flag_set(QUEUE_FLAG_DEAD, q);",
                        "",
                        "\t/* for synchronous bio-based driver finish in-flight integrity i/o */",
                        "\tblk_flush_integrity();",
                        "",
                        "\t/* @q won't process any more request, flush async actions */",
                        "\tdel_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer);",
                        "\tblk_sync_queue(q);",
                        "",
                        "\tif (queue_is_mq(q))",
                        "\t\tblk_mq_exit_queue(q);",
                        "",
                        "\t/*",
                        "\t * In theory, request pool of sched_tags belongs to request queue.",
                        "\t * However, the current implementation requires tag_set for freeing",
                        "\t * requests, so free the pool now.",
                        "\t *",
                        "\t * Queue has become frozen, there can't be any in-queue requests, so",
                        "\t * it is safe to free requests now.",
                        "\t */",
                        "\tmutex_lock(&q->sysfs_lock);",
                        "\tif (q->elevator)",
                        "\t\tblk_mq_sched_free_requests(q);",
                        "\tmutex_unlock(&q->sysfs_lock);",
                        "",
                        "\tpercpu_ref_exit(&q->q_usage_counter);",
                        "",
                        "\t/* @q is and will stay empty, shutdown and put */",
                        "\tblk_put_queue(q);",
                        "}"
                    ],
                    "start": 363,
                    "highlight": 380
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff813d4eec"
        },
        "7575": {
            "name": "blk_cleanup_queue",
            "parent_idx": 7573,
            "source_line": [
                {
                    "file": "block/genhd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/block/genhd.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n1324",
                    "code": [
                        "/**",
                        " * blk_cleanup_disk - shutdown a gendisk allocated by blk_alloc_disk",
                        " * @disk: gendisk to shutdown",
                        " *",
                        " * Mark the queue hanging off @disk DYING, drain all pending requests, then mark",
                        " * the queue DEAD, destroy and put it and the gendisk structure.",
                        " *",
                        " * Context: can sleep",
                        " */",
                        "void blk_cleanup_disk(struct gendisk *disk)",
                        "{",
                        "\tblk_cleanup_queue(disk->queue);",
                        "\tput_disk(disk);",
                        "}"
                    ],
                    "start": 1313,
                    "highlight": 1324
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff813e8fc8"
        },
        "7573": {
            "name": "blk_cleanup_disk",
            "parent_idx": 2298,
            "source_line": [
                {
                    "file": "drivers/block/nbd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/block/nbd.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n226",
                    "code": [
                        "static void nbd_dev_remove(struct nbd_device *nbd)",
                        "{",
                        "\tstruct gendisk *disk = nbd->disk;",
                        "",
                        "\tif (disk) {",
                        "\t\tdel_gendisk(disk);",
                        "\t\tblk_mq_free_tag_set(&nbd->tag_set);",
                        "\t\tblk_cleanup_disk(disk);",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Place this in the last just before the nbd is freed to",
                        "\t * make sure that the disk and the related kobject are also",
                        "\t * totally removed to avoid duplicate creation of the same",
                        "\t * one.",
                        "\t */",
                        "\tif (test_bit(NBD_DESTROY_ON_DISCONNECT, &nbd->flags) && nbd->destroy_complete)",
                        "\t\tcomplete(nbd->destroy_complete);",
                        "",
                        "\tkfree(nbd);",
                        "}"
                    ],
                    "start": 219,
                    "highlight": 226
                },
                {
                    "file": "drivers/block/nbd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/block/nbd.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n246",
                    "code": [
                        "static void nbd_put(struct nbd_device *nbd)",
                        "{",
                        "\tif (refcount_dec_and_mutex_lock(&nbd->refs,",
                        "\t\t\t\t\t&nbd_index_mutex)) {",
                        "\t\tidr_remove(&nbd_index_idr, nbd->index);",
                        "\t\tnbd_dev_remove(nbd);",
                        "\t\tmutex_unlock(&nbd_index_mutex);",
                        "\t}",
                        "}"
                    ],
                    "start": 241,
                    "highlight": 246
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816d5478"
        },
        "2298": {
            "name": "nbd_put",
            "parent_idx": 2196,
            "source_line": [
                {
                    "file": "./arch/x86/include/asm/bitops.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./arch/x86/include/asm/bitops.h?id=dbe69e43372212527abf48609aba7fc39a6daa27#n55",
                    "code": [
                        "static __always_inline void",
                        "arch_set_bit(long nr, volatile unsigned long *addr)",
                        "{",
                        "\tif (__builtin_constant_p(nr)) {",
                        "\t\tasm volatile(LOCK_PREFIX \"orb %b1,%0\"",
                        "\t\t\t: CONST_MASK_ADDR(nr, addr)",
                        "\t\t\t: \"iq\" (CONST_MASK(nr))",
                        "\t\t\t: \"memory\");",
                        "\t} else {",
                        "\t\tasm volatile(LOCK_PREFIX __ASM_SIZE(bts) \" %1,%0\"",
                        "\t\t\t: : RLONG_ADDR(addr), \"Ir\" (nr) : \"memory\");",
                        "\t}",
                        "}"
                    ],
                    "start": 51,
                    "highlight": 55
                },
                {
                    "file": "drivers/block/nbd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/block/nbd.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n1957",
                    "code": [
                        "static int nbd_genl_connect(struct sk_buff *skb, struct genl_info *info)",
                        "{",
                        "\tDECLARE_COMPLETION_ONSTACK(destroy_complete);",
                        "\tstruct nbd_device *nbd = NULL;",
                        "\tstruct nbd_config *config;",
                        "\tint index = -1;",
                        "\tint ret;",
                        "\tbool put_dev = false;",
                        "",
                        "\tif (!netlink_capable(skb, CAP_SYS_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\tif (info->attrs[NBD_ATTR_INDEX])",
                        "\t\tindex = nla_get_u32(info->attrs[NBD_ATTR_INDEX]);",
                        "\tif (!info->attrs[NBD_ATTR_SOCKETS]) {",
                        "\t\tprintk(KERN_ERR \"nbd: must specify at least one socket\\n\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "\tif (!info->attrs[NBD_ATTR_SIZE_BYTES]) {",
                        "\t\tprintk(KERN_ERR \"nbd: must specify a size in bytes for the device\\n\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "again:",
                        "\tmutex_lock(&nbd_index_mutex);",
                        "\tif (index == -1) {",
                        "\t\tret = idr_for_each(&nbd_index_idr, &find_free_cb, &nbd);",
                        "\t\tif (ret == 0) {",
                        "\t\t\tint new_index;",
                        "\t\t\tnew_index = nbd_dev_add(-1);",
                        "\t\t\tif (new_index < 0) {",
                        "\t\t\t\tmutex_unlock(&nbd_index_mutex);",
                        "\t\t\t\tprintk(KERN_ERR \"nbd: failed to add new device\\n\");",
                        "\t\t\t\treturn new_index;",
                        "\t\t\t}",
                        "\t\t\tnbd = idr_find(&nbd_index_idr, new_index);",
                        "\t\t}",
                        "\t} else {",
                        "\t\tnbd = idr_find(&nbd_index_idr, index);",
                        "\t\tif (!nbd) {",
                        "\t\t\tret = nbd_dev_add(index);",
                        "\t\t\tif (ret < 0) {",
                        "\t\t\t\tmutex_unlock(&nbd_index_mutex);",
                        "\t\t\t\tprintk(KERN_ERR \"nbd: failed to add new device\\n\");",
                        "\t\t\t\treturn ret;",
                        "\t\t\t}",
                        "\t\t\tnbd = idr_find(&nbd_index_idr, index);",
                        "\t\t}",
                        "\t}",
                        "\tif (!nbd) {",
                        "\t\tprintk(KERN_ERR \"nbd: couldn't find device at index %d\\n\",",
                        "\t\t       index);",
                        "\t\tmutex_unlock(&nbd_index_mutex);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (test_bit(NBD_DESTROY_ON_DISCONNECT, &nbd->flags) &&",
                        "\t    test_bit(NBD_DISCONNECT_REQUESTED, &nbd->flags)) {",
                        "\t\tnbd->destroy_complete = &destroy_complete;",
                        "\t\tmutex_unlock(&nbd_index_mutex);",
                        "",
                        "\t\t/* Wait untill the the nbd stuff is totally destroyed */",
                        "\t\twait_for_completion(&destroy_complete);",
                        "\t\tgoto again;",
                        "\t}",
                        "",
                        "\tif (!refcount_inc_not_zero(&nbd->refs)) {",
                        "\t\tmutex_unlock(&nbd_index_mutex);",
                        "\t\tif (index == -1)",
                        "\t\t\tgoto again;",
                        "\t\tprintk(KERN_ERR \"nbd: device at index %d is going down\\n\",",
                        "\t\t       index);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "\tmutex_unlock(&nbd_index_mutex);",
                        "",
                        "\tmutex_lock(&nbd->config_lock);",
                        "\tif (refcount_read(&nbd->config_refs)) {",
                        "\t\tmutex_unlock(&nbd->config_lock);",
                        "\t\tnbd_put(nbd);",
                        "\t\tif (index == -1)",
                        "\t\t\tgoto again;",
                        "\t\tprintk(KERN_ERR \"nbd: nbd%d already in use\\n\", index);",
                        "\t\treturn -EBUSY;",
                        "\t}",
                        "\tif (WARN_ON(nbd->config)) {",
                        "\t\tmutex_unlock(&nbd->config_lock);",
                        "\t\tnbd_put(nbd);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "\tconfig = nbd->config = nbd_alloc_config();",
                        "\tif (!nbd->config) {",
                        "\t\tmutex_unlock(&nbd->config_lock);",
                        "\t\tnbd_put(nbd);",
                        "\t\tprintk(KERN_ERR \"nbd: couldn't allocate config\\n\");",
                        "\t\treturn -ENOMEM;",
                        "\t}",
                        "\trefcount_set(&nbd->config_refs, 1);",
                        "\tset_bit(NBD_RT_BOUND, &config->runtime_flags);",
                        "",
                        "\tret = nbd_genl_size_set(info, nbd);",
                        "\tif (ret)",
                        "\t\tgoto out;",
                        "",
                        "\tif (info->attrs[NBD_ATTR_TIMEOUT])",
                        "\t\tnbd_set_cmd_timeout(nbd,",
                        "\t\t\t\t    nla_get_u64(info->attrs[NBD_ATTR_TIMEOUT]));",
                        "\tif (info->attrs[NBD_ATTR_DEAD_CONN_TIMEOUT]) {",
                        "\t\tconfig->dead_conn_timeout =",
                        "\t\t\tnla_get_u64(info->attrs[NBD_ATTR_DEAD_CONN_TIMEOUT]);",
                        "\t\tconfig->dead_conn_timeout *= HZ;",
                        "\t}",
                        "\tif (info->attrs[NBD_ATTR_SERVER_FLAGS])",
                        "\t\tconfig->flags =",
                        "\t\t\tnla_get_u64(info->attrs[NBD_ATTR_SERVER_FLAGS]);",
                        "\tif (info->attrs[NBD_ATTR_CLIENT_FLAGS]) {",
                        "\t\tu64 flags = nla_get_u64(info->attrs[NBD_ATTR_CLIENT_FLAGS]);",
                        "\t\tif (flags & NBD_CFLAG_DESTROY_ON_DISCONNECT) {",
                        "\t\t\t/*",
                        "\t\t\t * We have 1 ref to keep the device around, and then 1",
                        "\t\t\t * ref for our current operation here, which will be",
                        "\t\t\t * inherited by the config.  If we already have",
                        "\t\t\t * DESTROY_ON_DISCONNECT set then we know we don't have",
                        "\t\t\t * that extra ref already held so we don't need the",
                        "\t\t\t * put_dev.",
                        "\t\t\t */",
                        "\t\t\tif (!test_and_set_bit(NBD_DESTROY_ON_DISCONNECT,",
                        "\t\t\t\t\t      &nbd->flags))",
                        "\t\t\t\tput_dev = true;",
                        "\t\t} else {",
                        "\t\t\tif (test_and_clear_bit(NBD_DESTROY_ON_DISCONNECT,",
                        "\t\t\t\t\t       &nbd->flags))",
                        "\t\t\t\trefcount_inc(&nbd->refs);",
                        "\t\t}",
                        "\t\tif (flags & NBD_CFLAG_DISCONNECT_ON_CLOSE) {",
                        "\t\t\tset_bit(NBD_RT_DISCONNECT_ON_CLOSE,",
                        "\t\t\t\t&config->runtime_flags);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (info->attrs[NBD_ATTR_SOCKETS]) {",
                        "\t\tstruct nlattr *attr;",
                        "\t\tint rem, fd;",
                        "",
                        "\t\tnla_for_each_nested(attr, info->attrs[NBD_ATTR_SOCKETS],",
                        "\t\t\t\t    rem) {",
                        "\t\t\tstruct nlattr *socks[NBD_SOCK_MAX+1];",
                        "",
                        "\t\t\tif (nla_type(attr) != NBD_SOCK_ITEM) {",
                        "\t\t\t\tprintk(KERN_ERR \"nbd: socks must be embedded in a SOCK_ITEM attr\\n\");",
                        "\t\t\t\tret = -EINVAL;",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t\tret = nla_parse_nested_deprecated(socks, NBD_SOCK_MAX,",
                        "\t\t\t\t\t\t\t  attr,",
                        "\t\t\t\t\t\t\t  nbd_sock_policy,",
                        "\t\t\t\t\t\t\t  info->extack);",
                        "\t\t\tif (ret != 0) {",
                        "\t\t\t\tprintk(KERN_ERR \"nbd: error processing sock list\\n\");",
                        "\t\t\t\tret = -EINVAL;",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t\tif (!socks[NBD_SOCK_FD])",
                        "\t\t\t\tcontinue;",
                        "\t\t\tfd = (int)nla_get_u32(socks[NBD_SOCK_FD]);",
                        "\t\t\tret = nbd_add_socket(nbd, fd, true);",
                        "\t\t\tif (ret)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "\tret = nbd_start_device(nbd);",
                        "out:",
                        "\tmutex_unlock(&nbd->config_lock);",
                        "\tif (!ret) {",
                        "\t\tset_bit(NBD_RT_HAS_CONFIG_REF, &config->runtime_flags);",
                        "\t\trefcount_inc(&nbd->config_refs);",
                        "\t\tnbd_connect_reply(info, nbd->index);",
                        "\t}",
                        "\tnbd_config_put(nbd);",
                        "\tif (put_dev)",
                        "\t\tnbd_put(nbd);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1778,
                    "highlight": 1957
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816d8122"
        },
        "2196": {
            "name": "nbd_genl_connect(indirect)",
            "parent_idx": 2127,
            "source_line": [
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n739",
                    "code": [
                        "static int genl_family_rcv_msg_doit(const struct genl_family *family,",
                        "\t\t\t\t    struct sk_buff *skb,",
                        "\t\t\t\t    struct nlmsghdr *nlh,",
                        "\t\t\t\t    struct netlink_ext_ack *extack,",
                        "\t\t\t\t    const struct genl_ops *ops,",
                        "\t\t\t\t    int hdrlen, struct net *net)",
                        "{",
                        "\tstruct nlattr **attrbuf;",
                        "\tstruct genl_info info;",
                        "\tint err;",
                        "",
                        "\tif (!ops->doit)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tattrbuf = genl_family_rcv_msg_attrs_parse(family, nlh, extack,",
                        "\t\t\t\t\t\t  ops, hdrlen,",
                        "\t\t\t\t\t\t  GENL_DONT_VALIDATE_STRICT);",
                        "\tif (IS_ERR(attrbuf))",
                        "\t\treturn PTR_ERR(attrbuf);",
                        "",
                        "\tinfo.snd_seq = nlh->nlmsg_seq;",
                        "\tinfo.snd_portid = NETLINK_CB(skb).portid;",
                        "\tinfo.nlhdr = nlh;",
                        "\tinfo.genlhdr = nlmsg_data(nlh);",
                        "\tinfo.userhdr = nlmsg_data(nlh) + GENL_HDRLEN;",
                        "\tinfo.attrs = attrbuf;",
                        "\tinfo.extack = extack;",
                        "\tgenl_info_net_set(&info, net);",
                        "\tmemset(&info.user_ptr, 0, sizeof(info.user_ptr));",
                        "",
                        "\tif (family->pre_doit) {",
                        "\t\terr = family->pre_doit(ops, skb, &info);",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\terr = ops->doit(skb, &info);",
                        "",
                        "\tif (family->post_doit)",
                        "\t\tfamily->post_doit(ops, skb, &info);",
                        "",
                        "out:",
                        "\tgenl_family_rcv_msg_attrs_free(attrbuf);",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 703,
                    "highlight": 739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819418e0"
        },
        "2127": {
            "name": "genl_family_rcv_msg_doit",
            "parent_idx": 2076,
            "source_line": [
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n783",
                    "code": [
                        "static int genl_family_rcv_msg(const struct genl_family *family,",
                        "\t\t\t       struct sk_buff *skb,",
                        "\t\t\t       struct nlmsghdr *nlh,",
                        "\t\t\t       struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct genlmsghdr *hdr = nlmsg_data(nlh);",
                        "\tstruct genl_ops op;",
                        "\tint hdrlen;",
                        "",
                        "\t/* this family doesn't exist in this netns */",
                        "\tif (!family->netnsok && !net_eq(net, &init_net))",
                        "\t\treturn -ENOENT;",
                        "",
                        "\thdrlen = GENL_HDRLEN + family->hdrsize;",
                        "\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (genl_get_cmd(hdr->cmd, family, &op))",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tif ((op.flags & GENL_ADMIN_PERM) &&",
                        "\t    !netlink_capable(skb, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\tif ((op.flags & GENL_UNS_ADMIN_PERM) &&",
                        "\t    !netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\tif ((nlh->nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP)",
                        "\t\treturn genl_family_rcv_msg_dumpit(family, skb, nlh, extack,",
                        "\t\t\t\t\t\t  &op, hdrlen, net);",
                        "\telse",
                        "\t\treturn genl_family_rcv_msg_doit(family, skb, nlh, extack,",
                        "\t\t\t\t\t\t&op, hdrlen, net);",
                        "}"
                    ],
                    "start": 750,
                    "highlight": 783
                },
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n800",
                    "code": [
                        "static int genl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\tstruct netlink_ext_ack *extack)",
                        "{",
                        "\tconst struct genl_family *family;",
                        "\tint err;",
                        "",
                        "\tfamily = genl_family_find_byid(nlh->nlmsg_type);",
                        "\tif (family == NULL)",
                        "\t\treturn -ENOENT;",
                        "",
                        "\tif (!family->parallel_ops)",
                        "\t\tgenl_lock();",
                        "",
                        "\terr = genl_family_rcv_msg(family, skb, nlh, extack);",
                        "",
                        "\tif (!family->parallel_ops)",
                        "\t\tgenl_unlock();",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 787,
                    "highlight": 800
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81941d24"
        },
        "2076": {
            "name": "genl_rcv_msg(indirect)",
            "parent_idx": 2072,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n2504",
                    "code": [
                        "int netlink_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *,",
                        "\t\t\t\t\t\t   struct nlmsghdr *,",
                        "\t\t\t\t\t\t   struct netlink_ext_ack *))",
                        "{",
                        "\tstruct netlink_ext_ack extack;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tint err;",
                        "",
                        "\twhile (skb->len >= nlmsg_total_size(0)) {",
                        "\t\tint msglen;",
                        "",
                        "\t\tmemset(&extack, 0, sizeof(extack));",
                        "\t\tnlh = nlmsg_hdr(skb);",
                        "\t\terr = 0;",
                        "",
                        "\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len)",
                        "\t\t\treturn 0;",
                        "",
                        "\t\t/* Only requests are handled by the kernel */",
                        "\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST))",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\t/* Skip control messages */",
                        "\t\tif (nlh->nlmsg_type < NLMSG_MIN_TYPE)",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\terr = cb(skb, nlh, &extack);",
                        "\t\tif (err == -EINTR)",
                        "\t\t\tgoto skip;",
                        "",
                        "ack:",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err)",
                        "\t\t\tnetlink_ack(skb, nlh, err, &extack);",
                        "",
                        "skip:",
                        "\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);",
                        "\t\tif (msglen > skb->len)",
                        "\t\t\tmsglen = skb->len;",
                        "\t\tskb_pull(skb, msglen);",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 2478,
                    "highlight": 2504
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81940ca6"
        },
        "2072": {
            "name": "netlink_rcv_skb",
            "parent_idx": 2063,
            "source_line": [
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n811",
                    "code": [
                        "static void genl_rcv(struct sk_buff *skb)",
                        "{",
                        "\tdown_read(&cb_lock);",
                        "\tnetlink_rcv_skb(skb, &genl_rcv_msg);",
                        "\tup_read(&cb_lock);",
                        "}"
                    ],
                    "start": 808,
                    "highlight": 811
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8194129a"
        },
        "2063": {
            "name": "genl_rcv(indirect)",
            "parent_idx": 2045,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n1314",
                    "code": [
                        "static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,",
                        "\t\t\t\t  struct sock *ssk)",
                        "{",
                        "\tint ret;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "",
                        "\tret = -ECONNREFUSED;",
                        "\tif (nlk->netlink_rcv != NULL) {",
                        "\t\tret = skb->len;",
                        "\t\tnetlink_skb_set_owner_r(skb, sk);",
                        "\t\tNETLINK_CB(skb).sk = ssk;",
                        "\t\tnetlink_deliver_tap_kernel(sk, ssk, skb);",
                        "\t\tnlk->netlink_rcv(skb);",
                        "\t\tconsume_skb(skb);",
                        "\t} else {",
                        "\t\tkfree_skb(skb);",
                        "\t}",
                        "\tsock_put(sk);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1302,
                    "highlight": 1314
                },
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n1340",
                    "code": [
                        "int netlink_unicast(struct sock *ssk, struct sk_buff *skb,",
                        "\t\t    u32 portid, int nonblock)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tint err;",
                        "\tlong timeo;",
                        "",
                        "\tskb = netlink_trim(skb, gfp_any());",
                        "",
                        "\ttimeo = sock_sndtimeo(ssk, nonblock);",
                        "retry:",
                        "\tsk = netlink_getsockbyportid(ssk, portid);",
                        "\tif (IS_ERR(sk)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn PTR_ERR(sk);",
                        "\t}",
                        "\tif (netlink_is_kernel(sk))",
                        "\t\treturn netlink_unicast_kernel(sk, skb, ssk);",
                        "",
                        "\tif (sk_filter(sk, skb)) {",
                        "\t\terr = skb->len;",
                        "\t\tkfree_skb(skb);",
                        "\t\tsock_put(sk);",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = netlink_attachskb(sk, skb, &timeo, ssk);",
                        "\tif (err == 1)",
                        "\t\tgoto retry;",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\treturn netlink_sendskb(sk, skb);",
                        "}"
                    ],
                    "start": 1323,
                    "highlight": 1340
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819403d7"
        },
        "2045": {
            "name": "netlink_unicast",
            "parent_idx": 1958,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n1929",
                    "code": [
                        "static int netlink_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "\tDECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);",
                        "\tu32 dst_portid;",
                        "\tu32 dst_group;",
                        "\tstruct sk_buff *skb;",
                        "\tint err;",
                        "\tstruct scm_cookie scm;",
                        "\tu32 netlink_skb_flags = 0;",
                        "",
                        "\tif (msg->msg_flags & MSG_OOB)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\terr = scm_send(sock, msg, &scm, true);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tif (msg->msg_namelen) {",
                        "\t\terr = -EINVAL;",
                        "\t\tif (msg->msg_namelen < sizeof(struct sockaddr_nl))",
                        "\t\t\tgoto out;",
                        "\t\tif (addr->nl_family != AF_NETLINK)",
                        "\t\t\tgoto out;",
                        "\t\tdst_portid = addr->nl_pid;",
                        "\t\tdst_group = ffs(addr->nl_groups);",
                        "\t\terr =  -EPERM;",
                        "\t\tif ((dst_group || dst_portid) &&",
                        "\t\t    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))",
                        "\t\t\tgoto out;",
                        "\t\tnetlink_skb_flags |= NETLINK_SKB_DST;",
                        "\t} else {",
                        "\t\tdst_portid = nlk->dst_portid;",
                        "\t\tdst_group = nlk->dst_group;",
                        "\t}",
                        "",
                        "\tif (!nlk->bound) {",
                        "\t\terr = netlink_autobind(sock);",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t} else {",
                        "\t\t/* Ensure nlk is hashed and visible. */",
                        "\t\tsmp_rmb();",
                        "\t}",
                        "",
                        "\terr = -EMSGSIZE;",
                        "\tif (len > sk->sk_sndbuf - 32)",
                        "\t\tgoto out;",
                        "\terr = -ENOBUFS;",
                        "\tskb = netlink_alloc_large_skb(len, dst_group);",
                        "\tif (skb == NULL)",
                        "\t\tgoto out;",
                        "",
                        "\tNETLINK_CB(skb).portid\t= nlk->portid;",
                        "\tNETLINK_CB(skb).dst_group = dst_group;",
                        "\tNETLINK_CB(skb).creds\t= scm.creds;",
                        "\tNETLINK_CB(skb).flags\t= netlink_skb_flags;",
                        "",
                        "\terr = -EFAULT;",
                        "\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\terr = security_netlink_send(sk, skb);",
                        "\tif (err) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (dst_group) {",
                        "\t\trefcount_inc(&skb->users);",
                        "\t\tnetlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);",
                        "\t}",
                        "\terr = netlink_unicast(sk, skb, dst_portid, msg->msg_flags & MSG_DONTWAIT);",
                        "",
                        "out:",
                        "\tscm_destroy(&scm);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1854,
                    "highlight": 1929
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819406bb"
        },
        "1958": {
            "name": "netlink_sendmsg(indirect)",
            "parent_idx": 1949,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n702",
                    "code": [
                        "INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t   size_t));",
                        "INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t    size_t));",
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,",
                        "\t\t\t\t     inet_sendmsg, sock, msg,",
                        "\t\t\t\t     msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 696,
                    "highlight": 702
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n722",
                    "code": [
                        "/**",
                        " *\tsock_sendmsg - send a message through @sock",
                        " *\t@sock: socket",
                        " *\t@msg: message to send",
                        " *",
                        " *\tSends @msg through @sock, passing through LSM.",
                        " *\tReturns the number of bytes sent, or an error code.",
                        " */",
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 709,
                    "highlight": 722
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818c59e4"
        },
        "1949": {
            "name": "sock_sendmsg",
            "parent_idx": 1946,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n2385",
                    "code": [
                        "static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,",
                        "\t\t\t   unsigned int flags, struct used_address *used_address,",
                        "\t\t\t   unsigned int allowed_msghdr_flags)",
                        "{",
                        "\tunsigned char ctl[sizeof(struct cmsghdr) + 20]",
                        "\t\t\t\t__aligned(sizeof(__kernel_size_t));",
                        "\t/* 20 is size of ipv6_pktinfo */",
                        "\tunsigned char *ctl_buf = ctl;",
                        "\tint ctl_len;",
                        "\tssize_t err;",
                        "",
                        "\terr = -ENOBUFS;",
                        "",
                        "\tif (msg_sys->msg_controllen > INT_MAX)",
                        "\t\tgoto out;",
                        "\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);",
                        "\tctl_len = msg_sys->msg_controllen;",
                        "\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
                        "\t\terr =",
                        "\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,",
                        "\t\t\t\t\t\t     sizeof(ctl));",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t\tctl_buf = msg_sys->msg_control;",
                        "\t\tctl_len = msg_sys->msg_controllen;",
                        "\t} else if (ctl_len) {",
                        "\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=",
                        "\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));",
                        "\t\tif (ctl_len > sizeof(ctl)) {",
                        "\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);",
                        "\t\t\tif (ctl_buf == NULL)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\terr = -EFAULT;",
                        "\t\tif (copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len))",
                        "\t\t\tgoto out_freectl;",
                        "\t\tmsg_sys->msg_control = ctl_buf;",
                        "\t\tmsg_sys->msg_control_is_user = false;",
                        "\t}",
                        "\tmsg_sys->msg_flags = flags;",
                        "",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;",
                        "\t/*",
                        "\t * If this is sendmmsg() and current destination address is same as",
                        "\t * previously succeeded address, omit asking LSM's decision.",
                        "\t * used_address->name_len is initialized to UINT_MAX so that the first",
                        "\t * destination address never matches.",
                        "\t */",
                        "\tif (used_address && msg_sys->msg_name &&",
                        "\t    used_address->name_len == msg_sys->msg_namelen &&",
                        "\t    !memcmp(&used_address->name, msg_sys->msg_name,",
                        "\t\t    used_address->name_len)) {",
                        "\t\terr = sock_sendmsg_nosec(sock, msg_sys);",
                        "\t\tgoto out_freectl;",
                        "\t}",
                        "\terr = sock_sendmsg(sock, msg_sys);",
                        "\t/*",
                        "\t * If this is sendmmsg() and sending to current destination address was",
                        "\t * successful, remember it.",
                        "\t */",
                        "\tif (used_address && err >= 0) {",
                        "\t\tused_address->name_len = msg_sys->msg_namelen;",
                        "\t\tif (msg_sys->msg_name)",
                        "\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,",
                        "\t\t\t       used_address->name_len);",
                        "\t}",
                        "",
                        "out_freectl:",
                        "\tif (ctl_buf != ctl)",
                        "\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2329,
                    "highlight": 2385
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818c5cfd"
        },
        "1946": {
            "name": "____sys_sendmsg",
            "parent_idx": 1861,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n2439",
                    "code": [
                        "\terr = ____sys_sendmsg(sock, msg_sys, flags, used_address,",
                        "\t\t\t\tallowed_msghdr_flags);",
                        "\tkfree(iov);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2439,
                    "highlight": 2439
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818c860b"
        },
        "1861": {
            "name": "___sys_sendmsg",
            "parent_idx": 1850,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n2468",
                    "code": [
                        "\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);",
                        "",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2468,
                    "highlight": 2468
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818c86af"
        },
        "1850": {
            "name": "__x64_sys_sendmsg(indirect)",
            "parent_idx": 1847,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n50",
                    "code": [
                        "static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)",
                        "{",
                        "\t/*",
                        "\t * Convert negative numbers to very high and thus out of range",
                        "\t * numbers for comparisons.",
                        "\t */",
                        "\tunsigned int unr = nr;",
                        "",
                        "\tif (likely(unr < NR_syscalls)) {",
                        "\t\tunr = array_index_nospec(unr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[unr](regs);",
                        "\t\treturn true;",
                        "\t}",
                        "\treturn false;",
                        "}"
                    ],
                    "start": 40,
                    "highlight": 50
                },
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n80",
                    "code": [
                        "__visible noinstr void do_syscall_64(struct pt_regs *regs, int nr)",
                        "{",
                        "\tadd_random_kstack_offset();",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "",
                        "\tif (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {",
                        "\t\t/* Invalid system call, but still a system call. */",
                        "\t\tregs->ax = __x64_sys_ni_syscall(regs);",
                        "\t}",
                        "",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 73,
                    "highlight": 80
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81bc84be"
        },
        "1847": {
            "name": "do_syscall_64",
            "parent_idx": 1840,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=dbe69e43372212527abf48609aba7fc39a6daa27#n113",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rsp, %rdi",
                        "\t/* Sign extend the lower 32bit as syscall numbers are treated as int */",
                        "\tmovslq\t%eax, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t * In the Xen PV case we must use iret anyway.",
                        "\t */",
                        "",
                        "\tALTERNATIVE \"\", \"jmp\tswapgs_restore_regs_and_return_to_usermode\", \\",
                        "\t\tX86_FEATURE_XENPV",
                        "",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tswapgs",
                        "\tsysretq",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 87,
                    "highlight": 113
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "1840": {
            "name": "65_syscall_8",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "7602": {
            "name": "+0x97",
            "parent_idx": 7584,
            "source_line": [
                {
                    "file": "block/blk-mq.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/block/blk-mq.h?id=dbe69e43372212527abf48609aba7fc39a6daa27#n96",
                    "code": [
                        "/*",
                        " * blk_mq_map_queue_type() - map (hctx_type,cpu) to hardware queue",
                        " * @q: request queue",
                        " * @type: the hctx type index",
                        " * @cpu: CPU",
                        " */",
                        "static inline struct blk_mq_hw_ctx *blk_mq_map_queue_type(struct request_queue *q,",
                        "\t\t\t\t\t\t\t  enum hctx_type type,",
                        "\t\t\t\t\t\t\t  unsigned int cpu)",
                        "{",
                        "\treturn q->queue_hw_ctx[q->tag_set->map[type].mq_map[cpu]];",
                        "}"
                    ],
                    "start": 86,
                    "highlight": 96
                },
                {
                    "file": "block/blk-mq.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/block/blk-mq.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n1663",
                    "code": [
                        "/*",
                        " * Return prefered queue to dispatch from (if any) for non-mq aware IO",
                        " * scheduler.",
                        " */",
                        "static struct blk_mq_hw_ctx *blk_mq_get_sq_hctx(struct request_queue *q)",
                        "{",
                        "\tstruct blk_mq_hw_ctx *hctx;",
                        "",
                        "\t/*",
                        "\t * If the IO scheduler does not respect hardware queues when",
                        "\t * dispatching, we just don't bother with multiple HW queues and",
                        "\t * dispatch from hctx for the current CPU since running multiple queues",
                        "\t * just causes lock contention inside the scheduler and pointless cache",
                        "\t * bouncing.",
                        "\t */",
                        "\thctx = blk_mq_map_queue_type(q, HCTX_TYPE_DEFAULT,",
                        "\t\t\t\t     raw_smp_processor_id());",
                        "\tif (!blk_mq_hctx_stopped(hctx))",
                        "\t\treturn hctx;",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 1648,
                    "highlight": 1663
                },
                {
                    "file": "block/blk-mq.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/block/blk-mq.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n1682",
                    "code": [
                        "/**",
                        " * blk_mq_run_hw_queues - Run all hardware queues in a request queue.",
                        " * @q: Pointer to the request queue to run.",
                        " * @async: If we want to run the queue asynchronously.",
                        " */",
                        "void blk_mq_run_hw_queues(struct request_queue *q, bool async)",
                        "{",
                        "\tstruct blk_mq_hw_ctx *hctx, *sq_hctx;",
                        "\tint i;",
                        "",
                        "\tsq_hctx = NULL;",
                        "\tif (blk_mq_has_sqsched(q))",
                        "\t\tsq_hctx = blk_mq_get_sq_hctx(q);",
                        "\tqueue_for_each_hw_ctx(q, hctx, i) {",
                        "\t\tif (blk_mq_hctx_stopped(hctx))",
                        "\t\t\tcontinue;",
                        "\t\t/*",
                        "\t\t * Dispatch from this hctx either if there's no hctx preferred",
                        "\t\t * by IO scheduler or if it has requests that bypass the",
                        "\t\t * scheduler.",
                        "\t\t */",
                        "\t\tif (!sq_hctx || sq_hctx == hctx ||",
                        "\t\t    !list_empty_careful(&hctx->dispatch))",
                        "\t\t\tblk_mq_run_hw_queue(hctx, async);",
                        "\t}",
                        "}"
                    ],
                    "start": 1670,
                    "highlight": 1682
                }
            ],
            "ins_idx": 236,
            "addr": "0xffffffff813dfd37"
        },
        "7566": {
            "name": "+0xc8",
            "parent_idx": 7506,
            "source_line": [
                {
                    "file": "block/blk-mq.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/block/blk-mq.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n3594",
                    "code": [
                        "void blk_mq_free_tag_set(struct blk_mq_tag_set *set)",
                        "{",
                        "\tint i, j;",
                        "",
                        "\tfor (i = 0; i < set->nr_hw_queues; i++)",
                        "\t\tblk_mq_free_map_and_requests(set, i);",
                        "",
                        "\tif (blk_mq_is_sbitmap_shared(set->flags))",
                        "\t\tblk_mq_exit_shared_sbitmap(set);",
                        "",
                        "\tfor (j = 0; j < set->nr_maps; j++) {",
                        "\t\tkfree(set->map[j].mq_map);",
                        "\t\tset->map[j].mq_map = NULL;",
                        "\t}",
                        "",
                        "\tkfree(set->tags);",
                        "\tset->tags = NULL;",
                        "}"
                    ],
                    "start": 3582,
                    "highlight": 3594
                }
            ],
            "ins_idx": 385,
            "addr": "0xffffffff813e2d58"
        },
        "7506": {
            "name": "blk_mq_free_tag_set",
            "parent_idx": 2298,
            "source_line": [
                {
                    "file": "drivers/block/nbd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/block/nbd.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n225",
                    "code": [
                        "static void nbd_dev_remove(struct nbd_device *nbd)",
                        "{",
                        "\tstruct gendisk *disk = nbd->disk;",
                        "",
                        "\tif (disk) {",
                        "\t\tdel_gendisk(disk);",
                        "\t\tblk_mq_free_tag_set(&nbd->tag_set);",
                        "\t\tblk_cleanup_disk(disk);",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Place this in the last just before the nbd is freed to",
                        "\t * make sure that the disk and the related kobject are also",
                        "\t * totally removed to avoid duplicate creation of the same",
                        "\t * one.",
                        "\t */",
                        "\tif (test_bit(NBD_DESTROY_ON_DISCONNECT, &nbd->flags) && nbd->destroy_complete)",
                        "\t\tcomplete(nbd->destroy_complete);",
                        "",
                        "\tkfree(nbd);",
                        "}"
                    ],
                    "start": 219,
                    "highlight": 225
                },
                {
                    "file": "drivers/block/nbd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/block/nbd.c?id=dbe69e43372212527abf48609aba7fc39a6daa27#n246",
                    "code": [
                        "static void nbd_put(struct nbd_device *nbd)",
                        "{",
                        "\tif (refcount_dec_and_mutex_lock(&nbd->refs,",
                        "\t\t\t\t\t&nbd_index_mutex)) {",
                        "\t\tidr_remove(&nbd_index_idr, nbd->index);",
                        "\t\tnbd_dev_remove(nbd);",
                        "\t\tmutex_unlock(&nbd_index_mutex);",
                        "\t}",
                        "}"
                    ],
                    "start": 241,
                    "highlight": 246
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816d5470"
        }
    },
    "ins": {
        "88": {
            "name": "mov edx, dword ptr [rdx + rax*4]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x0",
            "call_idx": 7603,
            "inputs": [
                13569,
                13570,
                13571
            ],
            "outputs": [
                13572
            ]
        },
        "236": {
            "name": "mov rdx, qword ptr [rdx]",
            "desc": "",
            "call_idx": 7602,
            "inputs": [
                13566,
                13567
            ],
            "outputs": [
                13568
            ]
        },
        "385": {
            "name": "mov qword ptr [rbx + r12], 0",
            "desc": "Source of base address CONST 0x0",
            "call_idx": 7566,
            "inputs": [
                13509,
                13510
            ],
            "outputs": [
                13511
            ]
        }
    },
    "data": {
        "13569": {
            "name": "RAX",
            "ins_idx": 88,
            "value": "0x0",
            "sources": []
        },
        "13570": {
            "name": "RDX",
            "ins_idx": 88,
            "value": "0x0",
            "sources": []
        },
        "13571": {
            "name": "[0x0]",
            "ins_idx": 88,
            "value": "0x0",
            "sources": []
        },
        "13572": {
            "name": "RDX",
            "ins_idx": 88,
            "value": "0x0",
            "sources": []
        },
        "13566": {
            "name": "RDX",
            "ins_idx": 236,
            "value": "0xffff8881014dec00",
            "sources": []
        },
        "13567": {
            "name": "[0xffff8881014dec00]",
            "ins_idx": 236,
            "value": "0x0",
            "sources": []
        },
        "13568": {
            "name": "RDX",
            "ins_idx": 236,
            "value": "0x0",
            "sources": [
                13570
            ]
        },
        "13509": {
            "name": "R12",
            "ins_idx": 385,
            "value": "0x0",
            "sources": []
        },
        "13510": {
            "name": "RBX",
            "ins_idx": 385,
            "value": "0xffff8881014dec00",
            "sources": []
        },
        "13511": {
            "name": "[0xffff8881014dec00]",
            "ins_idx": 385,
            "value": "0x0",
            "sources": [
                13567
            ]
        }
    },
    "chain": {
        "88": [
            236
        ],
        "236": [
            385
        ]
    }
}