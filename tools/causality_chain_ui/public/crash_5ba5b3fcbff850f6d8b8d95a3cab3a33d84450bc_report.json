{
    "report": "https://syzkaller.appspot.com/bug?id=5ba5b3fcbff850f6d8b8d95a3cab3a33d84450bc",
    "title": "general protection fault in io_uring_show_cred",
    "call": {
        "2042": {
            "name": "+0x136",
            "parent_idx": 1988,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n8922",
                    "code": [
                        "#ifdef CONFIG_PROC_FS",
                        "static int io_uring_show_cred(int id, void *p, void *data)",
                        "{",
                        "\tconst struct cred *cred = p;",
                        "\tstruct seq_file *m = data;",
                        "\tstruct user_namespace *uns = seq_user_ns(m);",
                        "\tstruct group_info *gi;",
                        "\tkernel_cap_t cap;",
                        "\tunsigned __capi;",
                        "\tint g;",
                        "",
                        "\tseq_printf(m, \"%5d\\n\", id);",
                        "\tseq_put_decimal_ull(m, \"\\tUid:\\t\", from_kuid_munged(uns, cred->uid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->euid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->suid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->fsuid));",
                        "\tseq_put_decimal_ull(m, \"\\n\\tGid:\\t\", from_kgid_munged(uns, cred->gid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->egid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->sgid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->fsgid));",
                        "\tseq_puts(m, \"\\n\\tGroups:\\t\");",
                        "\tgi = cred->group_info;",
                        "\tfor (g = 0; g < gi->ngroups; g++) {",
                        "\t\tseq_put_decimal_ull(m, g ? \" \" : \"\",",
                        "\t\t\t\t\tfrom_kgid_munged(uns, gi->gid[g]));",
                        "\t}",
                        "\tseq_puts(m, \"\\n\\tCapEff:\\t\");",
                        "\tcap = cred->cap_effective;",
                        "\tCAP_FOR_EACH_U32(__capi)",
                        "\t\tseq_put_hex_ll(m, NULL, cap.cap[CAP_LAST_U32 - __capi], 8);",
                        "\tseq_putc(m, '\\n');",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 8900,
                    "highlight": 8922
                }
            ],
            "ins_idx": 4,
            "addr": "0xffffffff81235ea6"
        },
        "1988": {
            "name": "io_uring_show_cred(indirect)",
            "parent_idx": 1964,
            "source_line": [
                {
                    "file": "lib/idr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/idr.c?id=4ef8451b#n208",
                    "code": [
                        "/**",
                        " * idr_for_each() - Iterate through all stored pointers.",
                        " * @idr: IDR handle.",
                        " * @fn: Function to be called for each pointer.",
                        " * @data: Data passed to callback function.",
                        " *",
                        " * The callback function will be called for each entry in @idr, passing",
                        " * the ID, the entry and @data.",
                        " *",
                        " * If @fn returns anything other than %0, the iteration stops and that",
                        " * value is returned from this function.",
                        " *",
                        " * idr_for_each() can be called concurrently with idr_alloc() and",
                        " * idr_remove() if protected by RCU.  Newly added entries may not be",
                        " * seen and deleted entries may be seen, but adding and removing entries",
                        " * will not cause other entries to be skipped, nor spurious ones to be seen.",
                        " */",
                        "int idr_for_each(const struct idr *idr,",
                        "\t\tint (*fn)(int id, void *p, void *data), void *data)",
                        "{",
                        "\tstruct radix_tree_iter iter;",
                        "\tvoid __rcu **slot;",
                        "\tint base = idr->idr_base;",
                        "",
                        "\tradix_tree_for_each_slot(slot, &idr->idr_rt, &iter, 0) {",
                        "\t\tint ret;",
                        "\t\tunsigned long id = iter.index + base;",
                        "",
                        "\t\tif (WARN_ON_ONCE(id > INT_MAX))",
                        "\t\t\tbreak;",
                        "\t\tret = fn(id, rcu_dereference_raw(*slot), data);",
                        "\t\tif (ret)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 178,
                    "highlight": 208
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81420119"
        },
        "1964": {
            "name": "idr_for_each",
            "parent_idx": 1910,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n8974",
                    "code": [
                        "static void __io_uring_show_fdinfo(struct io_ring_ctx *ctx, struct seq_file *m)",
                        "{",
                        "\tstruct io_sq_data *sq = NULL;",
                        "\tbool has_lock;",
                        "\tint i;",
                        "",
                        "\t/*",
                        "\t * Avoid ABBA deadlock between the seq lock and the io_uring mutex,",
                        "\t * since fdinfo case grabs it in the opposite direction of normal use",
                        "\t * cases. If we fail to get the lock, we just don't iterate any",
                        "\t * structures that could be going away outside the io_uring mutex.",
                        "\t */",
                        "\thas_lock = mutex_trylock(&ctx->uring_lock);",
                        "",
                        "\tif (has_lock && (ctx->flags & IORING_SETUP_SQPOLL))",
                        "\t\tsq = ctx->sq_data;",
                        "",
                        "\tseq_printf(m, \"SqThread:\\t%d\\n\", sq ? task_pid_nr(sq->thread) : -1);",
                        "\tseq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq ? task_cpu(sq->thread) : -1);",
                        "\tseq_printf(m, \"UserFiles:\\t%u\\n\", ctx->nr_user_files);",
                        "\tfor (i = 0; has_lock && i < ctx->nr_user_files; i++) {",
                        "\t\tstruct fixed_file_table *table;",
                        "\t\tstruct file *f;",
                        "",
                        "\t\ttable = &ctx->file_data->table[i >> IORING_FILE_TABLE_SHIFT];",
                        "\t\tf = table->files[i & IORING_FILE_TABLE_MASK];",
                        "\t\tif (f)",
                        "\t\t\tseq_printf(m, \"%5u: %s\\n\", i, file_dentry(f)->d_iname);",
                        "\t\telse",
                        "\t\t\tseq_printf(m, \"%5u: <none>\\n\", i);",
                        "\t}",
                        "\tseq_printf(m, \"UserBufs:\\t%u\\n\", ctx->nr_user_bufs);",
                        "\tfor (i = 0; has_lock && i < ctx->nr_user_bufs; i++) {",
                        "\t\tstruct io_mapped_ubuf *buf = &ctx->user_bufs[i];",
                        "",
                        "\t\tseq_printf(m, \"%5u: 0x%llx/%u\\n\", i, buf->ubuf,",
                        "\t\t\t\t\t\t(unsigned int) buf->len);",
                        "\t}",
                        "\tif (has_lock && !idr_is_empty(&ctx->personality_idr)) {",
                        "\t\tseq_printf(m, \"Personalities:\\n\");",
                        "\t\tidr_for_each(&ctx->personality_idr, io_uring_show_cred, m);",
                        "\t}",
                        "\tseq_printf(m, \"PollList:\\n\");",
                        "\tspin_lock_irq(&ctx->completion_lock);",
                        "\tfor (i = 0; i < (1U << ctx->cancel_hash_bits); i++) {",
                        "\t\tstruct hlist_head *list = &ctx->cancel_hash[i];",
                        "\t\tstruct io_kiocb *req;",
                        "",
                        "\t\thlist_for_each_entry(req, list, hash_node)",
                        "\t\t\tseq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,",
                        "\t\t\t\t\treq->task->task_works != NULL);",
                        "\t}",
                        "\tspin_unlock_irq(&ctx->completion_lock);",
                        "\tif (has_lock)",
                        "\t\tmutex_unlock(&ctx->uring_lock);",
                        "}"
                    ],
                    "start": 8934,
                    "highlight": 8974
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n8996",
                    "code": [
                        "\tif (percpu_ref_tryget(&ctx->refs)) {",
                        "\t\t__io_uring_show_fdinfo(ctx, m);",
                        "\t\tpercpu_ref_put(&ctx->refs);",
                        "\t}",
                        "}"
                    ],
                    "start": 8995,
                    "highlight": 8996
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8123a968"
        },
        "1910": {
            "name": "io_uring_show_fdinfo(indirect)",
            "parent_idx": 1863,
            "source_line": [
                {
                    "file": "fs/proc/fd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/proc/fd.c?id=4ef8451b#n65",
                    "code": [
                        "static int seq_show(struct seq_file *m, void *v)",
                        "{",
                        "\tstruct files_struct *files = NULL;",
                        "\tint f_flags = 0, ret = -ENOENT;",
                        "\tstruct file *file = NULL;",
                        "\tstruct task_struct *task;",
                        "",
                        "\ttask = get_proc_task(m->private);",
                        "\tif (!task)",
                        "\t\treturn -ENOENT;",
                        "",
                        "\tfiles = get_files_struct(task);",
                        "\tput_task_struct(task);",
                        "",
                        "\tif (files) {",
                        "\t\tunsigned int fd = proc_fd(m->private);",
                        "",
                        "\t\tspin_lock(&files->file_lock);",
                        "\t\tfile = fcheck_files(files, fd);",
                        "\t\tif (file) {",
                        "\t\t\tstruct fdtable *fdt = files_fdtable(files);",
                        "",
                        "\t\t\tf_flags = file->f_flags;",
                        "\t\t\tif (close_on_exec(fd, fdt))",
                        "\t\t\t\tf_flags |= O_CLOEXEC;",
                        "",
                        "\t\t\tget_file(file);",
                        "\t\t\tret = 0;",
                        "\t\t}",
                        "\t\tspin_unlock(&files->file_lock);",
                        "\t\tput_files_struct(files);",
                        "\t}",
                        "",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\tseq_printf(m, \"pos:\\t%lli\\nflags:\\t0%o\\nmnt_id:\\t%i\\n\",",
                        "\t\t   (long long)file->f_pos, f_flags,",
                        "\t\t   real_mount(file->f_path.mnt)->mnt_id);",
                        "",
                        "\tshow_fd_locks(m, file, files);",
                        "\tif (seq_has_overflowed(m))",
                        "\t\tgoto out;",
                        "",
                        "\tif (file->f_op->show_fdinfo)",
                        "\t\tfile->f_op->show_fdinfo(m, file);",
                        "",
                        "out:",
                        "\tfput(file);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 20,
                    "highlight": 65
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81270da0"
        },
        "1863": {
            "name": "seq_show(indirect)",
            "parent_idx": 1860,
            "source_line": [
                {
                    "file": "fs/seq_file.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/seq_file.c?id=4ef8451b#n208",
                    "code": [
                        "/**",
                        " *\tseq_read -\t->read() method for sequential files.",
                        " *\t@file: the file to read from",
                        " *\t@buf: the buffer to read to",
                        " *\t@size: the maximum number of bytes to read",
                        " *\t@ppos: the current position in the file",
                        " *",
                        " *\tReady-made ->f_op->read()",
                        " */",
                        "ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)",
                        "{",
                        "\tstruct seq_file *m = file->private_data;",
                        "\tsize_t copied = 0;",
                        "\tsize_t n;",
                        "\tvoid *p;",
                        "\tint err = 0;",
                        "",
                        "\tmutex_lock(&m->lock);",
                        "",
                        "\t/*",
                        "\t * if request is to read from zero offset, reset iterator to first",
                        "\t * record as it might have been already advanced by previous requests",
                        "\t */",
                        "\tif (*ppos == 0) {",
                        "\t\tm->index = 0;",
                        "\t\tm->count = 0;",
                        "\t}",
                        "",
                        "\t/* Don't assume *ppos is where we left it */",
                        "\tif (unlikely(*ppos != m->read_pos)) {",
                        "\t\twhile ((err = traverse(m, *ppos)) == -EAGAIN)",
                        "\t\t\t;",
                        "\t\tif (err) {",
                        "\t\t\t/* With prejudice... */",
                        "\t\t\tm->read_pos = 0;",
                        "\t\t\tm->index = 0;",
                        "\t\t\tm->count = 0;",
                        "\t\t\tgoto Done;",
                        "\t\t} else {",
                        "\t\t\tm->read_pos = *ppos;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* grab buffer if we didn't have one */",
                        "\tif (!m->buf) {",
                        "\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);",
                        "\t\tif (!m->buf)",
                        "\t\t\tgoto Enomem;",
                        "\t}",
                        "\t/* if not empty - flush it first */",
                        "\tif (m->count) {",
                        "\t\tn = min(m->count, size);",
                        "\t\terr = copy_to_user(buf, m->buf + m->from, n);",
                        "\t\tif (err)",
                        "\t\t\tgoto Efault;",
                        "\t\tm->count -= n;",
                        "\t\tm->from += n;",
                        "\t\tsize -= n;",
                        "\t\tbuf += n;",
                        "\t\tcopied += n;",
                        "\t\tif (!size)",
                        "\t\t\tgoto Done;",
                        "\t}",
                        "\t/* we need at least one record in buffer */",
                        "\tm->from = 0;",
                        "\tp = m->op->start(m, &m->index);",
                        "\twhile (1) {",
                        "\t\terr = PTR_ERR(p);",
                        "\t\tif (!p || IS_ERR(p))",
                        "\t\t\tbreak;",
                        "\t\terr = m->op->show(m, p);",
                        "\t\tif (err < 0)",
                        "\t\t\tbreak;",
                        "\t\tif (unlikely(err))",
                        "\t\t\tm->count = 0;",
                        "\t\tif (unlikely(!m->count)) {",
                        "\t\t\tp = m->op->next(m, p, &m->index);",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t\tif (m->count < m->size)",
                        "\t\t\tgoto Fill;",
                        "\t\tm->op->stop(m, p);",
                        "\t\tkvfree(m->buf);",
                        "\t\tm->count = 0;",
                        "\t\tm->buf = seq_buf_alloc(m->size <<= 1);",
                        "\t\tif (!m->buf)",
                        "\t\t\tgoto Enomem;",
                        "\t\tp = m->op->start(m, &m->index);",
                        "\t}",
                        "\tm->op->stop(m, p);",
                        "\tm->count = 0;",
                        "\tgoto Done;",
                        "Fill:",
                        "\t/* they want more? let's try to get some more */",
                        "\twhile (1) {",
                        "\t\tsize_t offs = m->count;",
                        "\t\tloff_t pos = m->index;",
                        "",
                        "\t\tp = m->op->next(m, p, &m->index);",
                        "\t\tif (pos == m->index) {",
                        "\t\t\tpr_info_ratelimited(\"buggy .next function %ps did not update position index\\n\",",
                        "\t\t\t\t\t    m->op->next);",
                        "\t\t\tm->index++;",
                        "\t\t}",
                        "\t\tif (!p || IS_ERR(p)) {",
                        "\t\t\terr = PTR_ERR(p);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (m->count >= size)",
                        "\t\t\tbreak;",
                        "\t\terr = m->op->show(m, p);",
                        "\t\tif (seq_has_overflowed(m) || err) {",
                        "\t\t\tm->count = offs;",
                        "\t\t\tif (likely(err <= 0))",
                        "\t\t\t\tbreak;",
                        "\t\t}",
                        "\t}",
                        "\tm->op->stop(m, p);",
                        "\tn = min(m->count, size);",
                        "\terr = copy_to_user(buf, m->buf, n);",
                        "\tif (err)",
                        "\t\tgoto Efault;",
                        "\tcopied += n;",
                        "\tm->count -= n;",
                        "\tm->from = n;",
                        "Done:",
                        "\tif (!copied)",
                        "\t\tcopied = err;",
                        "\telse {",
                        "\t\t*ppos += copied;",
                        "\t\tm->read_pos += copied;",
                        "\t}",
                        "\tmutex_unlock(&m->lock);",
                        "\treturn copied;",
                        "Enomem:",
                        "\terr = -ENOMEM;",
                        "\tgoto Done;",
                        "Efault:",
                        "\terr = -EFAULT;",
                        "\tgoto Done;",
                        "}"
                    ],
                    "start": 138,
                    "highlight": 208
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812088da"
        },
        "1860": {
            "name": "seq_read(indirect)",
            "parent_idx": 1843,
            "source_line": [
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=4ef8451b#n761",
                    "code": [
                        "/* Do it by hand, with file-ops */",
                        "static ssize_t do_loop_readv_writev(struct file *filp, struct iov_iter *iter,",
                        "\t\tloff_t *ppos, int type, rwf_t flags)",
                        "{",
                        "\tssize_t ret = 0;",
                        "",
                        "\tif (flags & ~RWF_HIPRI)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\twhile (iov_iter_count(iter)) {",
                        "\t\tstruct iovec iovec = iov_iter_iovec(iter);",
                        "\t\tssize_t nr;",
                        "",
                        "\t\tif (type == READ) {",
                        "\t\t\tnr = filp->f_op->read(filp, iovec.iov_base,",
                        "\t\t\t\t\t      iovec.iov_len, ppos);",
                        "\t\t} else {",
                        "\t\t\tnr = filp->f_op->write(filp, iovec.iov_base,",
                        "\t\t\t\t\t       iovec.iov_len, ppos);",
                        "\t\t}",
                        "",
                        "\t\tif (nr < 0) {",
                        "\t\t\tif (!ret)",
                        "\t\t\t\tret = nr;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tret += nr;",
                        "\t\tif (nr != iovec.iov_len)",
                        "\t\t\tbreak;",
                        "\t\tiov_iter_advance(iter, nr);",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 747,
                    "highlight": 761
                },
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=4ef8451b#n748",
                    "code": [
                        "/* Do it by hand, with file-ops */",
                        "static ssize_t do_loop_readv_writev(struct file *filp, struct iov_iter *iter,",
                        "\t\tloff_t *ppos, int type, rwf_t flags)",
                        "{",
                        "\tssize_t ret = 0;",
                        "",
                        "\tif (flags & ~RWF_HIPRI)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\twhile (iov_iter_count(iter)) {",
                        "\t\tstruct iovec iovec = iov_iter_iovec(iter);",
                        "\t\tssize_t nr;",
                        "",
                        "\t\tif (type == READ) {",
                        "\t\t\tnr = filp->f_op->read(filp, iovec.iov_base,",
                        "\t\t\t\t\t      iovec.iov_len, ppos);",
                        "\t\t} else {",
                        "\t\t\tnr = filp->f_op->write(filp, iovec.iov_base,",
                        "\t\t\t\t\t       iovec.iov_len, ppos);",
                        "\t\t}",
                        "",
                        "\t\tif (nr < 0) {",
                        "\t\t\tif (!ret)",
                        "\t\t\t\tret = nr;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tret += nr;",
                        "\t\tif (nr != iovec.iov_len)",
                        "\t\t\tbreak;",
                        "\t\tiov_iter_advance(iter, nr);",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 747,
                    "highlight": 748
                },
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=4ef8451b#n803",
                    "code": [
                        "static ssize_t do_iter_read(struct file *file, struct iov_iter *iter,",
                        "\t\tloff_t *pos, rwf_t flags)",
                        "{",
                        "\tsize_t tot_len;",
                        "\tssize_t ret = 0;",
                        "",
                        "\tif (!(file->f_mode & FMODE_READ))",
                        "\t\treturn -EBADF;",
                        "\tif (!(file->f_mode & FMODE_CAN_READ))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\ttot_len = iov_iter_count(iter);",
                        "\tif (!tot_len)",
                        "\t\tgoto out;",
                        "\tret = rw_verify_area(READ, file, pos, tot_len);",
                        "\tif (ret < 0)",
                        "\t\treturn ret;",
                        "",
                        "\tif (file->f_op->read_iter)",
                        "\t\tret = do_iter_readv_writev(file, iter, pos, READ, flags);",
                        "\telse",
                        "\t\tret = do_loop_readv_writev(file, iter, pos, READ, flags);",
                        "out:",
                        "\tif (ret >= 0)",
                        "\t\tfsnotify_access(file);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 782,
                    "highlight": 803
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811ddb50"
        },
        "1843": {
            "name": "do_iter_read",
            "parent_idx": 1834,
            "source_line": [
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=4ef8451b#n921",
                    "code": [
                        "static ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,",
                        "\t\t  unsigned long vlen, loff_t *pos, rwf_t flags)",
                        "{",
                        "\tstruct iovec iovstack[UIO_FASTIOV];",
                        "\tstruct iovec *iov = iovstack;",
                        "\tstruct iov_iter iter;",
                        "\tssize_t ret;",
                        "",
                        "\tret = import_iovec(READ, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);",
                        "\tif (ret >= 0) {",
                        "\t\tret = do_iter_read(file, &iter, pos, flags);",
                        "\t\tkfree(iov);",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 911,
                    "highlight": 921
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811ddc5b"
        },
        "1834": {
            "name": "vfs_readv",
            "parent_idx": 1815,
            "source_line": [
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=4ef8451b#n1013",
                    "code": [
                        "static ssize_t do_preadv(unsigned long fd, const struct iovec __user *vec,",
                        "\t\t\t unsigned long vlen, loff_t pos, rwf_t flags)",
                        "{",
                        "\tstruct fd f;",
                        "\tssize_t ret = -EBADF;",
                        "",
                        "\tif (pos < 0)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tf = fdget(fd);",
                        "\tif (f.file) {",
                        "\t\tret = -ESPIPE;",
                        "\t\tif (f.file->f_mode & FMODE_PREAD)",
                        "\t\t\tret = vfs_readv(f.file, vec, vlen, &pos, flags);",
                        "\t\tfdput(f);",
                        "\t}",
                        "",
                        "\tif (ret > 0)",
                        "\t\tadd_rchar(current, ret);",
                        "\tinc_syscr(current);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1000,
                    "highlight": 1013
                },
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=4ef8451b#n1063",
                    "code": [
                        "SYSCALL_DEFINE5(preadv, unsigned long, fd, const struct iovec __user *, vec,",
                        "\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h)",
                        "{",
                        "\tloff_t pos = pos_from_hilo(pos_h, pos_l);",
                        "",
                        "\treturn do_preadv(fd, vec, vlen, pos, 0);",
                        "}"
                    ],
                    "start": 1058,
                    "highlight": 1063
                },
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=4ef8451b#n1058",
                    "code": [
                        "SYSCALL_DEFINE3(writev, unsigned long, fd, const struct iovec __user *, vec,",
                        "\t\tunsigned long, vlen)",
                        "{",
                        "\treturn do_writev(fd, vec, vlen, 0);",
                        "}",
                        "",
                        "SYSCALL_DEFINE5(preadv, unsigned long, fd, const struct iovec __user *, vec,",
                        "\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h)",
                        "{",
                        "\tloff_t pos = pos_from_hilo(pos_h, pos_l);",
                        "",
                        "\treturn do_preadv(fd, vec, vlen, pos, 0);",
                        "}"
                    ],
                    "start": 1052,
                    "highlight": 1058
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811de033"
        },
        "1815": {
            "name": "__x64_sys_preadv(indirect)",
            "parent_idx": 1812,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=4ef8451b#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b81d8e"
        },
        "1812": {
            "name": "do_syscall_64",
            "parent_idx": 1805,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=4ef8451b#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "1805": {
            "name": "73_syscall_8",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "2041": {
            "name": "+0x12e",
            "parent_idx": 1988,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n8921",
                    "code": [
                        "#ifdef CONFIG_PROC_FS",
                        "static int io_uring_show_cred(int id, void *p, void *data)",
                        "{",
                        "\tconst struct cred *cred = p;",
                        "\tstruct seq_file *m = data;",
                        "\tstruct user_namespace *uns = seq_user_ns(m);",
                        "\tstruct group_info *gi;",
                        "\tkernel_cap_t cap;",
                        "\tunsigned __capi;",
                        "\tint g;",
                        "",
                        "\tseq_printf(m, \"%5d\\n\", id);",
                        "\tseq_put_decimal_ull(m, \"\\tUid:\\t\", from_kuid_munged(uns, cred->uid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->euid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->suid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->fsuid));",
                        "\tseq_put_decimal_ull(m, \"\\n\\tGid:\\t\", from_kgid_munged(uns, cred->gid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->egid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->sgid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->fsgid));",
                        "\tseq_puts(m, \"\\n\\tGroups:\\t\");",
                        "\tgi = cred->group_info;",
                        "\tfor (g = 0; g < gi->ngroups; g++) {",
                        "\t\tseq_put_decimal_ull(m, g ? \" \" : \"\",",
                        "\t\t\t\t\tfrom_kgid_munged(uns, gi->gid[g]));",
                        "\t}",
                        "\tseq_puts(m, \"\\n\\tCapEff:\\t\");",
                        "\tcap = cred->cap_effective;",
                        "\tCAP_FOR_EACH_U32(__capi)",
                        "\t\tseq_put_hex_ll(m, NULL, cap.cap[CAP_LAST_U32 - __capi], 8);",
                        "\tseq_putc(m, '\\n');",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 8900,
                    "highlight": 8921
                }
            ],
            "ins_idx": 12,
            "addr": "0xffffffff81235e9e"
        },
        "1989": {
            "name": "+0x6",
            "parent_idx": 1988,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n8902",
                    "code": [
                        "#ifdef CONFIG_PROC_FS",
                        "static int io_uring_show_cred(int id, void *p, void *data)",
                        "{",
                        "\tconst struct cred *cred = p;",
                        "\tstruct seq_file *m = data;",
                        "\tstruct user_namespace *uns = seq_user_ns(m);",
                        "\tstruct group_info *gi;",
                        "\tkernel_cap_t cap;",
                        "\tunsigned __capi;",
                        "\tint g;",
                        "",
                        "\tseq_printf(m, \"%5d\\n\", id);",
                        "\tseq_put_decimal_ull(m, \"\\tUid:\\t\", from_kuid_munged(uns, cred->uid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->euid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->suid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->fsuid));",
                        "\tseq_put_decimal_ull(m, \"\\n\\tGid:\\t\", from_kgid_munged(uns, cred->gid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->egid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->sgid));",
                        "\tseq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->fsgid));",
                        "\tseq_puts(m, \"\\n\\tGroups:\\t\");",
                        "\tgi = cred->group_info;",
                        "\tfor (g = 0; g < gi->ngroups; g++) {",
                        "\t\tseq_put_decimal_ull(m, g ? \" \" : \"\",",
                        "\t\t\t\t\tfrom_kgid_munged(uns, gi->gid[g]));",
                        "\t}",
                        "\tseq_puts(m, \"\\n\\tCapEff:\\t\");",
                        "\tcap = cred->cap_effective;",
                        "\tCAP_FOR_EACH_U32(__capi)",
                        "\t\tseq_put_hex_ll(m, NULL, cap.cap[CAP_LAST_U32 - __capi], 8);",
                        "\tseq_putc(m, '\\n');",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 8900,
                    "highlight": 8902
                }
            ],
            "ins_idx": 227,
            "addr": "0xffffffff81235d76"
        },
        "1987": {
            "name": "+0x53",
            "parent_idx": 1964,
            "source_line": [
                {
                    "file": "lib/idr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/idr.c?id=4ef8451b#n208",
                    "code": [
                        "/**",
                        " * idr_for_each() - Iterate through all stored pointers.",
                        " * @idr: IDR handle.",
                        " * @fn: Function to be called for each pointer.",
                        " * @data: Data passed to callback function.",
                        " *",
                        " * The callback function will be called for each entry in @idr, passing",
                        " * the ID, the entry and @data.",
                        " *",
                        " * If @fn returns anything other than %0, the iteration stops and that",
                        " * value is returned from this function.",
                        " *",
                        " * idr_for_each() can be called concurrently with idr_alloc() and",
                        " * idr_remove() if protected by RCU.  Newly added entries may not be",
                        " * seen and deleted entries may be seen, but adding and removing entries",
                        " * will not cause other entries to be skipped, nor spurious ones to be seen.",
                        " */",
                        "int idr_for_each(const struct idr *idr,",
                        "\t\tint (*fn)(int id, void *p, void *data), void *data)",
                        "{",
                        "\tstruct radix_tree_iter iter;",
                        "\tvoid __rcu **slot;",
                        "\tint base = idr->idr_base;",
                        "",
                        "\tradix_tree_for_each_slot(slot, &idr->idr_rt, &iter, 0) {",
                        "\t\tint ret;",
                        "\t\tunsigned long id = iter.index + base;",
                        "",
                        "\t\tif (WARN_ON_ONCE(id > INT_MAX))",
                        "\t\t\tbreak;",
                        "\t\tret = fn(id, rcu_dereference_raw(*slot), data);",
                        "\t\tif (ret)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 178,
                    "highlight": 208
                }
            ],
            "ins_idx": 230,
            "addr": "0xffffffff81420113"
        },
        "397": {
            "name": "+0x7e",
            "parent_idx": 396,
            "source_line": [
                {
                    "file": "lib/radix-tree.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/radix-tree.c?id=4ef8451b#n829",
                    "code": [
                        "static void replace_slot(void __rcu **slot, void *item,",
                        "\t\tstruct radix_tree_node *node, int count, int values)",
                        "{",
                        "\tif (node && (count || values)) {",
                        "\t\tnode->count += count;",
                        "\t\tnode->nr_values += values;",
                        "\t}",
                        "",
                        "\trcu_assign_pointer(*slot, item);",
                        "}"
                    ],
                    "start": 821,
                    "highlight": 829
                },
                {
                    "file": "lib/radix-tree.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/radix-tree.c?id=4ef8451b#n888",
                    "code": [
                        "/**",
                        " * __radix_tree_replace\t\t- replace item in a slot",
                        " * @root:\t\tradix tree root",
                        " * @node:\t\tpointer to tree node",
                        " * @slot:\t\tpointer to slot in @node",
                        " * @item:\t\tnew item to store in the slot.",
                        " *",
                        " * For use with __radix_tree_lookup().  Caller must hold tree write locked",
                        " * across slot lookup and replacement.",
                        " */",
                        "void __radix_tree_replace(struct radix_tree_root *root,",
                        "\t\t\t  struct radix_tree_node *node,",
                        "\t\t\t  void __rcu **slot, void *item)",
                        "{",
                        "\tvoid *old = rcu_dereference_raw(*slot);",
                        "\tint values = !!xa_is_value(item) - !!xa_is_value(old);",
                        "\tint count = calculate_count(root, node, slot, item, old);",
                        "",
                        "\t/*",
                        "\t * This function supports replacing value entries and",
                        "\t * deleting entries, but that needs accounting against the",
                        "\t * node unless the slot is root->xa_head.",
                        "\t */",
                        "\tWARN_ON_ONCE(!node && (slot != (void __rcu **)&root->xa_head) &&",
                        "\t\t\t(count || values));",
                        "\treplace_slot(slot, item, node, count, values);",
                        "",
                        "\tif (!node)",
                        "\t\treturn;",
                        "",
                        "\tdelete_node(root, node);",
                        "}"
                    ],
                    "start": 863,
                    "highlight": 888
                }
            ],
            "ins_idx": 234,
            "addr": "0xffffffff81424cde"
        },
        "396": {
            "name": "radix_tree_iter_replace",
            "parent_idx": 331,
            "source_line": [
                {
                    "file": "lib/idr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/idr.c?id=4ef8451b#n52",
                    "code": [
                        "/**",
                        " * idr_alloc_u32() - Allocate an ID.",
                        " * @idr: IDR handle.",
                        " * @ptr: Pointer to be associated with the new ID.",
                        " * @nextid: Pointer to an ID.",
                        " * @max: The maximum ID to allocate (inclusive).",
                        " * @gfp: Memory allocation flags.",
                        " *",
                        " * Allocates an unused ID in the range specified by @nextid and @max.",
                        " * Note that @max is inclusive whereas the @end parameter to idr_alloc()",
                        " * is exclusive.  The new ID is assigned to @nextid before the pointer",
                        " * is inserted into the IDR, so if @nextid points into the object pointed",
                        " * to by @ptr, a concurrent lookup will not find an uninitialised ID.",
                        " *",
                        " * The caller should provide their own locking to ensure that two",
                        " * concurrent modifications to the IDR are not possible.  Read-only",
                        " * accesses to the IDR may be done under the RCU read lock or may",
                        " * exclude simultaneous writers.",
                        " *",
                        " * Return: 0 if an ID was allocated, -ENOMEM if memory allocation failed,",
                        " * or -ENOSPC if no free IDs could be found.  If an error occurred,",
                        " * @nextid is unchanged.",
                        " */",
                        "int idr_alloc_u32(struct idr *idr, void *ptr, u32 *nextid,",
                        "\t\t\tunsigned long max, gfp_t gfp)",
                        "{",
                        "\tstruct radix_tree_iter iter;",
                        "\tvoid __rcu **slot;",
                        "\tunsigned int base = idr->idr_base;",
                        "\tunsigned int id = *nextid;",
                        "",
                        "\tif (WARN_ON_ONCE(!(idr->idr_rt.xa_flags & ROOT_IS_IDR)))",
                        "\t\tidr->idr_rt.xa_flags |= IDR_RT_MARKER;",
                        "",
                        "\tid = (id < base) ? 0 : id - base;",
                        "\tradix_tree_iter_init(&iter, id);",
                        "\tslot = idr_get_free(&idr->idr_rt, &iter, gfp, max - base);",
                        "\tif (IS_ERR(slot))",
                        "\t\treturn PTR_ERR(slot);",
                        "",
                        "\t*nextid = iter.index + base;",
                        "\t/* there is a memory barrier inside radix_tree_iter_replace() */",
                        "\tradix_tree_iter_replace(&idr->idr_rt, &iter, slot, ptr);",
                        "\tradix_tree_iter_tag_clear(&idr->idr_rt, &iter, IDR_FREE);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 10,
                    "highlight": 52
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8141ff3b"
        },
        "331": {
            "name": "idr_alloc_u32",
            "parent_idx": 323,
            "source_line": [
                {
                    "file": "lib/idr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/idr.c?id=4ef8451b#n125",
                    "code": [
                        "/**",
                        " * idr_alloc_cyclic() - Allocate an ID cyclically.",
                        " * @idr: IDR handle.",
                        " * @ptr: Pointer to be associated with the new ID.",
                        " * @start: The minimum ID (inclusive).",
                        " * @end: The maximum ID (exclusive).",
                        " * @gfp: Memory allocation flags.",
                        " *",
                        " * Allocates an unused ID in the range specified by @nextid and @end.  If",
                        " * @end is <= 0, it is treated as one larger than %INT_MAX.  This allows",
                        " * callers to use @start + N as @end as long as N is within integer range.",
                        " * The search for an unused ID will start at the last ID allocated and will",
                        " * wrap around to @start if no free IDs are found before reaching @end.",
                        " *",
                        " * The caller should provide their own locking to ensure that two",
                        " * concurrent modifications to the IDR are not possible.  Read-only",
                        " * accesses to the IDR may be done under the RCU read lock or may",
                        " * exclude simultaneous writers.",
                        " *",
                        " * Return: The newly allocated ID, -ENOMEM if memory allocation failed,",
                        " * or -ENOSPC if no free IDs could be found.",
                        " */",
                        "int idr_alloc_cyclic(struct idr *idr, void *ptr, int start, int end, gfp_t gfp)",
                        "{",
                        "\tu32 id = idr->idr_next;",
                        "\tint err, max = end > 0 ? end - 1 : INT_MAX;",
                        "",
                        "\tif ((int)id < start)",
                        "\t\tid = start;",
                        "",
                        "\terr = idr_alloc_u32(idr, ptr, &id, max, gfp);",
                        "\tif ((err == -ENOSPC) && (id > start)) {",
                        "\t\tid = start;",
                        "\t\terr = idr_alloc_u32(idr, ptr, &id, max, gfp);",
                        "\t}",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tidr->idr_next = id + 1;",
                        "\treturn id;",
                        "}"
                    ],
                    "start": 95,
                    "highlight": 125
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8142003b"
        },
        "323": {
            "name": "idr_alloc_cyclic",
            "parent_idx": 314,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n9356",
                    "code": [
                        "static int io_register_personality(struct io_ring_ctx *ctx)",
                        "{",
                        "\tstruct io_identity *id;",
                        "\tint ret;",
                        "",
                        "\tid = kmalloc(sizeof(*id), GFP_KERNEL);",
                        "\tif (unlikely(!id))",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tio_init_identity(id);",
                        "\tid->creds = get_current_cred();",
                        "",
                        "\tret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);",
                        "\tif (ret < 0) {",
                        "\t\tput_cred(id->creds);",
                        "\t\tkfree(id);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9344,
                    "highlight": 9356
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n9585",
                    "code": [
                        "static int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,",
                        "\t\t\t       void __user *arg, unsigned nr_args)",
                        "\t__releases(ctx->uring_lock)",
                        "\t__acquires(ctx->uring_lock)",
                        "{",
                        "\tint ret;",
                        "",
                        "\t/*",
                        "\t * We're inside the ring mutex, if the ref is already dying, then",
                        "\t * someone else killed the ctx or is already going through",
                        "\t * io_uring_register().",
                        "\t */",
                        "\tif (percpu_ref_is_dying(&ctx->refs))",
                        "\t\treturn -ENXIO;",
                        "",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\tpercpu_ref_kill(&ctx->refs);",
                        "",
                        "\t\t/*",
                        "\t\t * Drop uring mutex before waiting for references to exit. If",
                        "\t\t * another thread is currently inside io_uring_enter() it might",
                        "\t\t * need to grab the uring_lock to make progress. If we hold it",
                        "\t\t * here across the drain wait, then we can deadlock. It's safe",
                        "\t\t * to drop the mutex here, since no new references will come in",
                        "\t\t * after we've killed the percpu ref.",
                        "\t\t */",
                        "\t\tmutex_unlock(&ctx->uring_lock);",
                        "\t\tdo {",
                        "\t\t\tret = wait_for_completion_interruptible(&ctx->ref_comp);",
                        "\t\t\tif (!ret)",
                        "\t\t\t\tbreak;",
                        "\t\t\tret = io_run_task_work_sig();",
                        "\t\t\tif (ret < 0)",
                        "\t\t\t\tbreak;",
                        "\t\t} while (1);",
                        "",
                        "\t\tmutex_lock(&ctx->uring_lock);",
                        "",
                        "\t\tif (ret) {",
                        "\t\t\tpercpu_ref_resurrect(&ctx->refs);",
                        "\t\t\tgoto out_quiesce;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (ctx->restricted) {",
                        "\t\tif (opcode >= IORING_REGISTER_LAST) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tif (!test_bit(opcode, ctx->restrictions.register_op)) {",
                        "\t\t\tret = -EACCES;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (opcode) {",
                        "\tcase IORING_REGISTER_BUFFERS:",
                        "\t\tret = io_sqe_buffer_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_BUFFERS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_buffer_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES:",
                        "\t\tret = io_sqe_files_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_FILES:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_files_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES_UPDATE:",
                        "\t\tret = io_sqe_files_update(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_EVENTFD:",
                        "\tcase IORING_REGISTER_EVENTFD_ASYNC:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (nr_args != 1)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_register(ctx, arg);",
                        "\t\tif (ret)",
                        "\t\t\tbreak;",
                        "\t\tif (opcode == IORING_REGISTER_EVENTFD_ASYNC)",
                        "\t\t\tctx->eventfd_async = 1;",
                        "\t\telse",
                        "\t\t\tctx->eventfd_async = 0;",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_EVENTFD:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PROBE:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (!arg || nr_args > 256)",
                        "\t\t\tbreak;",
                        "\t\tret = io_probe(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_personality(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg)",
                        "\t\t\tbreak;",
                        "\t\tret = io_unregister_personality(ctx, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_ENABLE_RINGS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_enable_rings(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_RESTRICTIONS:",
                        "\t\tret = io_register_restrictions(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tret = -EINVAL;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "out:",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\t/* bring the ctx back to life */",
                        "\t\tpercpu_ref_reinit(&ctx->refs);",
                        "out_quiesce:",
                        "\t\treinit_completion(&ctx->ref_comp);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9478,
                    "highlight": 9585
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8123933e"
        },
        "314": {
            "name": "__io_uring_register",
            "parent_idx": 289,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n9635",
                    "code": [
                        "SYSCALL_DEFINE4(io_uring_register, unsigned int, fd, unsigned int, opcode,",
                        "\t\tvoid __user *, arg, unsigned int, nr_args)",
                        "{",
                        "\tstruct io_ring_ctx *ctx;",
                        "\tlong ret = -EBADF;",
                        "\tstruct fd f;",
                        "",
                        "\tf = fdget(fd);",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\tret = -EOPNOTSUPP;",
                        "\tif (f.file->f_op != &io_uring_fops)",
                        "\t\tgoto out_fput;",
                        "",
                        "\tctx = f.file->private_data;",
                        "",
                        "\tmutex_lock(&ctx->uring_lock);",
                        "\tret = __io_uring_register(ctx, opcode, arg, nr_args);",
                        "\tmutex_unlock(&ctx->uring_lock);",
                        "\ttrace_io_uring_register(ctx, opcode, ctx->nr_user_files, ctx->nr_user_bufs,",
                        "\t\t\t\t\t\t\tctx->cq_ev_fd != NULL, ret);",
                        "out_fput:",
                        "\tfdput(f);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9617,
                    "highlight": 9635
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n9617",
                    "code": [
                        "static int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,",
                        "\t\t\t       void __user *arg, unsigned nr_args)",
                        "\t__releases(ctx->uring_lock)",
                        "\t__acquires(ctx->uring_lock)",
                        "{",
                        "\tint ret;",
                        "",
                        "\t/*",
                        "\t * We're inside the ring mutex, if the ref is already dying, then",
                        "\t * someone else killed the ctx or is already going through",
                        "\t * io_uring_register().",
                        "\t */",
                        "\tif (percpu_ref_is_dying(&ctx->refs))",
                        "\t\treturn -ENXIO;",
                        "",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\tpercpu_ref_kill(&ctx->refs);",
                        "",
                        "\t\t/*",
                        "\t\t * Drop uring mutex before waiting for references to exit. If",
                        "\t\t * another thread is currently inside io_uring_enter() it might",
                        "\t\t * need to grab the uring_lock to make progress. If we hold it",
                        "\t\t * here across the drain wait, then we can deadlock. It's safe",
                        "\t\t * to drop the mutex here, since no new references will come in",
                        "\t\t * after we've killed the percpu ref.",
                        "\t\t */",
                        "\t\tmutex_unlock(&ctx->uring_lock);",
                        "\t\tdo {",
                        "\t\t\tret = wait_for_completion_interruptible(&ctx->ref_comp);",
                        "\t\t\tif (!ret)",
                        "\t\t\t\tbreak;",
                        "\t\t\tret = io_run_task_work_sig();",
                        "\t\t\tif (ret < 0)",
                        "\t\t\t\tbreak;",
                        "\t\t} while (1);",
                        "",
                        "\t\tmutex_lock(&ctx->uring_lock);",
                        "",
                        "\t\tif (ret) {",
                        "\t\t\tpercpu_ref_resurrect(&ctx->refs);",
                        "\t\t\tgoto out_quiesce;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (ctx->restricted) {",
                        "\t\tif (opcode >= IORING_REGISTER_LAST) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tif (!test_bit(opcode, ctx->restrictions.register_op)) {",
                        "\t\t\tret = -EACCES;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (opcode) {",
                        "\tcase IORING_REGISTER_BUFFERS:",
                        "\t\tret = io_sqe_buffer_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_BUFFERS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_buffer_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES:",
                        "\t\tret = io_sqe_files_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_FILES:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_files_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES_UPDATE:",
                        "\t\tret = io_sqe_files_update(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_EVENTFD:",
                        "\tcase IORING_REGISTER_EVENTFD_ASYNC:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (nr_args != 1)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_register(ctx, arg);",
                        "\t\tif (ret)",
                        "\t\t\tbreak;",
                        "\t\tif (opcode == IORING_REGISTER_EVENTFD_ASYNC)",
                        "\t\t\tctx->eventfd_async = 1;",
                        "\t\telse",
                        "\t\t\tctx->eventfd_async = 0;",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_EVENTFD:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PROBE:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (!arg || nr_args > 256)",
                        "\t\t\tbreak;",
                        "\t\tret = io_probe(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_personality(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg)",
                        "\t\t\tbreak;",
                        "\t\tret = io_unregister_personality(ctx, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_ENABLE_RINGS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_enable_rings(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_RESTRICTIONS:",
                        "\t\tret = io_register_restrictions(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tret = -EINVAL;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "out:",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\t/* bring the ctx back to life */",
                        "\t\tpercpu_ref_reinit(&ctx->refs);",
                        "out_quiesce:",
                        "\t\treinit_completion(&ctx->ref_comp);",
                        "\t}",
                        "\treturn ret;",
                        "}",
                        "",
                        "SYSCALL_DEFINE4(io_uring_register, unsigned int, fd, unsigned int, opcode,",
                        "\t\tvoid __user *, arg, unsigned int, nr_args)",
                        "{",
                        "\tstruct io_ring_ctx *ctx;",
                        "\tlong ret = -EBADF;",
                        "\tstruct fd f;",
                        "",
                        "\tf = fdget(fd);",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\tret = -EOPNOTSUPP;",
                        "\tif (f.file->f_op != &io_uring_fops)",
                        "\t\tgoto out_fput;",
                        "",
                        "\tctx = f.file->private_data;",
                        "",
                        "\tmutex_lock(&ctx->uring_lock);",
                        "\tret = __io_uring_register(ctx, opcode, arg, nr_args);",
                        "\tmutex_unlock(&ctx->uring_lock);",
                        "\ttrace_io_uring_register(ctx, opcode, ctx->nr_user_files, ctx->nr_user_bufs,",
                        "\t\t\t\t\t\t\tctx->cq_ev_fd != NULL, ret);",
                        "out_fput:",
                        "\tfdput(f);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9478,
                    "highlight": 9617
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8123a4c3"
        },
        "289": {
            "name": "__x64_sys_io_uring_register(indirect)",
            "parent_idx": 286,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=4ef8451b#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b81d8e"
        },
        "286": {
            "name": "do_syscall_64",
            "parent_idx": 279,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=4ef8451b#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "279": {
            "name": "50_syscall_5",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "395": {
            "name": "+0x6e",
            "parent_idx": 331,
            "source_line": [
                {
                    "file": "lib/idr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/idr.c?id=4ef8451b#n52",
                    "code": [
                        "/**",
                        " * idr_alloc_u32() - Allocate an ID.",
                        " * @idr: IDR handle.",
                        " * @ptr: Pointer to be associated with the new ID.",
                        " * @nextid: Pointer to an ID.",
                        " * @max: The maximum ID to allocate (inclusive).",
                        " * @gfp: Memory allocation flags.",
                        " *",
                        " * Allocates an unused ID in the range specified by @nextid and @max.",
                        " * Note that @max is inclusive whereas the @end parameter to idr_alloc()",
                        " * is exclusive.  The new ID is assigned to @nextid before the pointer",
                        " * is inserted into the IDR, so if @nextid points into the object pointed",
                        " * to by @ptr, a concurrent lookup will not find an uninitialised ID.",
                        " *",
                        " * The caller should provide their own locking to ensure that two",
                        " * concurrent modifications to the IDR are not possible.  Read-only",
                        " * accesses to the IDR may be done under the RCU read lock or may",
                        " * exclude simultaneous writers.",
                        " *",
                        " * Return: 0 if an ID was allocated, -ENOMEM if memory allocation failed,",
                        " * or -ENOSPC if no free IDs could be found.  If an error occurred,",
                        " * @nextid is unchanged.",
                        " */",
                        "int idr_alloc_u32(struct idr *idr, void *ptr, u32 *nextid,",
                        "\t\t\tunsigned long max, gfp_t gfp)",
                        "{",
                        "\tstruct radix_tree_iter iter;",
                        "\tvoid __rcu **slot;",
                        "\tunsigned int base = idr->idr_base;",
                        "\tunsigned int id = *nextid;",
                        "",
                        "\tif (WARN_ON_ONCE(!(idr->idr_rt.xa_flags & ROOT_IS_IDR)))",
                        "\t\tidr->idr_rt.xa_flags |= IDR_RT_MARKER;",
                        "",
                        "\tid = (id < base) ? 0 : id - base;",
                        "\tradix_tree_iter_init(&iter, id);",
                        "\tslot = idr_get_free(&idr->idr_rt, &iter, gfp, max - base);",
                        "\tif (IS_ERR(slot))",
                        "\t\treturn PTR_ERR(slot);",
                        "",
                        "\t*nextid = iter.index + base;",
                        "\t/* there is a memory barrier inside radix_tree_iter_replace() */",
                        "\tradix_tree_iter_replace(&idr->idr_rt, &iter, slot, ptr);",
                        "\tradix_tree_iter_tag_clear(&idr->idr_rt, &iter, IDR_FREE);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 10,
                    "highlight": 52
                }
            ],
            "ins_idx": 237,
            "addr": "0xffffffff8141ff2e"
        },
        "332": {
            "name": "+0x2",
            "parent_idx": 331,
            "source_line": [
                {
                    "file": "lib/idr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/idr.c?id=4ef8451b#n35",
                    "code": [
                        "/**",
                        " * idr_alloc_u32() - Allocate an ID.",
                        " * @idr: IDR handle.",
                        " * @ptr: Pointer to be associated with the new ID.",
                        " * @nextid: Pointer to an ID.",
                        " * @max: The maximum ID to allocate (inclusive).",
                        " * @gfp: Memory allocation flags.",
                        " *",
                        " * Allocates an unused ID in the range specified by @nextid and @max.",
                        " * Note that @max is inclusive whereas the @end parameter to idr_alloc()",
                        " * is exclusive.  The new ID is assigned to @nextid before the pointer",
                        " * is inserted into the IDR, so if @nextid points into the object pointed",
                        " * to by @ptr, a concurrent lookup will not find an uninitialised ID.",
                        " *",
                        " * The caller should provide their own locking to ensure that two",
                        " * concurrent modifications to the IDR are not possible.  Read-only",
                        " * accesses to the IDR may be done under the RCU read lock or may",
                        " * exclude simultaneous writers.",
                        " *",
                        " * Return: 0 if an ID was allocated, -ENOMEM if memory allocation failed,",
                        " * or -ENOSPC if no free IDs could be found.  If an error occurred,",
                        " * @nextid is unchanged.",
                        " */",
                        "int idr_alloc_u32(struct idr *idr, void *ptr, u32 *nextid,",
                        "\t\t\tunsigned long max, gfp_t gfp)",
                        "{",
                        "\tstruct radix_tree_iter iter;",
                        "\tvoid __rcu **slot;",
                        "\tunsigned int base = idr->idr_base;",
                        "\tunsigned int id = *nextid;",
                        "",
                        "\tif (WARN_ON_ONCE(!(idr->idr_rt.xa_flags & ROOT_IS_IDR)))",
                        "\t\tidr->idr_rt.xa_flags |= IDR_RT_MARKER;",
                        "",
                        "\tid = (id < base) ? 0 : id - base;",
                        "\tradix_tree_iter_init(&iter, id);",
                        "\tslot = idr_get_free(&idr->idr_rt, &iter, gfp, max - base);",
                        "\tif (IS_ERR(slot))",
                        "\t\treturn PTR_ERR(slot);",
                        "",
                        "\t*nextid = iter.index + base;",
                        "\t/* there is a memory barrier inside radix_tree_iter_replace() */",
                        "\tradix_tree_iter_replace(&idr->idr_rt, &iter, slot, ptr);",
                        "\tradix_tree_iter_tag_clear(&idr->idr_rt, &iter, IDR_FREE);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 10,
                    "highlight": 35
                }
            ],
            "ins_idx": 256,
            "addr": "0xffffffff8141fec2"
        },
        "321": {
            "name": "+0x1f1",
            "parent_idx": 314,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n9356",
                    "code": [
                        "static int io_register_personality(struct io_ring_ctx *ctx)",
                        "{",
                        "\tstruct io_identity *id;",
                        "\tint ret;",
                        "",
                        "\tid = kmalloc(sizeof(*id), GFP_KERNEL);",
                        "\tif (unlikely(!id))",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tio_init_identity(id);",
                        "\tid->creds = get_current_cred();",
                        "",
                        "\tret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);",
                        "\tif (ret < 0) {",
                        "\t\tput_cred(id->creds);",
                        "\t\tkfree(id);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9344,
                    "highlight": 9356
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n9585",
                    "code": [
                        "static int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,",
                        "\t\t\t       void __user *arg, unsigned nr_args)",
                        "\t__releases(ctx->uring_lock)",
                        "\t__acquires(ctx->uring_lock)",
                        "{",
                        "\tint ret;",
                        "",
                        "\t/*",
                        "\t * We're inside the ring mutex, if the ref is already dying, then",
                        "\t * someone else killed the ctx or is already going through",
                        "\t * io_uring_register().",
                        "\t */",
                        "\tif (percpu_ref_is_dying(&ctx->refs))",
                        "\t\treturn -ENXIO;",
                        "",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\tpercpu_ref_kill(&ctx->refs);",
                        "",
                        "\t\t/*",
                        "\t\t * Drop uring mutex before waiting for references to exit. If",
                        "\t\t * another thread is currently inside io_uring_enter() it might",
                        "\t\t * need to grab the uring_lock to make progress. If we hold it",
                        "\t\t * here across the drain wait, then we can deadlock. It's safe",
                        "\t\t * to drop the mutex here, since no new references will come in",
                        "\t\t * after we've killed the percpu ref.",
                        "\t\t */",
                        "\t\tmutex_unlock(&ctx->uring_lock);",
                        "\t\tdo {",
                        "\t\t\tret = wait_for_completion_interruptible(&ctx->ref_comp);",
                        "\t\t\tif (!ret)",
                        "\t\t\t\tbreak;",
                        "\t\t\tret = io_run_task_work_sig();",
                        "\t\t\tif (ret < 0)",
                        "\t\t\t\tbreak;",
                        "\t\t} while (1);",
                        "",
                        "\t\tmutex_lock(&ctx->uring_lock);",
                        "",
                        "\t\tif (ret) {",
                        "\t\t\tpercpu_ref_resurrect(&ctx->refs);",
                        "\t\t\tgoto out_quiesce;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (ctx->restricted) {",
                        "\t\tif (opcode >= IORING_REGISTER_LAST) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tif (!test_bit(opcode, ctx->restrictions.register_op)) {",
                        "\t\t\tret = -EACCES;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (opcode) {",
                        "\tcase IORING_REGISTER_BUFFERS:",
                        "\t\tret = io_sqe_buffer_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_BUFFERS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_buffer_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES:",
                        "\t\tret = io_sqe_files_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_FILES:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_files_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES_UPDATE:",
                        "\t\tret = io_sqe_files_update(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_EVENTFD:",
                        "\tcase IORING_REGISTER_EVENTFD_ASYNC:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (nr_args != 1)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_register(ctx, arg);",
                        "\t\tif (ret)",
                        "\t\t\tbreak;",
                        "\t\tif (opcode == IORING_REGISTER_EVENTFD_ASYNC)",
                        "\t\t\tctx->eventfd_async = 1;",
                        "\t\telse",
                        "\t\t\tctx->eventfd_async = 0;",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_EVENTFD:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PROBE:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (!arg || nr_args > 256)",
                        "\t\t\tbreak;",
                        "\t\tret = io_probe(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_personality(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg)",
                        "\t\t\tbreak;",
                        "\t\tret = io_unregister_personality(ctx, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_ENABLE_RINGS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_enable_rings(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_RESTRICTIONS:",
                        "\t\tret = io_register_restrictions(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tret = -EINVAL;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "out:",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\t/* bring the ctx back to life */",
                        "\t\tpercpu_ref_reinit(&ctx->refs);",
                        "out_quiesce:",
                        "\t\treinit_completion(&ctx->ref_comp);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9478,
                    "highlight": 9585
                }
            ],
            "ins_idx": 262,
            "addr": "0xffffffff81239331"
        },
        "319": {
            "name": "+0x1aa",
            "parent_idx": 314,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=4ef8451b#n552",
                    "code": [
                        "/**",
                        " * kmalloc - allocate memory",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate.",
                        " *",
                        " * kmalloc is the normal method of allocating memory",
                        " * for objects smaller than page size in the kernel.",
                        " *",
                        " * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN",
                        " * bytes. For @size of power of two bytes, the alignment is also guaranteed",
                        " * to be at least to the size.",
                        " *",
                        " * The @flags argument may be one of the GFP flags defined at",
                        " * include/linux/gfp.h and described at",
                        " * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`",
                        " *",
                        " * The recommended usage of the @flags is described at",
                        " * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`",
                        " *",
                        " * Below is a brief outline of the most useful GFP flags",
                        " *",
                        " * %GFP_KERNEL",
                        " *\tAllocate normal kernel ram. May sleep.",
                        " *",
                        " * %GFP_NOWAIT",
                        " *\tAllocation will not sleep.",
                        " *",
                        " * %GFP_ATOMIC",
                        " *\tAllocation will not sleep.  May use emergency pools.",
                        " *",
                        " * %GFP_HIGHUSER",
                        " *\tAllocate memory from high memory on behalf of user.",
                        " *",
                        " * Also it is possible to set different flags by OR'ing",
                        " * in one or more of the following additional @flags:",
                        " *",
                        " * %__GFP_HIGH",
                        " *\tThis allocation has high priority and may use emergency pools.",
                        " *",
                        " * %__GFP_NOFAIL",
                        " *\tIndicate that this allocation is in no way allowed to fail",
                        " *\t(think twice before using).",
                        " *",
                        " * %__GFP_NORETRY",
                        " *\tIf memory is not immediately available,",
                        " *\tthen give up at once.",
                        " *",
                        " * %__GFP_NOWARN",
                        " *\tIf allocation fails, don't issue any warnings.",
                        " *",
                        " * %__GFP_RETRY_MAYFAIL",
                        " *\tTry really hard to succeed the allocation but fail",
                        " *\teventually.",
                        " */",
                        "static __always_inline void *kmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\tif (__builtin_constant_p(size)) {",
                        "#ifndef CONFIG_SLOB",
                        "\t\tunsigned int index;",
                        "#endif",
                        "\t\tif (size > KMALLOC_MAX_CACHE_SIZE)",
                        "\t\t\treturn kmalloc_large(size, flags);",
                        "#ifndef CONFIG_SLOB",
                        "\t\tindex = kmalloc_index(size);",
                        "",
                        "\t\tif (!index)",
                        "\t\t\treturn ZERO_SIZE_PTR;",
                        "",
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 484,
                    "highlight": 552
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n9349",
                    "code": [
                        "static int io_register_personality(struct io_ring_ctx *ctx)",
                        "{",
                        "\tstruct io_identity *id;",
                        "\tint ret;",
                        "",
                        "\tid = kmalloc(sizeof(*id), GFP_KERNEL);",
                        "\tif (unlikely(!id))",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tio_init_identity(id);",
                        "\tid->creds = get_current_cred();",
                        "",
                        "\tret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);",
                        "\tif (ret < 0) {",
                        "\t\tput_cred(id->creds);",
                        "\t\tkfree(id);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9344,
                    "highlight": 9349
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n9585",
                    "code": [
                        "static int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,",
                        "\t\t\t       void __user *arg, unsigned nr_args)",
                        "\t__releases(ctx->uring_lock)",
                        "\t__acquires(ctx->uring_lock)",
                        "{",
                        "\tint ret;",
                        "",
                        "\t/*",
                        "\t * We're inside the ring mutex, if the ref is already dying, then",
                        "\t * someone else killed the ctx or is already going through",
                        "\t * io_uring_register().",
                        "\t */",
                        "\tif (percpu_ref_is_dying(&ctx->refs))",
                        "\t\treturn -ENXIO;",
                        "",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\tpercpu_ref_kill(&ctx->refs);",
                        "",
                        "\t\t/*",
                        "\t\t * Drop uring mutex before waiting for references to exit. If",
                        "\t\t * another thread is currently inside io_uring_enter() it might",
                        "\t\t * need to grab the uring_lock to make progress. If we hold it",
                        "\t\t * here across the drain wait, then we can deadlock. It's safe",
                        "\t\t * to drop the mutex here, since no new references will come in",
                        "\t\t * after we've killed the percpu ref.",
                        "\t\t */",
                        "\t\tmutex_unlock(&ctx->uring_lock);",
                        "\t\tdo {",
                        "\t\t\tret = wait_for_completion_interruptible(&ctx->ref_comp);",
                        "\t\t\tif (!ret)",
                        "\t\t\t\tbreak;",
                        "\t\t\tret = io_run_task_work_sig();",
                        "\t\t\tif (ret < 0)",
                        "\t\t\t\tbreak;",
                        "\t\t} while (1);",
                        "",
                        "\t\tmutex_lock(&ctx->uring_lock);",
                        "",
                        "\t\tif (ret) {",
                        "\t\t\tpercpu_ref_resurrect(&ctx->refs);",
                        "\t\t\tgoto out_quiesce;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (ctx->restricted) {",
                        "\t\tif (opcode >= IORING_REGISTER_LAST) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tif (!test_bit(opcode, ctx->restrictions.register_op)) {",
                        "\t\t\tret = -EACCES;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (opcode) {",
                        "\tcase IORING_REGISTER_BUFFERS:",
                        "\t\tret = io_sqe_buffer_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_BUFFERS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_buffer_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES:",
                        "\t\tret = io_sqe_files_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_FILES:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_files_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES_UPDATE:",
                        "\t\tret = io_sqe_files_update(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_EVENTFD:",
                        "\tcase IORING_REGISTER_EVENTFD_ASYNC:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (nr_args != 1)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_register(ctx, arg);",
                        "\t\tif (ret)",
                        "\t\t\tbreak;",
                        "\t\tif (opcode == IORING_REGISTER_EVENTFD_ASYNC)",
                        "\t\t\tctx->eventfd_async = 1;",
                        "\t\telse",
                        "\t\t\tctx->eventfd_async = 0;",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_EVENTFD:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PROBE:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (!arg || nr_args > 256)",
                        "\t\t\tbreak;",
                        "\t\tret = io_probe(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_personality(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg)",
                        "\t\t\tbreak;",
                        "\t\tret = io_unregister_personality(ctx, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_ENABLE_RINGS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_enable_rings(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_RESTRICTIONS:",
                        "\t\tret = io_register_restrictions(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tret = -EINVAL;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "out:",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\t/* bring the ctx back to life */",
                        "\t\tpercpu_ref_reinit(&ctx->refs);",
                        "out_quiesce:",
                        "\t\treinit_completion(&ctx->ref_comp);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9478,
                    "highlight": 9585
                }
            ],
            "ins_idx": 270,
            "addr": "0xffffffff812392ea"
        },
        "318": {
            "name": "+0xd2",
            "parent_idx": 317,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=4ef8451b#n2930",
                    "code": [
                        "#ifdef CONFIG_NUMA",
                        "void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)",
                        "{",
                        "\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);",
                        "",
                        "\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,",
                        "\t\t\t\t    s->object_size, s->size, gfpflags, node);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2924,
                    "highlight": 2930
                }
            ],
            "ins_idx": 280,
            "addr": "0xffffffff811d38f2"
        },
        "317": {
            "name": "kmem_cache_alloc_trace",
            "parent_idx": 314,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=4ef8451b#n552",
                    "code": [
                        "/**",
                        " * kmalloc - allocate memory",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate.",
                        " *",
                        " * kmalloc is the normal method of allocating memory",
                        " * for objects smaller than page size in the kernel.",
                        " *",
                        " * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN",
                        " * bytes. For @size of power of two bytes, the alignment is also guaranteed",
                        " * to be at least to the size.",
                        " *",
                        " * The @flags argument may be one of the GFP flags defined at",
                        " * include/linux/gfp.h and described at",
                        " * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`",
                        " *",
                        " * The recommended usage of the @flags is described at",
                        " * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`",
                        " *",
                        " * Below is a brief outline of the most useful GFP flags",
                        " *",
                        " * %GFP_KERNEL",
                        " *\tAllocate normal kernel ram. May sleep.",
                        " *",
                        " * %GFP_NOWAIT",
                        " *\tAllocation will not sleep.",
                        " *",
                        " * %GFP_ATOMIC",
                        " *\tAllocation will not sleep.  May use emergency pools.",
                        " *",
                        " * %GFP_HIGHUSER",
                        " *\tAllocate memory from high memory on behalf of user.",
                        " *",
                        " * Also it is possible to set different flags by OR'ing",
                        " * in one or more of the following additional @flags:",
                        " *",
                        " * %__GFP_HIGH",
                        " *\tThis allocation has high priority and may use emergency pools.",
                        " *",
                        " * %__GFP_NOFAIL",
                        " *\tIndicate that this allocation is in no way allowed to fail",
                        " *\t(think twice before using).",
                        " *",
                        " * %__GFP_NORETRY",
                        " *\tIf memory is not immediately available,",
                        " *\tthen give up at once.",
                        " *",
                        " * %__GFP_NOWARN",
                        " *\tIf allocation fails, don't issue any warnings.",
                        " *",
                        " * %__GFP_RETRY_MAYFAIL",
                        " *\tTry really hard to succeed the allocation but fail",
                        " *\teventually.",
                        " */",
                        "static __always_inline void *kmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\tif (__builtin_constant_p(size)) {",
                        "#ifndef CONFIG_SLOB",
                        "\t\tunsigned int index;",
                        "#endif",
                        "\t\tif (size > KMALLOC_MAX_CACHE_SIZE)",
                        "\t\t\treturn kmalloc_large(size, flags);",
                        "#ifndef CONFIG_SLOB",
                        "\t\tindex = kmalloc_index(size);",
                        "",
                        "\t\tif (!index)",
                        "\t\t\treturn ZERO_SIZE_PTR;",
                        "",
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 484,
                    "highlight": 552
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n9349",
                    "code": [
                        "static int io_register_personality(struct io_ring_ctx *ctx)",
                        "{",
                        "\tstruct io_identity *id;",
                        "\tint ret;",
                        "",
                        "\tid = kmalloc(sizeof(*id), GFP_KERNEL);",
                        "\tif (unlikely(!id))",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tio_init_identity(id);",
                        "\tid->creds = get_current_cred();",
                        "",
                        "\tret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);",
                        "\tif (ret < 0) {",
                        "\t\tput_cred(id->creds);",
                        "\t\tkfree(id);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9344,
                    "highlight": 9349
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=4ef8451b#n9585",
                    "code": [
                        "static int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,",
                        "\t\t\t       void __user *arg, unsigned nr_args)",
                        "\t__releases(ctx->uring_lock)",
                        "\t__acquires(ctx->uring_lock)",
                        "{",
                        "\tint ret;",
                        "",
                        "\t/*",
                        "\t * We're inside the ring mutex, if the ref is already dying, then",
                        "\t * someone else killed the ctx or is already going through",
                        "\t * io_uring_register().",
                        "\t */",
                        "\tif (percpu_ref_is_dying(&ctx->refs))",
                        "\t\treturn -ENXIO;",
                        "",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\tpercpu_ref_kill(&ctx->refs);",
                        "",
                        "\t\t/*",
                        "\t\t * Drop uring mutex before waiting for references to exit. If",
                        "\t\t * another thread is currently inside io_uring_enter() it might",
                        "\t\t * need to grab the uring_lock to make progress. If we hold it",
                        "\t\t * here across the drain wait, then we can deadlock. It's safe",
                        "\t\t * to drop the mutex here, since no new references will come in",
                        "\t\t * after we've killed the percpu ref.",
                        "\t\t */",
                        "\t\tmutex_unlock(&ctx->uring_lock);",
                        "\t\tdo {",
                        "\t\t\tret = wait_for_completion_interruptible(&ctx->ref_comp);",
                        "\t\t\tif (!ret)",
                        "\t\t\t\tbreak;",
                        "\t\t\tret = io_run_task_work_sig();",
                        "\t\t\tif (ret < 0)",
                        "\t\t\t\tbreak;",
                        "\t\t} while (1);",
                        "",
                        "\t\tmutex_lock(&ctx->uring_lock);",
                        "",
                        "\t\tif (ret) {",
                        "\t\t\tpercpu_ref_resurrect(&ctx->refs);",
                        "\t\t\tgoto out_quiesce;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (ctx->restricted) {",
                        "\t\tif (opcode >= IORING_REGISTER_LAST) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tif (!test_bit(opcode, ctx->restrictions.register_op)) {",
                        "\t\t\tret = -EACCES;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (opcode) {",
                        "\tcase IORING_REGISTER_BUFFERS:",
                        "\t\tret = io_sqe_buffer_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_BUFFERS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_buffer_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES:",
                        "\t\tret = io_sqe_files_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_FILES:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_files_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES_UPDATE:",
                        "\t\tret = io_sqe_files_update(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_EVENTFD:",
                        "\tcase IORING_REGISTER_EVENTFD_ASYNC:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (nr_args != 1)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_register(ctx, arg);",
                        "\t\tif (ret)",
                        "\t\t\tbreak;",
                        "\t\tif (opcode == IORING_REGISTER_EVENTFD_ASYNC)",
                        "\t\t\tctx->eventfd_async = 1;",
                        "\t\telse",
                        "\t\t\tctx->eventfd_async = 0;",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_EVENTFD:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PROBE:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (!arg || nr_args > 256)",
                        "\t\t\tbreak;",
                        "\t\tret = io_probe(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_personality(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg)",
                        "\t\t\tbreak;",
                        "\t\tret = io_unregister_personality(ctx, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_ENABLE_RINGS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_enable_rings(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_RESTRICTIONS:",
                        "\t\tret = io_register_restrictions(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tret = -EINVAL;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "out:",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\t/* bring the ctx back to life */",
                        "\t\tpercpu_ref_reinit(&ctx->refs);",
                        "out_quiesce:",
                        "\t\treinit_completion(&ctx->ref_comp);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9478,
                    "highlight": 9585
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812392e5"
        }
    },
    "ins": {
        "4": {
            "name": "mov eax, dword ptr [r14 + 4]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x100000003",
            "call_idx": 2042,
            "inputs": [
                3866,
                3867
            ],
            "outputs": [
                3868
            ]
        },
        "12": {
            "name": "mov r14, qword ptr [r12 + 0x90]",
            "desc": "Out of Bound Access.\nSource of base address MEMREAD 0xffffffff",
            "call_idx": 2041,
            "inputs": [
                3863,
                3864
            ],
            "outputs": [
                3865
            ]
        },
        "227": {
            "name": "mov r12, rsi",
            "desc": "Type Confusion Read as * cred.",
            "call_idx": 1989,
            "inputs": [
                3781
            ],
            "outputs": [
                3782
            ]
        },
        "230": {
            "name": "mov rsi, qword ptr [r15]",
            "desc": "",
            "call_idx": 1987,
            "inputs": [
                3778,
                3779
            ],
            "outputs": [
                3780
            ]
        },
        "234": {
            "name": "mov qword ptr [rdx], rcx",
            "desc": "",
            "call_idx": 397,
            "inputs": [
                730,
                731
            ],
            "outputs": [
                732
            ]
        },
        "237": {
            "name": "mov rcx, r13",
            "desc": "",
            "call_idx": 395,
            "inputs": [
                728
            ],
            "outputs": [
                729
            ]
        },
        "256": {
            "name": "mov r13, rsi",
            "desc": "Write as * io_identity.",
            "call_idx": 332,
            "inputs": [
                599
            ],
            "outputs": [
                600
            ]
        },
        "262": {
            "name": "mov rsi, rbp",
            "desc": "",
            "call_idx": 321,
            "inputs": [
                579
            ],
            "outputs": [
                580
            ]
        },
        "270": {
            "name": "mov rbp, rax",
            "desc": "",
            "call_idx": 319,
            "inputs": [
                575
            ],
            "outputs": [
                576
            ]
        },
        "280": {
            "name": "ret ",
            "desc": "",
            "call_idx": 318,
            "inputs": [],
            "outputs": [
                574
            ]
        }
    },
    "data": {
        "3866": {
            "name": "R14",
            "ins_idx": 4,
            "value": "0xffffffff",
            "sources": []
        },
        "3867": {
            "name": "[0x100000003]",
            "ins_idx": 4,
            "value": "0x0",
            "sources": []
        },
        "3868": {
            "name": "RAX",
            "ins_idx": 4,
            "value": "0x0",
            "sources": []
        },
        "3863": {
            "name": "R12",
            "ins_idx": 12,
            "value": "0xffff888101023740",
            "sources": []
        },
        "3864": {
            "name": "[0xffff8881010237d0]",
            "ins_idx": 12,
            "value": "0xffffffff",
            "sources": []
        },
        "3865": {
            "name": "R14",
            "ins_idx": 12,
            "value": "0xffffffff",
            "sources": [
                3866
            ]
        },
        "3781": {
            "name": "RSI",
            "ins_idx": 227,
            "value": "0xffff888101023740",
            "sources": []
        },
        "3782": {
            "name": "R12",
            "ins_idx": 227,
            "value": "0xffff888101023740",
            "sources": [
                3863
            ]
        },
        "3778": {
            "name": "R15",
            "ins_idx": 230,
            "value": "0xffff8881027044c0",
            "sources": []
        },
        "3779": {
            "name": "[0xffff8881027044c0]",
            "ins_idx": 230,
            "value": "0xffff888101023740",
            "sources": []
        },
        "3780": {
            "name": "RSI",
            "ins_idx": 230,
            "value": "0xffff888101023740",
            "sources": [
                3781
            ]
        },
        "730": {
            "name": "RCX",
            "ins_idx": 234,
            "value": "0xffff888101023740",
            "sources": []
        },
        "731": {
            "name": "RDX",
            "ins_idx": 234,
            "value": "0xffff8881027044c0",
            "sources": []
        },
        "732": {
            "name": "[0xffff8881027044c0]",
            "ins_idx": 234,
            "value": "0xffff888101023740",
            "sources": [
                3779
            ]
        },
        "728": {
            "name": "R13",
            "ins_idx": 237,
            "value": "0xffff888101023740",
            "sources": []
        },
        "729": {
            "name": "RCX",
            "ins_idx": 237,
            "value": "0xffff888101023740",
            "sources": [
                730
            ]
        },
        "599": {
            "name": "RSI",
            "ins_idx": 256,
            "value": "0xffff888101023740",
            "sources": []
        },
        "600": {
            "name": "R13",
            "ins_idx": 256,
            "value": "0xffff888101023740",
            "sources": [
                728
            ]
        },
        "579": {
            "name": "RBP",
            "ins_idx": 262,
            "value": "0xffff888101023740",
            "sources": []
        },
        "580": {
            "name": "RSI",
            "ins_idx": 262,
            "value": "0xffff888101023740",
            "sources": [
                599
            ]
        },
        "575": {
            "name": "RAX",
            "ins_idx": 270,
            "value": "0xffff888101023740",
            "sources": []
        },
        "576": {
            "name": "RBP",
            "ins_idx": 270,
            "value": "0xffff888101023740",
            "sources": [
                579
            ]
        },
        "574": {
            "name": "RAX",
            "ins_idx": 280,
            "value": "0xffff888101023740",
            "sources": [
                575
            ]
        }
    },
    "chain": {
        "4": [
            12
        ],
        "12": [
            227
        ],
        "227": [
            230
        ],
        "230": [
            234
        ],
        "234": [
            237
        ],
        "237": [
            256
        ],
        "256": [
            262
        ],
        "262": [
            270
        ],
        "270": [
            280
        ]
    }
}