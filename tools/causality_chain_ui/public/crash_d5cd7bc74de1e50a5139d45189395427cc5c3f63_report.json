{
    "report": "https://syzkaller.appspot.com/bug?id=d5cd7bc74de1e50a5139d45189395427cc5c3f63",
    "title": "general protection fault in btf_array_resolve",
    "call": {
        "10": {
            "name": "+0x38",
            "parent_idx": 7,
            "source_line": [
                {
                    "file": "kernel/bpf/btf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n392",
                    "code": [
                        "static bool btf_type_is_var(const struct btf_type *t)",
                        "{",
                        "\treturn BTF_INFO_KIND(t->info) == BTF_KIND_VAR;",
                        "}"
                    ],
                    "start": 390,
                    "highlight": 392
                },
                {
                    "file": "kernel/bpf/btf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n405",
                    "code": [
                        "/* Types that act only as a source, not sink or intermediate",
                        " * type when resolving.",
                        " */",
                        "static bool btf_type_is_resolve_source_only(const struct btf_type *t)",
                        "{",
                        "\treturn btf_type_is_var(t) ||",
                        "\t       btf_type_is_datasec(t);",
                        "}"
                    ],
                    "start": 400,
                    "highlight": 405
                },
                {
                    "file": "kernel/bpf/btf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n1931",
                    "code": [
                        "static int btf_array_resolve(struct btf_verifier_env *env,",
                        "\t\t\t     const struct resolve_vertex *v)",
                        "{",
                        "\tconst struct btf_array *array = btf_type_array(v->t);",
                        "\tconst struct btf_type *elem_type, *index_type;",
                        "\tu32 elem_type_id, index_type_id;",
                        "\tstruct btf *btf = env->btf;",
                        "\tu32 elem_size;",
                        "",
                        "\t/* Check array->index_type */",
                        "\tindex_type_id = array->index_type;",
                        "\tindex_type = btf_type_by_id(btf, index_type_id);",
                        "\tif (btf_type_is_resolve_source_only(index_type) ||",
                        "\t    btf_type_nosize_or_null(index_type)) {",
                        "\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (!env_type_is_resolve_sink(env, index_type) &&",
                        "\t    !env_type_is_resolved(env, index_type_id))",
                        "\t\treturn env_stack_push(env, index_type, index_type_id);",
                        "",
                        "\tindex_type = btf_type_id_size(btf, &index_type_id, NULL);",
                        "\tif (!index_type || !btf_type_is_int(index_type) ||",
                        "\t    !btf_type_int_is_regular(index_type)) {",
                        "\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\t/* Check array->type */",
                        "\telem_type_id = array->type;",
                        "\telem_type = btf_type_by_id(btf, elem_type_id);",
                        "\tif (btf_type_is_resolve_source_only(elem_type) ||",
                        "\t    btf_type_nosize_or_null(elem_type)) {",
                        "\t\tbtf_verifier_log_type(env, v->t,",
                        "\t\t\t\t      \"Invalid elem\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (!env_type_is_resolve_sink(env, elem_type) &&",
                        "\t    !env_type_is_resolved(env, elem_type_id))",
                        "\t\treturn env_stack_push(env, elem_type, elem_type_id);",
                        "",
                        "\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);",
                        "\tif (!elem_type) {",
                        "\t\tbtf_verifier_log_type(env, v->t, \"Invalid elem\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (btf_type_is_int(elem_type) && !btf_type_int_is_regular(elem_type)) {",
                        "\t\tbtf_verifier_log_type(env, v->t, \"Invalid array of int\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (array->nelems && elem_size > U32_MAX / array->nelems) {",
                        "\t\tbtf_verifier_log_type(env, v->t,",
                        "\t\t\t\t      \"Array size overflows U32_MAX\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tenv_stack_pop_resolved(env, elem_type_id, elem_size * array->nelems);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1919,
                    "highlight": 1931
                }
            ],
            "ins_idx": 1,
            "addr": "0xffffffff81160ac8"
        },
        "7": {
            "name": "btf_array_resolve(indirect)",
            "parent_idx": 6,
            "source_line": [
                {
                    "file": "kernel/bpf/btf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n3037",
                    "code": [
                        "static int btf_resolve(struct btf_verifier_env *env,",
                        "\t\t       const struct btf_type *t, u32 type_id)",
                        "{",
                        "\tu32 save_log_type_id = env->log_type_id;",
                        "\tconst struct resolve_vertex *v;",
                        "\tint err = 0;",
                        "",
                        "\tenv->resolve_mode = RESOLVE_TBD;",
                        "\tenv_stack_push(env, t, type_id);",
                        "\twhile (!err && (v = env_stack_peak(env))) {",
                        "\t\tenv->log_type_id = v->type_id;",
                        "\t\terr = btf_type_ops(v->t)->resolve(env, v);",
                        "\t}",
                        "",
                        "\tenv->log_type_id = type_id;",
                        "\tif (err == -E2BIG) {",
                        "\t\tbtf_verifier_log_type(env, t,",
                        "\t\t\t\t      \"Exceeded max resolving depth:%u\",",
                        "\t\t\t\t      MAX_RESOLVE_DEPTH);",
                        "\t} else if (err == -EEXIST) {",
                        "\t\tbtf_verifier_log_type(env, t, \"Loop detected\");",
                        "\t}",
                        "",
                        "\t/* Final sanity check */",
                        "\tif (!err && !btf_resolve_valid(env, t, type_id)) {",
                        "\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");",
                        "\t\terr = -EINVAL;",
                        "\t}",
                        "",
                        "\tenv->log_type_id = save_log_type_id;",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 3026,
                    "highlight": 3037
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81160f4c"
        },
        "6": {
            "name": "btf_resolve",
            "parent_idx": 5,
            "source_line": [
                {
                    "file": "kernel/bpf/btf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n3076",
                    "code": [
                        "static int btf_check_all_types(struct btf_verifier_env *env)",
                        "{",
                        "\tstruct btf *btf = env->btf;",
                        "\tu32 type_id;",
                        "\tint err;",
                        "",
                        "\terr = env_resolve_init(env);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\tenv->phase++;",
                        "\tfor (type_id = 1; type_id <= btf->nr_types; type_id++) {",
                        "\t\tconst struct btf_type *t = btf_type_by_id(btf, type_id);",
                        "",
                        "\t\tenv->log_type_id = type_id;",
                        "\t\tif (btf_type_needs_resolve(t) &&",
                        "\t\t    !env_type_is_resolved(env, type_id)) {",
                        "\t\t\terr = btf_resolve(env, t, type_id);",
                        "\t\t\tif (err)",
                        "\t\t\t\treturn err;",
                        "\t\t}",
                        "",
                        "\t\tif (btf_type_is_func_proto(t)) {",
                        "\t\t\terr = btf_func_proto_check(env, t);",
                        "\t\t\tif (err)",
                        "\t\t\t\treturn err;",
                        "\t\t}",
                        "",
                        "\t\tif (btf_type_is_func(t)) {",
                        "\t\t\terr = btf_func_check(env, t);",
                        "\t\t\tif (err)",
                        "\t\t\t\treturn err;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 3059,
                    "highlight": 3076
                },
                {
                    "file": "kernel/bpf/btf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n3117",
                    "code": [
                        "static int btf_parse_type_sec(struct btf_verifier_env *env)",
                        "{",
                        "\tconst struct btf_header *hdr = &env->btf->hdr;",
                        "\tint err;",
                        "",
                        "\t/* Type section must align to 4 bytes */",
                        "\tif (hdr->type_off & (sizeof(u32) - 1)) {",
                        "\t\tbtf_verifier_log(env, \"Unaligned type_off\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (!hdr->type_len) {",
                        "\t\tbtf_verifier_log(env, \"No type found\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\terr = btf_check_all_metas(env);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\treturn btf_check_all_types(env);",
                        "}"
                    ],
                    "start": 3097,
                    "highlight": 3117
                },
                {
                    "file": "kernel/bpf/btf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n3346",
                    "code": [
                        "static struct btf *btf_parse(void __user *btf_data, u32 btf_data_size,",
                        "\t\t\t     u32 log_level, char __user *log_ubuf, u32 log_size)",
                        "{",
                        "\tstruct btf_verifier_env *env = NULL;",
                        "\tstruct bpf_verifier_log *log;",
                        "\tstruct btf *btf = NULL;",
                        "\tu8 *data;",
                        "\tint err;",
                        "",
                        "\tif (btf_data_size > BTF_MAX_SIZE)",
                        "\t\treturn ERR_PTR(-E2BIG);",
                        "",
                        "\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);",
                        "\tif (!env)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tlog = &env->log;",
                        "\tif (log_level || log_ubuf || log_size) {",
                        "\t\t/* user requested verbose verifier output",
                        "\t\t * and supplied buffer to store the verification trace",
                        "\t\t */",
                        "\t\tlog->level = log_level;",
                        "\t\tlog->ubuf = log_ubuf;",
                        "\t\tlog->len_total = log_size;",
                        "",
                        "\t\t/* log attributes have to be sane */",
                        "\t\tif (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||",
                        "\t\t    !log->level || !log->ubuf) {",
                        "\t\t\terr = -EINVAL;",
                        "\t\t\tgoto errout;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);",
                        "\tif (!btf) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto errout;",
                        "\t}",
                        "\tenv->btf = btf;",
                        "",
                        "\tdata = kvmalloc(btf_data_size, GFP_KERNEL | __GFP_NOWARN);",
                        "\tif (!data) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto errout;",
                        "\t}",
                        "",
                        "\tbtf->data = data;",
                        "\tbtf->data_size = btf_data_size;",
                        "",
                        "\tif (copy_from_user(data, btf_data, btf_data_size)) {",
                        "\t\terr = -EFAULT;",
                        "\t\tgoto errout;",
                        "\t}",
                        "",
                        "\terr = btf_parse_hdr(env);",
                        "\tif (err)",
                        "\t\tgoto errout;",
                        "",
                        "\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;",
                        "",
                        "\terr = btf_parse_str_sec(env);",
                        "\tif (err)",
                        "\t\tgoto errout;",
                        "",
                        "\terr = btf_parse_type_sec(env);",
                        "\tif (err)",
                        "\t\tgoto errout;",
                        "",
                        "\tif (log->level && bpf_verifier_log_full(log)) {",
                        "\t\terr = -ENOSPC;",
                        "\t\tgoto errout;",
                        "\t}",
                        "",
                        "\tbtf_verifier_env_free(env);",
                        "\trefcount_set(&btf->refcnt, 1);",
                        "\treturn btf;",
                        "",
                        "errout:",
                        "\tbtf_verifier_env_free(env);",
                        "\tif (btf)",
                        "\t\tbtf_free(btf);",
                        "\treturn ERR_PTR(err);",
                        "}"
                    ],
                    "start": 3282,
                    "highlight": 3346
                },
                {
                    "file": "kernel/bpf/btf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n3394",
                    "code": [
                        "int btf_new_fd(const union bpf_attr *attr)",
                        "{",
                        "\tstruct btf *btf;",
                        "\tint ret;",
                        "",
                        "\tbtf = btf_parse(u64_to_user_ptr(attr->btf),",
                        "\t\t\tattr->btf_size, attr->btf_log_level,",
                        "\t\t\tu64_to_user_ptr(attr->btf_log_buf),",
                        "\t\t\tattr->btf_log_size);",
                        "\tif (IS_ERR(btf))",
                        "\t\treturn PTR_ERR(btf);",
                        "",
                        "\tret = btf_alloc_id(btf);",
                        "\tif (ret) {",
                        "\t\tbtf_free(btf);",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * The BTF ID is published to the userspace.",
                        "\t * All BTF free must go through call_rcu() from",
                        "\t * now on (i.e. free by calling btf_put()).",
                        "\t */",
                        "",
                        "\tret = __btf_new_fd(btf);",
                        "\tif (ret < 0)",
                        "\t\tbtf_put(btf);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3389,
                    "highlight": 3394
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81161a94"
        },
        "5": {
            "name": "btf_new_fd",
            "parent_idx": 4,
            "source_line": [
                {
                    "file": "kernel/bpf/syscall.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/syscall.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n2630",
                    "code": [
                        "static int bpf_btf_load(const union bpf_attr *attr)",
                        "{",
                        "\tif (CHECK_ATTR(BPF_BTF_LOAD))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (!capable(CAP_SYS_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\treturn btf_new_fd(attr);",
                        "}"
                    ],
                    "start": 2622,
                    "highlight": 2630
                },
                {
                    "file": "kernel/bpf/syscall.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/syscall.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n2854",
                    "code": [
                        "SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)",
                        "{",
                        "\tunion bpf_attr attr = {};",
                        "\tint err;",
                        "",
                        "\tif (sysctl_unprivileged_bpf_disabled && !capable(CAP_SYS_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\terr = bpf_check_uarg_tail_zero(uattr, sizeof(attr), size);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\tsize = min_t(u32, size, sizeof(attr));",
                        "",
                        "\t/* copy attributes from user space, may be less than sizeof(bpf_attr) */",
                        "\tif (copy_from_user(&attr, uattr, size) != 0)",
                        "\t\treturn -EFAULT;",
                        "",
                        "\terr = security_bpf(cmd, &attr, size);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase BPF_MAP_CREATE:",
                        "\t\terr = map_create(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_LOOKUP_ELEM:",
                        "\t\terr = map_lookup_elem(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_UPDATE_ELEM:",
                        "\t\terr = map_update_elem(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_DELETE_ELEM:",
                        "\t\terr = map_delete_elem(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_GET_NEXT_KEY:",
                        "\t\terr = map_get_next_key(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_FREEZE:",
                        "\t\terr = map_freeze(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_LOAD:",
                        "\t\terr = bpf_prog_load(&attr, uattr);",
                        "\t\tbreak;",
                        "\tcase BPF_OBJ_PIN:",
                        "\t\terr = bpf_obj_pin(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_OBJ_GET:",
                        "\t\terr = bpf_obj_get(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_ATTACH:",
                        "\t\terr = bpf_prog_attach(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_DETACH:",
                        "\t\terr = bpf_prog_detach(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_QUERY:",
                        "\t\terr = bpf_prog_query(&attr, uattr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_TEST_RUN:",
                        "\t\terr = bpf_prog_test_run(&attr, uattr);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_GET_NEXT_ID:",
                        "\t\terr = bpf_obj_get_next_id(&attr, uattr,",
                        "\t\t\t\t\t  &prog_idr, &prog_idr_lock);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_GET_NEXT_ID:",
                        "\t\terr = bpf_obj_get_next_id(&attr, uattr,",
                        "\t\t\t\t\t  &map_idr, &map_idr_lock);",
                        "\t\tbreak;",
                        "\tcase BPF_PROG_GET_FD_BY_ID:",
                        "\t\terr = bpf_prog_get_fd_by_id(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_GET_FD_BY_ID:",
                        "\t\terr = bpf_map_get_fd_by_id(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_OBJ_GET_INFO_BY_FD:",
                        "\t\terr = bpf_obj_get_info_by_fd(&attr, uattr);",
                        "\t\tbreak;",
                        "\tcase BPF_RAW_TRACEPOINT_OPEN:",
                        "\t\terr = bpf_raw_tracepoint_open(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_BTF_LOAD:",
                        "\t\terr = bpf_btf_load(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_BTF_GET_FD_BY_ID:",
                        "\t\terr = bpf_btf_get_fd_by_id(&attr);",
                        "\t\tbreak;",
                        "\tcase BPF_TASK_FD_QUERY:",
                        "\t\terr = bpf_task_fd_query(&attr, uattr);",
                        "\t\tbreak;",
                        "\tcase BPF_MAP_LOOKUP_AND_DELETE_ELEM:",
                        "\t\terr = map_lookup_and_delete_elem(&attr);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\terr = -EINVAL;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2772,
                    "highlight": 2854
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81148af7"
        },
        "4": {
            "name": "__do_sys_bpf(indirect)",
            "parent_idx": 3,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n301",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\t/*",
                        "\t * NB: Native and x32 syscalls are dispatched from the same",
                        "\t * table.  The only functional difference is the x32 bit in",
                        "\t * regs->orig_ax, which changes the behavior of some syscalls.",
                        "\t */",
                        "\tnr &= __SYSCALL_MASK;",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 282,
                    "highlight": 301
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8100257e"
        },
        "3": {
            "name": "do_syscall_64",
            "parent_idx": 2,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n175",
                    "code": [
                        "ENTRY(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "GLOBAL(entry_SYSCALL_64_after_hwframe)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "2": {
            "name": "7_syscall_2",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "9": {
            "name": "+0x10",
            "parent_idx": 8,
            "source_line": [
                {
                    "file": "kernel/bpf/btf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n595",
                    "code": [
                        "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)",
                        "{",
                        "\tif (type_id > btf->nr_types)",
                        "\t\treturn NULL;",
                        "",
                        "\treturn btf->types[type_id];",
                        "}"
                    ],
                    "start": 592,
                    "highlight": 595
                }
            ],
            "ins_idx": 2,
            "addr": "0xffffffff8115fc20"
        },
        "8": {
            "name": "btf_type_by_id",
            "parent_idx": 7,
            "source_line": [
                {
                    "file": "kernel/bpf/btf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/btf.c?id=bed3c0d84e7e25c8e0964d297794f4c215b01f33#n1930",
                    "code": [
                        "static int btf_array_resolve(struct btf_verifier_env *env,",
                        "\t\t\t     const struct resolve_vertex *v)",
                        "{",
                        "\tconst struct btf_array *array = btf_type_array(v->t);",
                        "\tconst struct btf_type *elem_type, *index_type;",
                        "\tu32 elem_type_id, index_type_id;",
                        "\tstruct btf *btf = env->btf;",
                        "\tu32 elem_size;",
                        "",
                        "\t/* Check array->index_type */",
                        "\tindex_type_id = array->index_type;",
                        "\tindex_type = btf_type_by_id(btf, index_type_id);",
                        "\tif (btf_type_is_resolve_source_only(index_type) ||",
                        "\t    btf_type_nosize_or_null(index_type)) {",
                        "\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (!env_type_is_resolve_sink(env, index_type) &&",
                        "\t    !env_type_is_resolved(env, index_type_id))",
                        "\t\treturn env_stack_push(env, index_type, index_type_id);",
                        "",
                        "\tindex_type = btf_type_id_size(btf, &index_type_id, NULL);",
                        "\tif (!index_type || !btf_type_is_int(index_type) ||",
                        "\t    !btf_type_int_is_regular(index_type)) {",
                        "\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\t/* Check array->type */",
                        "\telem_type_id = array->type;",
                        "\telem_type = btf_type_by_id(btf, elem_type_id);",
                        "\tif (btf_type_is_resolve_source_only(elem_type) ||",
                        "\t    btf_type_nosize_or_null(elem_type)) {",
                        "\t\tbtf_verifier_log_type(env, v->t,",
                        "\t\t\t\t      \"Invalid elem\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (!env_type_is_resolve_sink(env, elem_type) &&",
                        "\t    !env_type_is_resolved(env, elem_type_id))",
                        "\t\treturn env_stack_push(env, elem_type, elem_type_id);",
                        "",
                        "\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);",
                        "\tif (!elem_type) {",
                        "\t\tbtf_verifier_log_type(env, v->t, \"Invalid elem\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (btf_type_is_int(elem_type) && !btf_type_int_is_regular(elem_type)) {",
                        "\t\tbtf_verifier_log_type(env, v->t, \"Invalid array of int\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (array->nelems && elem_size > U32_MAX / array->nelems) {",
                        "\t\tbtf_verifier_log_type(env, v->t,",
                        "\t\t\t\t      \"Array size overflows U32_MAX\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tenv_stack_pop_resolved(env, elem_type_id, elem_size * array->nelems);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1919,
                    "highlight": 1930
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81160ac0"
        }
    },
    "ins": {
        "1": {
            "name": "movzx eax, byte ptr [rax + 7]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x7",
            "call_idx": 10,
            "inputs": [
                4,
                5
            ],
            "outputs": [
                6
            ]
        },
        "2": {
            "name": "xor eax, eax",
            "desc": "Source of base address CONST 0x0",
            "call_idx": 9,
            "inputs": [
                1,
                2
            ],
            "outputs": [
                3
            ]
        }
    },
    "data": {
        "4": {
            "name": "RAX",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "5": {
            "name": "[0x7]",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "6": {
            "name": "RAX",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "1": {
            "name": "RAX",
            "ins_idx": 2,
            "value": "0x0",
            "sources": []
        },
        "2": {
            "name": "RAX",
            "ins_idx": 2,
            "value": "0x0",
            "sources": []
        },
        "3": {
            "name": "RAX",
            "ins_idx": 2,
            "value": "0x0",
            "sources": [
                4
            ]
        }
    },
    "chain": {
        "1": [
            2
        ]
    }
}