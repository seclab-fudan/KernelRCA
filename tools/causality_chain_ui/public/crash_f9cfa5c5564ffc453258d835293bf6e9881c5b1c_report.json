{
    "report": "https://syzkaller.appspot.com/bug?id=f9cfa5c5564ffc453258d835293bf6e9881c5b1c",
    "title": "general protection fault in sctp_sched_rr_dequeue",
    "call": {
        "4560": {
            "name": "+0x22",
            "parent_idx": 4557,
            "source_line": [
                {
                    "file": "net/sctp/stream_sched_rr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/stream_sched_rr.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n141",
                    "code": [
                        "static struct sctp_chunk *sctp_sched_rr_dequeue(struct sctp_outq *q)",
                        "{",
                        "\tstruct sctp_stream *stream = &q->asoc->stream;",
                        "\tstruct sctp_stream_out_ext *soute;",
                        "\tstruct sctp_chunk *ch = NULL;",
                        "",
                        "\t/* Bail out quickly if queue is empty */",
                        "\tif (list_empty(&q->out_chunk_list))",
                        "\t\tgoto out;",
                        "",
                        "\t/* Find which chunk is next */",
                        "\tif (stream->out_curr)",
                        "\t\tsoute = stream->out_curr->ext;",
                        "\telse",
                        "\t\tsoute = stream->rr_next;",
                        "\tch = list_entry(soute->outq.next, struct sctp_chunk, stream_list);",
                        "",
                        "\tsctp_sched_dequeue_common(q, ch);",
                        "",
                        "out:",
                        "\treturn ch;",
                        "}"
                    ],
                    "start": 126,
                    "highlight": 141
                }
            ],
            "ins_idx": 17,
            "addr": "0xffffffff819b0852"
        },
        "4557": {
            "name": "__indirect_thunk_start",
            "parent_idx": 4551,
            "source_line": [
                {
                    "file": "net/sctp/outqueue.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/outqueue.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n90",
                    "code": [
                        "/* Take data from the front of the queue. */",
                        "static inline struct sctp_chunk *sctp_outq_dequeue_data(struct sctp_outq *q)",
                        "{",
                        "\treturn q->sched->dequeue(q);",
                        "}"
                    ],
                    "start": 87,
                    "highlight": 90
                },
                {
                    "file": "net/sctp/outqueue.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/outqueue.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n1079",
                    "code": [
                        "static void sctp_outq_flush_data(struct sctp_flush_ctx *ctx,",
                        "\t\t\t\t int rtx_timeout)",
                        "{",
                        "\tstruct sctp_chunk *chunk;",
                        "\tenum sctp_xmit status;",
                        "",
                        "\t/* Is it OK to send data chunks?  */",
                        "\tswitch (ctx->asoc->state) {",
                        "\tcase SCTP_STATE_COOKIE_ECHOED:",
                        "\t\t/* Only allow bundling when this packet has a COOKIE-ECHO",
                        "\t\t * chunk.",
                        "\t\t */",
                        "\t\tif (!ctx->packet || !ctx->packet->has_cookie_echo)",
                        "\t\t\treturn;",
                        "",
                        "\t\t/* fall through */",
                        "\tcase SCTP_STATE_ESTABLISHED:",
                        "\tcase SCTP_STATE_SHUTDOWN_PENDING:",
                        "\tcase SCTP_STATE_SHUTDOWN_RECEIVED:",
                        "\t\tbreak;",
                        "",
                        "\tdefault:",
                        "\t\t/* Do nothing. */",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* RFC 2960 6.1  Transmission of DATA Chunks",
                        "\t *",
                        "\t * C) When the time comes for the sender to transmit,",
                        "\t * before sending new DATA chunks, the sender MUST",
                        "\t * first transmit any outstanding DATA chunks which",
                        "\t * are marked for retransmission (limited by the",
                        "\t * current cwnd).",
                        "\t */",
                        "\tif (!list_empty(&ctx->q->retransmit) &&",
                        "\t    !sctp_outq_flush_rtx(ctx, rtx_timeout))",
                        "\t\treturn;",
                        "",
                        "\t/* Apply Max.Burst limitation to the current transport in",
                        "\t * case it will be used for new data.  We are going to",
                        "\t * rest it before we return, but we want to apply the limit",
                        "\t * to the currently queued data.",
                        "\t */",
                        "\tif (ctx->transport)",
                        "\t\tsctp_transport_burst_limited(ctx->transport);",
                        "",
                        "\t/* Finally, transmit new packets.  */",
                        "\twhile ((chunk = sctp_outq_dequeue_data(ctx->q)) != NULL) {",
                        "\t\t__u32 sid = ntohs(chunk->subh.data_hdr->stream);",
                        "\t\t__u8 stream_state = SCTP_SO(&ctx->asoc->stream, sid)->state;",
                        "",
                        "\t\t/* Has this chunk expired? */",
                        "\t\tif (sctp_chunk_abandoned(chunk)) {",
                        "\t\t\tsctp_sched_dequeue_done(ctx->q, chunk);",
                        "\t\t\tsctp_chunk_fail(chunk, 0);",
                        "\t\t\tsctp_chunk_free(chunk);",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "",
                        "\t\tif (stream_state == SCTP_STREAM_CLOSED) {",
                        "\t\t\tsctp_outq_head_data(ctx->q, chunk);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\tsctp_outq_select_transport(ctx, chunk);",
                        "",
                        "\t\tpr_debug(\"%s: outq:%p, chunk:%p[%s], tx-tsn:0x%x skb->head:%p skb->users:%d\\n\",",
                        "\t\t\t __func__, ctx->q, chunk, chunk && chunk->chunk_hdr ?",
                        "\t\t\t sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)) :",
                        "\t\t\t \"illegal chunk\", ntohl(chunk->subh.data_hdr->tsn),",
                        "\t\t\t chunk->skb ? chunk->skb->head : NULL, chunk->skb ?",
                        "\t\t\t refcount_read(&chunk->skb->users) : -1);",
                        "",
                        "\t\t/* Add the chunk to the packet.  */",
                        "\t\tstatus = sctp_packet_transmit_chunk(ctx->packet, chunk, 0,",
                        "\t\t\t\t\t\t    ctx->gfp);",
                        "\t\tif (status != SCTP_XMIT_OK) {",
                        "\t\t\t/* We could not append this chunk, so put",
                        "\t\t\t * the chunk back on the output queue.",
                        "\t\t\t */",
                        "\t\t\tpr_debug(\"%s: could not transmit tsn:0x%x, status:%d\\n\",",
                        "\t\t\t\t __func__, ntohl(chunk->subh.data_hdr->tsn),",
                        "\t\t\t\t status);",
                        "",
                        "\t\t\tsctp_outq_head_data(ctx->q, chunk);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\t/* The sender is in the SHUTDOWN-PENDING state,",
                        "\t\t * The sender MAY set the I-bit in the DATA",
                        "\t\t * chunk header.",
                        "\t\t */",
                        "\t\tif (ctx->asoc->state == SCTP_STATE_SHUTDOWN_PENDING)",
                        "\t\t\tchunk->chunk_hdr->flags |= SCTP_DATA_SACK_IMM;",
                        "\t\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED)",
                        "\t\t\tctx->asoc->stats.ouodchunks++;",
                        "\t\telse",
                        "\t\t\tctx->asoc->stats.oodchunks++;",
                        "",
                        "\t\t/* Only now it's safe to consider this",
                        "\t\t * chunk as sent, sched-wise.",
                        "\t\t */",
                        "\t\tsctp_sched_dequeue_done(ctx->q, chunk);",
                        "",
                        "\t\tlist_add_tail(&chunk->transmitted_list,",
                        "\t\t\t      &ctx->transport->transmitted);",
                        "",
                        "\t\tsctp_transport_reset_t3_rtx(ctx->transport);",
                        "\t\tctx->transport->last_time_sent = jiffies;",
                        "",
                        "\t\t/* Only let one DATA chunk get bundled with a",
                        "\t\t * COOKIE-ECHO chunk.",
                        "\t\t */",
                        "\t\tif (ctx->packet->has_cookie_echo)",
                        "\t\t\tbreak;",
                        "\t}",
                        "}"
                    ],
                    "start": 1032,
                    "highlight": 1079
                },
                {
                    "file": "net/sctp/outqueue.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/outqueue.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n1205",
                    "code": [
                        "static void sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp)",
                        "{",
                        "\tstruct sctp_flush_ctx ctx = {",
                        "\t\t.q = q,",
                        "\t\t.transport = NULL,",
                        "\t\t.transport_list = LIST_HEAD_INIT(ctx.transport_list),",
                        "\t\t.asoc = q->asoc,",
                        "\t\t.packet = NULL,",
                        "\t\t.gfp = gfp,",
                        "\t};",
                        "",
                        "\t/* 6.10 Bundling",
                        "\t *   ...",
                        "\t *   When bundling control chunks with DATA chunks, an",
                        "\t *   endpoint MUST place control chunks first in the outbound",
                        "\t *   SCTP packet.  The transmitter MUST transmit DATA chunks",
                        "\t *   within a SCTP packet in increasing order of TSN.",
                        "\t *   ...",
                        "\t */",
                        "",
                        "\tsctp_outq_flush_ctrl(&ctx);",
                        "",
                        "\tif (q->asoc->src_out_of_asoc_ok)",
                        "\t\tgoto sctp_flush_out;",
                        "",
                        "\tsctp_outq_flush_data(&ctx, rtx_timeout);",
                        "",
                        "sctp_flush_out:",
                        "",
                        "\tsctp_outq_flush_transports(&ctx);",
                        "}"
                    ],
                    "start": 1180,
                    "highlight": 1205
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8199aa0e"
        },
        "4551": {
            "name": "sctp_outq_uncork",
            "parent_idx": 4472,
            "source_line": [
                {
                    "file": "net/sctp/sm_sideeffect.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/sm_sideeffect.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n1820",
                    "code": [
                        "/* This is the side-effect interpreter.  */",
                        "static int sctp_cmd_interpreter(enum sctp_event_type event_type,",
                        "\t\t\t\tunion sctp_subtype subtype,",
                        "\t\t\t\tenum sctp_state state,",
                        "\t\t\t\tstruct sctp_endpoint *ep,",
                        "\t\t\t\tstruct sctp_association *asoc,",
                        "\t\t\t\tvoid *event_arg,",
                        "\t\t\t\tenum sctp_disposition status,",
                        "\t\t\t\tstruct sctp_cmd_seq *commands,",
                        "\t\t\t\tgfp_t gfp)",
                        "{",
                        "\tstruct sctp_sock *sp = sctp_sk(ep->base.sk);",
                        "\tstruct sctp_chunk *chunk = NULL, *new_obj;",
                        "\tstruct sctp_packet *packet;",
                        "\tstruct sctp_sackhdr sackh;",
                        "\tstruct timer_list *timer;",
                        "\tstruct sctp_transport *t;",
                        "\tunsigned long timeout;",
                        "\tstruct sctp_cmd *cmd;",
                        "\tint local_cork = 0;",
                        "\tint error = 0;",
                        "\tint force;",
                        "",
                        "\tif (SCTP_EVENT_T_TIMEOUT != event_type)",
                        "\t\tchunk = event_arg;",
                        "",
                        "\t/* Note:  This whole file is a huge candidate for rework.",
                        "\t * For example, each command could either have its own handler, so",
                        "\t * the loop would look like:",
                        "\t *     while (cmds)",
                        "\t *         cmd->handle(x, y, z)",
                        "\t * --jgrimm",
                        "\t */",
                        "\twhile (NULL != (cmd = sctp_next_cmd(commands))) {",
                        "\t\tswitch (cmd->verb) {",
                        "\t\tcase SCTP_CMD_NOP:",
                        "\t\t\t/* Do nothing. */",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_NEW_ASOC:",
                        "\t\t\t/* Register a new association.  */",
                        "\t\t\tif (local_cork) {",
                        "\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t\t\t\tlocal_cork = 0;",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* Register with the endpoint.  */",
                        "\t\t\tasoc = cmd->obj.asoc;",
                        "\t\t\tBUG_ON(asoc->peer.primary_path == NULL);",
                        "\t\t\tsctp_endpoint_add_asoc(ep, asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_UPDATE_ASSOC:",
                        "\t\t       sctp_cmd_assoc_update(commands, asoc, cmd->obj.asoc);",
                        "\t\t       break;",
                        "",
                        "\t\tcase SCTP_CMD_PURGE_OUTQUEUE:",
                        "\t\t       sctp_outq_teardown(&asoc->outqueue);",
                        "\t\t       break;",
                        "",
                        "\t\tcase SCTP_CMD_DELETE_TCB:",
                        "\t\t\tif (local_cork) {",
                        "\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t\t\t\tlocal_cork = 0;",
                        "\t\t\t}",
                        "\t\t\t/* Delete the current association.  */",
                        "\t\t\tsctp_cmd_delete_tcb(commands, asoc);",
                        "\t\t\tasoc = NULL;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_NEW_STATE:",
                        "\t\t\t/* Enter a new state.  */",
                        "\t\t\tsctp_cmd_new_state(commands, asoc, cmd->obj.state);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPORT_TSN:",
                        "\t\t\t/* Record the arrival of a TSN.  */",
                        "\t\t\terror = sctp_tsnmap_mark(&asoc->peer.tsn_map,",
                        "\t\t\t\t\t\t cmd->obj.u32, NULL);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPORT_FWDTSN:",
                        "\t\t\tasoc->stream.si->report_ftsn(&asoc->ulpq, cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PROCESS_FWDTSN:",
                        "\t\t\tasoc->stream.si->handle_ftsn(&asoc->ulpq,",
                        "\t\t\t\t\t\t     cmd->obj.chunk);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_GEN_SACK:",
                        "\t\t\t/* Generate a Selective ACK.",
                        "\t\t\t * The argument tells us whether to just count",
                        "\t\t\t * the packet and MAYBE generate a SACK, or",
                        "\t\t\t * force a SACK out.",
                        "\t\t\t */",
                        "\t\t\tforce = cmd->obj.i32;",
                        "\t\t\terror = sctp_gen_sack(asoc, force, commands);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PROCESS_SACK:",
                        "\t\t\t/* Process an inbound SACK.  */",
                        "\t\t\terror = sctp_cmd_process_sack(commands, asoc,",
                        "\t\t\t\t\t\t      cmd->obj.chunk);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_GEN_INIT_ACK:",
                        "\t\t\t/* Generate an INIT ACK chunk.  */",
                        "\t\t\tnew_obj = sctp_make_init_ack(asoc, chunk, GFP_ATOMIC,",
                        "\t\t\t\t\t\t     0);",
                        "\t\t\tif (!new_obj)",
                        "\t\t\t\tgoto nomem;",
                        "",
                        "\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,",
                        "\t\t\t\t\tSCTP_CHUNK(new_obj));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PEER_INIT:",
                        "\t\t\t/* Process a unified INIT from the peer.",
                        "\t\t\t * Note: Only used during INIT-ACK processing.  If",
                        "\t\t\t * there is an error just return to the outter",
                        "\t\t\t * layer which will bail.",
                        "\t\t\t */",
                        "\t\t\terror = sctp_cmd_process_init(commands, asoc, chunk,",
                        "\t\t\t\t\t\t      cmd->obj.init, gfp);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_GEN_COOKIE_ECHO:",
                        "\t\t\t/* Generate a COOKIE ECHO chunk.  */",
                        "\t\t\tnew_obj = sctp_make_cookie_echo(asoc, chunk);",
                        "\t\t\tif (!new_obj) {",
                        "\t\t\t\tif (cmd->obj.chunk)",
                        "\t\t\t\t\tsctp_chunk_free(cmd->obj.chunk);",
                        "\t\t\t\tgoto nomem;",
                        "\t\t\t}",
                        "\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,",
                        "\t\t\t\t\tSCTP_CHUNK(new_obj));",
                        "",
                        "\t\t\t/* If there is an ERROR chunk to be sent along with",
                        "\t\t\t * the COOKIE_ECHO, send it, too.",
                        "\t\t\t */",
                        "\t\t\tif (cmd->obj.chunk)",
                        "\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,",
                        "\t\t\t\t\t\tSCTP_CHUNK(cmd->obj.chunk));",
                        "",
                        "\t\t\tif (new_obj->transport) {",
                        "\t\t\t\tnew_obj->transport->init_sent_count++;",
                        "\t\t\t\tasoc->init_last_sent_to = new_obj->transport;",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* FIXME - Eventually come up with a cleaner way to",
                        "\t\t\t * enabling COOKIE-ECHO + DATA bundling during",
                        "\t\t\t * multihoming stale cookie scenarios, the following",
                        "\t\t\t * command plays with asoc->peer.retran_path to",
                        "\t\t\t * avoid the problem of sending the COOKIE-ECHO and",
                        "\t\t\t * DATA in different paths, which could result",
                        "\t\t\t * in the association being ABORTed if the DATA chunk",
                        "\t\t\t * is processed first by the server.  Checking the",
                        "\t\t\t * init error counter simply causes this command",
                        "\t\t\t * to be executed only during failed attempts of",
                        "\t\t\t * association establishment.",
                        "\t\t\t */",
                        "\t\t\tif ((asoc->peer.retran_path !=",
                        "\t\t\t     asoc->peer.primary_path) &&",
                        "\t\t\t    (asoc->init_err_counter > 0)) {",
                        "\t\t\t\tsctp_add_cmd_sf(commands,",
                        "\t\t\t\t\t\tSCTP_CMD_FORCE_PRIM_RETRAN,",
                        "\t\t\t\t\t\tSCTP_NULL());",
                        "\t\t\t}",
                        "",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_GEN_SHUTDOWN:",
                        "\t\t\t/* Generate SHUTDOWN when in SHUTDOWN_SENT state.",
                        "\t\t\t * Reset error counts.",
                        "\t\t\t */",
                        "\t\t\tasoc->overall_error_count = 0;",
                        "",
                        "\t\t\t/* Generate a SHUTDOWN chunk.  */",
                        "\t\t\tnew_obj = sctp_make_shutdown(asoc, chunk);",
                        "\t\t\tif (!new_obj)",
                        "\t\t\t\tgoto nomem;",
                        "\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,",
                        "\t\t\t\t\tSCTP_CHUNK(new_obj));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_CHUNK_ULP:",
                        "\t\t\t/* Send a chunk to the sockets layer.  */",
                        "\t\t\tpr_debug(\"%s: sm_sideff: chunk_up:%p, ulpq:%p\\n\",",
                        "\t\t\t\t __func__, cmd->obj.chunk, &asoc->ulpq);",
                        "",
                        "\t\t\tasoc->stream.si->ulpevent_data(&asoc->ulpq,",
                        "\t\t\t\t\t\t       cmd->obj.chunk,",
                        "\t\t\t\t\t\t       GFP_ATOMIC);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_EVENT_ULP:",
                        "\t\t\t/* Send a notification to the sockets layer.  */",
                        "\t\t\tpr_debug(\"%s: sm_sideff: event_up:%p, ulpq:%p\\n\",",
                        "\t\t\t\t __func__, cmd->obj.ulpevent, &asoc->ulpq);",
                        "",
                        "\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq,",
                        "\t\t\t\t\t\t       cmd->obj.ulpevent);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPLY:",
                        "\t\t\t/* If an caller has not already corked, do cork. */",
                        "\t\t\tif (!asoc->outqueue.cork) {",
                        "\t\t\t\tsctp_outq_cork(&asoc->outqueue);",
                        "\t\t\t\tlocal_cork = 1;",
                        "\t\t\t}",
                        "\t\t\t/* Send a chunk to our peer.  */",
                        "\t\t\tsctp_outq_tail(&asoc->outqueue, cmd->obj.chunk, gfp);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_SEND_PKT:",
                        "\t\t\t/* Send a full packet to our peer.  */",
                        "\t\t\tpacket = cmd->obj.packet;",
                        "\t\t\tsctp_packet_transmit(packet, gfp);",
                        "\t\t\tsctp_ootb_pkt_free(packet);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_T1_RETRAN:",
                        "\t\t\t/* Mark a transport for retransmission.  */",
                        "\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,",
                        "\t\t\t\t\tSCTP_RTXR_T1_RTX);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_RETRAN:",
                        "\t\t\t/* Mark a transport for retransmission.  */",
                        "\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,",
                        "\t\t\t\t\tSCTP_RTXR_T3_RTX);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_ECN_CE:",
                        "\t\t\t/* Do delayed CE processing.   */",
                        "\t\t\tsctp_do_ecn_ce_work(asoc, cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_ECN_ECNE:",
                        "\t\t\t/* Do delayed ECNE processing. */",
                        "\t\t\tnew_obj = sctp_do_ecn_ecne_work(asoc, cmd->obj.u32,",
                        "\t\t\t\t\t\t\tchunk);",
                        "\t\t\tif (new_obj)",
                        "\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,",
                        "\t\t\t\t\t\tSCTP_CHUNK(new_obj));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_ECN_CWR:",
                        "\t\t\t/* Do delayed CWR processing.  */",
                        "\t\t\tsctp_do_ecn_cwr_work(asoc, cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_SETUP_T2:",
                        "\t\t\tsctp_cmd_setup_t2(commands, asoc, cmd->obj.chunk);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TIMER_START_ONCE:",
                        "\t\t\ttimer = &asoc->timers[cmd->obj.to];",
                        "",
                        "\t\t\tif (timer_pending(timer))",
                        "\t\t\t\tbreak;",
                        "\t\t\t/* fall through */",
                        "",
                        "\t\tcase SCTP_CMD_TIMER_START:",
                        "\t\t\ttimer = &asoc->timers[cmd->obj.to];",
                        "\t\t\ttimeout = asoc->timeouts[cmd->obj.to];",
                        "\t\t\tBUG_ON(!timeout);",
                        "",
                        "\t\t\ttimer->expires = jiffies + timeout;",
                        "\t\t\tsctp_association_hold(asoc);",
                        "\t\t\tadd_timer(timer);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TIMER_RESTART:",
                        "\t\t\ttimer = &asoc->timers[cmd->obj.to];",
                        "\t\t\ttimeout = asoc->timeouts[cmd->obj.to];",
                        "\t\t\tif (!mod_timer(timer, jiffies + timeout))",
                        "\t\t\t\tsctp_association_hold(asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TIMER_STOP:",
                        "\t\t\ttimer = &asoc->timers[cmd->obj.to];",
                        "\t\t\tif (del_timer(timer))",
                        "\t\t\t\tsctp_association_put(asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_INIT_CHOOSE_TRANSPORT:",
                        "\t\t\tchunk = cmd->obj.chunk;",
                        "\t\t\tt = sctp_assoc_choose_alter_transport(asoc,",
                        "\t\t\t\t\t\tasoc->init_last_sent_to);",
                        "\t\t\tasoc->init_last_sent_to = t;",
                        "\t\t\tchunk->transport = t;",
                        "\t\t\tt->init_sent_count++;",
                        "\t\t\t/* Set the new transport as primary */",
                        "\t\t\tsctp_assoc_set_primary(asoc, t);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_INIT_RESTART:",
                        "\t\t\t/* Do the needed accounting and updates",
                        "\t\t\t * associated with restarting an initialization",
                        "\t\t\t * timer. Only multiply the timeout by two if",
                        "\t\t\t * all transports have been tried at the current",
                        "\t\t\t * timeout.",
                        "\t\t\t */",
                        "\t\t\tsctp_cmd_t1_timer_update(asoc,",
                        "\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_INIT,",
                        "\t\t\t\t\t\t\"INIT\");",
                        "",
                        "\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,",
                        "\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_COOKIEECHO_RESTART:",
                        "\t\t\t/* Do the needed accounting and updates",
                        "\t\t\t * associated with restarting an initialization",
                        "\t\t\t * timer. Only multiply the timeout by two if",
                        "\t\t\t * all transports have been tried at the current",
                        "\t\t\t * timeout.",
                        "\t\t\t */",
                        "\t\t\tsctp_cmd_t1_timer_update(asoc,",
                        "\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_COOKIE,",
                        "\t\t\t\t\t\t\"COOKIE\");",
                        "",
                        "\t\t\t/* If we've sent any data bundled with",
                        "\t\t\t * COOKIE-ECHO we need to resend.",
                        "\t\t\t */",
                        "\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,",
                        "\t\t\t\t\ttransports) {",
                        "\t\t\t\tsctp_retransmit_mark(&asoc->outqueue, t,",
                        "\t\t\t\t\t    SCTP_RTXR_T1_RTX);",
                        "\t\t\t}",
                        "",
                        "\t\t\tsctp_add_cmd_sf(commands,",
                        "\t\t\t\t\tSCTP_CMD_TIMER_RESTART,",
                        "\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_INIT_FAILED:",
                        "\t\t\tsctp_cmd_init_failed(commands, asoc, cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_ASSOC_FAILED:",
                        "\t\t\tsctp_cmd_assoc_failed(commands, asoc, event_type,",
                        "\t\t\t\t\t      subtype, chunk, cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_INIT_COUNTER_INC:",
                        "\t\t\tasoc->init_err_counter++;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_INIT_COUNTER_RESET:",
                        "\t\t\tasoc->init_err_counter = 0;",
                        "\t\t\tasoc->init_cycle = 0;",
                        "\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,",
                        "\t\t\t\t\t    transports) {",
                        "\t\t\t\tt->init_sent_count = 0;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPORT_DUP:",
                        "\t\t\tsctp_tsnmap_mark_dup(&asoc->peer.tsn_map,",
                        "\t\t\t\t\t     cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPORT_BAD_TAG:",
                        "\t\t\tpr_debug(\"%s: vtag mismatch!\\n\", __func__);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_STRIKE:",
                        "\t\t\t/* Mark one strike against a transport.  */",
                        "\t\t\tsctp_do_8_2_transport_strike(commands, asoc,",
                        "\t\t\t\t\t\t    cmd->obj.transport, 0);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TRANSPORT_IDLE:",
                        "\t\t\tt = cmd->obj.transport;",
                        "\t\t\tsctp_transport_lower_cwnd(t, SCTP_LOWER_CWND_INACTIVE);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TRANSPORT_HB_SENT:",
                        "\t\t\tt = cmd->obj.transport;",
                        "\t\t\tsctp_do_8_2_transport_strike(commands, asoc,",
                        "\t\t\t\t\t\t     t, 1);",
                        "\t\t\tt->hb_sent = 1;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TRANSPORT_ON:",
                        "\t\t\tt = cmd->obj.transport;",
                        "\t\t\tsctp_cmd_transport_on(commands, asoc, t, chunk);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_HB_TIMERS_START:",
                        "\t\t\tsctp_cmd_hb_timers_start(commands, asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_HB_TIMER_UPDATE:",
                        "\t\t\tt = cmd->obj.transport;",
                        "\t\t\tsctp_transport_reset_hb_timer(t);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_HB_TIMERS_STOP:",
                        "\t\t\tsctp_cmd_hb_timers_stop(commands, asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPORT_ERROR:",
                        "\t\t\terror = cmd->obj.error;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PROCESS_CTSN:",
                        "\t\t\t/* Dummy up a SACK for processing. */",
                        "\t\t\tsackh.cum_tsn_ack = cmd->obj.be32;",
                        "\t\t\tsackh.a_rwnd = htonl(asoc->peer.rwnd +",
                        "\t\t\t\t\t     asoc->outqueue.outstanding_bytes);",
                        "\t\t\tsackh.num_gap_ack_blocks = 0;",
                        "\t\t\tsackh.num_dup_tsns = 0;",
                        "\t\t\tchunk->subh.sack_hdr = &sackh;",
                        "\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK,",
                        "\t\t\t\t\tSCTP_CHUNK(chunk));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_DISCARD_PACKET:",
                        "\t\t\t/* We need to discard the whole packet.",
                        "\t\t\t * Uncork the queue since there might be",
                        "\t\t\t * responses pending",
                        "\t\t\t */",
                        "\t\t\tchunk->pdiscard = 1;",
                        "\t\t\tif (asoc) {",
                        "\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t\t\t\tlocal_cork = 0;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_RTO_PENDING:",
                        "\t\t\tt = cmd->obj.transport;",
                        "\t\t\tt->rto_pending = 1;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PART_DELIVER:",
                        "\t\t\tasoc->stream.si->start_pd(&asoc->ulpq, GFP_ATOMIC);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_RENEGE:",
                        "\t\t\tasoc->stream.si->renege_events(&asoc->ulpq,",
                        "\t\t\t\t\t\t       cmd->obj.chunk,",
                        "\t\t\t\t\t\t       GFP_ATOMIC);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_SETUP_T4:",
                        "\t\t\tsctp_cmd_setup_t4(commands, asoc, cmd->obj.chunk);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PROCESS_OPERR:",
                        "\t\t\tsctp_cmd_process_operr(commands, asoc, chunk);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_CLEAR_INIT_TAG:",
                        "\t\t\tasoc->peer.i.init_tag = 0;",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_DEL_NON_PRIMARY:",
                        "\t\t\tsctp_cmd_del_non_primary(asoc);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_T3_RTX_TIMERS_STOP:",
                        "\t\t\tsctp_cmd_t3_rtx_timers_stop(commands, asoc);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_FORCE_PRIM_RETRAN:",
                        "\t\t\tt = asoc->peer.retran_path;",
                        "\t\t\tasoc->peer.retran_path = asoc->peer.primary_path;",
                        "\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t\t\tlocal_cork = 0;",
                        "\t\t\tasoc->peer.retran_path = t;",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_SET_SK_ERR:",
                        "\t\t\tsctp_cmd_set_sk_err(asoc, cmd->obj.error);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_ASSOC_CHANGE:",
                        "\t\t\tsctp_cmd_assoc_change(commands, asoc,",
                        "\t\t\t\t\t      cmd->obj.u8);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_ADAPTATION_IND:",
                        "\t\t\tsctp_cmd_adaptation_ind(commands, asoc);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_PEER_NO_AUTH:",
                        "\t\t\tsctp_cmd_peer_no_auth(commands, asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_ASSOC_SHKEY:",
                        "\t\t\terror = sctp_auth_asoc_init_active_key(asoc,",
                        "\t\t\t\t\t\tGFP_ATOMIC);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_UPDATE_INITTAG:",
                        "\t\t\tasoc->peer.i.init_tag = cmd->obj.u32;",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_SEND_MSG:",
                        "\t\t\tif (!asoc->outqueue.cork) {",
                        "\t\t\t\tsctp_outq_cork(&asoc->outqueue);",
                        "\t\t\t\tlocal_cork = 1;",
                        "\t\t\t}",
                        "\t\t\tsctp_cmd_send_msg(asoc, cmd->obj.msg, gfp);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_SEND_NEXT_ASCONF:",
                        "\t\t\tsctp_cmd_send_asconf(asoc);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_PURGE_ASCONF_QUEUE:",
                        "\t\t\tsctp_asconf_queue_teardown(asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_SET_ASOC:",
                        "\t\t\tif (asoc && local_cork) {",
                        "\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t\t\t\tlocal_cork = 0;",
                        "\t\t\t}",
                        "\t\t\tasoc = cmd->obj.asoc;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tdefault:",
                        "\t\t\tpr_warn(\"Impossible command: %u\\n\",",
                        "\t\t\t\tcmd->verb);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\tif (error)",
                        "\t\t\tbreak;",
                        "\t}",
                        "",
                        "out:",
                        "\t/* If this is in response to a received chunk, wait until",
                        "\t * we are done with the packet to open the queue so that we don't",
                        "\t * send multiple packets in response to a single request.",
                        "\t */",
                        "\tif (asoc && SCTP_EVENT_T_CHUNK == event_type && chunk) {",
                        "\t\tif (chunk->end_of_packet || chunk->singleton)",
                        "\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t} else if (local_cork)",
                        "\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "",
                        "\tif (sp->data_ready_signalled)",
                        "\t\tsp->data_ready_signalled = 0;",
                        "",
                        "\treturn error;",
                        "nomem:",
                        "\terror = -ENOMEM;",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 1287,
                    "highlight": 1820
                },
                {
                    "file": "net/sctp/sm_sideeffect.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/sm_sideeffect.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n1220",
                    "code": [
                        "/*****************************************************************",
                        " * This the master state function side effect processing function.",
                        " *****************************************************************/",
                        "static int sctp_side_effects(enum sctp_event_type event_type,",
                        "\t\t\t     union sctp_subtype subtype,",
                        "\t\t\t     enum sctp_state state,",
                        "\t\t\t     struct sctp_endpoint *ep,",
                        "\t\t\t     struct sctp_association **asoc,",
                        "\t\t\t     void *event_arg,",
                        "\t\t\t     enum sctp_disposition status,",
                        "\t\t\t     struct sctp_cmd_seq *commands,",
                        "\t\t\t     gfp_t gfp)",
                        "{",
                        "\tint error;",
                        "",
                        "\t/* FIXME - Most of the dispositions left today would be categorized",
                        "\t * as \"exceptional\" dispositions.  For those dispositions, it",
                        "\t * may not be proper to run through any of the commands at all.",
                        "\t * For example, the command interpreter might be run only with",
                        "\t * disposition SCTP_DISPOSITION_CONSUME.",
                        "\t */",
                        "\tif (0 != (error = sctp_cmd_interpreter(event_type, subtype, state,",
                        "\t\t\t\t\t       ep, *asoc,",
                        "\t\t\t\t\t       event_arg, status,",
                        "\t\t\t\t\t       commands, gfp)))",
                        "\t\tgoto bail;",
                        "",
                        "\tswitch (status) {",
                        "\tcase SCTP_DISPOSITION_DISCARD:",
                        "\t\tpr_debug(\"%s: ignored sctp protocol event - state:%d, \"",
                        "\t\t\t \"event_type:%d, event_id:%d\\n\", __func__, state,",
                        "\t\t\t event_type, subtype.chunk);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_NOMEM:",
                        "\t\t/* We ran out of memory, so we need to discard this",
                        "\t\t * packet.",
                        "\t\t */",
                        "\t\t/* BUG--we should now recover some memory, probably by",
                        "\t\t * reneging...",
                        "\t\t */",
                        "\t\terror = -ENOMEM;",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_DELETE_TCB:",
                        "\tcase SCTP_DISPOSITION_ABORT:",
                        "\t\t/* This should now be a command. */",
                        "\t\t*asoc = NULL;",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_CONSUME:",
                        "\t\t/*",
                        "\t\t * We should no longer have much work to do here as the",
                        "\t\t * real work has been done as explicit commands above.",
                        "\t\t */",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_VIOLATION:",
                        "\t\tnet_err_ratelimited(\"protocol violation state %d chunkid %d\\n\",",
                        "\t\t\t\t    state, subtype.chunk);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_NOT_IMPL:",
                        "\t\tpr_warn(\"unimplemented feature in state %d, event_type %d, event_id %d\\n\",",
                        "\t\t\tstate, event_type, subtype.chunk);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_BUG:",
                        "\t\tpr_err(\"bug in state %d, event_type %d, event_id %d\\n\",",
                        "\t\t       state, event_type, subtype.chunk);",
                        "\t\tBUG();",
                        "\t\tbreak;",
                        "",
                        "\tdefault:",
                        "\t\tpr_err(\"impossible disposition %d in state %d, event_type %d, event_id %d\\n\",",
                        "\t\t       status, state, event_type, subtype.chunk);",
                        "\t\tBUG();",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "bail:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 1199,
                    "highlight": 1220
                },
                {
                    "file": "net/sctp/sm_sideeffect.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/sm_sideeffect.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n1191",
                    "code": [
                        "/*",
                        " * This is the master state machine processing function.",
                        " *",
                        " * If you want to understand all of lksctp, this is a",
                        " * good place to start.",
                        " */",
                        "int sctp_do_sm(struct net *net, enum sctp_event_type event_type,",
                        "\t       union sctp_subtype subtype, enum sctp_state state,",
                        "\t       struct sctp_endpoint *ep, struct sctp_association *asoc,",
                        "\t       void *event_arg, gfp_t gfp)",
                        "{",
                        "\ttypedef const char *(printfn_t)(union sctp_subtype);",
                        "\tstatic printfn_t *table[] = {",
                        "\t\tNULL, sctp_cname, sctp_tname, sctp_oname, sctp_pname,",
                        "\t};",
                        "\tprintfn_t *debug_fn  __attribute__ ((unused)) = table[event_type];",
                        "\tconst struct sctp_sm_table_entry *state_fn;",
                        "\tstruct sctp_cmd_seq commands;",
                        "\tenum sctp_disposition status;",
                        "\tint error = 0;",
                        "",
                        "\t/* Look up the state function, run it, and then process the",
                        "\t * side effects.  These three steps are the heart of lksctp.",
                        "\t */",
                        "\tstate_fn = sctp_sm_lookup_event(net, event_type, state, subtype);",
                        "",
                        "\tsctp_init_cmd_seq(&commands);",
                        "",
                        "\tdebug_pre_sfn();",
                        "\tstatus = state_fn->fn(net, ep, asoc, subtype, event_arg, &commands);",
                        "\tdebug_post_sfn();",
                        "",
                        "\terror = sctp_side_effects(event_type, subtype, state,",
                        "\t\t\t\t  ep, &asoc, event_arg, status,",
                        "\t\t\t\t  &commands, gfp);",
                        "\tdebug_post_sfx();",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 1159,
                    "highlight": 1191
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8198c57a"
        },
        "4472": {
            "name": "sctp_do_sm",
            "parent_idx": 4457,
            "source_line": [
                {
                    "file": "net/sctp/associola.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/associola.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n1074",
                    "code": [
                        "/* Do delayed input processing.  This is scheduled by sctp_rcv(). */",
                        "static void sctp_assoc_bh_rcv(struct work_struct *work)",
                        "{",
                        "\tstruct sctp_association *asoc =",
                        "\t\tcontainer_of(work, struct sctp_association,",
                        "\t\t\t     base.inqueue.immediate);",
                        "\tstruct net *net = sock_net(asoc->base.sk);",
                        "\tunion sctp_subtype subtype;",
                        "\tstruct sctp_endpoint *ep;",
                        "\tstruct sctp_chunk *chunk;",
                        "\tstruct sctp_inq *inqueue;",
                        "\tint first_time = 1;\t/* is this the first time through the loop */",
                        "\tint error = 0;",
                        "\tint state;",
                        "",
                        "\t/* The association should be held so we should be safe. */",
                        "\tep = asoc->ep;",
                        "",
                        "\tinqueue = &asoc->base.inqueue;",
                        "\tsctp_association_hold(asoc);",
                        "\twhile (NULL != (chunk = sctp_inq_pop(inqueue))) {",
                        "\t\tstate = asoc->state;",
                        "\t\tsubtype = SCTP_ST_CHUNK(chunk->chunk_hdr->type);",
                        "",
                        "\t\t/* If the first chunk in the packet is AUTH, do special",
                        "\t\t * processing specified in Section 6.3 of SCTP-AUTH spec",
                        "\t\t */",
                        "\t\tif (first_time && subtype.chunk == SCTP_CID_AUTH) {",
                        "\t\t\tstruct sctp_chunkhdr *next_hdr;",
                        "",
                        "\t\t\tnext_hdr = sctp_inq_peek(inqueue);",
                        "\t\t\tif (!next_hdr)",
                        "\t\t\t\tgoto normal;",
                        "",
                        "\t\t\t/* If the next chunk is COOKIE-ECHO, skip the AUTH",
                        "\t\t\t * chunk while saving a pointer to it so we can do",
                        "\t\t\t * Authentication later (during cookie-echo",
                        "\t\t\t * processing).",
                        "\t\t\t */",
                        "\t\t\tif (next_hdr->type == SCTP_CID_COOKIE_ECHO) {",
                        "\t\t\t\tchunk->auth_chunk = skb_clone(chunk->skb,",
                        "\t\t\t\t\t\t\t      GFP_ATOMIC);",
                        "\t\t\t\tchunk->auth = 1;",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "normal:",
                        "\t\t/* SCTP-AUTH, Section 6.3:",
                        "\t\t *    The receiver has a list of chunk types which it expects",
                        "\t\t *    to be received only after an AUTH-chunk.  This list has",
                        "\t\t *    been sent to the peer during the association setup.  It",
                        "\t\t *    MUST silently discard these chunks if they are not placed",
                        "\t\t *    after an AUTH chunk in the packet.",
                        "\t\t */",
                        "\t\tif (sctp_auth_recv_cid(subtype.chunk, asoc) && !chunk->auth)",
                        "\t\t\tcontinue;",
                        "",
                        "\t\t/* Remember where the last DATA chunk came from so we",
                        "\t\t * know where to send the SACK.",
                        "\t\t */",
                        "\t\tif (sctp_chunk_is_data(chunk))",
                        "\t\t\tasoc->peer.last_data_from = chunk->transport;",
                        "\t\telse {",
                        "\t\t\tSCTP_INC_STATS(net, SCTP_MIB_INCTRLCHUNKS);",
                        "\t\t\tasoc->stats.ictrlchunks++;",
                        "\t\t\tif (chunk->chunk_hdr->type == SCTP_CID_SACK)",
                        "\t\t\t\tasoc->stats.isacks++;",
                        "\t\t}",
                        "",
                        "\t\tif (chunk->transport)",
                        "\t\t\tchunk->transport->last_time_heard = ktime_get();",
                        "",
                        "\t\t/* Run through the state machine. */",
                        "\t\terror = sctp_do_sm(net, SCTP_EVENT_T_CHUNK, subtype,",
                        "\t\t\t\t   state, ep, asoc, chunk, GFP_ATOMIC);",
                        "",
                        "\t\t/* Check to see if the association is freed in response to",
                        "\t\t * the incoming chunk.  If so, get out of the while loop.",
                        "\t\t */",
                        "\t\tif (asoc->base.dead)",
                        "\t\t\tbreak;",
                        "",
                        "\t\t/* If there is an error on chunk, discard this packet. */",
                        "\t\tif (error && chunk)",
                        "\t\t\tchunk->pdiscard = 1;",
                        "",
                        "\t\tif (first_time)",
                        "\t\t\tfirst_time = 0;",
                        "\t}",
                        "\tsctp_association_put(asoc);",
                        "}"
                    ],
                    "start": 1000,
                    "highlight": 1074
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8198fe3b"
        },
        "4457": {
            "name": "sctp_inq_push",
            "parent_idx": 4452,
            "source_line": [
                {
                    "file": "net/sctp/input.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/input.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n354",
                    "code": [
                        "/* Process the backlog queue of the socket.  Every skb on",
                        " * the backlog holds a ref on an association or endpoint.",
                        " * We hold this ref throughout the state machine to make",
                        " * sure that the structure we need is still around.",
                        " */",
                        "int sctp_backlog_rcv(struct sock *sk, struct sk_buff *skb)",
                        "{",
                        "\tstruct sctp_chunk *chunk = SCTP_INPUT_CB(skb)->chunk;",
                        "\tstruct sctp_inq *inqueue = &chunk->rcvr->inqueue;",
                        "\tstruct sctp_transport *t = chunk->transport;",
                        "\tstruct sctp_ep_common *rcvr = NULL;",
                        "\tint backloged = 0;",
                        "",
                        "\trcvr = chunk->rcvr;",
                        "",
                        "\t/* If the rcvr is dead then the association or endpoint",
                        "\t * has been deleted and we can safely drop the chunk",
                        "\t * and refs that we are holding.",
                        "\t */",
                        "\tif (rcvr->dead) {",
                        "\t\tsctp_chunk_free(chunk);",
                        "\t\tgoto done;",
                        "\t}",
                        "",
                        "\tif (unlikely(rcvr->sk != sk)) {",
                        "\t\t/* In this case, the association moved from one socket to",
                        "\t\t * another.  We are currently sitting on the backlog of the",
                        "\t\t * old socket, so we need to move.",
                        "\t\t * However, since we are here in the process context we",
                        "\t\t * need to take make sure that the user doesn't own",
                        "\t\t * the new socket when we process the packet.",
                        "\t\t * If the new socket is user-owned, queue the chunk to the",
                        "\t\t * backlog of the new socket without dropping any refs.",
                        "\t\t * Otherwise, we can safely push the chunk on the inqueue.",
                        "\t\t */",
                        "",
                        "\t\tsk = rcvr->sk;",
                        "\t\tlocal_bh_disable();",
                        "\t\tbh_lock_sock(sk);",
                        "",
                        "\t\tif (sock_owned_by_user(sk)) {",
                        "\t\t\tif (sk_add_backlog(sk, skb, sk->sk_rcvbuf))",
                        "\t\t\t\tsctp_chunk_free(chunk);",
                        "\t\t\telse",
                        "\t\t\t\tbackloged = 1;",
                        "\t\t} else",
                        "\t\t\tsctp_inq_push(inqueue, chunk);",
                        "",
                        "\t\tbh_unlock_sock(sk);",
                        "\t\tlocal_bh_enable();",
                        "",
                        "\t\t/* If the chunk was backloged again, don't drop refs */",
                        "\t\tif (backloged)",
                        "\t\t\treturn 0;",
                        "\t} else {",
                        "\t\tsctp_inq_push(inqueue, chunk);",
                        "\t}",
                        "",
                        "done:",
                        "\t/* Release the refs we took in sctp_add_backlog */",
                        "\tif (SCTP_EP_TYPE_ASSOCIATION == rcvr->type)",
                        "\t\tsctp_transport_put(t);",
                        "\telse if (SCTP_EP_TYPE_SOCKET == rcvr->type)",
                        "\t\tsctp_endpoint_put(sctp_ep(rcvr));",
                        "\telse",
                        "\t\tBUG();",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 299,
                    "highlight": 354
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819ab0c7"
        },
        "4452": {
            "name": "__indirect_thunk_start",
            "parent_idx": 3621,
            "source_line": [
                {
                    "file": "./include/net/sock.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/sock.h?id=63bdf4284c38a48af21745ceb148a087b190cd21#n937",
                    "code": [
                        "\treturn sk->sk_backlog_rcv(sk, skb);",
                        "}"
                    ],
                    "start": 937,
                    "highlight": 937
                },
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n2413",
                    "code": [
                        "void __release_sock(struct sock *sk)",
                        "\t__releases(&sk->sk_lock.slock)",
                        "\t__acquires(&sk->sk_lock.slock)",
                        "{",
                        "\tstruct sk_buff *skb, *next;",
                        "",
                        "\twhile ((skb = sk->sk_backlog.head) != NULL) {",
                        "\t\tsk->sk_backlog.head = sk->sk_backlog.tail = NULL;",
                        "",
                        "\t\tspin_unlock_bh(&sk->sk_lock.slock);",
                        "",
                        "\t\tdo {",
                        "\t\t\tnext = skb->next;",
                        "\t\t\tprefetch(next);",
                        "\t\t\tWARN_ON_ONCE(skb_dst_is_noref(skb));",
                        "\t\t\tskb_mark_not_on_list(skb);",
                        "\t\t\tsk_backlog_rcv(sk, skb);",
                        "",
                        "\t\t\tcond_resched();",
                        "",
                        "\t\t\tskb = next;",
                        "\t\t} while (skb != NULL);",
                        "",
                        "\t\tspin_lock_bh(&sk->sk_lock.slock);",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Doing the zeroing here guarantee we can not loop forever",
                        "\t * while a wild producer attempts to flood us.",
                        "\t */",
                        "\tsk->sk_backlog.len = 0;",
                        "}"
                    ],
                    "start": 2397,
                    "highlight": 2413
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817fa52e"
        },
        "3621": {
            "name": "__release_sock",
            "parent_idx": 3618,
            "source_line": [
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n2929",
                    "code": [
                        "void release_sock(struct sock *sk)",
                        "{",
                        "\tspin_lock_bh(&sk->sk_lock.slock);",
                        "\tif (sk->sk_backlog.tail)",
                        "\t\t__release_sock(sk);",
                        "",
                        "\t/* Warning : release_cb() might need to release sk ownership,",
                        "\t * ie call sock_release_ownership(sk) before us.",
                        "\t */",
                        "\tif (sk->sk_prot->release_cb)",
                        "\t\tsk->sk_prot->release_cb(sk);",
                        "",
                        "\tsock_release_ownership(sk);",
                        "\tif (waitqueue_active(&sk->sk_lock.wq))",
                        "\t\twake_up(&sk->sk_lock.wq);",
                        "\tspin_unlock_bh(&sk->sk_lock.slock);",
                        "}"
                    ],
                    "start": 2925,
                    "highlight": 2929
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817fa591"
        },
        "3618": {
            "name": "release_sock",
            "parent_idx": 3610,
            "source_line": [
                {
                    "file": "net/sctp/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n8999",
                    "code": [
                        "/* Wait for an association to go into ESTABLISHED state. If timeout is 0,",
                        " * returns immediately with EINPROGRESS.",
                        " */",
                        "static int sctp_wait_for_connect(struct sctp_association *asoc, long *timeo_p)",
                        "{",
                        "\tstruct sock *sk = asoc->base.sk;",
                        "\tint err = 0;",
                        "\tlong current_timeo = *timeo_p;",
                        "\tDEFINE_WAIT(wait);",
                        "",
                        "\tpr_debug(\"%s: asoc:%p, timeo:%ld\\n\", __func__, asoc, *timeo_p);",
                        "",
                        "\t/* Increment the association's refcnt.  */",
                        "\tsctp_association_hold(asoc);",
                        "",
                        "\tfor (;;) {",
                        "\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,",
                        "\t\t\t\t\t  TASK_INTERRUPTIBLE);",
                        "\t\tif (!*timeo_p)",
                        "\t\t\tgoto do_nonblock;",
                        "\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)",
                        "\t\t\tbreak;",
                        "\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||",
                        "\t\t    asoc->base.dead)",
                        "\t\t\tgoto do_error;",
                        "\t\tif (signal_pending(current))",
                        "\t\t\tgoto do_interrupted;",
                        "",
                        "\t\tif (sctp_state(asoc, ESTABLISHED))",
                        "\t\t\tbreak;",
                        "",
                        "\t\t/* Let another process have a go.  Since we are going",
                        "\t\t * to sleep anyway.",
                        "\t\t */",
                        "\t\trelease_sock(sk);",
                        "\t\tcurrent_timeo = schedule_timeout(current_timeo);",
                        "\t\tlock_sock(sk);",
                        "",
                        "\t\t*timeo_p = current_timeo;",
                        "\t}",
                        "",
                        "out:",
                        "\tfinish_wait(&asoc->wait, &wait);",
                        "",
                        "\t/* Release the association's refcnt.  */",
                        "\tsctp_association_put(asoc);",
                        "",
                        "\treturn err;",
                        "",
                        "do_error:",
                        "\tif (asoc->init_err_counter + 1 > asoc->max_init_attempts)",
                        "\t\terr = -ETIMEDOUT;",
                        "\telse",
                        "\t\terr = -ECONNREFUSED;",
                        "\tgoto out;",
                        "",
                        "do_interrupted:",
                        "\terr = sock_intr_errno(*timeo_p);",
                        "\tgoto out;",
                        "",
                        "do_nonblock:",
                        "\terr = -EINPROGRESS;",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 8965,
                    "highlight": 8999
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819a0c90"
        },
        "3610": {
            "name": "sctp_wait_for_connect",
            "parent_idx": 3113,
            "source_line": [
                {
                    "file": "net/sctp/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n1968",
                    "code": [
                        "static int sctp_sendmsg_to_asoc(struct sctp_association *asoc,",
                        "\t\t\t\tstruct msghdr *msg, size_t msg_len,",
                        "\t\t\t\tstruct sctp_transport *transport,",
                        "\t\t\t\tstruct sctp_sndrcvinfo *sinfo)",
                        "{",
                        "\tstruct sock *sk = asoc->base.sk;",
                        "\tstruct sctp_sock *sp = sctp_sk(sk);",
                        "\tstruct net *net = sock_net(sk);",
                        "\tstruct sctp_datamsg *datamsg;",
                        "\tbool wait_connect = false;",
                        "\tstruct sctp_chunk *chunk;",
                        "\tlong timeo;",
                        "\tint err;",
                        "",
                        "\tif (sinfo->sinfo_stream >= asoc->stream.outcnt) {",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto err;",
                        "\t}",
                        "",
                        "\tif (unlikely(!SCTP_SO(&asoc->stream, sinfo->sinfo_stream)->ext)) {",
                        "\t\terr = sctp_stream_init_ext(&asoc->stream, sinfo->sinfo_stream);",
                        "\t\tif (err)",
                        "\t\t\tgoto err;",
                        "\t}",
                        "",
                        "\tif (sp->disable_fragments && msg_len > asoc->frag_point) {",
                        "\t\terr = -EMSGSIZE;",
                        "\t\tgoto err;",
                        "\t}",
                        "",
                        "\tif (asoc->pmtu_pending) {",
                        "\t\tif (sp->param_flags & SPP_PMTUD_ENABLE)",
                        "\t\t\tsctp_assoc_sync_pmtu(asoc);",
                        "\t\tasoc->pmtu_pending = 0;",
                        "\t}",
                        "",
                        "\tif (sctp_wspace(asoc) < (int)msg_len)",
                        "\t\tsctp_prsctp_prune(asoc, sinfo, msg_len - sctp_wspace(asoc));",
                        "",
                        "\tif (sctp_wspace(asoc) <= 0) {",
                        "\t\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);",
                        "\t\terr = sctp_wait_for_sndbuf(asoc, &timeo, msg_len);",
                        "\t\tif (err)",
                        "\t\t\tgoto err;",
                        "\t}",
                        "",
                        "\tif (sctp_state(asoc, CLOSED)) {",
                        "\t\terr = sctp_primitive_ASSOCIATE(net, asoc, NULL);",
                        "\t\tif (err)",
                        "\t\t\tgoto err;",
                        "",
                        "\t\tif (sp->strm_interleave) {",
                        "\t\t\ttimeo = sock_sndtimeo(sk, 0);",
                        "\t\t\terr = sctp_wait_for_connect(asoc, &timeo);",
                        "\t\t\tif (err) {",
                        "\t\t\t\terr = -ESRCH;",
                        "\t\t\t\tgoto err;",
                        "\t\t\t}",
                        "\t\t} else {",
                        "\t\t\twait_connect = true;",
                        "\t\t}",
                        "",
                        "\t\tpr_debug(\"%s: we associated primitively\\n\", __func__);",
                        "\t}",
                        "",
                        "\tdatamsg = sctp_datamsg_from_user(asoc, sinfo, &msg->msg_iter);",
                        "\tif (IS_ERR(datamsg)) {",
                        "\t\terr = PTR_ERR(datamsg);",
                        "\t\tgoto err;",
                        "\t}",
                        "",
                        "\tasoc->force_delay = !!(msg->msg_flags & MSG_MORE);",
                        "",
                        "\tlist_for_each_entry(chunk, &datamsg->chunks, frag_list) {",
                        "\t\tsctp_chunk_hold(chunk);",
                        "\t\tsctp_set_owner_w(chunk);",
                        "\t\tchunk->transport = transport;",
                        "\t}",
                        "",
                        "\terr = sctp_primitive_SEND(net, asoc, datamsg);",
                        "\tif (err) {",
                        "\t\tsctp_datamsg_free(datamsg);",
                        "\t\tgoto err;",
                        "\t}",
                        "",
                        "\tpr_debug(\"%s: we sent primitively\\n\", __func__);",
                        "",
                        "\tsctp_datamsg_put(datamsg);",
                        "",
                        "\tif (unlikely(wait_connect)) {",
                        "\t\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);",
                        "\t\tsctp_wait_for_connect(asoc, &timeo);",
                        "\t}",
                        "",
                        "\terr = msg_len;",
                        "",
                        "err:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1877,
                    "highlight": 1968
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819a1b80"
        },
        "3113": {
            "name": "sctp_sendmsg_to_asoc",
            "parent_idx": 1621,
            "source_line": [
                {
                    "file": "net/sctp/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n2114",
                    "code": [
                        "static int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)",
                        "{",
                        "\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;",
                        "\tstruct sctp_transport *transport = NULL;",
                        "\tstruct sctp_sndrcvinfo _sinfo, *sinfo;",
                        "\tstruct sctp_association *asoc, *tmp;",
                        "\tstruct sctp_cmsgs cmsgs;",
                        "\tunion sctp_addr *daddr;",
                        "\tbool new = false;",
                        "\t__u16 sflags;",
                        "\tint err;",
                        "",
                        "\t/* Parse and get snd_info */",
                        "\terr = sctp_sendmsg_parse(sk, &cmsgs, &_sinfo, msg, msg_len);",
                        "\tif (err)",
                        "\t\tgoto out;",
                        "",
                        "\tsinfo  = &_sinfo;",
                        "\tsflags = sinfo->sinfo_flags;",
                        "",
                        "\t/* Get daddr from msg */",
                        "\tdaddr = sctp_sendmsg_get_daddr(sk, msg, &cmsgs);",
                        "\tif (IS_ERR(daddr)) {",
                        "\t\terr = PTR_ERR(daddr);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tlock_sock(sk);",
                        "",
                        "\t/* SCTP_SENDALL process */",
                        "\tif ((sflags & SCTP_SENDALL) && sctp_style(sk, UDP)) {",
                        "\t\tlist_for_each_entry_safe(asoc, tmp, &ep->asocs, asocs) {",
                        "\t\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg,",
                        "\t\t\t\t\t\t\tmsg_len);",
                        "\t\t\tif (err == 0)",
                        "\t\t\t\tcontinue;",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\tgoto out_unlock;",
                        "",
                        "\t\t\tsctp_sendmsg_update_sinfo(asoc, sinfo, &cmsgs);",
                        "",
                        "\t\t\terr = sctp_sendmsg_to_asoc(asoc, msg, msg_len,",
                        "\t\t\t\t\t\t   NULL, sinfo);",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\tgoto out_unlock;",
                        "",
                        "\t\t\tiov_iter_revert(&msg->msg_iter, err);",
                        "\t\t}",
                        "",
                        "\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\t/* Get and check or create asoc */",
                        "\tif (daddr) {",
                        "\t\tasoc = sctp_endpoint_lookup_assoc(ep, daddr, &transport);",
                        "\t\tif (asoc) {",
                        "\t\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg,",
                        "\t\t\t\t\t\t\tmsg_len);",
                        "\t\t\tif (err <= 0)",
                        "\t\t\t\tgoto out_unlock;",
                        "\t\t} else {",
                        "\t\t\terr = sctp_sendmsg_new_asoc(sk, sflags, &cmsgs, daddr,",
                        "\t\t\t\t\t\t    &transport);",
                        "\t\t\tif (err)",
                        "\t\t\t\tgoto out_unlock;",
                        "",
                        "\t\t\tasoc = transport->asoc;",
                        "\t\t\tnew = true;",
                        "\t\t}",
                        "",
                        "\t\tif (!sctp_style(sk, TCP) && !(sflags & SCTP_ADDR_OVER))",
                        "\t\t\ttransport = NULL;",
                        "\t} else {",
                        "\t\tasoc = sctp_id2assoc(sk, sinfo->sinfo_assoc_id);",
                        "\t\tif (!asoc) {",
                        "\t\t\terr = -EPIPE;",
                        "\t\t\tgoto out_unlock;",
                        "\t\t}",
                        "",
                        "\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg, msg_len);",
                        "\t\tif (err <= 0)",
                        "\t\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\t/* Update snd_info with the asoc */",
                        "\tsctp_sendmsg_update_sinfo(asoc, sinfo, &cmsgs);",
                        "",
                        "\t/* Send msg to the asoc */",
                        "\terr = sctp_sendmsg_to_asoc(asoc, msg, msg_len, transport, sinfo);",
                        "\tif (err < 0 && err != -ESRCH && new)",
                        "\t\tsctp_association_free(asoc);",
                        "",
                        "out_unlock:",
                        "\trelease_sock(sk);",
                        "out:",
                        "\treturn sctp_error(sk, msg->msg_flags, err);",
                        "}"
                    ],
                    "start": 2026,
                    "highlight": 2114
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819a2734"
        },
        "1621": {
            "name": "__indirect_thunk_start",
            "parent_idx": 1613,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n622",
                    "code": [
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = sock->ops->sendmsg(sock, msg, msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 620,
                    "highlight": 622
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n632",
                    "code": [
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 627,
                    "highlight": 632
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817f2dbf"
        },
        "1613": {
            "name": "sock_sendmsg",
            "parent_idx": 1604,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n2137",
                    "code": [
                        "static int ___sys_sendmsg(struct socket *sock, struct user_msghdr __user *msg,",
                        "\t\t\t struct msghdr *msg_sys, unsigned int flags,",
                        "\t\t\t struct used_address *used_address,",
                        "\t\t\t unsigned int allowed_msghdr_flags)",
                        "{",
                        "\tstruct compat_msghdr __user *msg_compat =",
                        "\t    (struct compat_msghdr __user *)msg;",
                        "\tstruct sockaddr_storage address;",
                        "\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;",
                        "\tunsigned char ctl[sizeof(struct cmsghdr) + 20]",
                        "\t\t\t\t__aligned(sizeof(__kernel_size_t));",
                        "\t/* 20 is size of ipv6_pktinfo */",
                        "\tunsigned char *ctl_buf = ctl;",
                        "\tint ctl_len;",
                        "\tssize_t err;",
                        "",
                        "\tmsg_sys->msg_name = &address;",
                        "",
                        "\tif (MSG_CMSG_COMPAT & flags)",
                        "\t\terr = get_compat_msghdr(msg_sys, msg_compat, NULL, &iov);",
                        "\telse",
                        "\t\terr = copy_msghdr_from_user(msg_sys, msg, NULL, &iov);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\terr = -ENOBUFS;",
                        "",
                        "\tif (msg_sys->msg_controllen > INT_MAX)",
                        "\t\tgoto out_freeiov;",
                        "\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);",
                        "\tctl_len = msg_sys->msg_controllen;",
                        "\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
                        "\t\terr =",
                        "\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,",
                        "\t\t\t\t\t\t     sizeof(ctl));",
                        "\t\tif (err)",
                        "\t\t\tgoto out_freeiov;",
                        "\t\tctl_buf = msg_sys->msg_control;",
                        "\t\tctl_len = msg_sys->msg_controllen;",
                        "\t} else if (ctl_len) {",
                        "\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=",
                        "\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));",
                        "\t\tif (ctl_len > sizeof(ctl)) {",
                        "\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);",
                        "\t\t\tif (ctl_buf == NULL)",
                        "\t\t\t\tgoto out_freeiov;",
                        "\t\t}",
                        "\t\terr = -EFAULT;",
                        "\t\t/*",
                        "\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.",
                        "\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted",
                        "\t\t * checking falls down on this.",
                        "\t\t */",
                        "\t\tif (copy_from_user(ctl_buf,",
                        "\t\t\t\t   (void __user __force *)msg_sys->msg_control,",
                        "\t\t\t\t   ctl_len))",
                        "\t\t\tgoto out_freectl;",
                        "\t\tmsg_sys->msg_control = ctl_buf;",
                        "\t}",
                        "\tmsg_sys->msg_flags = flags;",
                        "",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;",
                        "\t/*",
                        "\t * If this is sendmmsg() and current destination address is same as",
                        "\t * previously succeeded address, omit asking LSM's decision.",
                        "\t * used_address->name_len is initialized to UINT_MAX so that the first",
                        "\t * destination address never matches.",
                        "\t */",
                        "\tif (used_address && msg_sys->msg_name &&",
                        "\t    used_address->name_len == msg_sys->msg_namelen &&",
                        "\t    !memcmp(&used_address->name, msg_sys->msg_name,",
                        "\t\t    used_address->name_len)) {",
                        "\t\terr = sock_sendmsg_nosec(sock, msg_sys);",
                        "\t\tgoto out_freectl;",
                        "\t}",
                        "\terr = sock_sendmsg(sock, msg_sys);",
                        "\t/*",
                        "\t * If this is sendmmsg() and sending to current destination address was",
                        "\t * successful, remember it.",
                        "\t */",
                        "\tif (used_address && err >= 0) {",
                        "\t\tused_address->name_len = msg_sys->msg_namelen;",
                        "\t\tif (msg_sys->msg_name)",
                        "\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,",
                        "\t\t\t       used_address->name_len);",
                        "\t}",
                        "",
                        "out_freectl:",
                        "\tif (ctl_buf != ctl)",
                        "\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);",
                        "out_freeiov:",
                        "\tkfree(iov);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2061,
                    "highlight": 2137
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817f395c"
        },
        "1604": {
            "name": "___sys_sendmsg",
            "parent_idx": 1583,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n2175",
                    "code": [
                        "\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);",
                        "",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2175,
                    "highlight": 2175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff817f5cbf"
        },
        "1583": {
            "name": "__indirect_thunk_start",
            "parent_idx": 1580,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n290",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\t/*",
                        "\t * NB: Native and x32 syscalls are dispatched from the same",
                        "\t * table.  The only functional difference is the x32 bit in",
                        "\t * regs->orig_ax, which changes the behavior of some syscalls.",
                        "\t */",
                        "\tnr &= __SYSCALL_MASK;",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 271,
                    "highlight": 290
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8100242e"
        },
        "1580": {
            "name": "do_syscall_64",
            "parent_idx": 1573,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=63bdf4284c38a48af21745ceb148a087b190cd21#n175",
                    "code": [
                        "ENTRY(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "GLOBAL(entry_SYSCALL_64_after_hwframe)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "1573": {
            "name": "60_syscall_6",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "4559": {
            "name": "+0x38",
            "parent_idx": 4557,
            "source_line": [
                {
                    "file": "net/sctp/stream_sched_rr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/stream_sched_rr.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n140",
                    "code": [
                        "static struct sctp_chunk *sctp_sched_rr_dequeue(struct sctp_outq *q)",
                        "{",
                        "\tstruct sctp_stream *stream = &q->asoc->stream;",
                        "\tstruct sctp_stream_out_ext *soute;",
                        "\tstruct sctp_chunk *ch = NULL;",
                        "",
                        "\t/* Bail out quickly if queue is empty */",
                        "\tif (list_empty(&q->out_chunk_list))",
                        "\t\tgoto out;",
                        "",
                        "\t/* Find which chunk is next */",
                        "\tif (stream->out_curr)",
                        "\t\tsoute = stream->out_curr->ext;",
                        "\telse",
                        "\t\tsoute = stream->rr_next;",
                        "\tch = list_entry(soute->outq.next, struct sctp_chunk, stream_list);",
                        "",
                        "\tsctp_sched_dequeue_common(q, ch);",
                        "",
                        "out:",
                        "\treturn ch;",
                        "}"
                    ],
                    "start": 126,
                    "highlight": 140
                }
            ],
            "ins_idx": 38,
            "addr": "0xffffffff819b0868"
        },
        "4527": {
            "name": "+0x4",
            "parent_idx": 4526,
            "source_line": [
                {
                    "file": "net/sctp/stream_sched_rr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/stream_sched_rr.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n95",
                    "code": [
                        "static int sctp_sched_rr_init(struct sctp_stream *stream)",
                        "{",
                        "\tINIT_LIST_HEAD(&stream->rr_list);",
                        "\tstream->rr_next = NULL;",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 92,
                    "highlight": 95
                }
            ],
            "ins_idx": 64,
            "addr": "0xffffffff819b0634"
        },
        "4526": {
            "name": "__indirect_thunk_start",
            "parent_idx": 4490,
            "source_line": [
                {
                    "file": "net/sctp/stream.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/stream.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n233",
                    "code": [
                        "int sctp_stream_init(struct sctp_stream *stream, __u16 outcnt, __u16 incnt,",
                        "\t\t     gfp_t gfp)",
                        "{",
                        "\tstruct sctp_sched_ops *sched = sctp_sched_ops_from_stream(stream);",
                        "\tint i, ret = 0;",
                        "",
                        "\tgfp |= __GFP_NOWARN;",
                        "",
                        "\t/* Initial stream->out size may be very big, so free it and alloc",
                        "\t * a new one with new outcnt to save memory if needed.",
                        "\t */",
                        "\tif (outcnt == stream->outcnt)",
                        "\t\tgoto in;",
                        "",
                        "\t/* Filter out chunks queued on streams that won't exist anymore */",
                        "\tsched->unsched_all(stream);",
                        "\tsctp_stream_outq_migrate(stream, NULL, outcnt);",
                        "\tsched->sched_all(stream);",
                        "",
                        "\tret = sctp_stream_alloc_out(stream, outcnt, gfp);",
                        "\tif (ret)",
                        "\t\tgoto out;",
                        "",
                        "\tstream->outcnt = outcnt;",
                        "\tfor (i = 0; i < stream->outcnt; i++)",
                        "\t\tSCTP_SO(stream, i)->state = SCTP_STREAM_OPEN;",
                        "",
                        "\tsched->init(stream);",
                        "",
                        "in:",
                        "\tsctp_stream_interleave_init(stream);",
                        "\tif (!incnt)",
                        "\t\tgoto out;",
                        "",
                        "\tret = sctp_stream_alloc_in(stream, incnt, gfp);",
                        "\tif (ret) {",
                        "\t\tsched->free(stream);",
                        "\t\tfa_free(stream->out);",
                        "\t\tstream->out = NULL;",
                        "\t\tstream->outcnt = 0;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tstream->incnt = incnt;",
                        "",
                        "out:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 206,
                    "highlight": 233
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819ad19a"
        },
        "4490": {
            "name": "sctp_stream_init",
            "parent_idx": 4480,
            "source_line": [
                {
                    "file": "net/sctp/sm_make_chunk.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/sm_make_chunk.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n2466",
                    "code": [
                        "/* Unpack the parameters in an INIT packet into an association.",
                        " * Returns 0 on failure, else success.",
                        " * FIXME:  This is an association method.",
                        " */",
                        "int sctp_process_init(struct sctp_association *asoc, struct sctp_chunk *chunk,",
                        "\t\t      const union sctp_addr *peer_addr,",
                        "\t\t      struct sctp_init_chunk *peer_init, gfp_t gfp)",
                        "{",
                        "\tstruct net *net = sock_net(asoc->base.sk);",
                        "\tstruct sctp_transport *transport;",
                        "\tstruct list_head *pos, *temp;",
                        "\tunion sctp_params param;",
                        "\tunion sctp_addr addr;",
                        "\tstruct sctp_af *af;",
                        "\tint src_match = 0;",
                        "\tchar *cookie;",
                        "",
                        "\t/* We must include the address that the INIT packet came from.",
                        "\t * This is the only address that matters for an INIT packet.",
                        "\t * When processing a COOKIE ECHO, we retrieve the from address",
                        "\t * of the INIT from the cookie.",
                        "\t */",
                        "",
                        "\t/* This implementation defaults to making the first transport",
                        "\t * added as the primary transport.  The source address seems to",
                        "\t * be a a better choice than any of the embedded addresses.",
                        "\t */",
                        "\tif (!sctp_assoc_add_peer(asoc, peer_addr, gfp, SCTP_ACTIVE))",
                        "\t\tgoto nomem;",
                        "",
                        "\tif (sctp_cmp_addr_exact(sctp_source(chunk), peer_addr))",
                        "\t\tsrc_match = 1;",
                        "",
                        "\t/* Process the initialization parameters.  */",
                        "\tsctp_walk_params(param, peer_init, init_hdr.params) {",
                        "\t\tif (!src_match && (param.p->type == SCTP_PARAM_IPV4_ADDRESS ||",
                        "\t\t    param.p->type == SCTP_PARAM_IPV6_ADDRESS)) {",
                        "\t\t\taf = sctp_get_af_specific(param_type2af(param.p->type));",
                        "\t\t\taf->from_addr_param(&addr, param.addr,",
                        "\t\t\t\t\t    chunk->sctp_hdr->source, 0);",
                        "\t\t\tif (sctp_cmp_addr_exact(sctp_source(chunk), &addr))",
                        "\t\t\t\tsrc_match = 1;",
                        "\t\t}",
                        "",
                        "\t\tif (!sctp_process_param(asoc, param, peer_addr, gfp))",
                        "\t\t\tgoto clean_up;",
                        "\t}",
                        "",
                        "\t/* source address of chunk may not match any valid address */",
                        "\tif (!src_match)",
                        "\t\tgoto clean_up;",
                        "",
                        "\t/* AUTH: After processing the parameters, make sure that we",
                        "\t * have all the required info to potentially do authentications.",
                        "\t */",
                        "\tif (asoc->peer.auth_capable && (!asoc->peer.peer_random ||",
                        "\t\t\t\t\t!asoc->peer.peer_hmacs))",
                        "\t\tasoc->peer.auth_capable = 0;",
                        "",
                        "\t/* In a non-backward compatible mode, if the peer claims",
                        "\t * support for ADD-IP but not AUTH,  the ADD-IP spec states",
                        "\t * that we MUST ABORT the association. Section 6.  The section",
                        "\t * also give us an option to silently ignore the packet, which",
                        "\t * is what we'll do here.",
                        "\t */",
                        "\tif (!net->sctp.addip_noauth &&",
                        "\t     (asoc->peer.asconf_capable && !asoc->peer.auth_capable)) {",
                        "\t\tasoc->peer.addip_disabled_mask |= (SCTP_PARAM_ADD_IP |",
                        "\t\t\t\t\t\t  SCTP_PARAM_DEL_IP |",
                        "\t\t\t\t\t\t  SCTP_PARAM_SET_PRIMARY);",
                        "\t\tasoc->peer.asconf_capable = 0;",
                        "\t\tgoto clean_up;",
                        "\t}",
                        "",
                        "\t/* Walk list of transports, removing transports in the UNKNOWN state. */",
                        "\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {",
                        "\t\ttransport = list_entry(pos, struct sctp_transport, transports);",
                        "\t\tif (transport->state == SCTP_UNKNOWN) {",
                        "\t\t\tsctp_assoc_rm_peer(asoc, transport);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* The fixed INIT headers are always in network byte",
                        "\t * order.",
                        "\t */",
                        "\tasoc->peer.i.init_tag =",
                        "\t\tntohl(peer_init->init_hdr.init_tag);",
                        "\tasoc->peer.i.a_rwnd =",
                        "\t\tntohl(peer_init->init_hdr.a_rwnd);",
                        "\tasoc->peer.i.num_outbound_streams =",
                        "\t\tntohs(peer_init->init_hdr.num_outbound_streams);",
                        "\tasoc->peer.i.num_inbound_streams =",
                        "\t\tntohs(peer_init->init_hdr.num_inbound_streams);",
                        "\tasoc->peer.i.initial_tsn =",
                        "\t\tntohl(peer_init->init_hdr.initial_tsn);",
                        "",
                        "\tasoc->strreset_inseq = asoc->peer.i.initial_tsn;",
                        "",
                        "\t/* Apply the upper bounds for output streams based on peer's",
                        "\t * number of inbound streams.",
                        "\t */",
                        "\tif (asoc->c.sinit_num_ostreams  >",
                        "\t    ntohs(peer_init->init_hdr.num_inbound_streams)) {",
                        "\t\tasoc->c.sinit_num_ostreams =",
                        "\t\t\tntohs(peer_init->init_hdr.num_inbound_streams);",
                        "\t}",
                        "",
                        "\tif (asoc->c.sinit_max_instreams >",
                        "\t    ntohs(peer_init->init_hdr.num_outbound_streams)) {",
                        "\t\tasoc->c.sinit_max_instreams =",
                        "\t\t\tntohs(peer_init->init_hdr.num_outbound_streams);",
                        "\t}",
                        "",
                        "\t/* Copy Initiation tag from INIT to VT_peer in cookie.   */",
                        "\tasoc->c.peer_vtag = asoc->peer.i.init_tag;",
                        "",
                        "\t/* Peer Rwnd   : Current calculated value of the peer's rwnd.  */",
                        "\tasoc->peer.rwnd = asoc->peer.i.a_rwnd;",
                        "",
                        "\t/* Copy cookie in case we need to resend COOKIE-ECHO. */",
                        "\tcookie = asoc->peer.cookie;",
                        "\tif (cookie) {",
                        "\t\tasoc->peer.cookie = kmemdup(cookie, asoc->peer.cookie_len, gfp);",
                        "\t\tif (!asoc->peer.cookie)",
                        "\t\t\tgoto clean_up;",
                        "\t}",
                        "",
                        "\t/* RFC 2960 7.2.1 The initial value of ssthresh MAY be arbitrarily",
                        "\t * high (for example, implementations MAY use the size of the receiver",
                        "\t * advertised window).",
                        "\t */",
                        "\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,",
                        "\t\t\ttransports) {",
                        "\t\ttransport->ssthresh = asoc->peer.i.a_rwnd;",
                        "\t}",
                        "",
                        "\t/* Set up the TSN tracking pieces.  */",
                        "\tif (!sctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,",
                        "\t\t\t\tasoc->peer.i.initial_tsn, gfp))",
                        "\t\tgoto clean_up;",
                        "",
                        "\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number",
                        "\t *",
                        "\t * The stream sequence number in all the streams shall start",
                        "\t * from 0 when the association is established.  Also, when the",
                        "\t * stream sequence number reaches the value 65535 the next",
                        "\t * stream sequence number shall be set to 0.",
                        "\t */",
                        "",
                        "\tif (sctp_stream_init(&asoc->stream, asoc->c.sinit_num_ostreams,",
                        "\t\t\t     asoc->c.sinit_max_instreams, gfp))",
                        "\t\tgoto clean_up;",
                        "",
                        "\t/* Update frag_point when stream_interleave may get changed. */",
                        "\tsctp_assoc_update_frag_point(asoc);",
                        "",
                        "\tif (!asoc->temp && sctp_assoc_set_id(asoc, gfp))",
                        "\t\tgoto clean_up;",
                        "",
                        "\t/* ADDIP Section 4.1 ASCONF Chunk Procedures",
                        "\t *",
                        "\t * When an endpoint has an ASCONF signaled change to be sent to the",
                        "\t * remote endpoint it should do the following:",
                        "\t * ...",
                        "\t * A2) A serial number should be assigned to the Chunk. The serial",
                        "\t * number should be a monotonically increasing number. All serial",
                        "\t * numbers are defined to be initialized at the start of the",
                        "\t * association to the same value as the Initial TSN.",
                        "\t */",
                        "\tasoc->peer.addip_serial = asoc->peer.i.initial_tsn - 1;",
                        "\treturn 1;",
                        "",
                        "clean_up:",
                        "\t/* Release the transport structures. */",
                        "\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {",
                        "\t\ttransport = list_entry(pos, struct sctp_transport, transports);",
                        "\t\tif (transport->state != SCTP_ACTIVE)",
                        "\t\t\tsctp_assoc_rm_peer(asoc, transport);",
                        "\t}",
                        "",
                        "nomem:",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 2317,
                    "highlight": 2466
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81996319"
        },
        "4480": {
            "name": "sctp_process_init",
            "parent_idx": 4472,
            "source_line": [
                {
                    "file": "net/sctp/sm_sideeffect.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/sm_sideeffect.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n682",
                    "code": [
                        "/* Process an init chunk (may be real INIT/INIT-ACK or an embedded INIT",
                        " * inside the cookie.  In reality, this is only used for INIT-ACK processing",
                        " * since all other cases use \"temporary\" associations and can do all",
                        " * their work in statefuns directly.",
                        " */",
                        "static int sctp_cmd_process_init(struct sctp_cmd_seq *commands,",
                        "\t\t\t\t struct sctp_association *asoc,",
                        "\t\t\t\t struct sctp_chunk *chunk,",
                        "\t\t\t\t struct sctp_init_chunk *peer_init,",
                        "\t\t\t\t gfp_t gfp)",
                        "{",
                        "\tint error;",
                        "",
                        "\t/* We only process the init as a sideeffect in a single",
                        "\t * case.   This is when we process the INIT-ACK.   If we",
                        "\t * fail during INIT processing (due to malloc problems),",
                        "\t * just return the error and stop processing the stack.",
                        "\t */",
                        "\tif (!sctp_process_init(asoc, chunk, sctp_source(chunk), peer_init, gfp))",
                        "\t\terror = -ENOMEM;",
                        "\telse",
                        "\t\terror = 0;",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 664,
                    "highlight": 682
                },
                {
                    "file": "net/sctp/sm_sideeffect.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/sm_sideeffect.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n1410",
                    "code": [
                        "/* This is the side-effect interpreter.  */",
                        "static int sctp_cmd_interpreter(enum sctp_event_type event_type,",
                        "\t\t\t\tunion sctp_subtype subtype,",
                        "\t\t\t\tenum sctp_state state,",
                        "\t\t\t\tstruct sctp_endpoint *ep,",
                        "\t\t\t\tstruct sctp_association *asoc,",
                        "\t\t\t\tvoid *event_arg,",
                        "\t\t\t\tenum sctp_disposition status,",
                        "\t\t\t\tstruct sctp_cmd_seq *commands,",
                        "\t\t\t\tgfp_t gfp)",
                        "{",
                        "\tstruct sctp_sock *sp = sctp_sk(ep->base.sk);",
                        "\tstruct sctp_chunk *chunk = NULL, *new_obj;",
                        "\tstruct sctp_packet *packet;",
                        "\tstruct sctp_sackhdr sackh;",
                        "\tstruct timer_list *timer;",
                        "\tstruct sctp_transport *t;",
                        "\tunsigned long timeout;",
                        "\tstruct sctp_cmd *cmd;",
                        "\tint local_cork = 0;",
                        "\tint error = 0;",
                        "\tint force;",
                        "",
                        "\tif (SCTP_EVENT_T_TIMEOUT != event_type)",
                        "\t\tchunk = event_arg;",
                        "",
                        "\t/* Note:  This whole file is a huge candidate for rework.",
                        "\t * For example, each command could either have its own handler, so",
                        "\t * the loop would look like:",
                        "\t *     while (cmds)",
                        "\t *         cmd->handle(x, y, z)",
                        "\t * --jgrimm",
                        "\t */",
                        "\twhile (NULL != (cmd = sctp_next_cmd(commands))) {",
                        "\t\tswitch (cmd->verb) {",
                        "\t\tcase SCTP_CMD_NOP:",
                        "\t\t\t/* Do nothing. */",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_NEW_ASOC:",
                        "\t\t\t/* Register a new association.  */",
                        "\t\t\tif (local_cork) {",
                        "\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t\t\t\tlocal_cork = 0;",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* Register with the endpoint.  */",
                        "\t\t\tasoc = cmd->obj.asoc;",
                        "\t\t\tBUG_ON(asoc->peer.primary_path == NULL);",
                        "\t\t\tsctp_endpoint_add_asoc(ep, asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_UPDATE_ASSOC:",
                        "\t\t       sctp_cmd_assoc_update(commands, asoc, cmd->obj.asoc);",
                        "\t\t       break;",
                        "",
                        "\t\tcase SCTP_CMD_PURGE_OUTQUEUE:",
                        "\t\t       sctp_outq_teardown(&asoc->outqueue);",
                        "\t\t       break;",
                        "",
                        "\t\tcase SCTP_CMD_DELETE_TCB:",
                        "\t\t\tif (local_cork) {",
                        "\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t\t\t\tlocal_cork = 0;",
                        "\t\t\t}",
                        "\t\t\t/* Delete the current association.  */",
                        "\t\t\tsctp_cmd_delete_tcb(commands, asoc);",
                        "\t\t\tasoc = NULL;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_NEW_STATE:",
                        "\t\t\t/* Enter a new state.  */",
                        "\t\t\tsctp_cmd_new_state(commands, asoc, cmd->obj.state);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPORT_TSN:",
                        "\t\t\t/* Record the arrival of a TSN.  */",
                        "\t\t\terror = sctp_tsnmap_mark(&asoc->peer.tsn_map,",
                        "\t\t\t\t\t\t cmd->obj.u32, NULL);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPORT_FWDTSN:",
                        "\t\t\tasoc->stream.si->report_ftsn(&asoc->ulpq, cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PROCESS_FWDTSN:",
                        "\t\t\tasoc->stream.si->handle_ftsn(&asoc->ulpq,",
                        "\t\t\t\t\t\t     cmd->obj.chunk);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_GEN_SACK:",
                        "\t\t\t/* Generate a Selective ACK.",
                        "\t\t\t * The argument tells us whether to just count",
                        "\t\t\t * the packet and MAYBE generate a SACK, or",
                        "\t\t\t * force a SACK out.",
                        "\t\t\t */",
                        "\t\t\tforce = cmd->obj.i32;",
                        "\t\t\terror = sctp_gen_sack(asoc, force, commands);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PROCESS_SACK:",
                        "\t\t\t/* Process an inbound SACK.  */",
                        "\t\t\terror = sctp_cmd_process_sack(commands, asoc,",
                        "\t\t\t\t\t\t      cmd->obj.chunk);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_GEN_INIT_ACK:",
                        "\t\t\t/* Generate an INIT ACK chunk.  */",
                        "\t\t\tnew_obj = sctp_make_init_ack(asoc, chunk, GFP_ATOMIC,",
                        "\t\t\t\t\t\t     0);",
                        "\t\t\tif (!new_obj)",
                        "\t\t\t\tgoto nomem;",
                        "",
                        "\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,",
                        "\t\t\t\t\tSCTP_CHUNK(new_obj));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PEER_INIT:",
                        "\t\t\t/* Process a unified INIT from the peer.",
                        "\t\t\t * Note: Only used during INIT-ACK processing.  If",
                        "\t\t\t * there is an error just return to the outter",
                        "\t\t\t * layer which will bail.",
                        "\t\t\t */",
                        "\t\t\terror = sctp_cmd_process_init(commands, asoc, chunk,",
                        "\t\t\t\t\t\t      cmd->obj.init, gfp);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_GEN_COOKIE_ECHO:",
                        "\t\t\t/* Generate a COOKIE ECHO chunk.  */",
                        "\t\t\tnew_obj = sctp_make_cookie_echo(asoc, chunk);",
                        "\t\t\tif (!new_obj) {",
                        "\t\t\t\tif (cmd->obj.chunk)",
                        "\t\t\t\t\tsctp_chunk_free(cmd->obj.chunk);",
                        "\t\t\t\tgoto nomem;",
                        "\t\t\t}",
                        "\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,",
                        "\t\t\t\t\tSCTP_CHUNK(new_obj));",
                        "",
                        "\t\t\t/* If there is an ERROR chunk to be sent along with",
                        "\t\t\t * the COOKIE_ECHO, send it, too.",
                        "\t\t\t */",
                        "\t\t\tif (cmd->obj.chunk)",
                        "\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,",
                        "\t\t\t\t\t\tSCTP_CHUNK(cmd->obj.chunk));",
                        "",
                        "\t\t\tif (new_obj->transport) {",
                        "\t\t\t\tnew_obj->transport->init_sent_count++;",
                        "\t\t\t\tasoc->init_last_sent_to = new_obj->transport;",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* FIXME - Eventually come up with a cleaner way to",
                        "\t\t\t * enabling COOKIE-ECHO + DATA bundling during",
                        "\t\t\t * multihoming stale cookie scenarios, the following",
                        "\t\t\t * command plays with asoc->peer.retran_path to",
                        "\t\t\t * avoid the problem of sending the COOKIE-ECHO and",
                        "\t\t\t * DATA in different paths, which could result",
                        "\t\t\t * in the association being ABORTed if the DATA chunk",
                        "\t\t\t * is processed first by the server.  Checking the",
                        "\t\t\t * init error counter simply causes this command",
                        "\t\t\t * to be executed only during failed attempts of",
                        "\t\t\t * association establishment.",
                        "\t\t\t */",
                        "\t\t\tif ((asoc->peer.retran_path !=",
                        "\t\t\t     asoc->peer.primary_path) &&",
                        "\t\t\t    (asoc->init_err_counter > 0)) {",
                        "\t\t\t\tsctp_add_cmd_sf(commands,",
                        "\t\t\t\t\t\tSCTP_CMD_FORCE_PRIM_RETRAN,",
                        "\t\t\t\t\t\tSCTP_NULL());",
                        "\t\t\t}",
                        "",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_GEN_SHUTDOWN:",
                        "\t\t\t/* Generate SHUTDOWN when in SHUTDOWN_SENT state.",
                        "\t\t\t * Reset error counts.",
                        "\t\t\t */",
                        "\t\t\tasoc->overall_error_count = 0;",
                        "",
                        "\t\t\t/* Generate a SHUTDOWN chunk.  */",
                        "\t\t\tnew_obj = sctp_make_shutdown(asoc, chunk);",
                        "\t\t\tif (!new_obj)",
                        "\t\t\t\tgoto nomem;",
                        "\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,",
                        "\t\t\t\t\tSCTP_CHUNK(new_obj));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_CHUNK_ULP:",
                        "\t\t\t/* Send a chunk to the sockets layer.  */",
                        "\t\t\tpr_debug(\"%s: sm_sideff: chunk_up:%p, ulpq:%p\\n\",",
                        "\t\t\t\t __func__, cmd->obj.chunk, &asoc->ulpq);",
                        "",
                        "\t\t\tasoc->stream.si->ulpevent_data(&asoc->ulpq,",
                        "\t\t\t\t\t\t       cmd->obj.chunk,",
                        "\t\t\t\t\t\t       GFP_ATOMIC);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_EVENT_ULP:",
                        "\t\t\t/* Send a notification to the sockets layer.  */",
                        "\t\t\tpr_debug(\"%s: sm_sideff: event_up:%p, ulpq:%p\\n\",",
                        "\t\t\t\t __func__, cmd->obj.ulpevent, &asoc->ulpq);",
                        "",
                        "\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq,",
                        "\t\t\t\t\t\t       cmd->obj.ulpevent);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPLY:",
                        "\t\t\t/* If an caller has not already corked, do cork. */",
                        "\t\t\tif (!asoc->outqueue.cork) {",
                        "\t\t\t\tsctp_outq_cork(&asoc->outqueue);",
                        "\t\t\t\tlocal_cork = 1;",
                        "\t\t\t}",
                        "\t\t\t/* Send a chunk to our peer.  */",
                        "\t\t\tsctp_outq_tail(&asoc->outqueue, cmd->obj.chunk, gfp);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_SEND_PKT:",
                        "\t\t\t/* Send a full packet to our peer.  */",
                        "\t\t\tpacket = cmd->obj.packet;",
                        "\t\t\tsctp_packet_transmit(packet, gfp);",
                        "\t\t\tsctp_ootb_pkt_free(packet);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_T1_RETRAN:",
                        "\t\t\t/* Mark a transport for retransmission.  */",
                        "\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,",
                        "\t\t\t\t\tSCTP_RTXR_T1_RTX);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_RETRAN:",
                        "\t\t\t/* Mark a transport for retransmission.  */",
                        "\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,",
                        "\t\t\t\t\tSCTP_RTXR_T3_RTX);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_ECN_CE:",
                        "\t\t\t/* Do delayed CE processing.   */",
                        "\t\t\tsctp_do_ecn_ce_work(asoc, cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_ECN_ECNE:",
                        "\t\t\t/* Do delayed ECNE processing. */",
                        "\t\t\tnew_obj = sctp_do_ecn_ecne_work(asoc, cmd->obj.u32,",
                        "\t\t\t\t\t\t\tchunk);",
                        "\t\t\tif (new_obj)",
                        "\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,",
                        "\t\t\t\t\t\tSCTP_CHUNK(new_obj));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_ECN_CWR:",
                        "\t\t\t/* Do delayed CWR processing.  */",
                        "\t\t\tsctp_do_ecn_cwr_work(asoc, cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_SETUP_T2:",
                        "\t\t\tsctp_cmd_setup_t2(commands, asoc, cmd->obj.chunk);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TIMER_START_ONCE:",
                        "\t\t\ttimer = &asoc->timers[cmd->obj.to];",
                        "",
                        "\t\t\tif (timer_pending(timer))",
                        "\t\t\t\tbreak;",
                        "\t\t\t/* fall through */",
                        "",
                        "\t\tcase SCTP_CMD_TIMER_START:",
                        "\t\t\ttimer = &asoc->timers[cmd->obj.to];",
                        "\t\t\ttimeout = asoc->timeouts[cmd->obj.to];",
                        "\t\t\tBUG_ON(!timeout);",
                        "",
                        "\t\t\ttimer->expires = jiffies + timeout;",
                        "\t\t\tsctp_association_hold(asoc);",
                        "\t\t\tadd_timer(timer);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TIMER_RESTART:",
                        "\t\t\ttimer = &asoc->timers[cmd->obj.to];",
                        "\t\t\ttimeout = asoc->timeouts[cmd->obj.to];",
                        "\t\t\tif (!mod_timer(timer, jiffies + timeout))",
                        "\t\t\t\tsctp_association_hold(asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TIMER_STOP:",
                        "\t\t\ttimer = &asoc->timers[cmd->obj.to];",
                        "\t\t\tif (del_timer(timer))",
                        "\t\t\t\tsctp_association_put(asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_INIT_CHOOSE_TRANSPORT:",
                        "\t\t\tchunk = cmd->obj.chunk;",
                        "\t\t\tt = sctp_assoc_choose_alter_transport(asoc,",
                        "\t\t\t\t\t\tasoc->init_last_sent_to);",
                        "\t\t\tasoc->init_last_sent_to = t;",
                        "\t\t\tchunk->transport = t;",
                        "\t\t\tt->init_sent_count++;",
                        "\t\t\t/* Set the new transport as primary */",
                        "\t\t\tsctp_assoc_set_primary(asoc, t);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_INIT_RESTART:",
                        "\t\t\t/* Do the needed accounting and updates",
                        "\t\t\t * associated with restarting an initialization",
                        "\t\t\t * timer. Only multiply the timeout by two if",
                        "\t\t\t * all transports have been tried at the current",
                        "\t\t\t * timeout.",
                        "\t\t\t */",
                        "\t\t\tsctp_cmd_t1_timer_update(asoc,",
                        "\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_INIT,",
                        "\t\t\t\t\t\t\"INIT\");",
                        "",
                        "\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,",
                        "\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_COOKIEECHO_RESTART:",
                        "\t\t\t/* Do the needed accounting and updates",
                        "\t\t\t * associated with restarting an initialization",
                        "\t\t\t * timer. Only multiply the timeout by two if",
                        "\t\t\t * all transports have been tried at the current",
                        "\t\t\t * timeout.",
                        "\t\t\t */",
                        "\t\t\tsctp_cmd_t1_timer_update(asoc,",
                        "\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_COOKIE,",
                        "\t\t\t\t\t\t\"COOKIE\");",
                        "",
                        "\t\t\t/* If we've sent any data bundled with",
                        "\t\t\t * COOKIE-ECHO we need to resend.",
                        "\t\t\t */",
                        "\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,",
                        "\t\t\t\t\ttransports) {",
                        "\t\t\t\tsctp_retransmit_mark(&asoc->outqueue, t,",
                        "\t\t\t\t\t    SCTP_RTXR_T1_RTX);",
                        "\t\t\t}",
                        "",
                        "\t\t\tsctp_add_cmd_sf(commands,",
                        "\t\t\t\t\tSCTP_CMD_TIMER_RESTART,",
                        "\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_INIT_FAILED:",
                        "\t\t\tsctp_cmd_init_failed(commands, asoc, cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_ASSOC_FAILED:",
                        "\t\t\tsctp_cmd_assoc_failed(commands, asoc, event_type,",
                        "\t\t\t\t\t      subtype, chunk, cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_INIT_COUNTER_INC:",
                        "\t\t\tasoc->init_err_counter++;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_INIT_COUNTER_RESET:",
                        "\t\t\tasoc->init_err_counter = 0;",
                        "\t\t\tasoc->init_cycle = 0;",
                        "\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,",
                        "\t\t\t\t\t    transports) {",
                        "\t\t\t\tt->init_sent_count = 0;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPORT_DUP:",
                        "\t\t\tsctp_tsnmap_mark_dup(&asoc->peer.tsn_map,",
                        "\t\t\t\t\t     cmd->obj.u32);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPORT_BAD_TAG:",
                        "\t\t\tpr_debug(\"%s: vtag mismatch!\\n\", __func__);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_STRIKE:",
                        "\t\t\t/* Mark one strike against a transport.  */",
                        "\t\t\tsctp_do_8_2_transport_strike(commands, asoc,",
                        "\t\t\t\t\t\t    cmd->obj.transport, 0);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TRANSPORT_IDLE:",
                        "\t\t\tt = cmd->obj.transport;",
                        "\t\t\tsctp_transport_lower_cwnd(t, SCTP_LOWER_CWND_INACTIVE);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TRANSPORT_HB_SENT:",
                        "\t\t\tt = cmd->obj.transport;",
                        "\t\t\tsctp_do_8_2_transport_strike(commands, asoc,",
                        "\t\t\t\t\t\t     t, 1);",
                        "\t\t\tt->hb_sent = 1;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_TRANSPORT_ON:",
                        "\t\t\tt = cmd->obj.transport;",
                        "\t\t\tsctp_cmd_transport_on(commands, asoc, t, chunk);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_HB_TIMERS_START:",
                        "\t\t\tsctp_cmd_hb_timers_start(commands, asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_HB_TIMER_UPDATE:",
                        "\t\t\tt = cmd->obj.transport;",
                        "\t\t\tsctp_transport_reset_hb_timer(t);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_HB_TIMERS_STOP:",
                        "\t\t\tsctp_cmd_hb_timers_stop(commands, asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_REPORT_ERROR:",
                        "\t\t\terror = cmd->obj.error;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PROCESS_CTSN:",
                        "\t\t\t/* Dummy up a SACK for processing. */",
                        "\t\t\tsackh.cum_tsn_ack = cmd->obj.be32;",
                        "\t\t\tsackh.a_rwnd = htonl(asoc->peer.rwnd +",
                        "\t\t\t\t\t     asoc->outqueue.outstanding_bytes);",
                        "\t\t\tsackh.num_gap_ack_blocks = 0;",
                        "\t\t\tsackh.num_dup_tsns = 0;",
                        "\t\t\tchunk->subh.sack_hdr = &sackh;",
                        "\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK,",
                        "\t\t\t\t\tSCTP_CHUNK(chunk));",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_DISCARD_PACKET:",
                        "\t\t\t/* We need to discard the whole packet.",
                        "\t\t\t * Uncork the queue since there might be",
                        "\t\t\t * responses pending",
                        "\t\t\t */",
                        "\t\t\tchunk->pdiscard = 1;",
                        "\t\t\tif (asoc) {",
                        "\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t\t\t\tlocal_cork = 0;",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_RTO_PENDING:",
                        "\t\t\tt = cmd->obj.transport;",
                        "\t\t\tt->rto_pending = 1;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PART_DELIVER:",
                        "\t\t\tasoc->stream.si->start_pd(&asoc->ulpq, GFP_ATOMIC);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_RENEGE:",
                        "\t\t\tasoc->stream.si->renege_events(&asoc->ulpq,",
                        "\t\t\t\t\t\t       cmd->obj.chunk,",
                        "\t\t\t\t\t\t       GFP_ATOMIC);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_SETUP_T4:",
                        "\t\t\tsctp_cmd_setup_t4(commands, asoc, cmd->obj.chunk);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_PROCESS_OPERR:",
                        "\t\t\tsctp_cmd_process_operr(commands, asoc, chunk);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_CLEAR_INIT_TAG:",
                        "\t\t\tasoc->peer.i.init_tag = 0;",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_DEL_NON_PRIMARY:",
                        "\t\t\tsctp_cmd_del_non_primary(asoc);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_T3_RTX_TIMERS_STOP:",
                        "\t\t\tsctp_cmd_t3_rtx_timers_stop(commands, asoc);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_FORCE_PRIM_RETRAN:",
                        "\t\t\tt = asoc->peer.retran_path;",
                        "\t\t\tasoc->peer.retran_path = asoc->peer.primary_path;",
                        "\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t\t\tlocal_cork = 0;",
                        "\t\t\tasoc->peer.retran_path = t;",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_SET_SK_ERR:",
                        "\t\t\tsctp_cmd_set_sk_err(asoc, cmd->obj.error);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_ASSOC_CHANGE:",
                        "\t\t\tsctp_cmd_assoc_change(commands, asoc,",
                        "\t\t\t\t\t      cmd->obj.u8);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_ADAPTATION_IND:",
                        "\t\t\tsctp_cmd_adaptation_ind(commands, asoc);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_PEER_NO_AUTH:",
                        "\t\t\tsctp_cmd_peer_no_auth(commands, asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_ASSOC_SHKEY:",
                        "\t\t\terror = sctp_auth_asoc_init_active_key(asoc,",
                        "\t\t\t\t\t\tGFP_ATOMIC);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_UPDATE_INITTAG:",
                        "\t\t\tasoc->peer.i.init_tag = cmd->obj.u32;",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_SEND_MSG:",
                        "\t\t\tif (!asoc->outqueue.cork) {",
                        "\t\t\t\tsctp_outq_cork(&asoc->outqueue);",
                        "\t\t\t\tlocal_cork = 1;",
                        "\t\t\t}",
                        "\t\t\tsctp_cmd_send_msg(asoc, cmd->obj.msg, gfp);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_SEND_NEXT_ASCONF:",
                        "\t\t\tsctp_cmd_send_asconf(asoc);",
                        "\t\t\tbreak;",
                        "\t\tcase SCTP_CMD_PURGE_ASCONF_QUEUE:",
                        "\t\t\tsctp_asconf_queue_teardown(asoc);",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase SCTP_CMD_SET_ASOC:",
                        "\t\t\tif (asoc && local_cork) {",
                        "\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t\t\t\tlocal_cork = 0;",
                        "\t\t\t}",
                        "\t\t\tasoc = cmd->obj.asoc;",
                        "\t\t\tbreak;",
                        "",
                        "\t\tdefault:",
                        "\t\t\tpr_warn(\"Impossible command: %u\\n\",",
                        "\t\t\t\tcmd->verb);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\tif (error)",
                        "\t\t\tbreak;",
                        "\t}",
                        "",
                        "out:",
                        "\t/* If this is in response to a received chunk, wait until",
                        "\t * we are done with the packet to open the queue so that we don't",
                        "\t * send multiple packets in response to a single request.",
                        "\t */",
                        "\tif (asoc && SCTP_EVENT_T_CHUNK == event_type && chunk) {",
                        "\t\tif (chunk->end_of_packet || chunk->singleton)",
                        "\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "\t} else if (local_cork)",
                        "\t\tsctp_outq_uncork(&asoc->outqueue, gfp);",
                        "",
                        "\tif (sp->data_ready_signalled)",
                        "\t\tsp->data_ready_signalled = 0;",
                        "",
                        "\treturn error;",
                        "nomem:",
                        "\terror = -ENOMEM;",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 1287,
                    "highlight": 1410
                },
                {
                    "file": "net/sctp/sm_sideeffect.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/sm_sideeffect.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n1220",
                    "code": [
                        "/*****************************************************************",
                        " * This the master state function side effect processing function.",
                        " *****************************************************************/",
                        "static int sctp_side_effects(enum sctp_event_type event_type,",
                        "\t\t\t     union sctp_subtype subtype,",
                        "\t\t\t     enum sctp_state state,",
                        "\t\t\t     struct sctp_endpoint *ep,",
                        "\t\t\t     struct sctp_association **asoc,",
                        "\t\t\t     void *event_arg,",
                        "\t\t\t     enum sctp_disposition status,",
                        "\t\t\t     struct sctp_cmd_seq *commands,",
                        "\t\t\t     gfp_t gfp)",
                        "{",
                        "\tint error;",
                        "",
                        "\t/* FIXME - Most of the dispositions left today would be categorized",
                        "\t * as \"exceptional\" dispositions.  For those dispositions, it",
                        "\t * may not be proper to run through any of the commands at all.",
                        "\t * For example, the command interpreter might be run only with",
                        "\t * disposition SCTP_DISPOSITION_CONSUME.",
                        "\t */",
                        "\tif (0 != (error = sctp_cmd_interpreter(event_type, subtype, state,",
                        "\t\t\t\t\t       ep, *asoc,",
                        "\t\t\t\t\t       event_arg, status,",
                        "\t\t\t\t\t       commands, gfp)))",
                        "\t\tgoto bail;",
                        "",
                        "\tswitch (status) {",
                        "\tcase SCTP_DISPOSITION_DISCARD:",
                        "\t\tpr_debug(\"%s: ignored sctp protocol event - state:%d, \"",
                        "\t\t\t \"event_type:%d, event_id:%d\\n\", __func__, state,",
                        "\t\t\t event_type, subtype.chunk);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_NOMEM:",
                        "\t\t/* We ran out of memory, so we need to discard this",
                        "\t\t * packet.",
                        "\t\t */",
                        "\t\t/* BUG--we should now recover some memory, probably by",
                        "\t\t * reneging...",
                        "\t\t */",
                        "\t\terror = -ENOMEM;",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_DELETE_TCB:",
                        "\tcase SCTP_DISPOSITION_ABORT:",
                        "\t\t/* This should now be a command. */",
                        "\t\t*asoc = NULL;",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_CONSUME:",
                        "\t\t/*",
                        "\t\t * We should no longer have much work to do here as the",
                        "\t\t * real work has been done as explicit commands above.",
                        "\t\t */",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_VIOLATION:",
                        "\t\tnet_err_ratelimited(\"protocol violation state %d chunkid %d\\n\",",
                        "\t\t\t\t    state, subtype.chunk);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_NOT_IMPL:",
                        "\t\tpr_warn(\"unimplemented feature in state %d, event_type %d, event_id %d\\n\",",
                        "\t\t\tstate, event_type, subtype.chunk);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISPOSITION_BUG:",
                        "\t\tpr_err(\"bug in state %d, event_type %d, event_id %d\\n\",",
                        "\t\t       state, event_type, subtype.chunk);",
                        "\t\tBUG();",
                        "\t\tbreak;",
                        "",
                        "\tdefault:",
                        "\t\tpr_err(\"impossible disposition %d in state %d, event_type %d, event_id %d\\n\",",
                        "\t\t       status, state, event_type, subtype.chunk);",
                        "\t\tBUG();",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "bail:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 1199,
                    "highlight": 1220
                },
                {
                    "file": "net/sctp/sm_sideeffect.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/sm_sideeffect.c?id=63bdf4284c38a48af21745ceb148a087b190cd21#n1191",
                    "code": [
                        "/*",
                        " * This is the master state machine processing function.",
                        " *",
                        " * If you want to understand all of lksctp, this is a",
                        " * good place to start.",
                        " */",
                        "int sctp_do_sm(struct net *net, enum sctp_event_type event_type,",
                        "\t       union sctp_subtype subtype, enum sctp_state state,",
                        "\t       struct sctp_endpoint *ep, struct sctp_association *asoc,",
                        "\t       void *event_arg, gfp_t gfp)",
                        "{",
                        "\ttypedef const char *(printfn_t)(union sctp_subtype);",
                        "\tstatic printfn_t *table[] = {",
                        "\t\tNULL, sctp_cname, sctp_tname, sctp_oname, sctp_pname,",
                        "\t};",
                        "\tprintfn_t *debug_fn  __attribute__ ((unused)) = table[event_type];",
                        "\tconst struct sctp_sm_table_entry *state_fn;",
                        "\tstruct sctp_cmd_seq commands;",
                        "\tenum sctp_disposition status;",
                        "\tint error = 0;",
                        "",
                        "\t/* Look up the state function, run it, and then process the",
                        "\t * side effects.  These three steps are the heart of lksctp.",
                        "\t */",
                        "\tstate_fn = sctp_sm_lookup_event(net, event_type, state, subtype);",
                        "",
                        "\tsctp_init_cmd_seq(&commands);",
                        "",
                        "\tdebug_pre_sfn();",
                        "\tstatus = state_fn->fn(net, ep, asoc, subtype, event_arg, &commands);",
                        "\tdebug_post_sfn();",
                        "",
                        "\terror = sctp_side_effects(event_type, subtype, state,",
                        "\t\t\t\t  ep, &asoc, event_arg, status,",
                        "\t\t\t\t  &commands, gfp);",
                        "\tdebug_post_sfx();",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 1159,
                    "highlight": 1191
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8198ce93"
        }
    },
    "ins": {
        "17": {
            "name": "mov r12, qword ptr [rax + 0x30]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x30",
            "call_idx": 4560,
            "inputs": [
                10512,
                10513
            ],
            "outputs": [
                10514
            ]
        },
        "38": {
            "name": "mov rax, qword ptr [rdx + 0x560]",
            "desc": "",
            "call_idx": 4559,
            "inputs": [
                10509,
                10510
            ],
            "outputs": [
                10511
            ]
        },
        "64": {
            "name": "mov qword ptr [rdi + 0x30], 0",
            "desc": "Source of base address CONST 0x0",
            "call_idx": 4527,
            "inputs": [
                10458
            ],
            "outputs": [
                10459
            ]
        }
    },
    "data": {
        "10512": {
            "name": "RAX",
            "ins_idx": 17,
            "value": "0x0",
            "sources": []
        },
        "10513": {
            "name": "[0x30]",
            "ins_idx": 17,
            "value": "0x0",
            "sources": []
        },
        "10514": {
            "name": "R12",
            "ins_idx": 17,
            "value": "0x0",
            "sources": []
        },
        "10509": {
            "name": "RDX",
            "ins_idx": 38,
            "value": "0xffff8882366c5000",
            "sources": []
        },
        "10510": {
            "name": "[0xffff8882366c5560]",
            "ins_idx": 38,
            "value": "0x0",
            "sources": []
        },
        "10511": {
            "name": "RAX",
            "ins_idx": 38,
            "value": "0x0",
            "sources": [
                10512
            ]
        },
        "10458": {
            "name": "RDI",
            "ins_idx": 64,
            "value": "0xffff8882366c5530",
            "sources": []
        },
        "10459": {
            "name": "[0xffff8882366c5560]",
            "ins_idx": 64,
            "value": "0x0",
            "sources": [
                10510
            ]
        }
    },
    "chain": {
        "17": [
            38
        ],
        "38": [
            64
        ]
    }
}