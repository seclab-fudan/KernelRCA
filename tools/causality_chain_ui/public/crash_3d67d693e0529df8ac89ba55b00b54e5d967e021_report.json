{
    "report": "https://syzkaller.appspot.com/bug?id=3d67d693e0529df8ac89ba55b00b54e5d967e021",
    "title": "KASAN: slab-out-of-bounds Write in mpol_parse_str",
    "call": {
        "952": {
            "name": "+0xdb",
            "parent_idx": 935,
            "source_line": [
                {
                    "file": "mm/mempolicy.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/mempolicy.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n2922",
                    "code": [
                        "#ifdef CONFIG_TMPFS",
                        "/**",
                        " * mpol_parse_str - parse string to mempolicy, for tmpfs mpol mount option.",
                        " * @str:  string containing mempolicy to parse",
                        " * @mpol:  pointer to struct mempolicy pointer, returned on success.",
                        " *",
                        " * Format of input:",
                        " *\t<mode>[=<flags>][:<nodelist>]",
                        " *",
                        " * On success, returns 0, else 1",
                        " */",
                        "int mpol_parse_str(char *str, struct mempolicy **mpol)",
                        "{",
                        "\tstruct mempolicy *new = NULL;",
                        "\tunsigned short mode_flags;",
                        "\tnodemask_t nodes;",
                        "\tchar *nodelist = strchr(str, ':');",
                        "\tchar *flags = strchr(str, '=');",
                        "\tint err = 1, mode;",
                        "",
                        "\tif (nodelist) {",
                        "\t\t/* NUL-terminate mode or flags string */",
                        "\t\t*nodelist++ = '\\0';",
                        "\t\tif (nodelist_parse(nodelist, nodes))",
                        "\t\t\tgoto out;",
                        "\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))",
                        "\t\t\tgoto out;",
                        "\t} else",
                        "\t\tnodes_clear(nodes);",
                        "",
                        "\tif (flags)",
                        "\t\t*flags++ = '\\0';\t/* terminate mode string */",
                        "",
                        "\tmode = match_string(policy_modes, MPOL_MAX, str);",
                        "\tif (mode < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tswitch (mode) {",
                        "\tcase MPOL_PREFERRED:",
                        "\t\t/*",
                        "\t\t * Insist on a nodelist of one node only",
                        "\t\t */",
                        "\t\tif (nodelist) {",
                        "\t\t\tchar *rest = nodelist;",
                        "\t\t\twhile (isdigit(*rest))",
                        "\t\t\t\trest++;",
                        "\t\t\tif (*rest)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\tcase MPOL_INTERLEAVE:",
                        "\t\t/*",
                        "\t\t * Default to online nodes with memory if no nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\tnodes = node_states[N_MEMORY];",
                        "\t\tbreak;",
                        "\tcase MPOL_LOCAL:",
                        "\t\t/*",
                        "\t\t * Don't allow a nodelist;  mpol_new() checks flags",
                        "\t\t */",
                        "\t\tif (nodelist)",
                        "\t\t\tgoto out;",
                        "\t\tmode = MPOL_PREFERRED;",
                        "\t\tbreak;",
                        "\tcase MPOL_DEFAULT:",
                        "\t\t/*",
                        "\t\t * Insist on a empty nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\terr = 0;",
                        "\t\tgoto out;",
                        "\tcase MPOL_BIND:",
                        "\t\t/*",
                        "\t\t * Insist on a nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tmode_flags = 0;",
                        "\tif (flags) {",
                        "\t\t/*",
                        "\t\t * Currently, we only support two mutually exclusive",
                        "\t\t * mode flags.",
                        "\t\t */",
                        "\t\tif (!strcmp(flags, \"static\"))",
                        "\t\t\tmode_flags |= MPOL_F_STATIC_NODES;",
                        "\t\telse if (!strcmp(flags, \"relative\"))",
                        "\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;",
                        "\t\telse",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tnew = mpol_new(mode, mode_flags, &nodes);",
                        "\tif (IS_ERR(new))",
                        "\t\tgoto out;",
                        "",
                        "\t/*",
                        "\t * Save nodes for mpol_to_str() to show the tmpfs mount options",
                        "\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.",
                        "\t */",
                        "\tif (mode != MPOL_PREFERRED)",
                        "\t\tnew->v.nodes = nodes;",
                        "\telse if (nodelist)",
                        "\t\tnew->v.preferred_node = first_node(nodes);",
                        "\telse",
                        "\t\tnew->flags |= MPOL_F_LOCAL;",
                        "",
                        "\t/*",
                        "\t * Save nodes for contextualization: this will be used to \"clone\"",
                        "\t * the mempolicy in a specific context [cpuset] at a later time.",
                        "\t */",
                        "\tnew->w.user_nodemask = nodes;",
                        "",
                        "\terr = 0;",
                        "",
                        "out:",
                        "\t/* Restore string for error message */",
                        "\tif (nodelist)",
                        "\t\t*--nodelist = ':';",
                        "\tif (flags)",
                        "\t\t*--flags = '=';",
                        "\tif (!err)",
                        "\t\t*mpol = new;",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2800,
                    "highlight": 2922
                }
            ],
            "ins_idx": 15,
            "addr": "0xffffffff812ef64b"
        },
        "935": {
            "name": "mpol_parse_str",
            "parent_idx": 927,
            "source_line": [
                {
                    "file": "mm/shmem.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/shmem.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n3472",
                    "code": [
                        "static int shmem_parse_one(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tstruct shmem_options *ctx = fc->fs_private;",
                        "\tstruct fs_parse_result result;",
                        "\tunsigned long long size;",
                        "\tchar *rest;",
                        "\tint opt;",
                        "",
                        "\topt = fs_parse(fc, &shmem_fs_parameters, param, &result);",
                        "\tif (opt < 0)",
                        "\t\treturn opt;",
                        "",
                        "\tswitch (opt) {",
                        "\tcase Opt_size:",
                        "\t\tsize = memparse(param->string, &rest);",
                        "\t\tif (*rest == '%') {",
                        "\t\t\tsize <<= PAGE_SHIFT;",
                        "\t\t\tsize *= totalram_pages();",
                        "\t\t\tdo_div(size, 100);",
                        "\t\t\trest++;",
                        "\t\t}",
                        "\t\tif (*rest)",
                        "\t\t\tgoto bad_value;",
                        "\t\tctx->blocks = DIV_ROUND_UP(size, PAGE_SIZE);",
                        "\t\tctx->seen |= SHMEM_SEEN_BLOCKS;",
                        "\t\tbreak;",
                        "\tcase Opt_nr_blocks:",
                        "\t\tctx->blocks = memparse(param->string, &rest);",
                        "\t\tif (*rest)",
                        "\t\t\tgoto bad_value;",
                        "\t\tctx->seen |= SHMEM_SEEN_BLOCKS;",
                        "\t\tbreak;",
                        "\tcase Opt_nr_inodes:",
                        "\t\tctx->inodes = memparse(param->string, &rest);",
                        "\t\tif (*rest)",
                        "\t\t\tgoto bad_value;",
                        "\t\tctx->seen |= SHMEM_SEEN_INODES;",
                        "\t\tbreak;",
                        "\tcase Opt_mode:",
                        "\t\tctx->mode = result.uint_32 & 07777;",
                        "\t\tbreak;",
                        "\tcase Opt_uid:",
                        "\t\tctx->uid = make_kuid(current_user_ns(), result.uint_32);",
                        "\t\tif (!uid_valid(ctx->uid))",
                        "\t\t\tgoto bad_value;",
                        "\t\tbreak;",
                        "\tcase Opt_gid:",
                        "\t\tctx->gid = make_kgid(current_user_ns(), result.uint_32);",
                        "\t\tif (!gid_valid(ctx->gid))",
                        "\t\t\tgoto bad_value;",
                        "\t\tbreak;",
                        "\tcase Opt_huge:",
                        "\t\tctx->huge = result.uint_32;",
                        "\t\tif (ctx->huge != SHMEM_HUGE_NEVER &&",
                        "\t\t    !(IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE) &&",
                        "\t\t      has_transparent_hugepage()))",
                        "\t\t\tgoto unsupported_parameter;",
                        "\t\tctx->seen |= SHMEM_SEEN_HUGE;",
                        "\t\tbreak;",
                        "\tcase Opt_mpol:",
                        "\t\tif (IS_ENABLED(CONFIG_NUMA)) {",
                        "\t\t\tmpol_put(ctx->mpol);",
                        "\t\t\tctx->mpol = NULL;",
                        "\t\t\tif (mpol_parse_str(param->string, &ctx->mpol))",
                        "\t\t\t\tgoto bad_value;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tgoto unsupported_parameter;",
                        "\t}",
                        "\treturn 0;",
                        "",
                        "unsupported_parameter:",
                        "\treturn invalf(fc, \"tmpfs: Unsupported parameter '%s'\", param->key);",
                        "bad_value:",
                        "\treturn invalf(fc, \"tmpfs: Bad value for '%s'\", param->key);",
                        "}"
                    ],
                    "start": 3409,
                    "highlight": 3472
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81276256"
        },
        "927": {
            "name": "shmem_parse_one(indirect)",
            "parent_idx": 909,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n145",
                    "code": [
                        "/**",
                        " * vfs_parse_fs_param - Add a single parameter to a superblock config",
                        " * @fc: The filesystem context to modify",
                        " * @param: The parameter",
                        " *",
                        " * A single mount option in string form is applied to the filesystem context",
                        " * being set up.  Certain standard options (for example \"ro\") are translated",
                        " * into flag bits without going to the filesystem.  The active security module",
                        " * is allowed to observe and poach options.  Any other options are passed over",
                        " * to the filesystem to parse.",
                        " *",
                        " * This may be called multiple times for a context.",
                        " *",
                        " * Returns 0 on success and a negative error code on failure.  In the event of",
                        " * failure, supplementary error information may have been set.",
                        " */",
                        "int vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tif (!param->key)",
                        "\t\treturn invalf(fc, \"Unnamed parameter\\n\");",
                        "",
                        "\tret = vfs_parse_sb_flag(fc, param->key);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\treturn ret;",
                        "",
                        "\tret = security_fs_context_parse_param(fc, param);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\t/* Param belongs to the LSM or is disallowed by the LSM; so",
                        "\t\t * don't pass to the FS.",
                        "\t\t */",
                        "\t\treturn ret;",
                        "",
                        "\tif (fc->ops->parse_param) {",
                        "\t\tret = fc->ops->parse_param(fc, param);",
                        "\t\tif (ret != -ENOPARAM)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "",
                        "\t/* If the filesystem doesn't take any arguments, give it the",
                        "\t * default handling of source.",
                        "\t */",
                        "\tif (strcmp(param->key, \"source\") == 0) {",
                        "\t\tif (param->type != fs_value_is_string)",
                        "\t\t\treturn invalf(fc, \"VFS: Non-string source\");",
                        "\t\tif (fc->source)",
                        "\t\t\treturn invalf(fc, \"VFS: Multiple sources\");",
                        "\t\tfc->source = param->string;",
                        "\t\tparam->string = NULL;",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\treturn invalf(fc, \"%s: Unknown parameter '%s'\",",
                        "\t\t      fc->fs_type->name, param->key);",
                        "}"
                    ],
                    "start": 110,
                    "highlight": 145
                },
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n126",
                    "code": [
                        "/**",
                        " * vfs_parse_fs_param - Add a single parameter to a superblock config",
                        " * @fc: The filesystem context to modify",
                        " * @param: The parameter",
                        " *",
                        " * A single mount option in string form is applied to the filesystem context",
                        " * being set up.  Certain standard options (for example \"ro\") are translated",
                        " * into flag bits without going to the filesystem.  The active security module",
                        " * is allowed to observe and poach options.  Any other options are passed over",
                        " * to the filesystem to parse.",
                        " *",
                        " * This may be called multiple times for a context.",
                        " *",
                        " * Returns 0 on success and a negative error code on failure.  In the event of",
                        " * failure, supplementary error information may have been set.",
                        " */",
                        "int vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tif (!param->key)",
                        "\t\treturn invalf(fc, \"Unnamed parameter\\n\");",
                        "",
                        "\tret = vfs_parse_sb_flag(fc, param->key);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\treturn ret;",
                        "",
                        "\tret = security_fs_context_parse_param(fc, param);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\t/* Param belongs to the LSM or is disallowed by the LSM; so",
                        "\t\t * don't pass to the FS.",
                        "\t\t */",
                        "\t\treturn ret;",
                        "",
                        "\tif (fc->ops->parse_param) {",
                        "\t\tret = fc->ops->parse_param(fc, param);",
                        "\t\tif (ret != -ENOPARAM)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "",
                        "\t/* If the filesystem doesn't take any arguments, give it the",
                        "\t * default handling of source.",
                        "\t */",
                        "\tif (strcmp(param->key, \"source\") == 0) {",
                        "\t\tif (param->type != fs_value_is_string)",
                        "\t\t\treturn invalf(fc, \"VFS: Non-string source\");",
                        "\t\tif (fc->source)",
                        "\t\t\treturn invalf(fc, \"VFS: Multiple sources\");",
                        "\t\tfc->source = param->string;",
                        "\t\tparam->string = NULL;",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\treturn invalf(fc, \"%s: Unknown parameter '%s'\",",
                        "\t\t      fc->fs_type->name, param->key);",
                        "}"
                    ],
                    "start": 110,
                    "highlight": 126
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8136b2fa"
        },
        "909": {
            "name": "vfs_parse_fs_param",
            "parent_idx": 892,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n188",
                    "code": [
                        "/**",
                        " * vfs_parse_fs_string - Convenience function to just parse a string.",
                        " */",
                        "int vfs_parse_fs_string(struct fs_context *fc, const char *key,",
                        "\t\t\tconst char *value, size_t v_size)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tstruct fs_parameter param = {",
                        "\t\t.key\t= key,",
                        "\t\t.type\t= fs_value_is_string,",
                        "\t\t.size\t= v_size,",
                        "\t};",
                        "",
                        "\tif (v_size > 0) {",
                        "\t\tparam.string = kmemdup_nul(value, v_size, GFP_KERNEL);",
                        "\t\tif (!param.string)",
                        "\t\t\treturn -ENOMEM;",
                        "\t}",
                        "",
                        "\tret = vfs_parse_fs_param(fc, &param);",
                        "\tkfree(param.string);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 168,
                    "highlight": 188
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8136b4cb"
        },
        "892": {
            "name": "vfs_parse_fs_string",
            "parent_idx": 889,
            "source_line": [
                {
                    "file": "mm/shmem.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/shmem.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n3522",
                    "code": [
                        "static int shmem_parse_options(struct fs_context *fc, void *data)",
                        "{",
                        "\tchar *options = data;",
                        "",
                        "\tif (options) {",
                        "\t\tint err = security_sb_eat_lsm_opts(options, &fc->security);",
                        "\t\tif (err)",
                        "\t\t\treturn err;",
                        "\t}",
                        "",
                        "\twhile (options != NULL) {",
                        "\t\tchar *this_char = options;",
                        "\t\tfor (;;) {",
                        "\t\t\t/*",
                        "\t\t\t * NUL-terminate this option: unfortunately,",
                        "\t\t\t * mount options form a comma-separated list,",
                        "\t\t\t * but mpol's nodelist may also contain commas.",
                        "\t\t\t */",
                        "\t\t\toptions = strchr(options, ',');",
                        "\t\t\tif (options == NULL)",
                        "\t\t\t\tbreak;",
                        "\t\t\toptions++;",
                        "\t\t\tif (!isdigit(*options)) {",
                        "\t\t\t\toptions[-1] = '\\0';",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (*this_char) {",
                        "\t\t\tchar *value = strchr(this_char,'=');",
                        "\t\t\tsize_t len = 0;",
                        "\t\t\tint err;",
                        "",
                        "\t\t\tif (value) {",
                        "\t\t\t\t*value++ = '\\0';",
                        "\t\t\t\tlen = strlen(value);",
                        "\t\t\t}",
                        "\t\t\terr = vfs_parse_fs_string(fc, this_char, value, len);",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\treturn err;",
                        "\t\t}",
                        "\t}",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 3486,
                    "highlight": 3522
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81276105"
        },
        "889": {
            "name": "parse_monolithic_mount_data",
            "parent_idx": 865,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n2818",
                    "code": [
                        "/*",
                        " * create a new mount for userspace and request it to be added into the",
                        " * namespace's tree",
                        " */",
                        "static int do_new_mount(struct path *path, const char *fstype, int sb_flags,",
                        "\t\t\tint mnt_flags, const char *name, void *data)",
                        "{",
                        "\tstruct file_system_type *type;",
                        "\tstruct fs_context *fc;",
                        "\tconst char *subtype = NULL;",
                        "\tint err = 0;",
                        "",
                        "\tif (!fstype)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\ttype = get_fs_type(fstype);",
                        "\tif (!type)",
                        "\t\treturn -ENODEV;",
                        "",
                        "\tif (type->fs_flags & FS_HAS_SUBTYPE) {",
                        "\t\tsubtype = strchr(fstype, '.');",
                        "\t\tif (subtype) {",
                        "\t\t\tsubtype++;",
                        "\t\t\tif (!*subtype) {",
                        "\t\t\t\tput_filesystem(type);",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tfc = fs_context_for_mount(type, sb_flags);",
                        "\tput_filesystem(type);",
                        "\tif (IS_ERR(fc))",
                        "\t\treturn PTR_ERR(fc);",
                        "",
                        "\tif (subtype)",
                        "\t\terr = vfs_parse_fs_string(fc, \"subtype\",",
                        "\t\t\t\t\t  subtype, strlen(subtype));",
                        "\tif (!err && name)",
                        "\t\terr = vfs_parse_fs_string(fc, \"source\", name, strlen(name));",
                        "\tif (!err)",
                        "\t\terr = parse_monolithic_mount_data(fc, data);",
                        "\tif (!err && !mount_capable(fc))",
                        "\t\terr = -EPERM;",
                        "\tif (!err)",
                        "\t\terr = vfs_get_tree(fc);",
                        "\tif (!err)",
                        "\t\terr = do_new_mount_fc(fc, path, mnt_flags);",
                        "",
                        "\tput_fs_context(fc);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2777,
                    "highlight": 2818
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n3142",
                    "code": [
                        "/*",
                        " * Flags is a 32-bit value that allows up to 31 non-fs dependent flags to",
                        " * be given to the mount() call (ie: read-only, no-dev, no-suid etc).",
                        " *",
                        " * data is a (void *) that can point to any structure up to",
                        " * PAGE_SIZE-1 bytes, which can contain arbitrary fs-dependent",
                        " * information (or be NULL).",
                        " *",
                        " * Pre-0.97 versions of mount() didn't have a flags word.",
                        " * When the flags word was introduced its top half was required",
                        " * to have the magic value 0xC0ED, and this remained so until 2.4.0-test9.",
                        " * Therefore, if this magic number is present, it carries no information",
                        " * and must be discarded.",
                        " */",
                        "long do_mount(const char *dev_name, const char __user *dir_name,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tstruct path path;",
                        "\tunsigned int mnt_flags = 0, sb_flags;",
                        "\tint retval = 0;",
                        "",
                        "\t/* Discard magic */",
                        "\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)",
                        "\t\tflags &= ~MS_MGC_MSK;",
                        "",
                        "\t/* Basic sanity checks */",
                        "\tif (data_page)",
                        "\t\t((char *)data_page)[PAGE_SIZE - 1] = 0;",
                        "",
                        "\tif (flags & MS_NOUSER)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\t/* ... and get the mountpoint */",
                        "\tretval = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &path);",
                        "\tif (retval)",
                        "\t\treturn retval;",
                        "",
                        "\tretval = security_sb_mount(dev_name, &path,",
                        "\t\t\t\t   type_page, flags, data_page);",
                        "\tif (!retval && !may_mount())",
                        "\t\tretval = -EPERM;",
                        "\tif (!retval && (flags & SB_MANDLOCK) && !may_mandlock())",
                        "\t\tretval = -EPERM;",
                        "\tif (retval)",
                        "\t\tgoto dput_out;",
                        "",
                        "\t/* Default to relatime unless overriden */",
                        "\tif (!(flags & MS_NOATIME))",
                        "\t\tmnt_flags |= MNT_RELATIME;",
                        "",
                        "\t/* Separate the per-mountpoint flags */",
                        "\tif (flags & MS_NOSUID)",
                        "\t\tmnt_flags |= MNT_NOSUID;",
                        "\tif (flags & MS_NODEV)",
                        "\t\tmnt_flags |= MNT_NODEV;",
                        "\tif (flags & MS_NOEXEC)",
                        "\t\tmnt_flags |= MNT_NOEXEC;",
                        "\tif (flags & MS_NOATIME)",
                        "\t\tmnt_flags |= MNT_NOATIME;",
                        "\tif (flags & MS_NODIRATIME)",
                        "\t\tmnt_flags |= MNT_NODIRATIME;",
                        "\tif (flags & MS_STRICTATIME)",
                        "\t\tmnt_flags &= ~(MNT_RELATIME | MNT_NOATIME);",
                        "\tif (flags & MS_RDONLY)",
                        "\t\tmnt_flags |= MNT_READONLY;",
                        "",
                        "\t/* The default atime for remount is preservation */",
                        "\tif ((flags & MS_REMOUNT) &&",
                        "\t    ((flags & (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |",
                        "\t\t       MS_STRICTATIME)) == 0)) {",
                        "\t\tmnt_flags &= ~MNT_ATIME_MASK;",
                        "\t\tmnt_flags |= path.mnt->mnt_flags & MNT_ATIME_MASK;",
                        "\t}",
                        "",
                        "\tsb_flags = flags & (SB_RDONLY |",
                        "\t\t\t    SB_SYNCHRONOUS |",
                        "\t\t\t    SB_MANDLOCK |",
                        "\t\t\t    SB_DIRSYNC |",
                        "\t\t\t    SB_SILENT |",
                        "\t\t\t    SB_POSIXACL |",
                        "\t\t\t    SB_LAZYTIME |",
                        "\t\t\t    SB_I_VERSION);",
                        "",
                        "\tif ((flags & (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND))",
                        "\t\tretval = do_reconfigure_mnt(&path, mnt_flags);",
                        "\telse if (flags & MS_REMOUNT)",
                        "\t\tretval = do_remount(&path, flags, sb_flags, mnt_flags,",
                        "\t\t\t\t    data_page);",
                        "\telse if (flags & MS_BIND)",
                        "\t\tretval = do_loopback(&path, dev_name, flags & MS_REC);",
                        "\telse if (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))",
                        "\t\tretval = do_change_type(&path, flags);",
                        "\telse if (flags & MS_MOVE)",
                        "\t\tretval = do_move_mount_old(&path, dev_name);",
                        "\telse",
                        "\t\tretval = do_new_mount(&path, type_page, sb_flags, mnt_flags,",
                        "\t\t\t\t      dev_name, data_page);",
                        "dput_out:",
                        "\tpath_put(&path);",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 3047,
                    "highlight": 3142
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff813493e4"
        },
        "865": {
            "name": "do_mount",
            "parent_idx": 864,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n3351",
                    "code": [
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3328,
                    "highlight": 3351
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n3328",
                    "code": [
                        "struct dentry *mount_subtree(struct vfsmount *m, const char *name)",
                        "{",
                        "\tstruct mount *mnt = real_mount(m);",
                        "\tstruct mnt_namespace *ns;",
                        "\tstruct super_block *s;",
                        "\tstruct path path;",
                        "\tint err;",
                        "",
                        "\tns = alloc_mnt_ns(&init_user_ns, true);",
                        "\tif (IS_ERR(ns)) {",
                        "\t\tmntput(m);",
                        "\t\treturn ERR_CAST(ns);",
                        "\t}",
                        "\tmnt->mnt_ns = ns;",
                        "\tns->root = mnt;",
                        "\tns->mounts++;",
                        "\tlist_add(&mnt->mnt_list, &ns->list);",
                        "",
                        "\terr = vfs_path_lookup(m->mnt_root, m,",
                        "\t\t\tname, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);",
                        "",
                        "\tput_mnt_ns(ns);",
                        "",
                        "\tif (err)",
                        "\t\treturn ERR_PTR(err);",
                        "",
                        "\t/* trade a vfsmount reference for active sb one */",
                        "\ts = path.mnt->mnt_sb;",
                        "\tatomic_inc(&s->s_active);",
                        "\tmntput(path.mnt);",
                        "\t/* lock the sucker */",
                        "\tdown_write(&s->s_umount);",
                        "\t/* ... and return the root of (sub)tree on it */",
                        "\treturn path.dentry;",
                        "}",
                        "EXPORT_SYMBOL(mount_subtree);",
                        "",
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3291,
                    "highlight": 3328
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81349fb4"
        },
        "864": {
            "name": "__x64_sys_mount(indirect)",
            "parent_idx": 863,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n294",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 281,
                    "highlight": 294
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81003f35"
        },
        "863": {
            "name": "do_syscall_64",
            "parent_idx": 862,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "862": {
            "name": "174_syscall_7",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "946": {
            "name": "+0x7c",
            "parent_idx": 935,
            "source_line": [
                {
                    "file": "mm/mempolicy.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/mempolicy.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n2817",
                    "code": [
                        "#ifdef CONFIG_TMPFS",
                        "/**",
                        " * mpol_parse_str - parse string to mempolicy, for tmpfs mpol mount option.",
                        " * @str:  string containing mempolicy to parse",
                        " * @mpol:  pointer to struct mempolicy pointer, returned on success.",
                        " *",
                        " * Format of input:",
                        " *\t<mode>[=<flags>][:<nodelist>]",
                        " *",
                        " * On success, returns 0, else 1",
                        " */",
                        "int mpol_parse_str(char *str, struct mempolicy **mpol)",
                        "{",
                        "\tstruct mempolicy *new = NULL;",
                        "\tunsigned short mode_flags;",
                        "\tnodemask_t nodes;",
                        "\tchar *nodelist = strchr(str, ':');",
                        "\tchar *flags = strchr(str, '=');",
                        "\tint err = 1, mode;",
                        "",
                        "\tif (nodelist) {",
                        "\t\t/* NUL-terminate mode or flags string */",
                        "\t\t*nodelist++ = '\\0';",
                        "\t\tif (nodelist_parse(nodelist, nodes))",
                        "\t\t\tgoto out;",
                        "\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))",
                        "\t\t\tgoto out;",
                        "\t} else",
                        "\t\tnodes_clear(nodes);",
                        "",
                        "\tif (flags)",
                        "\t\t*flags++ = '\\0';\t/* terminate mode string */",
                        "",
                        "\tmode = match_string(policy_modes, MPOL_MAX, str);",
                        "\tif (mode < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tswitch (mode) {",
                        "\tcase MPOL_PREFERRED:",
                        "\t\t/*",
                        "\t\t * Insist on a nodelist of one node only",
                        "\t\t */",
                        "\t\tif (nodelist) {",
                        "\t\t\tchar *rest = nodelist;",
                        "\t\t\twhile (isdigit(*rest))",
                        "\t\t\t\trest++;",
                        "\t\t\tif (*rest)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\tcase MPOL_INTERLEAVE:",
                        "\t\t/*",
                        "\t\t * Default to online nodes with memory if no nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\tnodes = node_states[N_MEMORY];",
                        "\t\tbreak;",
                        "\tcase MPOL_LOCAL:",
                        "\t\t/*",
                        "\t\t * Don't allow a nodelist;  mpol_new() checks flags",
                        "\t\t */",
                        "\t\tif (nodelist)",
                        "\t\t\tgoto out;",
                        "\t\tmode = MPOL_PREFERRED;",
                        "\t\tbreak;",
                        "\tcase MPOL_DEFAULT:",
                        "\t\t/*",
                        "\t\t * Insist on a empty nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\terr = 0;",
                        "\t\tgoto out;",
                        "\tcase MPOL_BIND:",
                        "\t\t/*",
                        "\t\t * Insist on a nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tmode_flags = 0;",
                        "\tif (flags) {",
                        "\t\t/*",
                        "\t\t * Currently, we only support two mutually exclusive",
                        "\t\t * mode flags.",
                        "\t\t */",
                        "\t\tif (!strcmp(flags, \"static\"))",
                        "\t\t\tmode_flags |= MPOL_F_STATIC_NODES;",
                        "\t\telse if (!strcmp(flags, \"relative\"))",
                        "\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;",
                        "\t\telse",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tnew = mpol_new(mode, mode_flags, &nodes);",
                        "\tif (IS_ERR(new))",
                        "\t\tgoto out;",
                        "",
                        "\t/*",
                        "\t * Save nodes for mpol_to_str() to show the tmpfs mount options",
                        "\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.",
                        "\t */",
                        "\tif (mode != MPOL_PREFERRED)",
                        "\t\tnew->v.nodes = nodes;",
                        "\telse if (nodelist)",
                        "\t\tnew->v.preferred_node = first_node(nodes);",
                        "\telse",
                        "\t\tnew->flags |= MPOL_F_LOCAL;",
                        "",
                        "\t/*",
                        "\t * Save nodes for contextualization: this will be used to \"clone\"",
                        "\t * the mempolicy in a specific context [cpuset] at a later time.",
                        "\t */",
                        "\tnew->w.user_nodemask = nodes;",
                        "",
                        "\terr = 0;",
                        "",
                        "out:",
                        "\t/* Restore string for error message */",
                        "\tif (nodelist)",
                        "\t\t*--nodelist = ':';",
                        "\tif (flags)",
                        "\t\t*--flags = '=';",
                        "\tif (!err)",
                        "\t\t*mpol = new;",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2800,
                    "highlight": 2817
                }
            ],
            "ins_idx": 74,
            "addr": "0xffffffff812ef5ec"
        },
        "945": {
            "name": "+0x3b",
            "parent_idx": 943,
            "source_line": [
                {
                    "file": "lib/string.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/string.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n411",
                    "code": [
                        "#ifndef __HAVE_ARCH_STRCHR",
                        "/**",
                        " * strchr - Find the first occurrence of a character in a string",
                        " * @s: The string to be searched",
                        " * @c: The character to search for",
                        " *",
                        " * Note that the %NUL-terminator is considered part of the string, and can",
                        " * be searched for.",
                        " */",
                        "char *strchr(const char *s, int c)",
                        "{",
                        "\tfor (; *s != (char)c; ++s)",
                        "\t\tif (*s == '\\0')",
                        "\t\t\treturn NULL;",
                        "\treturn (char *)s;",
                        "}"
                    ],
                    "start": 400,
                    "highlight": 411
                }
            ],
            "ins_idx": 97,
            "addr": "0xffffffff8221ce1b"
        },
        "943": {
            "name": "strchr",
            "parent_idx": 935,
            "source_line": [
                {
                    "file": "mm/mempolicy.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/mempolicy.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n2817",
                    "code": [
                        "#ifdef CONFIG_TMPFS",
                        "/**",
                        " * mpol_parse_str - parse string to mempolicy, for tmpfs mpol mount option.",
                        " * @str:  string containing mempolicy to parse",
                        " * @mpol:  pointer to struct mempolicy pointer, returned on success.",
                        " *",
                        " * Format of input:",
                        " *\t<mode>[=<flags>][:<nodelist>]",
                        " *",
                        " * On success, returns 0, else 1",
                        " */",
                        "int mpol_parse_str(char *str, struct mempolicy **mpol)",
                        "{",
                        "\tstruct mempolicy *new = NULL;",
                        "\tunsigned short mode_flags;",
                        "\tnodemask_t nodes;",
                        "\tchar *nodelist = strchr(str, ':');",
                        "\tchar *flags = strchr(str, '=');",
                        "\tint err = 1, mode;",
                        "",
                        "\tif (nodelist) {",
                        "\t\t/* NUL-terminate mode or flags string */",
                        "\t\t*nodelist++ = '\\0';",
                        "\t\tif (nodelist_parse(nodelist, nodes))",
                        "\t\t\tgoto out;",
                        "\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))",
                        "\t\t\tgoto out;",
                        "\t} else",
                        "\t\tnodes_clear(nodes);",
                        "",
                        "\tif (flags)",
                        "\t\t*flags++ = '\\0';\t/* terminate mode string */",
                        "",
                        "\tmode = match_string(policy_modes, MPOL_MAX, str);",
                        "\tif (mode < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tswitch (mode) {",
                        "\tcase MPOL_PREFERRED:",
                        "\t\t/*",
                        "\t\t * Insist on a nodelist of one node only",
                        "\t\t */",
                        "\t\tif (nodelist) {",
                        "\t\t\tchar *rest = nodelist;",
                        "\t\t\twhile (isdigit(*rest))",
                        "\t\t\t\trest++;",
                        "\t\t\tif (*rest)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\tcase MPOL_INTERLEAVE:",
                        "\t\t/*",
                        "\t\t * Default to online nodes with memory if no nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\tnodes = node_states[N_MEMORY];",
                        "\t\tbreak;",
                        "\tcase MPOL_LOCAL:",
                        "\t\t/*",
                        "\t\t * Don't allow a nodelist;  mpol_new() checks flags",
                        "\t\t */",
                        "\t\tif (nodelist)",
                        "\t\t\tgoto out;",
                        "\t\tmode = MPOL_PREFERRED;",
                        "\t\tbreak;",
                        "\tcase MPOL_DEFAULT:",
                        "\t\t/*",
                        "\t\t * Insist on a empty nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\terr = 0;",
                        "\t\tgoto out;",
                        "\tcase MPOL_BIND:",
                        "\t\t/*",
                        "\t\t * Insist on a nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tmode_flags = 0;",
                        "\tif (flags) {",
                        "\t\t/*",
                        "\t\t * Currently, we only support two mutually exclusive",
                        "\t\t * mode flags.",
                        "\t\t */",
                        "\t\tif (!strcmp(flags, \"static\"))",
                        "\t\t\tmode_flags |= MPOL_F_STATIC_NODES;",
                        "\t\telse if (!strcmp(flags, \"relative\"))",
                        "\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;",
                        "\t\telse",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tnew = mpol_new(mode, mode_flags, &nodes);",
                        "\tif (IS_ERR(new))",
                        "\t\tgoto out;",
                        "",
                        "\t/*",
                        "\t * Save nodes for mpol_to_str() to show the tmpfs mount options",
                        "\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.",
                        "\t */",
                        "\tif (mode != MPOL_PREFERRED)",
                        "\t\tnew->v.nodes = nodes;",
                        "\telse if (nodelist)",
                        "\t\tnew->v.preferred_node = first_node(nodes);",
                        "\telse",
                        "\t\tnew->flags |= MPOL_F_LOCAL;",
                        "",
                        "\t/*",
                        "\t * Save nodes for contextualization: this will be used to \"clone\"",
                        "\t * the mempolicy in a specific context [cpuset] at a later time.",
                        "\t */",
                        "\tnew->w.user_nodemask = nodes;",
                        "",
                        "\terr = 0;",
                        "",
                        "out:",
                        "\t/* Restore string for error message */",
                        "\tif (nodelist)",
                        "\t\t*--nodelist = ':';",
                        "\tif (flags)",
                        "\t\t*--flags = '=';",
                        "\tif (!err)",
                        "\t\t*mpol = new;",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2800,
                    "highlight": 2817
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812ef5e7"
        },
        "944": {
            "name": "+0x7",
            "parent_idx": 943,
            "source_line": [
                {
                    "file": "lib/string.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/string.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n410",
                    "code": [
                        "#ifndef __HAVE_ARCH_STRCHR",
                        "/**",
                        " * strchr - Find the first occurrence of a character in a string",
                        " * @s: The string to be searched",
                        " * @c: The character to search for",
                        " *",
                        " * Note that the %NUL-terminator is considered part of the string, and can",
                        " * be searched for.",
                        " */",
                        "char *strchr(const char *s, int c)",
                        "{",
                        "\tfor (; *s != (char)c; ++s)",
                        "\t\tif (*s == '\\0')",
                        "\t\t\treturn NULL;",
                        "\treturn (char *)s;",
                        "}"
                    ],
                    "start": 400,
                    "highlight": 410
                }
            ],
            "ins_idx": 122,
            "addr": "0xffffffff8221cde7"
        },
        "942": {
            "name": "+0x71",
            "parent_idx": 935,
            "source_line": [
                {
                    "file": "mm/mempolicy.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/mempolicy.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n2817",
                    "code": [
                        "#ifdef CONFIG_TMPFS",
                        "/**",
                        " * mpol_parse_str - parse string to mempolicy, for tmpfs mpol mount option.",
                        " * @str:  string containing mempolicy to parse",
                        " * @mpol:  pointer to struct mempolicy pointer, returned on success.",
                        " *",
                        " * Format of input:",
                        " *\t<mode>[=<flags>][:<nodelist>]",
                        " *",
                        " * On success, returns 0, else 1",
                        " */",
                        "int mpol_parse_str(char *str, struct mempolicy **mpol)",
                        "{",
                        "\tstruct mempolicy *new = NULL;",
                        "\tunsigned short mode_flags;",
                        "\tnodemask_t nodes;",
                        "\tchar *nodelist = strchr(str, ':');",
                        "\tchar *flags = strchr(str, '=');",
                        "\tint err = 1, mode;",
                        "",
                        "\tif (nodelist) {",
                        "\t\t/* NUL-terminate mode or flags string */",
                        "\t\t*nodelist++ = '\\0';",
                        "\t\tif (nodelist_parse(nodelist, nodes))",
                        "\t\t\tgoto out;",
                        "\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))",
                        "\t\t\tgoto out;",
                        "\t} else",
                        "\t\tnodes_clear(nodes);",
                        "",
                        "\tif (flags)",
                        "\t\t*flags++ = '\\0';\t/* terminate mode string */",
                        "",
                        "\tmode = match_string(policy_modes, MPOL_MAX, str);",
                        "\tif (mode < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tswitch (mode) {",
                        "\tcase MPOL_PREFERRED:",
                        "\t\t/*",
                        "\t\t * Insist on a nodelist of one node only",
                        "\t\t */",
                        "\t\tif (nodelist) {",
                        "\t\t\tchar *rest = nodelist;",
                        "\t\t\twhile (isdigit(*rest))",
                        "\t\t\t\trest++;",
                        "\t\t\tif (*rest)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\tcase MPOL_INTERLEAVE:",
                        "\t\t/*",
                        "\t\t * Default to online nodes with memory if no nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\tnodes = node_states[N_MEMORY];",
                        "\t\tbreak;",
                        "\tcase MPOL_LOCAL:",
                        "\t\t/*",
                        "\t\t * Don't allow a nodelist;  mpol_new() checks flags",
                        "\t\t */",
                        "\t\tif (nodelist)",
                        "\t\t\tgoto out;",
                        "\t\tmode = MPOL_PREFERRED;",
                        "\t\tbreak;",
                        "\tcase MPOL_DEFAULT:",
                        "\t\t/*",
                        "\t\t * Insist on a empty nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\terr = 0;",
                        "\t\tgoto out;",
                        "\tcase MPOL_BIND:",
                        "\t\t/*",
                        "\t\t * Insist on a nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tmode_flags = 0;",
                        "\tif (flags) {",
                        "\t\t/*",
                        "\t\t * Currently, we only support two mutually exclusive",
                        "\t\t * mode flags.",
                        "\t\t */",
                        "\t\tif (!strcmp(flags, \"static\"))",
                        "\t\t\tmode_flags |= MPOL_F_STATIC_NODES;",
                        "\t\telse if (!strcmp(flags, \"relative\"))",
                        "\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;",
                        "\t\telse",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tnew = mpol_new(mode, mode_flags, &nodes);",
                        "\tif (IS_ERR(new))",
                        "\t\tgoto out;",
                        "",
                        "\t/*",
                        "\t * Save nodes for mpol_to_str() to show the tmpfs mount options",
                        "\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.",
                        "\t */",
                        "\tif (mode != MPOL_PREFERRED)",
                        "\t\tnew->v.nodes = nodes;",
                        "\telse if (nodelist)",
                        "\t\tnew->v.preferred_node = first_node(nodes);",
                        "\telse",
                        "\t\tnew->flags |= MPOL_F_LOCAL;",
                        "",
                        "\t/*",
                        "\t * Save nodes for contextualization: this will be used to \"clone\"",
                        "\t * the mempolicy in a specific context [cpuset] at a later time.",
                        "\t */",
                        "\tnew->w.user_nodemask = nodes;",
                        "",
                        "\terr = 0;",
                        "",
                        "out:",
                        "\t/* Restore string for error message */",
                        "\tif (nodelist)",
                        "\t\t*--nodelist = ':';",
                        "\tif (flags)",
                        "\t\t*--flags = '=';",
                        "\tif (!err)",
                        "\t\t*mpol = new;",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2800,
                    "highlight": 2817
                }
            ],
            "ins_idx": 151,
            "addr": "0xffffffff812ef5e1"
        },
        "936": {
            "name": "+0x1a",
            "parent_idx": 935,
            "source_line": [
                {
                    "file": "mm/mempolicy.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/mempolicy.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n2812",
                    "code": [
                        "#ifdef CONFIG_TMPFS",
                        "/**",
                        " * mpol_parse_str - parse string to mempolicy, for tmpfs mpol mount option.",
                        " * @str:  string containing mempolicy to parse",
                        " * @mpol:  pointer to struct mempolicy pointer, returned on success.",
                        " *",
                        " * Format of input:",
                        " *\t<mode>[=<flags>][:<nodelist>]",
                        " *",
                        " * On success, returns 0, else 1",
                        " */",
                        "int mpol_parse_str(char *str, struct mempolicy **mpol)",
                        "{",
                        "\tstruct mempolicy *new = NULL;",
                        "\tunsigned short mode_flags;",
                        "\tnodemask_t nodes;",
                        "\tchar *nodelist = strchr(str, ':');",
                        "\tchar *flags = strchr(str, '=');",
                        "\tint err = 1, mode;",
                        "",
                        "\tif (nodelist) {",
                        "\t\t/* NUL-terminate mode or flags string */",
                        "\t\t*nodelist++ = '\\0';",
                        "\t\tif (nodelist_parse(nodelist, nodes))",
                        "\t\t\tgoto out;",
                        "\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))",
                        "\t\t\tgoto out;",
                        "\t} else",
                        "\t\tnodes_clear(nodes);",
                        "",
                        "\tif (flags)",
                        "\t\t*flags++ = '\\0';\t/* terminate mode string */",
                        "",
                        "\tmode = match_string(policy_modes, MPOL_MAX, str);",
                        "\tif (mode < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tswitch (mode) {",
                        "\tcase MPOL_PREFERRED:",
                        "\t\t/*",
                        "\t\t * Insist on a nodelist of one node only",
                        "\t\t */",
                        "\t\tif (nodelist) {",
                        "\t\t\tchar *rest = nodelist;",
                        "\t\t\twhile (isdigit(*rest))",
                        "\t\t\t\trest++;",
                        "\t\t\tif (*rest)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\tcase MPOL_INTERLEAVE:",
                        "\t\t/*",
                        "\t\t * Default to online nodes with memory if no nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\tnodes = node_states[N_MEMORY];",
                        "\t\tbreak;",
                        "\tcase MPOL_LOCAL:",
                        "\t\t/*",
                        "\t\t * Don't allow a nodelist;  mpol_new() checks flags",
                        "\t\t */",
                        "\t\tif (nodelist)",
                        "\t\t\tgoto out;",
                        "\t\tmode = MPOL_PREFERRED;",
                        "\t\tbreak;",
                        "\tcase MPOL_DEFAULT:",
                        "\t\t/*",
                        "\t\t * Insist on a empty nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\terr = 0;",
                        "\t\tgoto out;",
                        "\tcase MPOL_BIND:",
                        "\t\t/*",
                        "\t\t * Insist on a nodelist",
                        "\t\t */",
                        "\t\tif (!nodelist)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tmode_flags = 0;",
                        "\tif (flags) {",
                        "\t\t/*",
                        "\t\t * Currently, we only support two mutually exclusive",
                        "\t\t * mode flags.",
                        "\t\t */",
                        "\t\tif (!strcmp(flags, \"static\"))",
                        "\t\t\tmode_flags |= MPOL_F_STATIC_NODES;",
                        "\t\telse if (!strcmp(flags, \"relative\"))",
                        "\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;",
                        "\t\telse",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\tnew = mpol_new(mode, mode_flags, &nodes);",
                        "\tif (IS_ERR(new))",
                        "\t\tgoto out;",
                        "",
                        "\t/*",
                        "\t * Save nodes for mpol_to_str() to show the tmpfs mount options",
                        "\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.",
                        "\t */",
                        "\tif (mode != MPOL_PREFERRED)",
                        "\t\tnew->v.nodes = nodes;",
                        "\telse if (nodelist)",
                        "\t\tnew->v.preferred_node = first_node(nodes);",
                        "\telse",
                        "\t\tnew->flags |= MPOL_F_LOCAL;",
                        "",
                        "\t/*",
                        "\t * Save nodes for contextualization: this will be used to \"clone\"",
                        "\t * the mempolicy in a specific context [cpuset] at a later time.",
                        "\t */",
                        "\tnew->w.user_nodemask = nodes;",
                        "",
                        "\terr = 0;",
                        "",
                        "out:",
                        "\t/* Restore string for error message */",
                        "\tif (nodelist)",
                        "\t\t*--nodelist = ':';",
                        "\tif (flags)",
                        "\t\t*--flags = '=';",
                        "\tif (!err)",
                        "\t\t*mpol = new;",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2800,
                    "highlight": 2812
                }
            ],
            "ins_idx": 250,
            "addr": "0xffffffff812ef58a"
        },
        "934": {
            "name": "+0xee",
            "parent_idx": 927,
            "source_line": [
                {
                    "file": "mm/shmem.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/shmem.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n3472",
                    "code": [
                        "static int shmem_parse_one(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tstruct shmem_options *ctx = fc->fs_private;",
                        "\tstruct fs_parse_result result;",
                        "\tunsigned long long size;",
                        "\tchar *rest;",
                        "\tint opt;",
                        "",
                        "\topt = fs_parse(fc, &shmem_fs_parameters, param, &result);",
                        "\tif (opt < 0)",
                        "\t\treturn opt;",
                        "",
                        "\tswitch (opt) {",
                        "\tcase Opt_size:",
                        "\t\tsize = memparse(param->string, &rest);",
                        "\t\tif (*rest == '%') {",
                        "\t\t\tsize <<= PAGE_SHIFT;",
                        "\t\t\tsize *= totalram_pages();",
                        "\t\t\tdo_div(size, 100);",
                        "\t\t\trest++;",
                        "\t\t}",
                        "\t\tif (*rest)",
                        "\t\t\tgoto bad_value;",
                        "\t\tctx->blocks = DIV_ROUND_UP(size, PAGE_SIZE);",
                        "\t\tctx->seen |= SHMEM_SEEN_BLOCKS;",
                        "\t\tbreak;",
                        "\tcase Opt_nr_blocks:",
                        "\t\tctx->blocks = memparse(param->string, &rest);",
                        "\t\tif (*rest)",
                        "\t\t\tgoto bad_value;",
                        "\t\tctx->seen |= SHMEM_SEEN_BLOCKS;",
                        "\t\tbreak;",
                        "\tcase Opt_nr_inodes:",
                        "\t\tctx->inodes = memparse(param->string, &rest);",
                        "\t\tif (*rest)",
                        "\t\t\tgoto bad_value;",
                        "\t\tctx->seen |= SHMEM_SEEN_INODES;",
                        "\t\tbreak;",
                        "\tcase Opt_mode:",
                        "\t\tctx->mode = result.uint_32 & 07777;",
                        "\t\tbreak;",
                        "\tcase Opt_uid:",
                        "\t\tctx->uid = make_kuid(current_user_ns(), result.uint_32);",
                        "\t\tif (!uid_valid(ctx->uid))",
                        "\t\t\tgoto bad_value;",
                        "\t\tbreak;",
                        "\tcase Opt_gid:",
                        "\t\tctx->gid = make_kgid(current_user_ns(), result.uint_32);",
                        "\t\tif (!gid_valid(ctx->gid))",
                        "\t\t\tgoto bad_value;",
                        "\t\tbreak;",
                        "\tcase Opt_huge:",
                        "\t\tctx->huge = result.uint_32;",
                        "\t\tif (ctx->huge != SHMEM_HUGE_NEVER &&",
                        "\t\t    !(IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE) &&",
                        "\t\t      has_transparent_hugepage()))",
                        "\t\t\tgoto unsupported_parameter;",
                        "\t\tctx->seen |= SHMEM_SEEN_HUGE;",
                        "\t\tbreak;",
                        "\tcase Opt_mpol:",
                        "\t\tif (IS_ENABLED(CONFIG_NUMA)) {",
                        "\t\t\tmpol_put(ctx->mpol);",
                        "\t\t\tctx->mpol = NULL;",
                        "\t\t\tif (mpol_parse_str(param->string, &ctx->mpol))",
                        "\t\t\t\tgoto bad_value;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tgoto unsupported_parameter;",
                        "\t}",
                        "\treturn 0;",
                        "",
                        "unsupported_parameter:",
                        "\treturn invalf(fc, \"tmpfs: Unsupported parameter '%s'\", param->key);",
                        "bad_value:",
                        "\treturn invalf(fc, \"tmpfs: Bad value for '%s'\", param->key);",
                        "}"
                    ],
                    "start": 3409,
                    "highlight": 3472
                }
            ],
            "ins_idx": 289,
            "addr": "0xffffffff8127624e"
        },
        "907": {
            "name": "+0xa9",
            "parent_idx": 892,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n183",
                    "code": [
                        "/**",
                        " * vfs_parse_fs_string - Convenience function to just parse a string.",
                        " */",
                        "int vfs_parse_fs_string(struct fs_context *fc, const char *key,",
                        "\t\t\tconst char *value, size_t v_size)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tstruct fs_parameter param = {",
                        "\t\t.key\t= key,",
                        "\t\t.type\t= fs_value_is_string,",
                        "\t\t.size\t= v_size,",
                        "\t};",
                        "",
                        "\tif (v_size > 0) {",
                        "\t\tparam.string = kmemdup_nul(value, v_size, GFP_KERNEL);",
                        "\t\tif (!param.string)",
                        "\t\t\treturn -ENOMEM;",
                        "\t}",
                        "",
                        "\tret = vfs_parse_fs_param(fc, &param);",
                        "\tkfree(param.string);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 168,
                    "highlight": 183
                }
            ],
            "ins_idx": 321,
            "addr": "0xffffffff8136b4b9"
        },
        "905": {
            "name": "+0x43",
            "parent_idx": 894,
            "source_line": [
                {
                    "file": "mm/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/util.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n160",
                    "code": [
                        "/**",
                        " * kmemdup_nul - Create a NUL-terminated string from unterminated data",
                        " * @s: The data to stringify",
                        " * @len: The size of the data",
                        " * @gfp: the GFP mask used in the kmalloc() call when allocating memory",
                        " *",
                        " * Return: newly allocated copy of @s with NUL-termination or %NULL in",
                        " * case of error",
                        " */",
                        "char *kmemdup_nul(const char *s, size_t len, gfp_t gfp)",
                        "{",
                        "\tchar *buf;",
                        "",
                        "\tif (!s)",
                        "\t\treturn NULL;",
                        "",
                        "\tbuf = kmalloc_track_caller(len + 1, gfp);",
                        "\tif (buf) {",
                        "\t\tmemcpy(buf, s, len);",
                        "\t\tbuf[len] = '\\0';",
                        "\t}",
                        "\treturn buf;",
                        "}",
                        "EXPORT_SYMBOL(kmemdup_nul);",
                        "",
                        "/**",
                        " * memdup_user - duplicate memory region from user space",
                        " *",
                        " * @src: source address in user space",
                        " * @len: number of bytes to copy",
                        " *",
                        " * Return: an ERR_PTR() on failure.  Result is physically",
                        " * contiguous, to be freed by kfree().",
                        " */",
                        "void *memdup_user(const void __user *src, size_t len)",
                        "{",
                        "\tvoid *p;",
                        "",
                        "\tp = kmalloc_track_caller(len, GFP_USER | __GFP_NOWARN);",
                        "\tif (!p)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tif (copy_from_user(p, src, len)) {",
                        "\t\tkfree(p);",
                        "\t\treturn ERR_PTR(-EFAULT);",
                        "\t}",
                        "",
                        "\treturn p;",
                        "}"
                    ],
                    "start": 134,
                    "highlight": 160
                }
            ],
            "ins_idx": 350,
            "addr": "0xffffffff8127e973"
        },
        "894": {
            "name": "kmemdup_nul",
            "parent_idx": 892,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n183",
                    "code": [
                        "/**",
                        " * vfs_parse_fs_string - Convenience function to just parse a string.",
                        " */",
                        "int vfs_parse_fs_string(struct fs_context *fc, const char *key,",
                        "\t\t\tconst char *value, size_t v_size)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tstruct fs_parameter param = {",
                        "\t\t.key\t= key,",
                        "\t\t.type\t= fs_value_is_string,",
                        "\t\t.size\t= v_size,",
                        "\t};",
                        "",
                        "\tif (v_size > 0) {",
                        "\t\tparam.string = kmemdup_nul(value, v_size, GFP_KERNEL);",
                        "\t\tif (!param.string)",
                        "\t\t\treturn -ENOMEM;",
                        "\t}",
                        "",
                        "\tret = vfs_parse_fs_param(fc, &param);",
                        "\tkfree(param.string);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 168,
                    "highlight": 183
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8136b4b4"
        },
        "899": {
            "name": "+0x1f",
            "parent_idx": 894,
            "source_line": [
                {
                    "file": "mm/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/util.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n154",
                    "code": [
                        "/**",
                        " * kmemdup_nul - Create a NUL-terminated string from unterminated data",
                        " * @s: The data to stringify",
                        " * @len: The size of the data",
                        " * @gfp: the GFP mask used in the kmalloc() call when allocating memory",
                        " *",
                        " * Return: newly allocated copy of @s with NUL-termination or %NULL in",
                        " * case of error",
                        " */",
                        "char *kmemdup_nul(const char *s, size_t len, gfp_t gfp)",
                        "{",
                        "\tchar *buf;",
                        "",
                        "\tif (!s)",
                        "\t\treturn NULL;",
                        "",
                        "\tbuf = kmalloc_track_caller(len + 1, gfp);",
                        "\tif (buf) {",
                        "\t\tmemcpy(buf, s, len);",
                        "\t\tbuf[len] = '\\0';",
                        "\t}",
                        "\treturn buf;",
                        "}"
                    ],
                    "start": 134,
                    "highlight": 154
                }
            ],
            "ins_idx": 426,
            "addr": "0xffffffff8127e94f"
        },
        "898": {
            "name": "+0xfe",
            "parent_idx": 897,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n4381",
                    "code": [
                        "static int count_total(struct page *page)",
                        "{",
                        "\treturn page->objects;",
                        "}"
                    ],
                    "start": 4380,
                    "highlight": 4381
                }
            ],
            "ins_idx": 453,
            "addr": "0xffffffff812f884e"
        },
        "897": {
            "name": "__kmalloc_track_caller",
            "parent_idx": 894,
            "source_line": [
                {
                    "file": "mm/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/util.c?id=e69ec487b2c7c82ef99b4b15122f58a2a99289a3#n154",
                    "code": [
                        "/**",
                        " * kmemdup_nul - Create a NUL-terminated string from unterminated data",
                        " * @s: The data to stringify",
                        " * @len: The size of the data",
                        " * @gfp: the GFP mask used in the kmalloc() call when allocating memory",
                        " *",
                        " * Return: newly allocated copy of @s with NUL-termination or %NULL in",
                        " * case of error",
                        " */",
                        "char *kmemdup_nul(const char *s, size_t len, gfp_t gfp)",
                        "{",
                        "\tchar *buf;",
                        "",
                        "\tif (!s)",
                        "\t\treturn NULL;",
                        "",
                        "\tbuf = kmalloc_track_caller(len + 1, gfp);",
                        "\tif (buf) {",
                        "\t\tmemcpy(buf, s, len);",
                        "\t\tbuf[len] = '\\0';",
                        "\t}",
                        "\treturn buf;",
                        "}"
                    ],
                    "start": 134,
                    "highlight": 154
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8127e94a"
        }
    },
    "ins": {
        "15": {
            "name": "mov byte ptr [rbx - 1], 0x3d",
            "desc": "Invalid Memory Access\nOut of Bound Access.",
            "call_idx": 952,
            "inputs": [
                1522
            ],
            "outputs": [
                1523
            ]
        },
        "74": {
            "name": "mov rbx, rax",
            "desc": "",
            "call_idx": 946,
            "inputs": [
                1512
            ],
            "outputs": [
                1513
            ]
        },
        "97": {
            "name": "mov rax, rbx",
            "desc": "",
            "call_idx": 945,
            "inputs": [
                1510
            ],
            "outputs": [
                1511
            ]
        },
        "122": {
            "name": "mov rbx, rdi",
            "desc": "",
            "call_idx": 944,
            "inputs": [
                1508
            ],
            "outputs": [
                1509
            ]
        },
        "151": {
            "name": "mov rdi, r12",
            "desc": "",
            "call_idx": 942,
            "inputs": [
                1506
            ],
            "outputs": [
                1507
            ]
        },
        "250": {
            "name": "mov r12, rdi",
            "desc": "",
            "call_idx": 936,
            "inputs": [
                1496
            ],
            "outputs": [
                1497
            ]
        },
        "289": {
            "name": "mov rdi, qword ptr [r12 + 0x10]",
            "desc": "",
            "call_idx": 934,
            "inputs": [
                1493,
                1494
            ],
            "outputs": [
                1495
            ]
        },
        "321": {
            "name": "mov qword ptr [rsp + 0x40], rax",
            "desc": "",
            "call_idx": 907,
            "inputs": [
                1450,
                1451
            ],
            "outputs": [
                1452
            ]
        },
        "350": {
            "name": "mov rax, r12",
            "desc": "",
            "call_idx": 905,
            "inputs": [
                1447
            ],
            "outputs": [
                1448
            ]
        },
        "426": {
            "name": "mov r12, rax",
            "desc": "",
            "call_idx": 899,
            "inputs": [
                1437
            ],
            "outputs": [
                1438
            ]
        },
        "453": {
            "name": "ret ",
            "desc": "",
            "call_idx": 898,
            "inputs": [],
            "outputs": [
                1436
            ]
        }
    },
    "data": {
        "1522": {
            "name": "RBX",
            "ins_idx": 15,
            "value": "0xffff8881e9543ae0",
            "sources": []
        },
        "1523": {
            "name": "[0xffff8881e9543adf]",
            "ins_idx": 15,
            "value": "0x3d",
            "sources": []
        },
        "1512": {
            "name": "RAX",
            "ins_idx": 74,
            "value": "0xffff8881e9543ae0",
            "sources": []
        },
        "1513": {
            "name": "RBX",
            "ins_idx": 74,
            "value": "0xffff8881e9543ae0",
            "sources": [
                1522
            ]
        },
        "1510": {
            "name": "RBX",
            "ins_idx": 97,
            "value": "0xffff8881e9543ae0",
            "sources": []
        },
        "1511": {
            "name": "RAX",
            "ins_idx": 97,
            "value": "0xffff8881e9543ae0",
            "sources": [
                1512
            ]
        },
        "1508": {
            "name": "RDI",
            "ins_idx": 122,
            "value": "0xffff8881e9543ae0",
            "sources": []
        },
        "1509": {
            "name": "RBX",
            "ins_idx": 122,
            "value": "0xffff8881e9543ae0",
            "sources": [
                1510
            ]
        },
        "1506": {
            "name": "R12",
            "ins_idx": 151,
            "value": "0xffff8881e9543ae0",
            "sources": []
        },
        "1507": {
            "name": "RDI",
            "ins_idx": 151,
            "value": "0xffff8881e9543ae0",
            "sources": [
                1508
            ]
        },
        "1496": {
            "name": "RDI",
            "ins_idx": 250,
            "value": "0xffff8881e9543ae0",
            "sources": []
        },
        "1497": {
            "name": "R12",
            "ins_idx": 250,
            "value": "0xffff8881e9543ae0",
            "sources": [
                1506
            ]
        },
        "1493": {
            "name": "R12",
            "ins_idx": 289,
            "value": "0xffff8881e6c0fd30",
            "sources": []
        },
        "1494": {
            "name": "[0xffff8881e6c0fd40]",
            "ins_idx": 289,
            "value": "0xffff8881e9543ae0",
            "sources": []
        },
        "1495": {
            "name": "RDI",
            "ins_idx": 289,
            "value": "0xffff8881e9543ae0",
            "sources": [
                1496
            ]
        },
        "1450": {
            "name": "RSP",
            "ins_idx": 321,
            "value": "0xffff8881e6c0fd00",
            "sources": []
        },
        "1451": {
            "name": "RAX",
            "ins_idx": 321,
            "value": "0xffff8881e9543ae0",
            "sources": []
        },
        "1452": {
            "name": "[0xffff8881e6c0fd40]",
            "ins_idx": 321,
            "value": "0xffff8881e9543ae0",
            "sources": [
                1494
            ]
        },
        "1447": {
            "name": "R12",
            "ins_idx": 350,
            "value": "0xffff8881e9543ae0",
            "sources": []
        },
        "1448": {
            "name": "RAX",
            "ins_idx": 350,
            "value": "0xffff8881e9543ae0",
            "sources": [
                1451
            ]
        },
        "1437": {
            "name": "RAX",
            "ins_idx": 426,
            "value": "0xffff8881e9543ae0",
            "sources": []
        },
        "1438": {
            "name": "R12",
            "ins_idx": 426,
            "value": "0xffff8881e9543ae0",
            "sources": [
                1447
            ]
        },
        "1436": {
            "name": "RAX",
            "ins_idx": 453,
            "value": "0xffff8881e9543ae0",
            "sources": [
                1437
            ]
        }
    },
    "chain": {
        "15": [
            74
        ],
        "74": [
            97
        ],
        "97": [
            122
        ],
        "122": [
            151
        ],
        "151": [
            250
        ],
        "250": [
            289
        ],
        "289": [
            321
        ],
        "321": [
            350
        ],
        "350": [
            426
        ],
        "426": [
            453
        ]
    }
}