{
    "report": "https://syzkaller.appspot.com/bug?id=afa337a1ede8e89814a04c6b82a4eb86953d80a0",
    "title": "BUG: unable to handle kernel paging request in percpu_ref_exit",
    "call": {
        "3049": {
            "name": "+0x2",
            "parent_idx": 3048,
            "source_line": [
                {
                    "file": "lib/percpu-refcount.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/percpu-refcount.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n130",
                    "code": [
                        "/**",
                        " * percpu_ref_exit - undo percpu_ref_init()",
                        " * @ref: percpu_ref to exit",
                        " *",
                        " * This function exits @ref.  The caller is responsible for ensuring that",
                        " * @ref is no longer in active use.  The usual places to invoke this",
                        " * function from are the @ref->release() callback or in init failure path",
                        " * where percpu_ref_init() succeeded but other parts of the initialization",
                        " * of the embedding object failed.",
                        " */",
                        "void percpu_ref_exit(struct percpu_ref *ref)",
                        "{",
                        "\tstruct percpu_ref_data *data = ref->data;",
                        "\tunsigned long flags;",
                        "",
                        "\t__percpu_ref_exit(ref);",
                        "",
                        "\tif (!data)",
                        "\t\treturn;",
                        "",
                        "\tspin_lock_irqsave(&percpu_ref_switch_lock, flags);",
                        "\tref->percpu_count_ptr |= atomic_long_read(&ref->data->count) <<",
                        "\t\t__PERCPU_REF_FLAG_BITS;",
                        "\tref->data = NULL;",
                        "\tspin_unlock_irqrestore(&percpu_ref_switch_lock, flags);",
                        "",
                        "\tkfree(data);",
                        "}"
                    ],
                    "start": 118,
                    "highlight": 130
                }
            ],
            "ins_idx": 39,
            "addr": "0xffffffff813f1442"
        },
        "3048": {
            "name": "percpu_ref_exit",
            "parent_idx": 2709,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n7703",
                    "code": [
                        "static void destroy_fixed_file_ref_node(struct fixed_file_ref_node *ref_node)",
                        "{",
                        "\tpercpu_ref_exit(&ref_node->refs);",
                        "\tkfree(ref_node);",
                        "}"
                    ],
                    "start": 7701,
                    "highlight": 7703
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n7293",
                    "code": [
                        "\t__io_sqe_files_unregister(ctx);",
                        "\tnr_tables = DIV_ROUND_UP(ctx->nr_user_files, IORING_MAX_FILES_TABLE);",
                        "\tfor (i = 0; i < nr_tables; i++)",
                        "\t\tkfree(data->table[i].files);",
                        "\tkfree(data->table);",
                        "\tpercpu_ref_exit(&data->refs);",
                        "\tkfree(data);",
                        "\tctx->file_data = NULL;",
                        "\tctx->nr_user_files = 0;",
                        "\tdestroy_fixed_file_ref_node(backup_node);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 7284,
                    "highlight": 7293
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8123f944"
        },
        "2709": {
            "name": "__io_uring_register",
            "parent_idx": 2684,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n10000",
                    "code": [
                        "SYSCALL_DEFINE4(io_uring_register, unsigned int, fd, unsigned int, opcode,",
                        "\t\tvoid __user *, arg, unsigned int, nr_args)",
                        "{",
                        "\tstruct io_ring_ctx *ctx;",
                        "\tlong ret = -EBADF;",
                        "\tstruct fd f;",
                        "",
                        "\tf = fdget(fd);",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\tret = -EOPNOTSUPP;",
                        "\tif (f.file->f_op != &io_uring_fops)",
                        "\t\tgoto out_fput;",
                        "",
                        "\tctx = f.file->private_data;",
                        "",
                        "\tmutex_lock(&ctx->uring_lock);",
                        "\tret = __io_uring_register(ctx, opcode, arg, nr_args);",
                        "\tmutex_unlock(&ctx->uring_lock);",
                        "\ttrace_io_uring_register(ctx, opcode, ctx->nr_user_files, ctx->nr_user_bufs,",
                        "\t\t\t\t\t\t\tctx->cq_ev_fd != NULL, ret);",
                        "out_fput:",
                        "\tfdput(f);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9982,
                    "highlight": 10000
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n9982",
                    "code": [
                        "static int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,",
                        "\t\t\t       void __user *arg, unsigned nr_args)",
                        "\t__releases(ctx->uring_lock)",
                        "\t__acquires(ctx->uring_lock)",
                        "{",
                        "\tint ret;",
                        "",
                        "\t/*",
                        "\t * We're inside the ring mutex, if the ref is already dying, then",
                        "\t * someone else killed the ctx or is already going through",
                        "\t * io_uring_register().",
                        "\t */",
                        "\tif (percpu_ref_is_dying(&ctx->refs))",
                        "\t\treturn -ENXIO;",
                        "",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\tpercpu_ref_kill(&ctx->refs);",
                        "",
                        "\t\t/*",
                        "\t\t * Drop uring mutex before waiting for references to exit. If",
                        "\t\t * another thread is currently inside io_uring_enter() it might",
                        "\t\t * need to grab the uring_lock to make progress. If we hold it",
                        "\t\t * here across the drain wait, then we can deadlock. It's safe",
                        "\t\t * to drop the mutex here, since no new references will come in",
                        "\t\t * after we've killed the percpu ref.",
                        "\t\t */",
                        "\t\tmutex_unlock(&ctx->uring_lock);",
                        "\t\tdo {",
                        "\t\t\tret = wait_for_completion_interruptible(&ctx->ref_comp);",
                        "\t\t\tif (!ret)",
                        "\t\t\t\tbreak;",
                        "\t\t\tret = io_run_task_work_sig();",
                        "\t\t\tif (ret < 0)",
                        "\t\t\t\tbreak;",
                        "\t\t} while (1);",
                        "",
                        "\t\tmutex_lock(&ctx->uring_lock);",
                        "",
                        "\t\tif (ret) {",
                        "\t\t\tpercpu_ref_resurrect(&ctx->refs);",
                        "\t\t\tgoto out_quiesce;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (ctx->restricted) {",
                        "\t\tif (opcode >= IORING_REGISTER_LAST) {",
                        "\t\t\tret = -EINVAL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tif (!test_bit(opcode, ctx->restrictions.register_op)) {",
                        "\t\t\tret = -EACCES;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (opcode) {",
                        "\tcase IORING_REGISTER_BUFFERS:",
                        "\t\tret = io_sqe_buffer_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_BUFFERS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_buffer_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES:",
                        "\t\tret = io_sqe_files_register(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_FILES:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_sqe_files_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_FILES_UPDATE:",
                        "\t\tret = io_sqe_files_update(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_EVENTFD:",
                        "\tcase IORING_REGISTER_EVENTFD_ASYNC:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (nr_args != 1)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_register(ctx, arg);",
                        "\t\tif (ret)",
                        "\t\t\tbreak;",
                        "\t\tif (opcode == IORING_REGISTER_EVENTFD_ASYNC)",
                        "\t\t\tctx->eventfd_async = 1;",
                        "\t\telse",
                        "\t\t\tctx->eventfd_async = 0;",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_EVENTFD:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_eventfd_unregister(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PROBE:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (!arg || nr_args > 256)",
                        "\t\t\tbreak;",
                        "\t\tret = io_probe(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_personality(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_UNREGISTER_PERSONALITY:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg)",
                        "\t\t\tbreak;",
                        "\t\tret = io_unregister_personality(ctx, nr_args);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_ENABLE_RINGS:",
                        "\t\tret = -EINVAL;",
                        "\t\tif (arg || nr_args)",
                        "\t\t\tbreak;",
                        "\t\tret = io_register_enable_rings(ctx);",
                        "\t\tbreak;",
                        "\tcase IORING_REGISTER_RESTRICTIONS:",
                        "\t\tret = io_register_restrictions(ctx, arg, nr_args);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tret = -EINVAL;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "out:",
                        "\tif (io_register_op_must_quiesce(opcode)) {",
                        "\t\t/* bring the ctx back to life */",
                        "\t\tpercpu_ref_reinit(&ctx->refs);",
                        "out_quiesce:",
                        "\t\treinit_completion(&ctx->ref_comp);",
                        "\t}",
                        "\treturn ret;",
                        "}",
                        "",
                        "SYSCALL_DEFINE4(io_uring_register, unsigned int, fd, unsigned int, opcode,",
                        "\t\tvoid __user *, arg, unsigned int, nr_args)",
                        "{",
                        "\tstruct io_ring_ctx *ctx;",
                        "\tlong ret = -EBADF;",
                        "\tstruct fd f;",
                        "",
                        "\tf = fdget(fd);",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\tret = -EOPNOTSUPP;",
                        "\tif (f.file->f_op != &io_uring_fops)",
                        "\t\tgoto out_fput;",
                        "",
                        "\tctx = f.file->private_data;",
                        "",
                        "\tmutex_lock(&ctx->uring_lock);",
                        "\tret = __io_uring_register(ctx, opcode, arg, nr_args);",
                        "\tmutex_unlock(&ctx->uring_lock);",
                        "\ttrace_io_uring_register(ctx, opcode, ctx->nr_user_files, ctx->nr_user_bufs,",
                        "\t\t\t\t\t\t\tctx->cq_ev_fd != NULL, ret);",
                        "out_fput:",
                        "\tfdput(f);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9843,
                    "highlight": 9982
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81242503"
        },
        "2684": {
            "name": "__x64_sys_io_uring_register(indirect)",
            "parent_idx": 2681,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b9217e"
        },
        "2681": {
            "name": "do_syscall_64",
            "parent_idx": 2674,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "2674": {
            "name": "125_syscall_26",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "3047": {
            "name": "+0x119",
            "parent_idx": 2709,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n7703",
                    "code": [
                        "static void destroy_fixed_file_ref_node(struct fixed_file_ref_node *ref_node)",
                        "{",
                        "\tpercpu_ref_exit(&ref_node->refs);",
                        "\tkfree(ref_node);",
                        "}"
                    ],
                    "start": 7701,
                    "highlight": 7703
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n7293",
                    "code": [
                        "\t__io_sqe_files_unregister(ctx);",
                        "\tnr_tables = DIV_ROUND_UP(ctx->nr_user_files, IORING_MAX_FILES_TABLE);",
                        "\tfor (i = 0; i < nr_tables; i++)",
                        "\t\tkfree(data->table[i].files);",
                        "\tkfree(data->table);",
                        "\tpercpu_ref_exit(&data->refs);",
                        "\tkfree(data);",
                        "\tctx->file_data = NULL;",
                        "\tctx->nr_user_files = 0;",
                        "\tdestroy_fixed_file_ref_node(backup_node);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 7284,
                    "highlight": 7293
                }
            ],
            "ins_idx": 87,
            "addr": "0xffffffff8123f929"
        },
        "2723": {
            "name": "+0x26",
            "parent_idx": 2709,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n7257",
                    "code": [
                        "static int io_sqe_files_unregister(struct io_ring_ctx *ctx)",
                        "{",
                        "\tstruct fixed_file_data *data = ctx->file_data;",
                        "\tstruct fixed_file_ref_node *backup_node, *ref_node = NULL;",
                        "\tunsigned nr_tables, i;",
                        "\tint ret;",
                        "",
                        "\tif (!data)",
                        "\t\treturn -ENXIO;",
                        "\tbackup_node = alloc_fixed_file_ref_node(ctx);",
                        "\tif (!backup_node)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tspin_lock_bh(&data->lock);",
                        "\tref_node = data->node;",
                        "\tspin_unlock_bh(&data->lock);",
                        "\tif (ref_node)",
                        "\t\tpercpu_ref_kill(&ref_node->refs);",
                        "",
                        "\tpercpu_ref_kill(&data->refs);",
                        "",
                        "\t/* wait for all refs nodes to complete */",
                        "\tflush_delayed_work(&ctx->file_put_work);",
                        "\tdo {",
                        "\t\tret = wait_for_completion_interruptible(&data->done);",
                        "\t\tif (!ret)",
                        "\t\t\tbreak;",
                        "\t\tret = io_run_task_work_sig();",
                        "\t\tif (ret < 0) {",
                        "\t\t\tpercpu_ref_resurrect(&data->refs);",
                        "\t\t\treinit_completion(&data->done);",
                        "\t\t\tio_sqe_files_set_node(data, backup_node);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t} while (1);",
                        "",
                        "\t__io_sqe_files_unregister(ctx);",
                        "\tnr_tables = DIV_ROUND_UP(ctx->nr_user_files, IORING_MAX_FILES_TABLE);",
                        "\tfor (i = 0; i < nr_tables; i++)",
                        "\t\tkfree(data->table[i].files);",
                        "\tkfree(data->table);",
                        "\tpercpu_ref_exit(&data->refs);",
                        "\tkfree(data);",
                        "\tctx->file_data = NULL;",
                        "\tctx->nr_user_files = 0;",
                        "\tdestroy_fixed_file_ref_node(backup_node);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 7248,
                    "highlight": 7257
                }
            ],
            "ins_idx": 1501,
            "addr": "0xffffffff8123f836"
        },
        "2720": {
            "name": "+0x75",
            "parent_idx": 2715,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n7699",
                    "code": [
                        "static struct fixed_file_ref_node *alloc_fixed_file_ref_node(",
                        "\t\t\tstruct io_ring_ctx *ctx)",
                        "{",
                        "\tstruct fixed_file_ref_node *ref_node;",
                        "",
                        "\tref_node = kzalloc(sizeof(*ref_node), GFP_KERNEL);",
                        "\tif (!ref_node)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tif (percpu_ref_init(&ref_node->refs, io_file_data_ref_zero,",
                        "\t\t\t    0, GFP_KERNEL)) {",
                        "\t\tkfree(ref_node);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "\tINIT_LIST_HEAD(&ref_node->node);",
                        "\tINIT_LIST_HEAD(&ref_node->file_list);",
                        "\tref_node->file_data = ctx->file_data;",
                        "\tref_node->done = false;",
                        "\treturn ref_node;",
                        "}"
                    ],
                    "start": 7680,
                    "highlight": 7699
                }
            ],
            "ins_idx": 1544,
            "addr": "0xffffffff8123ec35"
        },
        "2715": {
            "name": "alloc_fixed_file_ref_node",
            "parent_idx": 2709,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n7257",
                    "code": [
                        "static int io_sqe_files_unregister(struct io_ring_ctx *ctx)",
                        "{",
                        "\tstruct fixed_file_data *data = ctx->file_data;",
                        "\tstruct fixed_file_ref_node *backup_node, *ref_node = NULL;",
                        "\tunsigned nr_tables, i;",
                        "\tint ret;",
                        "",
                        "\tif (!data)",
                        "\t\treturn -ENXIO;",
                        "\tbackup_node = alloc_fixed_file_ref_node(ctx);",
                        "\tif (!backup_node)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tspin_lock_bh(&data->lock);",
                        "\tref_node = data->node;",
                        "\tspin_unlock_bh(&data->lock);",
                        "\tif (ref_node)",
                        "\t\tpercpu_ref_kill(&ref_node->refs);",
                        "",
                        "\tpercpu_ref_kill(&data->refs);",
                        "",
                        "\t/* wait for all refs nodes to complete */",
                        "\tflush_delayed_work(&ctx->file_put_work);",
                        "\tdo {",
                        "\t\tret = wait_for_completion_interruptible(&data->done);",
                        "\t\tif (!ret)",
                        "\t\t\tbreak;",
                        "\t\tret = io_run_task_work_sig();",
                        "\t\tif (ret < 0) {",
                        "\t\t\tpercpu_ref_resurrect(&data->refs);",
                        "\t\t\treinit_completion(&data->done);",
                        "\t\t\tio_sqe_files_set_node(data, backup_node);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t} while (1);",
                        "",
                        "\t__io_sqe_files_unregister(ctx);",
                        "\tnr_tables = DIV_ROUND_UP(ctx->nr_user_files, IORING_MAX_FILES_TABLE);",
                        "\tfor (i = 0; i < nr_tables; i++)",
                        "\t\tkfree(data->table[i].files);",
                        "\tkfree(data->table);",
                        "\tpercpu_ref_exit(&data->refs);",
                        "\tkfree(data);",
                        "\tctx->file_data = NULL;",
                        "\tctx->nr_user_files = 0;",
                        "\tdestroy_fixed_file_ref_node(backup_node);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 7248,
                    "highlight": 7257
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8123f831"
        },
        "2717": {
            "name": "+0xc",
            "parent_idx": 2715,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=36bbbd0e234d817938bdc52121a0f5473b3e58f5#n7687",
                    "code": [
                        "static struct fixed_file_ref_node *alloc_fixed_file_ref_node(",
                        "\t\t\tstruct io_ring_ctx *ctx)",
                        "{",
                        "\tstruct fixed_file_ref_node *ref_node;",
                        "",
                        "\tref_node = kzalloc(sizeof(*ref_node), GFP_KERNEL);",
                        "\tif (!ref_node)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tif (percpu_ref_init(&ref_node->refs, io_file_data_ref_zero,",
                        "\t\t\t    0, GFP_KERNEL)) {",
                        "\t\tkfree(ref_node);",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "\t}",
                        "\tINIT_LIST_HEAD(&ref_node->node);",
                        "\tINIT_LIST_HEAD(&ref_node->file_list);",
                        "\tref_node->file_data = ctx->file_data;",
                        "\tref_node->done = false;",
                        "\treturn ref_node;",
                        "}"
                    ],
                    "start": 7680,
                    "highlight": 7687
                }
            ],
            "ins_idx": 1589,
            "addr": "0xffffffff8123ebcc"
        }
    },
    "ins": {
        "39": {
            "name": "mov rbp, qword ptr [rdi + 8]",
            "desc": "Invalid Memory Access\nError code as addr: -12",
            "call_idx": 3049,
            "inputs": [
                5483,
                5484
            ],
            "outputs": [
                5485
            ]
        },
        "87": {
            "name": "mov rdi, r13",
            "desc": "",
            "call_idx": 3047,
            "inputs": [
                5481
            ],
            "outputs": [
                5482
            ]
        },
        "1501": {
            "name": "mov r13, rax",
            "desc": "",
            "call_idx": 2723,
            "inputs": [
                4887
            ],
            "outputs": [
                4888
            ]
        },
        "1544": {
            "name": "mov rax, r12",
            "desc": "",
            "call_idx": 2720,
            "inputs": [
                4881
            ],
            "outputs": [
                4882
            ]
        },
        "1589": {
            "name": "mov r12, -0xc",
            "desc": "Error code -12 generated",
            "call_idx": 2717,
            "inputs": [],
            "outputs": [
                4879
            ]
        }
    },
    "data": {
        "5483": {
            "name": "RDI",
            "ins_idx": 39,
            "value": "0xfffffffffffffff4",
            "sources": []
        },
        "5484": {
            "name": "[0xfffffffffffffffc]",
            "ins_idx": 39,
            "value": "0x0",
            "sources": []
        },
        "5485": {
            "name": "RBP",
            "ins_idx": 39,
            "value": "0x0",
            "sources": []
        },
        "5481": {
            "name": "R13",
            "ins_idx": 87,
            "value": "0xfffffffffffffff4",
            "sources": []
        },
        "5482": {
            "name": "RDI",
            "ins_idx": 87,
            "value": "0xfffffffffffffff4",
            "sources": [
                5483
            ]
        },
        "4887": {
            "name": "RAX",
            "ins_idx": 1501,
            "value": "0xfffffffffffffff4",
            "sources": []
        },
        "4888": {
            "name": "R13",
            "ins_idx": 1501,
            "value": "0xfffffffffffffff4",
            "sources": [
                5481
            ]
        },
        "4881": {
            "name": "R12",
            "ins_idx": 1544,
            "value": "0xfffffffffffffff4",
            "sources": []
        },
        "4882": {
            "name": "RAX",
            "ins_idx": 1544,
            "value": "0xfffffffffffffff4",
            "sources": [
                4887
            ]
        },
        "4879": {
            "name": "R12",
            "ins_idx": 1589,
            "value": "0xfffffffffffffff4",
            "sources": [
                4881
            ]
        }
    },
    "chain": {
        "39": [
            87
        ],
        "87": [
            1501
        ],
        "1501": [
            1544
        ],
        "1544": [
            1589
        ]
    }
}