{
    "report": "https://syzkaller.appspot.com/bug?id=2c91a9ebeb17895972ec695b8349426d1904d7b3",
    "title": "general protection fault in tcf_ife_cleanup",
    "call": {
        "122": {
            "name": "+0x46",
            "parent_idx": 119,
            "source_line": [
                {
                    "file": "net/sched/act_ife.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_ife.c?id=e69ec487b2c7#n412",
                    "code": [
                        "/* under ife->tcf_lock */",
                        "static void _tcf_ife_cleanup(struct tc_action *a)",
                        "{",
                        "\tstruct tcf_ife_info *ife = to_ife(a);",
                        "\tstruct tcf_meta_info *e, *n;",
                        "",
                        "\tlist_for_each_entry_safe(e, n, &ife->metalist, metalist) {",
                        "\t\tlist_del(&e->metalist);",
                        "\t\tif (e->metaval) {",
                        "\t\t\tif (e->ops->release)",
                        "\t\t\t\te->ops->release(e);",
                        "\t\t\telse",
                        "\t\t\t\tkfree(e->metaval);",
                        "\t\t}",
                        "\t\tmodule_put(e->ops->owner);",
                        "\t\tkfree(e);",
                        "\t}",
                        "}"
                    ],
                    "start": 406,
                    "highlight": 412
                },
                {
                    "file": "net/sched/act_ife.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_ife.c?id=e69ec487b2c7#n431",
                    "code": [
                        "\tspin_lock_bh(&ife->tcf_lock);",
                        "\t_tcf_ife_cleanup(a);",
                        "\tspin_unlock_bh(&ife->tcf_lock);",
                        "",
                        "\tp = rcu_dereference_protected(ife->params, 1);",
                        "\tif (p)",
                        "\t\tkfree_rcu(p, rcu);",
                        "}"
                    ],
                    "start": 430,
                    "highlight": 431
                }
            ],
            "ins_idx": 2,
            "addr": "0xffffffff818d3746"
        },
        "119": {
            "name": "tcf_ife_cleanup(indirect)",
            "parent_idx": 118,
            "source_line": [
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n119",
                    "code": [
                        "static void tcf_action_cleanup(struct tc_action *p)",
                        "{",
                        "\tif (p->ops->cleanup)",
                        "\t\tp->ops->cleanup(p);",
                        "",
                        "\tgen_kill_estimator(&p->tcfa_rate_est);",
                        "\tfree_tcf(p);",
                        "}"
                    ],
                    "start": 116,
                    "highlight": 119
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818d13c2"
        },
        "118": {
            "name": "tcf_action_cleanup",
            "parent_idx": 105,
            "source_line": [
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n135",
                    "code": [
                        "static int __tcf_action_put(struct tc_action *p, bool bind)",
                        "{",
                        "\tstruct tcf_idrinfo *idrinfo = p->idrinfo;",
                        "",
                        "\tif (refcount_dec_and_mutex_lock(&p->tcfa_refcnt, &idrinfo->lock)) {",
                        "\t\tif (bind)",
                        "\t\t\tatomic_dec(&p->tcfa_bindcnt);",
                        "\t\tidr_remove(&idrinfo->action_idr, p->tcfa_index);",
                        "\t\tmutex_unlock(&idrinfo->lock);",
                        "",
                        "\t\ttcf_action_cleanup(p);",
                        "\t\treturn 1;",
                        "\t}",
                        "",
                        "\tif (bind)",
                        "\t\tatomic_dec(&p->tcfa_bindcnt);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 125,
                    "highlight": 135
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818d148c"
        },
        "105": {
            "name": "__tcf_action_put",
            "parent_idx": 104,
            "source_line": [
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n165",
                    "code": [
                        "int __tcf_idr_release(struct tc_action *p, bool bind, bool strict)",
                        "{",
                        "\tint ret = 0;",
                        "",
                        "\t/* Release with strict==1 and bind==0 is only called through act API",
                        "\t * interface (classifiers always bind). Only case when action with",
                        "\t * positive reference count and zero bind count can exist is when it was",
                        "\t * also created with act API (unbinding last classifier will destroy the",
                        "\t * action if it was created by classifier). So only case when bind count",
                        "\t * can be changed after initial check is when unbound action is",
                        "\t * destroyed by act API while classifier binds to action with same id",
                        "\t * concurrently. This result either creation of new action(same behavior",
                        "\t * as before), or reusing existing action if concurrent process",
                        "\t * increments reference count before action is deleted. Both scenarios",
                        "\t * are acceptable.",
                        "\t */",
                        "\tif (p) {",
                        "\t\tif (!bind && strict && atomic_read(&p->tcfa_bindcnt) > 0)",
                        "\t\t\treturn -EPERM;",
                        "",
                        "\t\tif (__tcf_action_put(p, bind))",
                        "\t\t\tret = ACT_P_DELETED;",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 145,
                    "highlight": 165
                },
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n145",
                    "code": [
                        "int __tcf_idr_release(struct tc_action *p, bool bind, bool strict)",
                        "{",
                        "\tint ret = 0;",
                        "",
                        "\t/* Release with strict==1 and bind==0 is only called through act API",
                        "\t * interface (classifiers always bind). Only case when action with",
                        "\t * positive reference count and zero bind count can exist is when it was",
                        "\t * also created with act API (unbinding last classifier will destroy the",
                        "\t * action if it was created by classifier). So only case when bind count",
                        "\t * can be changed after initial check is when unbound action is",
                        "\t * destroyed by act API while classifier binds to action with same id",
                        "\t * concurrently. This result either creation of new action(same behavior",
                        "\t * as before), or reusing existing action if concurrent process",
                        "\t * increments reference count before action is deleted. Both scenarios",
                        "\t * are acceptable.",
                        "\t */",
                        "\tif (p) {",
                        "\t\tif (!bind && strict && atomic_read(&p->tcfa_bindcnt) > 0)",
                        "\t\t\treturn -EPERM;",
                        "",
                        "\t\tif (__tcf_action_put(p, bind))",
                        "\t\t\tret = ACT_P_DELETED;",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 145,
                    "highlight": 145
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818d14c1"
        },
        "104": {
            "name": "__tcf_idr_release",
            "parent_idx": 75,
            "source_line": [
                {
                    "file": "./include/net/act_api.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/act_api.h?id=e69ec487b2c7#n171",
                    "code": [
                        "static inline int tcf_idr_release(struct tc_action *a, bool bind)",
                        "{",
                        "\treturn __tcf_idr_release(a, bind, false);",
                        "}"
                    ],
                    "start": 169,
                    "highlight": 171
                },
                {
                    "file": "net/sched/act_ife.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_ife.c?id=e69ec487b2c7#n616",
                    "code": [
                        "static int tcf_ife_init(struct net *net, struct nlattr *nla,",
                        "\t\t\tstruct nlattr *est, struct tc_action **a,",
                        "\t\t\tint ovr, int bind, bool rtnl_held,",
                        "\t\t\tstruct tcf_proto *tp, u32 flags,",
                        "\t\t\tstruct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct tc_action_net *tn = net_generic(net, ife_net_id);",
                        "\tstruct nlattr *tb[TCA_IFE_MAX + 1];",
                        "\tstruct nlattr *tb2[IFE_META_MAX + 1];",
                        "\tstruct tcf_chain *goto_ch = NULL;",
                        "\tstruct tcf_ife_params *p;",
                        "\tstruct tcf_ife_info *ife;",
                        "\tu16 ife_type = ETH_P_IFE;",
                        "\tstruct tc_ife *parm;",
                        "\tu8 *daddr = NULL;",
                        "\tu8 *saddr = NULL;",
                        "\tbool exists = false;",
                        "\tint ret = 0;",
                        "\tu32 index;",
                        "\tint err;",
                        "",
                        "\tif (!nla) {",
                        "\t\tNL_SET_ERR_MSG_MOD(extack, \"IFE requires attributes to be passed\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\terr = nla_parse_nested_deprecated(tb, TCA_IFE_MAX, nla, ife_policy,",
                        "\t\t\t\t\t  NULL);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tif (!tb[TCA_IFE_PARMS])",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tparm = nla_data(tb[TCA_IFE_PARMS]);",
                        "",
                        "\t/* IFE_DECODE is 0 and indicates the opposite of IFE_ENCODE because",
                        "\t * they cannot run as the same time. Check on all other values which",
                        "\t * are not supported right now.",
                        "\t */",
                        "\tif (parm->flags & ~IFE_ENCODE)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tp = kzalloc(sizeof(*p), GFP_KERNEL);",
                        "\tif (!p)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tindex = parm->index;",
                        "\terr = tcf_idr_check_alloc(tn, &index, a, bind);",
                        "\tif (err < 0) {",
                        "\t\tkfree(p);",
                        "\t\treturn err;",
                        "\t}",
                        "\texists = err;",
                        "\tif (exists && bind) {",
                        "\t\tkfree(p);",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\tif (!exists) {",
                        "\t\tret = tcf_idr_create(tn, index, est, a, &act_ife_ops,",
                        "\t\t\t\t     bind, true, 0);",
                        "\t\tif (ret) {",
                        "\t\t\ttcf_idr_cleanup(tn, index);",
                        "\t\t\tkfree(p);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t\tret = ACT_P_CREATED;",
                        "\t} else if (!ovr) {",
                        "\t\ttcf_idr_release(*a, bind);",
                        "\t\tkfree(p);",
                        "\t\treturn -EEXIST;",
                        "\t}",
                        "",
                        "\tife = to_ife(*a);",
                        "\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);",
                        "\tif (err < 0)",
                        "\t\tgoto release_idr;",
                        "",
                        "\tp->flags = parm->flags;",
                        "",
                        "\tif (parm->flags & IFE_ENCODE) {",
                        "\t\tif (tb[TCA_IFE_TYPE])",
                        "\t\t\tife_type = nla_get_u16(tb[TCA_IFE_TYPE]);",
                        "\t\tif (tb[TCA_IFE_DMAC])",
                        "\t\t\tdaddr = nla_data(tb[TCA_IFE_DMAC]);",
                        "\t\tif (tb[TCA_IFE_SMAC])",
                        "\t\t\tsaddr = nla_data(tb[TCA_IFE_SMAC]);",
                        "\t}",
                        "",
                        "\tif (parm->flags & IFE_ENCODE) {",
                        "\t\tif (daddr)",
                        "\t\t\tether_addr_copy(p->eth_dst, daddr);",
                        "\t\telse",
                        "\t\t\teth_zero_addr(p->eth_dst);",
                        "",
                        "\t\tif (saddr)",
                        "\t\t\tether_addr_copy(p->eth_src, saddr);",
                        "\t\telse",
                        "\t\t\teth_zero_addr(p->eth_src);",
                        "",
                        "\t\tp->eth_type = ife_type;",
                        "\t}",
                        "",
                        "",
                        "\tif (ret == ACT_P_CREATED)",
                        "\t\tINIT_LIST_HEAD(&ife->metalist);",
                        "",
                        "\tif (tb[TCA_IFE_METALST]) {",
                        "\t\terr = nla_parse_nested_deprecated(tb2, IFE_META_MAX,",
                        "\t\t\t\t\t\t  tb[TCA_IFE_METALST], NULL,",
                        "\t\t\t\t\t\t  NULL);",
                        "\t\tif (err)",
                        "\t\t\tgoto metadata_parse_err;",
                        "\t\terr = populate_metalist(ife, tb2, exists, rtnl_held);",
                        "\t\tif (err)",
                        "\t\t\tgoto metadata_parse_err;",
                        "",
                        "\t} else {",
                        "\t\t/* if no passed metadata allow list or passed allow-all",
                        "\t\t * then here we process by adding as many supported metadatum",
                        "\t\t * as we can. You better have at least one else we are",
                        "\t\t * going to bail out",
                        "\t\t */",
                        "\t\terr = use_all_metadata(ife, exists);",
                        "\t\tif (err)",
                        "\t\t\tgoto metadata_parse_err;",
                        "\t}",
                        "",
                        "\tif (exists)",
                        "\t\tspin_lock_bh(&ife->tcf_lock);",
                        "\t/* protected by tcf_lock when modifying existing action */",
                        "\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);",
                        "\tp = rcu_replace_pointer(ife->params, p, 1);",
                        "",
                        "\tif (exists)",
                        "\t\tspin_unlock_bh(&ife->tcf_lock);",
                        "\tif (goto_ch)",
                        "\t\ttcf_chain_put_by_act(goto_ch);",
                        "\tif (p)",
                        "\t\tkfree_rcu(p, rcu);",
                        "",
                        "\tif (ret == ACT_P_CREATED)",
                        "\t\ttcf_idr_insert(tn, *a);",
                        "",
                        "\treturn ret;",
                        "metadata_parse_err:",
                        "\tif (goto_ch)",
                        "\t\ttcf_chain_put_by_act(goto_ch);",
                        "release_idr:",
                        "\tkfree(p);",
                        "\ttcf_idr_release(*a, bind);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 465,
                    "highlight": 616
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818d4128"
        },
        "75": {
            "name": "tcf_ife_init(indirect)",
            "parent_idx": 72,
            "source_line": [
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n944",
                    "code": [
                        "struct tc_action *tcf_action_init_1(struct net *net, struct tcf_proto *tp,",
                        "\t\t\t\t    struct nlattr *nla, struct nlattr *est,",
                        "\t\t\t\t    char *name, int ovr, int bind,",
                        "\t\t\t\t    bool rtnl_held,",
                        "\t\t\t\t    struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct nla_bitfield32 flags = { 0, 0 };",
                        "\tstruct tc_action *a;",
                        "\tstruct tc_action_ops *a_o;",
                        "\tstruct tc_cookie *cookie = NULL;",
                        "\tchar act_name[IFNAMSIZ];",
                        "\tstruct nlattr *tb[TCA_ACT_MAX + 1];",
                        "\tstruct nlattr *kind;",
                        "\tint err;",
                        "",
                        "\tif (name == NULL) {",
                        "\t\terr = nla_parse_nested_deprecated(tb, TCA_ACT_MAX, nla,",
                        "\t\t\t\t\t\t  tcf_action_policy, extack);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto err_out;",
                        "\t\terr = -EINVAL;",
                        "\t\tkind = tb[TCA_ACT_KIND];",
                        "\t\tif (!kind) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"TC action kind must be specified\");",
                        "\t\t\tgoto err_out;",
                        "\t\t}",
                        "\t\tif (nla_strlcpy(act_name, kind, IFNAMSIZ) >= IFNAMSIZ) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"TC action name too long\");",
                        "\t\t\tgoto err_out;",
                        "\t\t}",
                        "\t\tif (tb[TCA_ACT_COOKIE]) {",
                        "\t\t\tcookie = nla_memdup_cookie(tb);",
                        "\t\t\tif (!cookie) {",
                        "\t\t\t\tNL_SET_ERR_MSG(extack, \"No memory to generate TC cookie\");",
                        "\t\t\t\terr = -ENOMEM;",
                        "\t\t\t\tgoto err_out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (tb[TCA_ACT_FLAGS])",
                        "\t\t\tflags = nla_get_bitfield32(tb[TCA_ACT_FLAGS]);",
                        "\t} else {",
                        "\t\tif (strlcpy(act_name, name, IFNAMSIZ) >= IFNAMSIZ) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"TC action name too long\");",
                        "\t\t\terr = -EINVAL;",
                        "\t\t\tgoto err_out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\ta_o = tc_lookup_action_n(act_name);",
                        "\tif (a_o == NULL) {",
                        "#ifdef CONFIG_MODULES",
                        "\t\tif (rtnl_held)",
                        "\t\t\trtnl_unlock();",
                        "\t\trequest_module(\"act_%s\", act_name);",
                        "\t\tif (rtnl_held)",
                        "\t\t\trtnl_lock();",
                        "",
                        "\t\ta_o = tc_lookup_action_n(act_name);",
                        "",
                        "\t\t/* We dropped the RTNL semaphore in order to",
                        "\t\t * perform the module load.  So, even if we",
                        "\t\t * succeeded in loading the module we have to",
                        "\t\t * tell the caller to replay the request.  We",
                        "\t\t * indicate this using -EAGAIN.",
                        "\t\t */",
                        "\t\tif (a_o != NULL) {",
                        "\t\t\terr = -EAGAIN;",
                        "\t\t\tgoto err_mod;",
                        "\t\t}",
                        "#endif",
                        "\t\tNL_SET_ERR_MSG(extack, \"Failed to load TC action module\");",
                        "\t\terr = -ENOENT;",
                        "\t\tgoto err_out;",
                        "\t}",
                        "",
                        "\t/* backward compatibility for policer */",
                        "\tif (name == NULL)",
                        "\t\terr = a_o->init(net, tb[TCA_ACT_OPTIONS], est, &a, ovr, bind,",
                        "\t\t\t\trtnl_held, tp, flags.value, extack);",
                        "\telse",
                        "\t\terr = a_o->init(net, nla, est, &a, ovr, bind, rtnl_held,",
                        "\t\t\t\ttp, flags.value, extack);",
                        "\tif (err < 0)",
                        "\t\tgoto err_mod;",
                        "",
                        "\tif (!name && tb[TCA_ACT_COOKIE])",
                        "\t\ttcf_set_action_cookie(&a->act_cookie, cookie);",
                        "",
                        "\t/* module count goes up only when brand new policy is created",
                        "\t * if it exists and is only bound to in a_o->init() then",
                        "\t * ACT_P_CREATED is not returned (a zero is).",
                        "\t */",
                        "\tif (err != ACT_P_CREATED)",
                        "\t\tmodule_put(a_o->owner);",
                        "",
                        "\tif (TC_ACT_EXT_CMP(a->tcfa_action, TC_ACT_GOTO_CHAIN) &&",
                        "\t    !rcu_access_pointer(a->goto_chain)) {",
                        "\t\ttcf_action_destroy_1(a, bind);",
                        "\t\tNL_SET_ERR_MSG(extack, \"can't use goto chain with NULL chain\");",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "\t}",
                        "",
                        "\treturn a;",
                        "",
                        "err_mod:",
                        "\tmodule_put(a_o->owner);",
                        "err_out:",
                        "\tif (cookie) {",
                        "\t\tkfree(cookie->data);",
                        "\t\tkfree(cookie);",
                        "\t}",
                        "\treturn ERR_PTR(err);",
                        "}"
                    ],
                    "start": 867,
                    "highlight": 944
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818d1d48"
        },
        "72": {
            "name": "tcf_action_init_1",
            "parent_idx": 71,
            "source_line": [
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n1000",
                    "code": [
                        "int tcf_action_init(struct net *net, struct tcf_proto *tp, struct nlattr *nla,",
                        "\t\t    struct nlattr *est, char *name, int ovr, int bind,",
                        "\t\t    struct tc_action *actions[], size_t *attr_size,",
                        "\t\t    bool rtnl_held, struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct nlattr *tb[TCA_ACT_MAX_PRIO + 1];",
                        "\tstruct tc_action *act;",
                        "\tsize_t sz = 0;",
                        "\tint err;",
                        "\tint i;",
                        "",
                        "\terr = nla_parse_nested_deprecated(tb, TCA_ACT_MAX_PRIO, nla, NULL,",
                        "\t\t\t\t\t  extack);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tfor (i = 1; i <= TCA_ACT_MAX_PRIO && tb[i]; i++) {",
                        "\t\tact = tcf_action_init_1(net, tp, tb[i], est, name, ovr, bind,",
                        "\t\t\t\t\trtnl_held, extack);",
                        "\t\tif (IS_ERR(act)) {",
                        "\t\t\terr = PTR_ERR(act);",
                        "\t\t\tgoto err;",
                        "\t\t}",
                        "\t\tsz += tcf_action_fill_size(act);",
                        "\t\t/* Start from index 0 */",
                        "\t\tactions[i - 1] = act;",
                        "\t}",
                        "",
                        "\t*attr_size = tcf_action_full_attrs_size(sz);",
                        "\treturn i - 1;",
                        "",
                        "err:",
                        "\ttcf_action_destroy(actions, bind);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 983,
                    "highlight": 1000
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818d200b"
        },
        "71": {
            "name": "tcf_action_init",
            "parent_idx": 70,
            "source_line": [
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n1410",
                    "code": [
                        "static int tcf_action_add(struct net *net, struct nlattr *nla,",
                        "\t\t\t  struct nlmsghdr *n, u32 portid, int ovr,",
                        "\t\t\t  struct netlink_ext_ack *extack)",
                        "{",
                        "\tsize_t attr_size = 0;",
                        "\tint loop, ret;",
                        "\tstruct tc_action *actions[TCA_ACT_MAX_PRIO] = {};",
                        "",
                        "\tfor (loop = 0; loop < 10; loop++) {",
                        "\t\tret = tcf_action_init(net, NULL, nla, NULL, NULL, ovr, 0,",
                        "\t\t\t\t      actions, &attr_size, true, extack);",
                        "\t\tif (ret != -EAGAIN)",
                        "\t\t\tbreak;",
                        "\t}",
                        "",
                        "\tif (ret < 0)",
                        "\t\treturn ret;",
                        "\tret = tcf_add_notify(net, n, actions, portid, attr_size, extack);",
                        "\tif (ovr)",
                        "\t\ttcf_action_put_many(actions);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1401,
                    "highlight": 1410
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818d30b3"
        },
        "70": {
            "name": "tcf_action_add",
            "parent_idx": 69,
            "source_line": [
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n1465",
                    "code": [
                        "static int tc_ctl_action(struct sk_buff *skb, struct nlmsghdr *n,",
                        "\t\t\t struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct nlattr *tca[TCA_ROOT_MAX + 1];",
                        "\tu32 portid = skb ? NETLINK_CB(skb).portid : 0;",
                        "\tint ret = 0, ovr = 0;",
                        "",
                        "\tif ((n->nlmsg_type != RTM_GETACTION) &&",
                        "\t    !netlink_capable(skb, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\tret = nlmsg_parse_deprecated(n, sizeof(struct tcamsg), tca,",
                        "\t\t\t\t     TCA_ROOT_MAX, NULL, extack);",
                        "\tif (ret < 0)",
                        "\t\treturn ret;",
                        "",
                        "\tif (tca[TCA_ACT_TAB] == NULL) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Netlink action attributes missing\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\t/* n->nlmsg_flags & NLM_F_CREATE */",
                        "\tswitch (n->nlmsg_type) {",
                        "\tcase RTM_NEWACTION:",
                        "\t\t/* we are going to assume all other flags",
                        "\t\t * imply create only if it doesn't exist",
                        "\t\t * Note that CREATE | EXCL implies that",
                        "\t\t * but since we want avoid ambiguity (eg when flags",
                        "\t\t * is zero) then just set this",
                        "\t\t */",
                        "\t\tif (n->nlmsg_flags & NLM_F_REPLACE)",
                        "\t\t\tovr = 1;",
                        "\t\tret = tcf_action_add(net, tca[TCA_ACT_TAB], n, portid, ovr,",
                        "\t\t\t\t     extack);",
                        "\t\tbreak;",
                        "\tcase RTM_DELACTION:",
                        "\t\tret = tca_action_gd(net, tca[TCA_ACT_TAB], n,",
                        "\t\t\t\t    portid, RTM_DELACTION, extack);",
                        "\t\tbreak;",
                        "\tcase RTM_GETACTION:",
                        "\t\tret = tca_action_gd(net, tca[TCA_ACT_TAB], n,",
                        "\t\t\t\t    portid, RTM_GETACTION, extack);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tBUG();",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1432,
                    "highlight": 1465
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818d32ad"
        },
        "69": {
            "name": "tc_ctl_action(indirect)",
            "parent_idx": 68,
            "source_line": [
                {
                    "file": "net/core/rtnetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/rtnetlink.c?id=e69ec487b2c7#n5424",
                    "code": [
                        "static int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t     struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct rtnl_link *link;",
                        "\tstruct module *owner;",
                        "\tint err = -EOPNOTSUPP;",
                        "\trtnl_doit_func doit;",
                        "\tunsigned int flags;",
                        "\tint kind;",
                        "\tint family;",
                        "\tint type;",
                        "",
                        "\ttype = nlh->nlmsg_type;",
                        "\tif (type > RTM_MAX)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\ttype -= RTM_BASE;",
                        "",
                        "\t/* All the messages must have at least 1 byte length */",
                        "\tif (nlmsg_len(nlh) < sizeof(struct rtgenmsg))",
                        "\t\treturn 0;",
                        "",
                        "\tfamily = ((struct rtgenmsg *)nlmsg_data(nlh))->rtgen_family;",
                        "\tkind = type&3;",
                        "",
                        "\tif (kind != 2 && !netlink_net_capable(skb, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\trcu_read_lock();",
                        "\tif (kind == 2 && nlh->nlmsg_flags&NLM_F_DUMP) {",
                        "\t\tstruct sock *rtnl;",
                        "\t\trtnl_dumpit_func dumpit;",
                        "\t\tu16 min_dump_alloc = 0;",
                        "",
                        "\t\tlink = rtnl_get_link(family, type);",
                        "\t\tif (!link || !link->dumpit) {",
                        "\t\t\tfamily = PF_UNSPEC;",
                        "\t\t\tlink = rtnl_get_link(family, type);",
                        "\t\t\tif (!link || !link->dumpit)",
                        "\t\t\t\tgoto err_unlock;",
                        "\t\t}",
                        "\t\towner = link->owner;",
                        "\t\tdumpit = link->dumpit;",
                        "",
                        "\t\tif (type == RTM_GETLINK - RTM_BASE)",
                        "\t\t\tmin_dump_alloc = rtnl_calcit(skb, nlh);",
                        "",
                        "\t\terr = 0;",
                        "\t\t/* need to do this before rcu_read_unlock() */",
                        "\t\tif (!try_module_get(owner))",
                        "\t\t\terr = -EPROTONOSUPPORT;",
                        "",
                        "\t\trcu_read_unlock();",
                        "",
                        "\t\trtnl = net->rtnl;",
                        "\t\tif (err == 0) {",
                        "\t\t\tstruct netlink_dump_control c = {",
                        "\t\t\t\t.dump\t\t= dumpit,",
                        "\t\t\t\t.min_dump_alloc\t= min_dump_alloc,",
                        "\t\t\t\t.module\t\t= owner,",
                        "\t\t\t};",
                        "\t\t\terr = netlink_dump_start(rtnl, skb, nlh, &c);",
                        "\t\t\t/* netlink_dump_start() will keep a reference on",
                        "\t\t\t * module if dump is still in progress.",
                        "\t\t\t */",
                        "\t\t\tmodule_put(owner);",
                        "\t\t}",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\tlink = rtnl_get_link(family, type);",
                        "\tif (!link || !link->doit) {",
                        "\t\tfamily = PF_UNSPEC;",
                        "\t\tlink = rtnl_get_link(PF_UNSPEC, type);",
                        "\t\tif (!link || !link->doit)",
                        "\t\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\towner = link->owner;",
                        "\tif (!try_module_get(owner)) {",
                        "\t\terr = -EPROTONOSUPPORT;",
                        "\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\tflags = link->flags;",
                        "\tif (flags & RTNL_FLAG_DOIT_UNLOCKED) {",
                        "\t\tdoit = link->doit;",
                        "\t\trcu_read_unlock();",
                        "\t\tif (doit)",
                        "\t\t\terr = doit(skb, nlh, extack);",
                        "\t\tmodule_put(owner);",
                        "\t\treturn err;",
                        "\t}",
                        "\trcu_read_unlock();",
                        "",
                        "\trtnl_lock();",
                        "\tlink = rtnl_get_link(family, type);",
                        "\tif (link && link->doit)",
                        "\t\terr = link->doit(skb, nlh, extack);",
                        "\trtnl_unlock();",
                        "",
                        "\tmodule_put(owner);",
                        "",
                        "\treturn err;",
                        "",
                        "out_unlock:",
                        "\trcu_read_unlock();",
                        "\treturn err;",
                        "",
                        "err_unlock:",
                        "\trcu_read_unlock();",
                        "\treturn -EOPNOTSUPP;",
                        "}"
                    ],
                    "start": 5325,
                    "highlight": 5424
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8189df86"
        },
        "68": {
            "name": "rtnetlink_rcv_msg(indirect)",
            "parent_idx": 67,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=e69ec487b2c7#n2477",
                    "code": [
                        "int netlink_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *,",
                        "\t\t\t\t\t\t   struct nlmsghdr *,",
                        "\t\t\t\t\t\t   struct netlink_ext_ack *))",
                        "{",
                        "\tstruct netlink_ext_ack extack;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tint err;",
                        "",
                        "\twhile (skb->len >= nlmsg_total_size(0)) {",
                        "\t\tint msglen;",
                        "",
                        "\t\tmemset(&extack, 0, sizeof(extack));",
                        "\t\tnlh = nlmsg_hdr(skb);",
                        "\t\terr = 0;",
                        "",
                        "\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len)",
                        "\t\t\treturn 0;",
                        "",
                        "\t\t/* Only requests are handled by the kernel */",
                        "\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST))",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\t/* Skip control messages */",
                        "\t\tif (nlh->nlmsg_type < NLMSG_MIN_TYPE)",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\terr = cb(skb, nlh, &extack);",
                        "\t\tif (err == -EINTR)",
                        "\t\t\tgoto skip;",
                        "",
                        "ack:",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err)",
                        "\t\t\tnetlink_ack(skb, nlh, err, &extack);",
                        "",
                        "skip:",
                        "\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);",
                        "\t\tif (msglen > skb->len)",
                        "\t\t\tmsglen = skb->len;",
                        "\t\tskb_pull(skb, msglen);",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 2451,
                    "highlight": 2477
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818dad6d"
        },
        "67": {
            "name": "netlink_rcv_skb(indirect)",
            "parent_idx": 66,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=e69ec487b2c7#n1302",
                    "code": [
                        "static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,",
                        "\t\t\t\t  struct sock *ssk)",
                        "{",
                        "\tint ret;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "",
                        "\tret = -ECONNREFUSED;",
                        "\tif (nlk->netlink_rcv != NULL) {",
                        "\t\tret = skb->len;",
                        "\t\tnetlink_skb_set_owner_r(skb, sk);",
                        "\t\tNETLINK_CB(skb).sk = ssk;",
                        "\t\tnetlink_deliver_tap_kernel(sk, ssk, skb);",
                        "\t\tnlk->netlink_rcv(skb);",
                        "\t\tconsume_skb(skb);",
                        "\t} else {",
                        "\t\tkfree_skb(skb);",
                        "\t}",
                        "\tsock_put(sk);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1290,
                    "highlight": 1302
                },
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=e69ec487b2c7#n1328",
                    "code": [
                        "int netlink_unicast(struct sock *ssk, struct sk_buff *skb,",
                        "\t\t    u32 portid, int nonblock)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tint err;",
                        "\tlong timeo;",
                        "",
                        "\tskb = netlink_trim(skb, gfp_any());",
                        "",
                        "\ttimeo = sock_sndtimeo(ssk, nonblock);",
                        "retry:",
                        "\tsk = netlink_getsockbyportid(ssk, portid);",
                        "\tif (IS_ERR(sk)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn PTR_ERR(sk);",
                        "\t}",
                        "\tif (netlink_is_kernel(sk))",
                        "\t\treturn netlink_unicast_kernel(sk, skb, ssk);",
                        "",
                        "\tif (sk_filter(sk, skb)) {",
                        "\t\terr = skb->len;",
                        "\t\tkfree_skb(skb);",
                        "\t\tsock_put(sk);",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = netlink_attachskb(sk, skb, &timeo, ssk);",
                        "\tif (err == 1)",
                        "\t\tgoto retry;",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\treturn netlink_sendskb(sk, skb);",
                        "}"
                    ],
                    "start": 1311,
                    "highlight": 1328
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818da4ff"
        },
        "66": {
            "name": "netlink_unicast",
            "parent_idx": 65,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=e69ec487b2c7#n1917",
                    "code": [
                        "static int netlink_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "\tDECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);",
                        "\tu32 dst_portid;",
                        "\tu32 dst_group;",
                        "\tstruct sk_buff *skb;",
                        "\tint err;",
                        "\tstruct scm_cookie scm;",
                        "\tu32 netlink_skb_flags = 0;",
                        "",
                        "\tif (msg->msg_flags&MSG_OOB)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\terr = scm_send(sock, msg, &scm, true);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tif (msg->msg_namelen) {",
                        "\t\terr = -EINVAL;",
                        "\t\tif (msg->msg_namelen < sizeof(struct sockaddr_nl))",
                        "\t\t\tgoto out;",
                        "\t\tif (addr->nl_family != AF_NETLINK)",
                        "\t\t\tgoto out;",
                        "\t\tdst_portid = addr->nl_pid;",
                        "\t\tdst_group = ffs(addr->nl_groups);",
                        "\t\terr =  -EPERM;",
                        "\t\tif ((dst_group || dst_portid) &&",
                        "\t\t    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))",
                        "\t\t\tgoto out;",
                        "\t\tnetlink_skb_flags |= NETLINK_SKB_DST;",
                        "\t} else {",
                        "\t\tdst_portid = nlk->dst_portid;",
                        "\t\tdst_group = nlk->dst_group;",
                        "\t}",
                        "",
                        "\tif (!nlk->bound) {",
                        "\t\terr = netlink_autobind(sock);",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t} else {",
                        "\t\t/* Ensure nlk is hashed and visible. */",
                        "\t\tsmp_rmb();",
                        "\t}",
                        "",
                        "\terr = -EMSGSIZE;",
                        "\tif (len > sk->sk_sndbuf - 32)",
                        "\t\tgoto out;",
                        "\terr = -ENOBUFS;",
                        "\tskb = netlink_alloc_large_skb(len, dst_group);",
                        "\tif (skb == NULL)",
                        "\t\tgoto out;",
                        "",
                        "\tNETLINK_CB(skb).portid\t= nlk->portid;",
                        "\tNETLINK_CB(skb).dst_group = dst_group;",
                        "\tNETLINK_CB(skb).creds\t= scm.creds;",
                        "\tNETLINK_CB(skb).flags\t= netlink_skb_flags;",
                        "",
                        "\terr = -EFAULT;",
                        "\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\terr = security_netlink_send(sk, skb);",
                        "\tif (err) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (dst_group) {",
                        "\t\trefcount_inc(&skb->users);",
                        "\t\tnetlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);",
                        "\t}",
                        "\terr = netlink_unicast(sk, skb, dst_portid, msg->msg_flags&MSG_DONTWAIT);",
                        "",
                        "out:",
                        "\tscm_destroy(&scm);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1842,
                    "highlight": 1917
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818da7eb"
        },
        "65": {
            "name": "netlink_sendmsg(indirect)",
            "parent_idx": 64,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=e69ec487b2c7#n639",
                    "code": [
                        "INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t   size_t));",
                        "INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t    size_t));",
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,",
                        "\t\t\t\t     inet_sendmsg, sock, msg,",
                        "\t\t\t\t     msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 633,
                    "highlight": 639
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=e69ec487b2c7#n659",
                    "code": [
                        "/**",
                        " *\tsock_sendmsg - send a message through @sock",
                        " *\t@sock: socket",
                        " *\t@msg: message to send",
                        " *",
                        " *\tSends @msg through @sock, passing through LSM.",
                        " *\tReturns the number of bytes sent, or an error code.",
                        " */",
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 646,
                    "highlight": 659
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81863294"
        },
        "64": {
            "name": "sock_sendmsg",
            "parent_idx": 63,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=e69ec487b2c7#n2330",
                    "code": [
                        "static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,",
                        "\t\t\t   unsigned int flags, struct used_address *used_address,",
                        "\t\t\t   unsigned int allowed_msghdr_flags)",
                        "{",
                        "\tunsigned char ctl[sizeof(struct cmsghdr) + 20]",
                        "\t\t\t\t__aligned(sizeof(__kernel_size_t));",
                        "\t/* 20 is size of ipv6_pktinfo */",
                        "\tunsigned char *ctl_buf = ctl;",
                        "\tint ctl_len;",
                        "\tssize_t err;",
                        "",
                        "\terr = -ENOBUFS;",
                        "",
                        "\tif (msg_sys->msg_controllen > INT_MAX)",
                        "\t\tgoto out;",
                        "\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);",
                        "\tctl_len = msg_sys->msg_controllen;",
                        "\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
                        "\t\terr =",
                        "\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,",
                        "\t\t\t\t\t\t     sizeof(ctl));",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t\tctl_buf = msg_sys->msg_control;",
                        "\t\tctl_len = msg_sys->msg_controllen;",
                        "\t} else if (ctl_len) {",
                        "\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=",
                        "\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));",
                        "\t\tif (ctl_len > sizeof(ctl)) {",
                        "\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);",
                        "\t\t\tif (ctl_buf == NULL)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\terr = -EFAULT;",
                        "\t\t/*",
                        "\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.",
                        "\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted",
                        "\t\t * checking falls down on this.",
                        "\t\t */",
                        "\t\tif (copy_from_user(ctl_buf,",
                        "\t\t\t\t   (void __user __force *)msg_sys->msg_control,",
                        "\t\t\t\t   ctl_len))",
                        "\t\t\tgoto out_freectl;",
                        "\t\tmsg_sys->msg_control = ctl_buf;",
                        "\t}",
                        "\tmsg_sys->msg_flags = flags;",
                        "",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;",
                        "\t/*",
                        "\t * If this is sendmmsg() and current destination address is same as",
                        "\t * previously succeeded address, omit asking LSM's decision.",
                        "\t * used_address->name_len is initialized to UINT_MAX so that the first",
                        "\t * destination address never matches.",
                        "\t */",
                        "\tif (used_address && msg_sys->msg_name &&",
                        "\t    used_address->name_len == msg_sys->msg_namelen &&",
                        "\t    !memcmp(&used_address->name, msg_sys->msg_name,",
                        "\t\t    used_address->name_len)) {",
                        "\t\terr = sock_sendmsg_nosec(sock, msg_sys);",
                        "\t\tgoto out_freectl;",
                        "\t}",
                        "\terr = sock_sendmsg(sock, msg_sys);",
                        "\t/*",
                        "\t * If this is sendmmsg() and sending to current destination address was",
                        "\t * successful, remember it.",
                        "\t */",
                        "\tif (used_address && err >= 0) {",
                        "\t\tused_address->name_len = msg_sys->msg_namelen;",
                        "\t\tif (msg_sys->msg_name)",
                        "\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,",
                        "\t\t\t       used_address->name_len);",
                        "\t}",
                        "",
                        "out_freectl:",
                        "\tif (ctl_buf != ctl)",
                        "\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2268,
                    "highlight": 2330
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818635a9"
        },
        "63": {
            "name": "____sys_sendmsg",
            "parent_idx": 62,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=e69ec487b2c7#n2384",
                    "code": [
                        "\terr = ____sys_sendmsg(sock, msg_sys, flags, used_address,",
                        "\t\t\t\tallowed_msghdr_flags);",
                        "\tkfree(iov);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2384,
                    "highlight": 2384
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81863f32"
        },
        "62": {
            "name": "___sys_sendmsg",
            "parent_idx": 61,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=e69ec487b2c7#n2417",
                    "code": [
                        "\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);",
                        "",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2417,
                    "highlight": 2417
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81865fff"
        },
        "61": {
            "name": "__sys_sendmsg(indirect)",
            "parent_idx": 60,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=e69ec487b2c7#n294",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 281,
                    "highlight": 294
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff810027c9"
        },
        "60": {
            "name": "do_syscall_64",
            "parent_idx": 59,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=e69ec487b2c7#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "59": {
            "name": "31_syscall_3",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "121": {
            "name": "+0x3f",
            "parent_idx": 119,
            "source_line": [
                {
                    "file": "net/sched/act_ife.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_ife.c?id=e69ec487b2c7#n412",
                    "code": [
                        "/* under ife->tcf_lock */",
                        "static void _tcf_ife_cleanup(struct tc_action *a)",
                        "{",
                        "\tstruct tcf_ife_info *ife = to_ife(a);",
                        "\tstruct tcf_meta_info *e, *n;",
                        "",
                        "\tlist_for_each_entry_safe(e, n, &ife->metalist, metalist) {",
                        "\t\tlist_del(&e->metalist);",
                        "\t\tif (e->metaval) {",
                        "\t\t\tif (e->ops->release)",
                        "\t\t\t\te->ops->release(e);",
                        "\t\t\telse",
                        "\t\t\t\tkfree(e->metaval);",
                        "\t\t}",
                        "\t\tmodule_put(e->ops->owner);",
                        "\t\tkfree(e);",
                        "\t}",
                        "}"
                    ],
                    "start": 406,
                    "highlight": 412
                },
                {
                    "file": "net/sched/act_ife.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_ife.c?id=e69ec487b2c7#n431",
                    "code": [
                        "\tspin_lock_bh(&ife->tcf_lock);",
                        "\t_tcf_ife_cleanup(a);",
                        "\tspin_unlock_bh(&ife->tcf_lock);",
                        "",
                        "\tp = rcu_dereference_protected(ife->params, 1);",
                        "\tif (p)",
                        "\t\tkfree_rcu(p, rcu);",
                        "}"
                    ],
                    "start": 430,
                    "highlight": 431
                }
            ],
            "ins_idx": 7,
            "addr": "0xffffffff818d373f"
        },
        "91": {
            "name": "+0x0",
            "parent_idx": 90,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=e69ec487b2c7#n3817",
                    "code": [
                        "#ifdef CONFIG_NUMA",
                        "static void *kmalloc_large_node(size_t size, gfp_t flags, int node)",
                        "{",
                        "\tstruct page *page;",
                        "\tvoid *ptr = NULL;",
                        "\tunsigned int order = get_order(size);",
                        "",
                        "\tflags |= __GFP_COMP;",
                        "\tpage = alloc_pages_node(node, flags, order);",
                        "\tif (page) {",
                        "\t\tptr = page_address(page);",
                        "\t\tmod_node_page_state(page_pgdat(page), NR_SLAB_UNRECLAIMABLE,",
                        "\t\t\t\t    1 << order);",
                        "\t}",
                        "",
                        "\treturn kmalloc_large_node_hook(ptr, size, flags);",
                        "}"
                    ],
                    "start": 3809,
                    "highlight": 3817
                }
            ],
            "ins_idx": 14,
            "addr": "0xffffffff811cd220"
        },
        "90": {
            "name": "__kmalloc",
            "parent_idx": 86,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=e69ec487b2c7#n561",
                    "code": [
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 556,
                    "highlight": 561
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=e69ec487b2c7#n670",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 663,
                    "highlight": 670
                },
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n406",
                    "code": [
                        "int tcf_idr_create(struct tc_action_net *tn, u32 index, struct nlattr *est,",
                        "\t\t   struct tc_action **a, const struct tc_action_ops *ops,",
                        "\t\t   int bind, bool cpustats, u32 flags)",
                        "{",
                        "\tstruct tc_action *p = kzalloc(ops->size, GFP_KERNEL);",
                        "\tstruct tcf_idrinfo *idrinfo = tn->idrinfo;",
                        "\tint err = -ENOMEM;",
                        "",
                        "\tif (unlikely(!p))",
                        "\t\treturn -ENOMEM;",
                        "\trefcount_set(&p->tcfa_refcnt, 1);",
                        "\tif (bind)",
                        "\t\tatomic_set(&p->tcfa_bindcnt, 1);",
                        "",
                        "\tif (cpustats) {",
                        "\t\tp->cpu_bstats = netdev_alloc_pcpu_stats(struct gnet_stats_basic_cpu);",
                        "\t\tif (!p->cpu_bstats)",
                        "\t\t\tgoto err1;",
                        "\t\tp->cpu_bstats_hw = netdev_alloc_pcpu_stats(struct gnet_stats_basic_cpu);",
                        "\t\tif (!p->cpu_bstats_hw)",
                        "\t\t\tgoto err2;",
                        "\t\tp->cpu_qstats = alloc_percpu(struct gnet_stats_queue);",
                        "\t\tif (!p->cpu_qstats)",
                        "\t\t\tgoto err3;",
                        "\t}",
                        "\tspin_lock_init(&p->tcfa_lock);",
                        "\tp->tcfa_index = index;",
                        "\tp->tcfa_tm.install = jiffies;",
                        "\tp->tcfa_tm.lastuse = jiffies;",
                        "\tp->tcfa_tm.firstuse = 0;",
                        "\tp->tcfa_flags = flags;",
                        "\tif (est) {",
                        "\t\terr = gen_new_estimator(&p->tcfa_bstats, p->cpu_bstats,",
                        "\t\t\t\t\t&p->tcfa_rate_est,",
                        "\t\t\t\t\t&p->tcfa_lock, NULL, est);",
                        "\t\tif (err)",
                        "\t\t\tgoto err4;",
                        "\t}",
                        "",
                        "\tp->idrinfo = idrinfo;",
                        "\tp->ops = ops;",
                        "\t*a = p;",
                        "\treturn 0;",
                        "err4:",
                        "\tfree_percpu(p->cpu_qstats);",
                        "err3:",
                        "\tfree_percpu(p->cpu_bstats_hw);",
                        "err2:",
                        "\tfree_percpu(p->cpu_bstats);",
                        "err1:",
                        "\tkfree(p);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 402,
                    "highlight": 406
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818d1131"
        },
        "86": {
            "name": "tcf_idr_create",
            "parent_idx": 75,
            "source_line": [
                {
                    "file": "net/sched/act_ife.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_ife.c?id=e69ec487b2c7#n525",
                    "code": [
                        "static int tcf_ife_init(struct net *net, struct nlattr *nla,",
                        "\t\t\tstruct nlattr *est, struct tc_action **a,",
                        "\t\t\tint ovr, int bind, bool rtnl_held,",
                        "\t\t\tstruct tcf_proto *tp, u32 flags,",
                        "\t\t\tstruct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct tc_action_net *tn = net_generic(net, ife_net_id);",
                        "\tstruct nlattr *tb[TCA_IFE_MAX + 1];",
                        "\tstruct nlattr *tb2[IFE_META_MAX + 1];",
                        "\tstruct tcf_chain *goto_ch = NULL;",
                        "\tstruct tcf_ife_params *p;",
                        "\tstruct tcf_ife_info *ife;",
                        "\tu16 ife_type = ETH_P_IFE;",
                        "\tstruct tc_ife *parm;",
                        "\tu8 *daddr = NULL;",
                        "\tu8 *saddr = NULL;",
                        "\tbool exists = false;",
                        "\tint ret = 0;",
                        "\tu32 index;",
                        "\tint err;",
                        "",
                        "\tif (!nla) {",
                        "\t\tNL_SET_ERR_MSG_MOD(extack, \"IFE requires attributes to be passed\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\terr = nla_parse_nested_deprecated(tb, TCA_IFE_MAX, nla, ife_policy,",
                        "\t\t\t\t\t  NULL);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tif (!tb[TCA_IFE_PARMS])",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tparm = nla_data(tb[TCA_IFE_PARMS]);",
                        "",
                        "\t/* IFE_DECODE is 0 and indicates the opposite of IFE_ENCODE because",
                        "\t * they cannot run as the same time. Check on all other values which",
                        "\t * are not supported right now.",
                        "\t */",
                        "\tif (parm->flags & ~IFE_ENCODE)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tp = kzalloc(sizeof(*p), GFP_KERNEL);",
                        "\tif (!p)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tindex = parm->index;",
                        "\terr = tcf_idr_check_alloc(tn, &index, a, bind);",
                        "\tif (err < 0) {",
                        "\t\tkfree(p);",
                        "\t\treturn err;",
                        "\t}",
                        "\texists = err;",
                        "\tif (exists && bind) {",
                        "\t\tkfree(p);",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\tif (!exists) {",
                        "\t\tret = tcf_idr_create(tn, index, est, a, &act_ife_ops,",
                        "\t\t\t\t     bind, true, 0);",
                        "\t\tif (ret) {",
                        "\t\t\ttcf_idr_cleanup(tn, index);",
                        "\t\t\tkfree(p);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t\tret = ACT_P_CREATED;",
                        "\t} else if (!ovr) {",
                        "\t\ttcf_idr_release(*a, bind);",
                        "\t\tkfree(p);",
                        "\t\treturn -EEXIST;",
                        "\t}",
                        "",
                        "\tife = to_ife(*a);",
                        "\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);",
                        "\tif (err < 0)",
                        "\t\tgoto release_idr;",
                        "",
                        "\tp->flags = parm->flags;",
                        "",
                        "\tif (parm->flags & IFE_ENCODE) {",
                        "\t\tif (tb[TCA_IFE_TYPE])",
                        "\t\t\tife_type = nla_get_u16(tb[TCA_IFE_TYPE]);",
                        "\t\tif (tb[TCA_IFE_DMAC])",
                        "\t\t\tdaddr = nla_data(tb[TCA_IFE_DMAC]);",
                        "\t\tif (tb[TCA_IFE_SMAC])",
                        "\t\t\tsaddr = nla_data(tb[TCA_IFE_SMAC]);",
                        "\t}",
                        "",
                        "\tif (parm->flags & IFE_ENCODE) {",
                        "\t\tif (daddr)",
                        "\t\t\tether_addr_copy(p->eth_dst, daddr);",
                        "\t\telse",
                        "\t\t\teth_zero_addr(p->eth_dst);",
                        "",
                        "\t\tif (saddr)",
                        "\t\t\tether_addr_copy(p->eth_src, saddr);",
                        "\t\telse",
                        "\t\t\teth_zero_addr(p->eth_src);",
                        "",
                        "\t\tp->eth_type = ife_type;",
                        "\t}",
                        "",
                        "",
                        "\tif (ret == ACT_P_CREATED)",
                        "\t\tINIT_LIST_HEAD(&ife->metalist);",
                        "",
                        "\tif (tb[TCA_IFE_METALST]) {",
                        "\t\terr = nla_parse_nested_deprecated(tb2, IFE_META_MAX,",
                        "\t\t\t\t\t\t  tb[TCA_IFE_METALST], NULL,",
                        "\t\t\t\t\t\t  NULL);",
                        "\t\tif (err)",
                        "\t\t\tgoto metadata_parse_err;",
                        "\t\terr = populate_metalist(ife, tb2, exists, rtnl_held);",
                        "\t\tif (err)",
                        "\t\t\tgoto metadata_parse_err;",
                        "",
                        "\t} else {",
                        "\t\t/* if no passed metadata allow list or passed allow-all",
                        "\t\t * then here we process by adding as many supported metadatum",
                        "\t\t * as we can. You better have at least one else we are",
                        "\t\t * going to bail out",
                        "\t\t */",
                        "\t\terr = use_all_metadata(ife, exists);",
                        "\t\tif (err)",
                        "\t\t\tgoto metadata_parse_err;",
                        "\t}",
                        "",
                        "\tif (exists)",
                        "\t\tspin_lock_bh(&ife->tcf_lock);",
                        "\t/* protected by tcf_lock when modifying existing action */",
                        "\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);",
                        "\tp = rcu_replace_pointer(ife->params, p, 1);",
                        "",
                        "\tif (exists)",
                        "\t\tspin_unlock_bh(&ife->tcf_lock);",
                        "\tif (goto_ch)",
                        "\t\ttcf_chain_put_by_act(goto_ch);",
                        "\tif (p)",
                        "\t\tkfree_rcu(p, rcu);",
                        "",
                        "\tif (ret == ACT_P_CREATED)",
                        "\t\ttcf_idr_insert(tn, *a);",
                        "",
                        "\treturn ret;",
                        "metadata_parse_err:",
                        "\tif (goto_ch)",
                        "\t\ttcf_chain_put_by_act(goto_ch);",
                        "release_idr:",
                        "\tkfree(p);",
                        "\ttcf_idr_release(*a, bind);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 465,
                    "highlight": 525
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818d4179"
        },
        "120": {
            "name": "+0xb",
            "parent_idx": 119,
            "source_line": [
                {
                    "file": "net/sched/act_ife.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_ife.c?id=e69ec487b2c7#n426",
                    "code": [
                        "static void tcf_ife_cleanup(struct tc_action *a)",
                        "{",
                        "\tstruct tcf_ife_info *ife = to_ife(a);",
                        "\tstruct tcf_ife_params *p;",
                        "",
                        "\tspin_lock_bh(&ife->tcf_lock);",
                        "\t_tcf_ife_cleanup(a);",
                        "\tspin_unlock_bh(&ife->tcf_lock);",
                        "",
                        "\tp = rcu_dereference_protected(ife->params, 1);",
                        "\tif (p)",
                        "\t\tkfree_rcu(p, rcu);",
                        "}"
                    ],
                    "start": 425,
                    "highlight": 426
                }
            ],
            "ins_idx": 13,
            "addr": "0xffffffff818d370b"
        },
        "117": {
            "name": "+0x49",
            "parent_idx": 105,
            "source_line": [
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n135",
                    "code": [
                        "static int __tcf_action_put(struct tc_action *p, bool bind)",
                        "{",
                        "\tstruct tcf_idrinfo *idrinfo = p->idrinfo;",
                        "",
                        "\tif (refcount_dec_and_mutex_lock(&p->tcfa_refcnt, &idrinfo->lock)) {",
                        "\t\tif (bind)",
                        "\t\t\tatomic_dec(&p->tcfa_bindcnt);",
                        "\t\tidr_remove(&idrinfo->action_idr, p->tcfa_index);",
                        "\t\tmutex_unlock(&idrinfo->lock);",
                        "",
                        "\t\ttcf_action_cleanup(p);",
                        "\t\treturn 1;",
                        "\t}",
                        "",
                        "\tif (bind)",
                        "\t\tatomic_dec(&p->tcfa_bindcnt);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 125,
                    "highlight": 135
                }
            ],
            "ins_idx": 20,
            "addr": "0xffffffff818d1489"
        },
        "106": {
            "name": "+0x3",
            "parent_idx": 105,
            "source_line": [
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n126",
                    "code": [
                        "static int __tcf_action_put(struct tc_action *p, bool bind)",
                        "{",
                        "\tstruct tcf_idrinfo *idrinfo = p->idrinfo;",
                        "",
                        "\tif (refcount_dec_and_mutex_lock(&p->tcfa_refcnt, &idrinfo->lock)) {",
                        "\t\tif (bind)",
                        "\t\t\tatomic_dec(&p->tcfa_bindcnt);",
                        "\t\tidr_remove(&idrinfo->action_idr, p->tcfa_index);",
                        "\t\tmutex_unlock(&idrinfo->lock);",
                        "",
                        "\t\ttcf_action_cleanup(p);",
                        "\t\treturn 1;",
                        "\t}",
                        "",
                        "\tif (bind)",
                        "\t\tatomic_dec(&p->tcfa_bindcnt);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 125,
                    "highlight": 126
                }
            ],
            "ins_idx": 46,
            "addr": "0xffffffff818d1443"
        },
        "103": {
            "name": "+0x295",
            "parent_idx": 75,
            "source_line": [
                {
                    "file": "./include/net/act_api.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/act_api.h?id=e69ec487b2c7#n171",
                    "code": [
                        "static inline int tcf_idr_release(struct tc_action *a, bool bind)",
                        "{",
                        "\treturn __tcf_idr_release(a, bind, false);",
                        "}"
                    ],
                    "start": 169,
                    "highlight": 171
                },
                {
                    "file": "net/sched/act_ife.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_ife.c?id=e69ec487b2c7#n616",
                    "code": [
                        "static int tcf_ife_init(struct net *net, struct nlattr *nla,",
                        "\t\t\tstruct nlattr *est, struct tc_action **a,",
                        "\t\t\tint ovr, int bind, bool rtnl_held,",
                        "\t\t\tstruct tcf_proto *tp, u32 flags,",
                        "\t\t\tstruct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct tc_action_net *tn = net_generic(net, ife_net_id);",
                        "\tstruct nlattr *tb[TCA_IFE_MAX + 1];",
                        "\tstruct nlattr *tb2[IFE_META_MAX + 1];",
                        "\tstruct tcf_chain *goto_ch = NULL;",
                        "\tstruct tcf_ife_params *p;",
                        "\tstruct tcf_ife_info *ife;",
                        "\tu16 ife_type = ETH_P_IFE;",
                        "\tstruct tc_ife *parm;",
                        "\tu8 *daddr = NULL;",
                        "\tu8 *saddr = NULL;",
                        "\tbool exists = false;",
                        "\tint ret = 0;",
                        "\tu32 index;",
                        "\tint err;",
                        "",
                        "\tif (!nla) {",
                        "\t\tNL_SET_ERR_MSG_MOD(extack, \"IFE requires attributes to be passed\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\terr = nla_parse_nested_deprecated(tb, TCA_IFE_MAX, nla, ife_policy,",
                        "\t\t\t\t\t  NULL);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tif (!tb[TCA_IFE_PARMS])",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tparm = nla_data(tb[TCA_IFE_PARMS]);",
                        "",
                        "\t/* IFE_DECODE is 0 and indicates the opposite of IFE_ENCODE because",
                        "\t * they cannot run as the same time. Check on all other values which",
                        "\t * are not supported right now.",
                        "\t */",
                        "\tif (parm->flags & ~IFE_ENCODE)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tp = kzalloc(sizeof(*p), GFP_KERNEL);",
                        "\tif (!p)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tindex = parm->index;",
                        "\terr = tcf_idr_check_alloc(tn, &index, a, bind);",
                        "\tif (err < 0) {",
                        "\t\tkfree(p);",
                        "\t\treturn err;",
                        "\t}",
                        "\texists = err;",
                        "\tif (exists && bind) {",
                        "\t\tkfree(p);",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\tif (!exists) {",
                        "\t\tret = tcf_idr_create(tn, index, est, a, &act_ife_ops,",
                        "\t\t\t\t     bind, true, 0);",
                        "\t\tif (ret) {",
                        "\t\t\ttcf_idr_cleanup(tn, index);",
                        "\t\t\tkfree(p);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t\tret = ACT_P_CREATED;",
                        "\t} else if (!ovr) {",
                        "\t\ttcf_idr_release(*a, bind);",
                        "\t\tkfree(p);",
                        "\t\treturn -EEXIST;",
                        "\t}",
                        "",
                        "\tife = to_ife(*a);",
                        "\terr = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);",
                        "\tif (err < 0)",
                        "\t\tgoto release_idr;",
                        "",
                        "\tp->flags = parm->flags;",
                        "",
                        "\tif (parm->flags & IFE_ENCODE) {",
                        "\t\tif (tb[TCA_IFE_TYPE])",
                        "\t\t\tife_type = nla_get_u16(tb[TCA_IFE_TYPE]);",
                        "\t\tif (tb[TCA_IFE_DMAC])",
                        "\t\t\tdaddr = nla_data(tb[TCA_IFE_DMAC]);",
                        "\t\tif (tb[TCA_IFE_SMAC])",
                        "\t\t\tsaddr = nla_data(tb[TCA_IFE_SMAC]);",
                        "\t}",
                        "",
                        "\tif (parm->flags & IFE_ENCODE) {",
                        "\t\tif (daddr)",
                        "\t\t\tether_addr_copy(p->eth_dst, daddr);",
                        "\t\telse",
                        "\t\t\teth_zero_addr(p->eth_dst);",
                        "",
                        "\t\tif (saddr)",
                        "\t\t\tether_addr_copy(p->eth_src, saddr);",
                        "\t\telse",
                        "\t\t\teth_zero_addr(p->eth_src);",
                        "",
                        "\t\tp->eth_type = ife_type;",
                        "\t}",
                        "",
                        "",
                        "\tif (ret == ACT_P_CREATED)",
                        "\t\tINIT_LIST_HEAD(&ife->metalist);",
                        "",
                        "\tif (tb[TCA_IFE_METALST]) {",
                        "\t\terr = nla_parse_nested_deprecated(tb2, IFE_META_MAX,",
                        "\t\t\t\t\t\t  tb[TCA_IFE_METALST], NULL,",
                        "\t\t\t\t\t\t  NULL);",
                        "\t\tif (err)",
                        "\t\t\tgoto metadata_parse_err;",
                        "\t\terr = populate_metalist(ife, tb2, exists, rtnl_held);",
                        "\t\tif (err)",
                        "\t\t\tgoto metadata_parse_err;",
                        "",
                        "\t} else {",
                        "\t\t/* if no passed metadata allow list or passed allow-all",
                        "\t\t * then here we process by adding as many supported metadatum",
                        "\t\t * as we can. You better have at least one else we are",
                        "\t\t * going to bail out",
                        "\t\t */",
                        "\t\terr = use_all_metadata(ife, exists);",
                        "\t\tif (err)",
                        "\t\t\tgoto metadata_parse_err;",
                        "\t}",
                        "",
                        "\tif (exists)",
                        "\t\tspin_lock_bh(&ife->tcf_lock);",
                        "\t/* protected by tcf_lock when modifying existing action */",
                        "\tgoto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);",
                        "\tp = rcu_replace_pointer(ife->params, p, 1);",
                        "",
                        "\tif (exists)",
                        "\t\tspin_unlock_bh(&ife->tcf_lock);",
                        "\tif (goto_ch)",
                        "\t\ttcf_chain_put_by_act(goto_ch);",
                        "\tif (p)",
                        "\t\tkfree_rcu(p, rcu);",
                        "",
                        "\tif (ret == ACT_P_CREATED)",
                        "\t\ttcf_idr_insert(tn, *a);",
                        "",
                        "\treturn ret;",
                        "metadata_parse_err:",
                        "\tif (goto_ch)",
                        "\t\ttcf_chain_put_by_act(goto_ch);",
                        "release_idr:",
                        "\tkfree(p);",
                        "\ttcf_idr_release(*a, bind);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 465,
                    "highlight": 616
                }
            ],
            "ins_idx": 50,
            "addr": "0xffffffff818d4125"
        },
        "95": {
            "name": "+0xe2",
            "parent_idx": 86,
            "source_line": [
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n443",
                    "code": [
                        "int tcf_idr_create(struct tc_action_net *tn, u32 index, struct nlattr *est,",
                        "\t\t   struct tc_action **a, const struct tc_action_ops *ops,",
                        "\t\t   int bind, bool cpustats, u32 flags)",
                        "{",
                        "\tstruct tc_action *p = kzalloc(ops->size, GFP_KERNEL);",
                        "\tstruct tcf_idrinfo *idrinfo = tn->idrinfo;",
                        "\tint err = -ENOMEM;",
                        "",
                        "\tif (unlikely(!p))",
                        "\t\treturn -ENOMEM;",
                        "\trefcount_set(&p->tcfa_refcnt, 1);",
                        "\tif (bind)",
                        "\t\tatomic_set(&p->tcfa_bindcnt, 1);",
                        "",
                        "\tif (cpustats) {",
                        "\t\tp->cpu_bstats = netdev_alloc_pcpu_stats(struct gnet_stats_basic_cpu);",
                        "\t\tif (!p->cpu_bstats)",
                        "\t\t\tgoto err1;",
                        "\t\tp->cpu_bstats_hw = netdev_alloc_pcpu_stats(struct gnet_stats_basic_cpu);",
                        "\t\tif (!p->cpu_bstats_hw)",
                        "\t\t\tgoto err2;",
                        "\t\tp->cpu_qstats = alloc_percpu(struct gnet_stats_queue);",
                        "\t\tif (!p->cpu_qstats)",
                        "\t\t\tgoto err3;",
                        "\t}",
                        "\tspin_lock_init(&p->tcfa_lock);",
                        "\tp->tcfa_index = index;",
                        "\tp->tcfa_tm.install = jiffies;",
                        "\tp->tcfa_tm.lastuse = jiffies;",
                        "\tp->tcfa_tm.firstuse = 0;",
                        "\tp->tcfa_flags = flags;",
                        "\tif (est) {",
                        "\t\terr = gen_new_estimator(&p->tcfa_bstats, p->cpu_bstats,",
                        "\t\t\t\t\t&p->tcfa_rate_est,",
                        "\t\t\t\t\t&p->tcfa_lock, NULL, est);",
                        "\t\tif (err)",
                        "\t\t\tgoto err4;",
                        "\t}",
                        "",
                        "\tp->idrinfo = idrinfo;",
                        "\tp->ops = ops;",
                        "\t*a = p;",
                        "\treturn 0;",
                        "err4:",
                        "\tfree_percpu(p->cpu_qstats);",
                        "err3:",
                        "\tfree_percpu(p->cpu_bstats_hw);",
                        "err2:",
                        "\tfree_percpu(p->cpu_bstats);",
                        "err1:",
                        "\tkfree(p);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 402,
                    "highlight": 443
                }
            ],
            "ins_idx": 56,
            "addr": "0xffffffff818d11e2"
        },
        "92": {
            "name": "+0x36",
            "parent_idx": 86,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=e69ec487b2c7#n561",
                    "code": [
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 556,
                    "highlight": 561
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=e69ec487b2c7#n670",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 663,
                    "highlight": 670
                },
                {
                    "file": "net/sched/act_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/act_api.c?id=e69ec487b2c7#n406",
                    "code": [
                        "int tcf_idr_create(struct tc_action_net *tn, u32 index, struct nlattr *est,",
                        "\t\t   struct tc_action **a, const struct tc_action_ops *ops,",
                        "\t\t   int bind, bool cpustats, u32 flags)",
                        "{",
                        "\tstruct tc_action *p = kzalloc(ops->size, GFP_KERNEL);",
                        "\tstruct tcf_idrinfo *idrinfo = tn->idrinfo;",
                        "\tint err = -ENOMEM;",
                        "",
                        "\tif (unlikely(!p))",
                        "\t\treturn -ENOMEM;",
                        "\trefcount_set(&p->tcfa_refcnt, 1);",
                        "\tif (bind)",
                        "\t\tatomic_set(&p->tcfa_bindcnt, 1);",
                        "",
                        "\tif (cpustats) {",
                        "\t\tp->cpu_bstats = netdev_alloc_pcpu_stats(struct gnet_stats_basic_cpu);",
                        "\t\tif (!p->cpu_bstats)",
                        "\t\t\tgoto err1;",
                        "\t\tp->cpu_bstats_hw = netdev_alloc_pcpu_stats(struct gnet_stats_basic_cpu);",
                        "\t\tif (!p->cpu_bstats_hw)",
                        "\t\t\tgoto err2;",
                        "\t\tp->cpu_qstats = alloc_percpu(struct gnet_stats_queue);",
                        "\t\tif (!p->cpu_qstats)",
                        "\t\t\tgoto err3;",
                        "\t}",
                        "\tspin_lock_init(&p->tcfa_lock);",
                        "\tp->tcfa_index = index;",
                        "\tp->tcfa_tm.install = jiffies;",
                        "\tp->tcfa_tm.lastuse = jiffies;",
                        "\tp->tcfa_tm.firstuse = 0;",
                        "\tp->tcfa_flags = flags;",
                        "\tif (est) {",
                        "\t\terr = gen_new_estimator(&p->tcfa_bstats, p->cpu_bstats,",
                        "\t\t\t\t\t&p->tcfa_rate_est,",
                        "\t\t\t\t\t&p->tcfa_lock, NULL, est);",
                        "\t\tif (err)",
                        "\t\t\tgoto err4;",
                        "\t}",
                        "",
                        "\tp->idrinfo = idrinfo;",
                        "\tp->ops = ops;",
                        "\t*a = p;",
                        "\treturn 0;",
                        "err4:",
                        "\tfree_percpu(p->cpu_qstats);",
                        "err3:",
                        "\tfree_percpu(p->cpu_bstats_hw);",
                        "err2:",
                        "\tfree_percpu(p->cpu_bstats);",
                        "err1:",
                        "\tkfree(p);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 402,
                    "highlight": 406
                }
            ],
            "ins_idx": 60,
            "addr": "0xffffffff818d1136"
        }
    },
    "ins": {
        "2": {
            "name": "mov rax, qword ptr [rdx]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x0",
            "call_idx": 122,
            "inputs": [
                169,
                170
            ],
            "outputs": [
                171
            ]
        },
        "7": {
            "name": "mov rdx, qword ptr [r14 + 0xc8]",
            "desc": "Heap Use Before Initialization",
            "call_idx": 121,
            "inputs": [
                166,
                167
            ],
            "outputs": [
                168
            ]
        },
        "14": {
            "name": "push r15",
            "desc": "Source of base address MEMALLOC 0x0",
            "call_idx": 91,
            "inputs": [],
            "outputs": [
                121
            ]
        },
        "13": {
            "name": "mov r14, rdi",
            "desc": "",
            "call_idx": 120,
            "inputs": [
                164
            ],
            "outputs": [
                165
            ]
        },
        "20": {
            "name": "mov rdi, rbp",
            "desc": "",
            "call_idx": 117,
            "inputs": [
                162
            ],
            "outputs": [
                163
            ]
        },
        "46": {
            "name": "mov rbp, rdi",
            "desc": "",
            "call_idx": 106,
            "inputs": [
                144
            ],
            "outputs": [
                145
            ]
        },
        "50": {
            "name": "mov rdi, qword ptr [rax]",
            "desc": "",
            "call_idx": 103,
            "inputs": [
                141,
                142
            ],
            "outputs": [
                143
            ]
        },
        "56": {
            "name": "mov qword ptr [rax], r14",
            "desc": "",
            "call_idx": 95,
            "inputs": [
                128,
                129
            ],
            "outputs": [
                130
            ]
        },
        "60": {
            "name": "mov r14, rax",
            "desc": "",
            "call_idx": 92,
            "inputs": [
                122
            ],
            "outputs": [
                123
            ]
        }
    },
    "data": {
        "169": {
            "name": "RDX",
            "ins_idx": 2,
            "value": "0x0",
            "sources": []
        },
        "170": {
            "name": "[0x0]",
            "ins_idx": 2,
            "value": "0x0",
            "sources": []
        },
        "171": {
            "name": "RAX",
            "ins_idx": 2,
            "value": "0x0",
            "sources": []
        },
        "166": {
            "name": "R14",
            "ins_idx": 7,
            "value": "0xffff888235336800",
            "sources": []
        },
        "167": {
            "name": "[0xffff8882353368c8]",
            "ins_idx": 7,
            "value": "0x0",
            "sources": []
        },
        "168": {
            "name": "RDX",
            "ins_idx": 7,
            "value": "0x0",
            "sources": [
                169
            ]
        },
        "121": {
            "name": "RAX",
            "ins_idx": 14,
            "value": "0xffff888235336800",
            "sources": [
                122
            ]
        },
        "164": {
            "name": "RDI",
            "ins_idx": 13,
            "value": "0xffff888235336800",
            "sources": []
        },
        "165": {
            "name": "R14",
            "ins_idx": 13,
            "value": "0xffff888235336800",
            "sources": [
                166
            ]
        },
        "162": {
            "name": "RBP",
            "ins_idx": 20,
            "value": "0xffff888235336800",
            "sources": []
        },
        "163": {
            "name": "RDI",
            "ins_idx": 20,
            "value": "0xffff888235336800",
            "sources": [
                164
            ]
        },
        "144": {
            "name": "RDI",
            "ins_idx": 46,
            "value": "0xffff888235336800",
            "sources": []
        },
        "145": {
            "name": "RBP",
            "ins_idx": 46,
            "value": "0xffff888235336800",
            "sources": [
                162
            ]
        },
        "141": {
            "name": "RAX",
            "ins_idx": 50,
            "value": "0xffffc900002c3740",
            "sources": []
        },
        "142": {
            "name": "[0xffffc900002c3740]",
            "ins_idx": 50,
            "value": "0xffff888235336800",
            "sources": []
        },
        "143": {
            "name": "RDI",
            "ins_idx": 50,
            "value": "0xffff888235336800",
            "sources": [
                144
            ]
        },
        "128": {
            "name": "R14",
            "ins_idx": 56,
            "value": "0xffff888235336800",
            "sources": []
        },
        "129": {
            "name": "RAX",
            "ins_idx": 56,
            "value": "0xffffc900002c3740",
            "sources": []
        },
        "130": {
            "name": "[0xffffc900002c3740]",
            "ins_idx": 56,
            "value": "0xffff888235336800",
            "sources": [
                142
            ]
        },
        "122": {
            "name": "RAX",
            "ins_idx": 60,
            "value": "0xffff888235336800",
            "sources": []
        },
        "123": {
            "name": "R14",
            "ins_idx": 60,
            "value": "0xffff888235336800",
            "sources": [
                128
            ]
        }
    },
    "chain": {
        "2": [
            7
        ],
        "7": [
            14,
            13
        ],
        "13": [
            20
        ],
        "20": [
            46
        ],
        "46": [
            50
        ],
        "50": [
            56
        ],
        "56": [
            60
        ],
        "60": [
            14
        ]
    }
}