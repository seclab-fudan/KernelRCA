{
    "report": "https://syzkaller.appspot.com/bug?id=6922c8c31f1fdd120d1cef3f58b319b6dd1d8c00",
    "title": "general protection fault in qp_release_pages",
    "call": {
        "163": {
            "name": "+0x1d",
            "parent_idx": 158,
            "source_line": [
                {
                    "file": "./include/linux/page-flags.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/page-flags.h?id=3dd0130f2430#n182",
                    "code": [
                        "static inline struct page *compound_head(struct page *page)",
                        "{",
                        "\tunsigned long head = READ_ONCE(page->compound_head);",
                        "",
                        "\tif (unlikely(head & 1))",
                        "\t\treturn (struct page *) (head - 1);",
                        "\treturn page;",
                        "}"
                    ],
                    "start": 180,
                    "highlight": 182
                },
                {
                    "file": "./include/linux/mm.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/mm.h?id=3dd0130f2430#n1172",
                    "code": [
                        "static inline void put_page(struct page *page)",
                        "{",
                        "\tpage = compound_head(page);",
                        "",
                        "\t/*",
                        "\t * For devmap managed pages we need to catch refcount transition from",
                        "\t * 2 to 1, when refcount reach one it means the page is free and we",
                        "\t * need to inform the device driver through callback. See",
                        "\t * include/linux/memremap.h and HMM for details.",
                        "\t */",
                        "\tif (page_is_devmap_managed(page)) {",
                        "\t\tput_devmap_managed_page(page);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\tif (put_page_testzero(page))",
                        "\t\t__put_page(page);",
                        "}"
                    ],
                    "start": 1170,
                    "highlight": 1172
                },
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n635",
                    "code": [
                        "/*",
                        " * Helper function to release pages in the PageStoreAttachInfo",
                        " * previously obtained using get_user_pages.",
                        " */",
                        "static void qp_release_pages(struct page **pages,",
                        "\t\t\t     u64 num_pages, bool dirty)",
                        "{",
                        "\tint i;",
                        "",
                        "\tfor (i = 0; i < num_pages; i++) {",
                        "\t\tif (dirty)",
                        "\t\t\tset_page_dirty(pages[i]);",
                        "",
                        "\t\tput_page(pages[i]);",
                        "\t\tpages[i] = NULL;",
                        "\t}",
                        "}"
                    ],
                    "start": 622,
                    "highlight": 635
                }
            ],
            "ins_idx": 1,
            "addr": "0xffffffff816b57fd"
        },
        "158": {
            "name": "qp_release_pages",
            "parent_idx": 149,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n660",
                    "code": [
                        "/*",
                        " * Lock the user pages referenced by the {produce,consume}Buffer",
                        " * struct into memory and populate the {produce,consume}Pages",
                        " * arrays in the attach structure with them.",
                        " */",
                        "static int qp_host_get_user_memory(u64 produce_uva,",
                        "\t\t\t\t   u64 consume_uva,",
                        "\t\t\t\t   struct vmci_queue *produce_q,",
                        "\t\t\t\t   struct vmci_queue *consume_q)",
                        "{",
                        "\tint retval;",
                        "\tint err = VMCI_SUCCESS;",
                        "",
                        "\tretval = get_user_pages_fast((uintptr_t) produce_uva,",
                        "\t\t\t\t     produce_q->kernel_if->num_pages,",
                        "\t\t\t\t     FOLL_WRITE,",
                        "\t\t\t\t     produce_q->kernel_if->u.h.header_page);",
                        "\tif (retval < (int)produce_q->kernel_if->num_pages) {",
                        "\t\tpr_debug(\"get_user_pages_fast(produce) failed (retval=%d)\",",
                        "\t\t\tretval);",
                        "\t\tqp_release_pages(produce_q->kernel_if->u.h.header_page,",
                        "\t\t\t\t retval, false);",
                        "\t\terr = VMCI_ERROR_NO_MEM;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tretval = get_user_pages_fast((uintptr_t) consume_uva,",
                        "\t\t\t\t     consume_q->kernel_if->num_pages,",
                        "\t\t\t\t     FOLL_WRITE,",
                        "\t\t\t\t     consume_q->kernel_if->u.h.header_page);",
                        "\tif (retval < (int)consume_q->kernel_if->num_pages) {",
                        "\t\tpr_debug(\"get_user_pages_fast(consume) failed (retval=%d)\",",
                        "\t\t\tretval);",
                        "\t\tqp_release_pages(consume_q->kernel_if->u.h.header_page,",
                        "\t\t\t\t retval, false);",
                        "\t\tqp_release_pages(produce_q->kernel_if->u.h.header_page,",
                        "\t\t\t\t produce_q->kernel_if->num_pages, false);",
                        "\t\terr = VMCI_ERROR_NO_MEM;",
                        "\t}",
                        "",
                        " out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 640,
                    "highlight": 660
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816b58ae"
        },
        "149": {
            "name": "qp_host_get_user_memory",
            "parent_idx": 129,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n704",
                    "code": [
                        "/*",
                        " * Registers the specification of the user pages used for backing a queue",
                        " * pair. Enough information to map in pages is stored in the OS specific",
                        " * part of the struct vmci_queue structure.",
                        " */",
                        "static int qp_host_register_user_memory(struct vmci_qp_page_store *page_store,",
                        "\t\t\t\t\tstruct vmci_queue *produce_q,",
                        "\t\t\t\t\tstruct vmci_queue *consume_q)",
                        "{",
                        "\tu64 produce_uva;",
                        "\tu64 consume_uva;",
                        "",
                        "\t/*",
                        "\t * The new style and the old style mapping only differs in",
                        "\t * that we either get a single or two UVAs, so we split the",
                        "\t * single UVA range at the appropriate spot.",
                        "\t */",
                        "\tproduce_uva = page_store->pages;",
                        "\tconsume_uva = page_store->pages +",
                        "\t    produce_q->kernel_if->num_pages * PAGE_SIZE;",
                        "\treturn qp_host_get_user_memory(produce_uva, consume_uva, produce_q,",
                        "\t\t\t\t       consume_q);",
                        "}"
                    ],
                    "start": 684,
                    "highlight": 704
                },
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n1383",
                    "code": [
                        "/*",
                        " * The first endpoint issuing a queue pair allocation will create the state",
                        " * of the queue pair in the queue pair broker.",
                        " *",
                        " * If the creator is a guest, it will associate a VMX virtual address range",
                        " * with the queue pair as specified by the page_store. For compatibility with",
                        " * older VMX'en, that would use a separate step to set the VMX virtual",
                        " * address range, the virtual address range can be registered later using",
                        " * vmci_qp_broker_set_page_store. In that case, a page_store of NULL should be",
                        " * used.",
                        " *",
                        " * If the creator is the host, a page_store of NULL should be used as well,",
                        " * since the host is not able to supply a page store for the queue pair.",
                        " *",
                        " * For older VMX and host callers, the queue pair will be created in the",
                        " * VMCIQPB_CREATED_NO_MEM state, and for current VMX callers, it will be",
                        " * created in VMCOQPB_CREATED_MEM state.",
                        " */",
                        "static int qp_broker_create(struct vmci_handle handle,",
                        "\t\t\t    u32 peer,",
                        "\t\t\t    u32 flags,",
                        "\t\t\t    u32 priv_flags,",
                        "\t\t\t    u64 produce_size,",
                        "\t\t\t    u64 consume_size,",
                        "\t\t\t    struct vmci_qp_page_store *page_store,",
                        "\t\t\t    struct vmci_ctx *context,",
                        "\t\t\t    vmci_event_release_cb wakeup_cb,",
                        "\t\t\t    void *client_data, struct qp_broker_entry **ent)",
                        "{",
                        "\tstruct qp_broker_entry *entry = NULL;",
                        "\tconst u32 context_id = vmci_ctx_get_id(context);",
                        "\tbool is_local = flags & VMCI_QPFLAG_LOCAL;",
                        "\tint result;",
                        "\tu64 guest_produce_size;",
                        "\tu64 guest_consume_size;",
                        "",
                        "\t/* Do not create if the caller asked not to. */",
                        "\tif (flags & VMCI_QPFLAG_ATTACH_ONLY)",
                        "\t\treturn VMCI_ERROR_NOT_FOUND;",
                        "",
                        "\t/*",
                        "\t * Creator's context ID should match handle's context ID or the creator",
                        "\t * must allow the context in handle's context ID as the \"peer\".",
                        "\t */",
                        "\tif (handle.context != context_id && handle.context != peer)",
                        "\t\treturn VMCI_ERROR_NO_ACCESS;",
                        "",
                        "\tif (VMCI_CONTEXT_IS_VM(context_id) && VMCI_CONTEXT_IS_VM(peer))",
                        "\t\treturn VMCI_ERROR_DST_UNREACHABLE;",
                        "",
                        "\t/*",
                        "\t * Creator's context ID for local queue pairs should match the",
                        "\t * peer, if a peer is specified.",
                        "\t */",
                        "\tif (is_local && peer != VMCI_INVALID_ID && context_id != peer)",
                        "\t\treturn VMCI_ERROR_NO_ACCESS;",
                        "",
                        "\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);",
                        "\tif (!entry)",
                        "\t\treturn VMCI_ERROR_NO_MEM;",
                        "",
                        "\tif (vmci_ctx_get_id(context) == VMCI_HOST_CONTEXT_ID && !is_local) {",
                        "\t\t/*",
                        "\t\t * The queue pair broker entry stores values from the guest",
                        "\t\t * point of view, so a creating host side endpoint should swap",
                        "\t\t * produce and consume values -- unless it is a local queue",
                        "\t\t * pair, in which case no swapping is necessary, since the local",
                        "\t\t * attacher will swap queues.",
                        "\t\t */",
                        "",
                        "\t\tguest_produce_size = consume_size;",
                        "\t\tguest_consume_size = produce_size;",
                        "\t} else {",
                        "\t\tguest_produce_size = produce_size;",
                        "\t\tguest_consume_size = consume_size;",
                        "\t}",
                        "",
                        "\tentry->qp.handle = handle;",
                        "\tentry->qp.peer = peer;",
                        "\tentry->qp.flags = flags;",
                        "\tentry->qp.produce_size = guest_produce_size;",
                        "\tentry->qp.consume_size = guest_consume_size;",
                        "\tentry->qp.ref_count = 1;",
                        "\tentry->create_id = context_id;",
                        "\tentry->attach_id = VMCI_INVALID_ID;",
                        "\tentry->state = VMCIQPB_NEW;",
                        "\tentry->require_trusted_attach =",
                        "\t    !!(context->priv_flags & VMCI_PRIVILEGE_FLAG_RESTRICTED);",
                        "\tentry->created_by_trusted =",
                        "\t    !!(priv_flags & VMCI_PRIVILEGE_FLAG_TRUSTED);",
                        "\tentry->vmci_page_files = false;",
                        "\tentry->wakeup_cb = wakeup_cb;",
                        "\tentry->client_data = client_data;",
                        "\tentry->produce_q = qp_host_alloc_queue(guest_produce_size);",
                        "\tif (entry->produce_q == NULL) {",
                        "\t\tresult = VMCI_ERROR_NO_MEM;",
                        "\t\tgoto error;",
                        "\t}",
                        "\tentry->consume_q = qp_host_alloc_queue(guest_consume_size);",
                        "\tif (entry->consume_q == NULL) {",
                        "\t\tresult = VMCI_ERROR_NO_MEM;",
                        "\t\tgoto error;",
                        "\t}",
                        "",
                        "\tqp_init_queue_mutex(entry->produce_q, entry->consume_q);",
                        "",
                        "\tINIT_LIST_HEAD(&entry->qp.list_item);",
                        "",
                        "\tif (is_local) {",
                        "\t\tu8 *tmp;",
                        "",
                        "\t\tentry->local_mem = kcalloc(QPE_NUM_PAGES(entry->qp),",
                        "\t\t\t\t\t   PAGE_SIZE, GFP_KERNEL);",
                        "\t\tif (entry->local_mem == NULL) {",
                        "\t\t\tresult = VMCI_ERROR_NO_MEM;",
                        "\t\t\tgoto error;",
                        "\t\t}",
                        "\t\tentry->state = VMCIQPB_CREATED_MEM;",
                        "\t\tentry->produce_q->q_header = entry->local_mem;",
                        "\t\ttmp = (u8 *)entry->local_mem + PAGE_SIZE *",
                        "\t\t    (DIV_ROUND_UP(entry->qp.produce_size, PAGE_SIZE) + 1);",
                        "\t\tentry->consume_q->q_header = (struct vmci_queue_header *)tmp;",
                        "\t} else if (page_store) {",
                        "\t\t/*",
                        "\t\t * The VMX already initialized the queue pair headers, so no",
                        "\t\t * need for the kernel side to do that.",
                        "\t\t */",
                        "\t\tresult = qp_host_register_user_memory(page_store,",
                        "\t\t\t\t\t\t      entry->produce_q,",
                        "\t\t\t\t\t\t      entry->consume_q);",
                        "\t\tif (result < VMCI_SUCCESS)",
                        "\t\t\tgoto error;",
                        "",
                        "\t\tentry->state = VMCIQPB_CREATED_MEM;",
                        "\t} else {",
                        "\t\t/*",
                        "\t\t * A create without a page_store may be either a host",
                        "\t\t * side create (in which case we are waiting for the",
                        "\t\t * guest side to supply the memory) or an old style",
                        "\t\t * queue pair create (in which case we will expect a",
                        "\t\t * set page store call as the next step).",
                        "\t\t */",
                        "\t\tentry->state = VMCIQPB_CREATED_NO_MEM;",
                        "\t}",
                        "",
                        "\tqp_list_add_entry(&qp_broker_list, &entry->qp);",
                        "\tif (ent != NULL)",
                        "\t\t*ent = entry;",
                        "",
                        "\t/* Add to resource obj */",
                        "\tresult = vmci_resource_add(&entry->resource,",
                        "\t\t\t\t   VMCI_RESOURCE_TYPE_QPAIR_HOST,",
                        "\t\t\t\t   handle);",
                        "\tif (result != VMCI_SUCCESS) {",
                        "\t\tpr_warn(\"Failed to add new resource (handle=0x%x:0x%x), error: %d\",",
                        "\t\t\thandle.context, handle.resource, result);",
                        "\t\tgoto error;",
                        "\t}",
                        "",
                        "\tentry->qp.handle = vmci_resource_handle(&entry->resource);",
                        "\tif (is_local) {",
                        "\t\tvmci_q_header_init(entry->produce_q->q_header,",
                        "\t\t\t\t   entry->qp.handle);",
                        "\t\tvmci_q_header_init(entry->consume_q->q_header,",
                        "\t\t\t\t   entry->qp.handle);",
                        "\t}",
                        "",
                        "\tvmci_ctx_qp_create(context, entry->qp.handle);",
                        "",
                        "\treturn VMCI_SUCCESS;",
                        "",
                        " error:",
                        "\tif (entry != NULL) {",
                        "\t\tqp_host_free_queue(entry->produce_q, guest_produce_size);",
                        "\t\tqp_host_free_queue(entry->consume_q, guest_consume_size);",
                        "\t\tkfree(entry);",
                        "\t}",
                        "",
                        "\treturn result;",
                        "}"
                    ],
                    "start": 1256,
                    "highlight": 1383
                },
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n1737",
                    "code": [
                        "/*",
                        " * queue_pair_Alloc for use when setting up queue pair endpoints",
                        " * on the host.",
                        " */",
                        "static int qp_broker_alloc(struct vmci_handle handle,",
                        "\t\t\t   u32 peer,",
                        "\t\t\t   u32 flags,",
                        "\t\t\t   u32 priv_flags,",
                        "\t\t\t   u64 produce_size,",
                        "\t\t\t   u64 consume_size,",
                        "\t\t\t   struct vmci_qp_page_store *page_store,",
                        "\t\t\t   struct vmci_ctx *context,",
                        "\t\t\t   vmci_event_release_cb wakeup_cb,",
                        "\t\t\t   void *client_data,",
                        "\t\t\t   struct qp_broker_entry **ent,",
                        "\t\t\t   bool *swap)",
                        "{",
                        "\tconst u32 context_id = vmci_ctx_get_id(context);",
                        "\tbool create;",
                        "\tstruct qp_broker_entry *entry = NULL;",
                        "\tbool is_local = flags & VMCI_QPFLAG_LOCAL;",
                        "\tint result;",
                        "",
                        "\tif (vmci_handle_is_invalid(handle) ||",
                        "\t    (flags & ~VMCI_QP_ALL_FLAGS) || is_local ||",
                        "\t    !(produce_size || consume_size) ||",
                        "\t    !context || context_id == VMCI_INVALID_ID ||",
                        "\t    handle.context == VMCI_INVALID_ID) {",
                        "\t\treturn VMCI_ERROR_INVALID_ARGS;",
                        "\t}",
                        "",
                        "\tif (page_store && !VMCI_QP_PAGESTORE_IS_WELLFORMED(page_store))",
                        "\t\treturn VMCI_ERROR_INVALID_ARGS;",
                        "",
                        "\t/*",
                        "\t * In the initial argument check, we ensure that non-vmkernel hosts",
                        "\t * are not allowed to create local queue pairs.",
                        "\t */",
                        "",
                        "\tmutex_lock(&qp_broker_list.mutex);",
                        "",
                        "\tif (!is_local && vmci_ctx_qp_exists(context, handle)) {",
                        "\t\tpr_devel(\"Context (ID=0x%x) already attached to queue pair (handle=0x%x:0x%x)\\n\",",
                        "\t\t\t context_id, handle.context, handle.resource);",
                        "\t\tmutex_unlock(&qp_broker_list.mutex);",
                        "\t\treturn VMCI_ERROR_ALREADY_EXISTS;",
                        "\t}",
                        "",
                        "\tif (handle.resource != VMCI_INVALID_ID)",
                        "\t\tentry = qp_broker_handle_to_entry(handle);",
                        "",
                        "\tif (!entry) {",
                        "\t\tcreate = true;",
                        "\t\tresult =",
                        "\t\t    qp_broker_create(handle, peer, flags, priv_flags,",
                        "\t\t\t\t     produce_size, consume_size, page_store,",
                        "\t\t\t\t     context, wakeup_cb, client_data, ent);",
                        "\t} else {",
                        "\t\tcreate = false;",
                        "\t\tresult =",
                        "\t\t    qp_broker_attach(entry, peer, flags, priv_flags,",
                        "\t\t\t\t     produce_size, consume_size, page_store,",
                        "\t\t\t\t     context, wakeup_cb, client_data, ent);",
                        "\t}",
                        "",
                        "\tmutex_unlock(&qp_broker_list.mutex);",
                        "",
                        "\tif (swap)",
                        "\t\t*swap = (context_id == VMCI_HOST_CONTEXT_ID) &&",
                        "\t\t    !(create && is_local);",
                        "",
                        "\treturn result;",
                        "}"
                    ],
                    "start": 1683,
                    "highlight": 1737
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816b7320"
        },
        "129": {
            "name": "qp_broker_alloc",
            "parent_idx": 128,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n1930",
                    "code": [
                        "/*",
                        " * Requests that a queue pair be allocated with the VMCI queue",
                        " * pair broker. Allocates a queue pair entry if one does not",
                        " * exist. Attaches to one if it exists, and retrieves the page",
                        " * files backing that queue_pair.  Assumes that the queue pair",
                        " * broker lock is held.",
                        " */",
                        "int vmci_qp_broker_alloc(struct vmci_handle handle,",
                        "\t\t\t u32 peer,",
                        "\t\t\t u32 flags,",
                        "\t\t\t u32 priv_flags,",
                        "\t\t\t u64 produce_size,",
                        "\t\t\t u64 consume_size,",
                        "\t\t\t struct vmci_qp_page_store *page_store,",
                        "\t\t\t struct vmci_ctx *context)",
                        "{",
                        "\treturn qp_broker_alloc(handle, peer, flags, priv_flags,",
                        "\t\t\t       produce_size, consume_size,",
                        "\t\t\t       page_store, context, NULL, NULL, NULL, NULL);",
                        "}"
                    ],
                    "start": 1914,
                    "highlight": 1930
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816b8190"
        },
        "128": {
            "name": "vmci_qp_broker_alloc",
            "parent_idx": 115,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_host.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_host.c?id=3dd0130f2430#n488",
                    "code": [
                        "static int vmci_host_do_alloc_queuepair(struct vmci_host_dev *vmci_host_dev,",
                        "\t\t\t\t\tconst char *ioctl_name,",
                        "\t\t\t\t\tvoid __user *uptr)",
                        "{",
                        "\tstruct vmci_handle handle;",
                        "\tint vmci_status;",
                        "\tint __user *retptr;",
                        "",
                        "\tif (vmci_host_dev->ct_type != VMCIOBJ_CONTEXT) {",
                        "\t\tvmci_ioctl_err(\"only valid for contexts\\n\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (vmci_host_dev->user_version < VMCI_VERSION_NOVMVM) {",
                        "\t\tstruct vmci_qp_alloc_info_vmvm alloc_info;",
                        "\t\tstruct vmci_qp_alloc_info_vmvm __user *info = uptr;",
                        "",
                        "\t\tif (copy_from_user(&alloc_info, uptr, sizeof(alloc_info)))",
                        "\t\t\treturn -EFAULT;",
                        "",
                        "\t\thandle = alloc_info.handle;",
                        "\t\tretptr = &info->result;",
                        "",
                        "\t\tvmci_status = vmci_qp_broker_alloc(alloc_info.handle,",
                        "\t\t\t\t\t\talloc_info.peer,",
                        "\t\t\t\t\t\talloc_info.flags,",
                        "\t\t\t\t\t\tVMCI_NO_PRIVILEGE_FLAGS,",
                        "\t\t\t\t\t\talloc_info.produce_size,",
                        "\t\t\t\t\t\talloc_info.consume_size,",
                        "\t\t\t\t\t\tNULL,",
                        "\t\t\t\t\t\tvmci_host_dev->context);",
                        "",
                        "\t\tif (vmci_status == VMCI_SUCCESS)",
                        "\t\t\tvmci_status = VMCI_SUCCESS_QUEUEPAIR_CREATE;",
                        "\t} else {",
                        "\t\tstruct vmci_qp_alloc_info alloc_info;",
                        "\t\tstruct vmci_qp_alloc_info __user *info = uptr;",
                        "\t\tstruct vmci_qp_page_store page_store;",
                        "",
                        "\t\tif (copy_from_user(&alloc_info, uptr, sizeof(alloc_info)))",
                        "\t\t\treturn -EFAULT;",
                        "",
                        "\t\thandle = alloc_info.handle;",
                        "\t\tretptr = &info->result;",
                        "",
                        "\t\tpage_store.pages = alloc_info.ppn_va;",
                        "\t\tpage_store.len = alloc_info.num_ppns;",
                        "",
                        "\t\tvmci_status = vmci_qp_broker_alloc(alloc_info.handle,",
                        "\t\t\t\t\t\talloc_info.peer,",
                        "\t\t\t\t\t\talloc_info.flags,",
                        "\t\t\t\t\t\tVMCI_NO_PRIVILEGE_FLAGS,",
                        "\t\t\t\t\t\talloc_info.produce_size,",
                        "\t\t\t\t\t\talloc_info.consume_size,",
                        "\t\t\t\t\t\t&page_store,",
                        "\t\t\t\t\t\tvmci_host_dev->context);",
                        "\t}",
                        "",
                        "\tif (put_user(vmci_status, retptr)) {",
                        "\t\tif (vmci_status >= VMCI_SUCCESS) {",
                        "\t\t\tvmci_status = vmci_qp_broker_detach(handle,",
                        "\t\t\t\t\t\t\tvmci_host_dev->context);",
                        "\t\t}",
                        "\t\treturn -EFAULT;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 440,
                    "highlight": 488
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816b4aba"
        },
        "115": {
            "name": "vmci_host_do_alloc_queuepair",
            "parent_idx": 113,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_host.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_host.c?id=3dd0130f2430#n927",
                    "code": [
                        "static long vmci_host_unlocked_ioctl(struct file *filp,",
                        "\t\t\t\t     unsigned int iocmd, unsigned long ioarg)",
                        "{",
                        "#define VMCI_DO_IOCTL(ioctl_name, ioctl_fn) do {\t\t\t\\",
                        "\t\tchar *name = __stringify(IOCTL_VMCI_ ## ioctl_name);\t\\",
                        "\t\treturn vmci_host_do_ ## ioctl_fn(\t\t\t\\",
                        "\t\t\tvmci_host_dev, name, uptr);\t\t\t\\",
                        "\t} while (0)",
                        "",
                        "\tstruct vmci_host_dev *vmci_host_dev = filp->private_data;",
                        "\tvoid __user *uptr = (void __user *)ioarg;",
                        "",
                        "\tswitch (iocmd) {",
                        "\tcase IOCTL_VMCI_INIT_CONTEXT:",
                        "\t\tVMCI_DO_IOCTL(INIT_CONTEXT, init_context);",
                        "\tcase IOCTL_VMCI_DATAGRAM_SEND:",
                        "\t\tVMCI_DO_IOCTL(DATAGRAM_SEND, send_datagram);",
                        "\tcase IOCTL_VMCI_DATAGRAM_RECEIVE:",
                        "\t\tVMCI_DO_IOCTL(DATAGRAM_RECEIVE, receive_datagram);",
                        "\tcase IOCTL_VMCI_QUEUEPAIR_ALLOC:",
                        "\t\tVMCI_DO_IOCTL(QUEUEPAIR_ALLOC, alloc_queuepair);",
                        "\tcase IOCTL_VMCI_QUEUEPAIR_SETVA:",
                        "\t\tVMCI_DO_IOCTL(QUEUEPAIR_SETVA, queuepair_setva);",
                        "\tcase IOCTL_VMCI_QUEUEPAIR_SETPAGEFILE:",
                        "\t\tVMCI_DO_IOCTL(QUEUEPAIR_SETPAGEFILE, queuepair_setpf);",
                        "\tcase IOCTL_VMCI_QUEUEPAIR_DETACH:",
                        "\t\tVMCI_DO_IOCTL(QUEUEPAIR_DETACH, qp_detach);",
                        "\tcase IOCTL_VMCI_CTX_ADD_NOTIFICATION:",
                        "\t\tVMCI_DO_IOCTL(CTX_ADD_NOTIFICATION, ctx_add_notify);",
                        "\tcase IOCTL_VMCI_CTX_REMOVE_NOTIFICATION:",
                        "\t\tVMCI_DO_IOCTL(CTX_REMOVE_NOTIFICATION, ctx_remove_notify);",
                        "\tcase IOCTL_VMCI_CTX_GET_CPT_STATE:",
                        "\t\tVMCI_DO_IOCTL(CTX_GET_CPT_STATE, ctx_get_cpt_state);",
                        "\tcase IOCTL_VMCI_CTX_SET_CPT_STATE:",
                        "\t\tVMCI_DO_IOCTL(CTX_SET_CPT_STATE, ctx_set_cpt_state);",
                        "\tcase IOCTL_VMCI_GET_CONTEXT_ID:",
                        "\t\tVMCI_DO_IOCTL(GET_CONTEXT_ID, get_context_id);",
                        "\tcase IOCTL_VMCI_SET_NOTIFY:",
                        "\t\tVMCI_DO_IOCTL(SET_NOTIFY, set_notify);",
                        "\tcase IOCTL_VMCI_NOTIFY_RESOURCE:",
                        "\t\tVMCI_DO_IOCTL(NOTIFY_RESOURCE, notify_resource);",
                        "\tcase IOCTL_VMCI_NOTIFICATIONS_RECEIVE:",
                        "\t\tVMCI_DO_IOCTL(NOTIFICATIONS_RECEIVE, recv_notifications);",
                        "",
                        "\tcase IOCTL_VMCI_VERSION:",
                        "\tcase IOCTL_VMCI_VERSION2:",
                        "\t\treturn vmci_host_get_version(vmci_host_dev, iocmd, uptr);",
                        "",
                        "\tdefault:",
                        "\t\tpr_devel(\"%s: Unknown ioctl (iocmd=%d)\\n\", __func__, iocmd);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "#undef VMCI_DO_IOCTL",
                        "}"
                    ],
                    "start": 907,
                    "highlight": 927
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816b4dde"
        },
        "113": {
            "name": "vmci_host_unlocked_ioctl(indirect)",
            "parent_idx": 100,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=3dd0130f2430#n48",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 30,
                    "highlight": 48
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=3dd0130f2430#n753",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 739,
                    "highlight": 753
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=3dd0130f2430#n739",
                    "code": [
                        "/*",
                        " * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.",
                        " * It's just a simple helper for sys_ioctl and compat_sys_ioctl.",
                        " *",
                        " * When you add any new common ioctls to the switches above and below,",
                        " * please ensure they have compatible arguments in compat mode.",
                        " */",
                        "static int do_vfs_ioctl(struct file *filp, unsigned int fd,",
                        "\t\t\tunsigned int cmd, unsigned long arg)",
                        "{",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tstruct inode *inode = file_inode(filp);",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIOCLEX:",
                        "\t\tset_close_on_exec(fd, 1);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONCLEX:",
                        "\t\tset_close_on_exec(fd, 0);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONBIO:",
                        "\t\treturn ioctl_fionbio(filp, argp);",
                        "",
                        "\tcase FIOASYNC:",
                        "\t\treturn ioctl_fioasync(fd, filp, argp);",
                        "",
                        "\tcase FIOQSIZE:",
                        "\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||",
                        "\t\t    S_ISLNK(inode->i_mode)) {",
                        "\t\t\tloff_t res = inode_get_bytes(inode);",
                        "\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?",
                        "\t\t\t\t\t    -EFAULT : 0;",
                        "\t\t}",
                        "",
                        "\t\treturn -ENOTTY;",
                        "",
                        "\tcase FIFREEZE:",
                        "\t\treturn ioctl_fsfreeze(filp);",
                        "",
                        "\tcase FITHAW:",
                        "\t\treturn ioctl_fsthaw(filp);",
                        "",
                        "\tcase FS_IOC_FIEMAP:",
                        "\t\treturn ioctl_fiemap(filp, argp);",
                        "",
                        "\tcase FIGETBSZ:",
                        "\t\t/* anon_bdev filesystems may not have a block size */",
                        "\t\tif (!inode->i_sb->s_blocksize)",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
                        "",
                        "\tcase FICLONE:",
                        "\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);",
                        "",
                        "\tcase FICLONERANGE:",
                        "\t\treturn ioctl_file_clone_range(filp, argp);",
                        "",
                        "\tcase FIDEDUPERANGE:",
                        "\t\treturn ioctl_file_dedupe_range(filp, argp);",
                        "",
                        "\tcase FIONREAD:",
                        "\t\tif (!S_ISREG(inode->i_mode))",
                        "\t\t\treturn vfs_ioctl(filp, cmd, arg);",
                        "",
                        "\t\treturn put_user(i_size_read(inode) - filp->f_pos,",
                        "\t\t\t\t(int __user *)argp);",
                        "",
                        "\tdefault:",
                        "\t\tif (S_ISREG(inode->i_mode))",
                        "\t\t\treturn file_ioctl(filp, cmd, argp);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn -ENOIOCTLCMD;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 660,
                    "highlight": 739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811feab9"
        },
        "100": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 97,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=3dd0130f2430#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b575ee"
        },
        "97": {
            "name": "do_syscall_64",
            "parent_idx": 91,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=3dd0130f2430#n118",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 118
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "91": {
            "name": "24_syscall_7",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "162": {
            "name": "+0x49",
            "parent_idx": 158,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n633",
                    "code": [
                        "/*",
                        " * Helper function to release pages in the PageStoreAttachInfo",
                        " * previously obtained using get_user_pages.",
                        " */",
                        "static void qp_release_pages(struct page **pages,",
                        "\t\t\t     u64 num_pages, bool dirty)",
                        "{",
                        "\tint i;",
                        "",
                        "\tfor (i = 0; i < num_pages; i++) {",
                        "\t\tif (dirty)",
                        "\t\t\tset_page_dirty(pages[i]);",
                        "",
                        "\t\tput_page(pages[i]);",
                        "\t\tpages[i] = NULL;",
                        "\t}",
                        "}"
                    ],
                    "start": 622,
                    "highlight": 633
                }
            ],
            "ins_idx": 6,
            "addr": "0xffffffff816b5829"
        },
        "142": {
            "name": "+0x0",
            "parent_idx": 141,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=3dd0130f2430#n3979",
                    "code": [
                        "#ifdef CONFIG_NUMA",
                        "static void *kmalloc_large_node(size_t size, gfp_t flags, int node)",
                        "{",
                        "\tstruct page *page;",
                        "\tvoid *ptr = NULL;",
                        "\tunsigned int order = get_order(size);",
                        "",
                        "\tflags |= __GFP_COMP;",
                        "\tpage = alloc_pages_node(node, flags, order);",
                        "\tif (page) {",
                        "\t\tptr = page_address(page);",
                        "\t\tmod_node_page_state(page_pgdat(page), NR_SLAB_UNRECLAIMABLE_B,",
                        "\t\t\t\t    PAGE_SIZE << order);",
                        "\t}",
                        "",
                        "\treturn kmalloc_large_node_hook(ptr, size, flags);",
                        "}"
                    ],
                    "start": 3971,
                    "highlight": 3979
                }
            ],
            "ins_idx": 12,
            "addr": "0xffffffff811dadf0"
        },
        "141": {
            "name": "__kmalloc",
            "parent_idx": 137,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=3dd0130f2430#n559",
                    "code": [
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 554,
                    "highlight": 559
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=3dd0130f2430#n666",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 659,
                    "highlight": 666
                },
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n540",
                    "code": [
                        "/*",
                        " * Allocates kernel VA space of specified size plus space for the queue",
                        " * and kernel interface.  This is different from the guest queue allocator,",
                        " * because we do not allocate our own queue header/data pages here but",
                        " * share those of the guest.",
                        " */",
                        "static struct vmci_queue *qp_host_alloc_queue(u64 size)",
                        "{",
                        "\tstruct vmci_queue *queue;",
                        "\tsize_t queue_page_size;",
                        "\tu64 num_pages;",
                        "\tconst size_t queue_size = sizeof(*queue) + sizeof(*(queue->kernel_if));",
                        "",
                        "\tif (size > SIZE_MAX - PAGE_SIZE)",
                        "\t\treturn NULL;",
                        "\tnum_pages = DIV_ROUND_UP(size, PAGE_SIZE) + 1;",
                        "\tif (num_pages > (SIZE_MAX - queue_size) /",
                        "\t\t sizeof(*queue->kernel_if->u.h.page))",
                        "\t\treturn NULL;",
                        "",
                        "\tqueue_page_size = num_pages * sizeof(*queue->kernel_if->u.h.page);",
                        "",
                        "\tqueue = kzalloc(queue_size + queue_page_size, GFP_KERNEL);",
                        "\tif (queue) {",
                        "\t\tqueue->q_header = NULL;",
                        "\t\tqueue->saved_header = NULL;",
                        "\t\tqueue->kernel_if = (struct vmci_queue_kern_if *)(queue + 1);",
                        "\t\tqueue->kernel_if->host = true;",
                        "\t\tqueue->kernel_if->mutex = NULL;",
                        "\t\tqueue->kernel_if->num_pages = num_pages;",
                        "\t\tqueue->kernel_if->u.h.header_page =",
                        "\t\t    (struct page **)((u8 *)queue + queue_size);",
                        "\t\tqueue->kernel_if->u.h.page =",
                        "\t\t\t&queue->kernel_if->u.h.header_page[1];",
                        "\t}",
                        "",
                        "\treturn queue;",
                        "}"
                    ],
                    "start": 518,
                    "highlight": 540
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816b5798"
        },
        "137": {
            "name": "qp_host_alloc_queue",
            "parent_idx": 129,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n1349",
                    "code": [
                        "/*",
                        " * The first endpoint issuing a queue pair allocation will create the state",
                        " * of the queue pair in the queue pair broker.",
                        " *",
                        " * If the creator is a guest, it will associate a VMX virtual address range",
                        " * with the queue pair as specified by the page_store. For compatibility with",
                        " * older VMX'en, that would use a separate step to set the VMX virtual",
                        " * address range, the virtual address range can be registered later using",
                        " * vmci_qp_broker_set_page_store. In that case, a page_store of NULL should be",
                        " * used.",
                        " *",
                        " * If the creator is the host, a page_store of NULL should be used as well,",
                        " * since the host is not able to supply a page store for the queue pair.",
                        " *",
                        " * For older VMX and host callers, the queue pair will be created in the",
                        " * VMCIQPB_CREATED_NO_MEM state, and for current VMX callers, it will be",
                        " * created in VMCOQPB_CREATED_MEM state.",
                        " */",
                        "static int qp_broker_create(struct vmci_handle handle,",
                        "\t\t\t    u32 peer,",
                        "\t\t\t    u32 flags,",
                        "\t\t\t    u32 priv_flags,",
                        "\t\t\t    u64 produce_size,",
                        "\t\t\t    u64 consume_size,",
                        "\t\t\t    struct vmci_qp_page_store *page_store,",
                        "\t\t\t    struct vmci_ctx *context,",
                        "\t\t\t    vmci_event_release_cb wakeup_cb,",
                        "\t\t\t    void *client_data, struct qp_broker_entry **ent)",
                        "{",
                        "\tstruct qp_broker_entry *entry = NULL;",
                        "\tconst u32 context_id = vmci_ctx_get_id(context);",
                        "\tbool is_local = flags & VMCI_QPFLAG_LOCAL;",
                        "\tint result;",
                        "\tu64 guest_produce_size;",
                        "\tu64 guest_consume_size;",
                        "",
                        "\t/* Do not create if the caller asked not to. */",
                        "\tif (flags & VMCI_QPFLAG_ATTACH_ONLY)",
                        "\t\treturn VMCI_ERROR_NOT_FOUND;",
                        "",
                        "\t/*",
                        "\t * Creator's context ID should match handle's context ID or the creator",
                        "\t * must allow the context in handle's context ID as the \"peer\".",
                        "\t */",
                        "\tif (handle.context != context_id && handle.context != peer)",
                        "\t\treturn VMCI_ERROR_NO_ACCESS;",
                        "",
                        "\tif (VMCI_CONTEXT_IS_VM(context_id) && VMCI_CONTEXT_IS_VM(peer))",
                        "\t\treturn VMCI_ERROR_DST_UNREACHABLE;",
                        "",
                        "\t/*",
                        "\t * Creator's context ID for local queue pairs should match the",
                        "\t * peer, if a peer is specified.",
                        "\t */",
                        "\tif (is_local && peer != VMCI_INVALID_ID && context_id != peer)",
                        "\t\treturn VMCI_ERROR_NO_ACCESS;",
                        "",
                        "\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);",
                        "\tif (!entry)",
                        "\t\treturn VMCI_ERROR_NO_MEM;",
                        "",
                        "\tif (vmci_ctx_get_id(context) == VMCI_HOST_CONTEXT_ID && !is_local) {",
                        "\t\t/*",
                        "\t\t * The queue pair broker entry stores values from the guest",
                        "\t\t * point of view, so a creating host side endpoint should swap",
                        "\t\t * produce and consume values -- unless it is a local queue",
                        "\t\t * pair, in which case no swapping is necessary, since the local",
                        "\t\t * attacher will swap queues.",
                        "\t\t */",
                        "",
                        "\t\tguest_produce_size = consume_size;",
                        "\t\tguest_consume_size = produce_size;",
                        "\t} else {",
                        "\t\tguest_produce_size = produce_size;",
                        "\t\tguest_consume_size = consume_size;",
                        "\t}",
                        "",
                        "\tentry->qp.handle = handle;",
                        "\tentry->qp.peer = peer;",
                        "\tentry->qp.flags = flags;",
                        "\tentry->qp.produce_size = guest_produce_size;",
                        "\tentry->qp.consume_size = guest_consume_size;",
                        "\tentry->qp.ref_count = 1;",
                        "\tentry->create_id = context_id;",
                        "\tentry->attach_id = VMCI_INVALID_ID;",
                        "\tentry->state = VMCIQPB_NEW;",
                        "\tentry->require_trusted_attach =",
                        "\t    !!(context->priv_flags & VMCI_PRIVILEGE_FLAG_RESTRICTED);",
                        "\tentry->created_by_trusted =",
                        "\t    !!(priv_flags & VMCI_PRIVILEGE_FLAG_TRUSTED);",
                        "\tentry->vmci_page_files = false;",
                        "\tentry->wakeup_cb = wakeup_cb;",
                        "\tentry->client_data = client_data;",
                        "\tentry->produce_q = qp_host_alloc_queue(guest_produce_size);",
                        "\tif (entry->produce_q == NULL) {",
                        "\t\tresult = VMCI_ERROR_NO_MEM;",
                        "\t\tgoto error;",
                        "\t}",
                        "\tentry->consume_q = qp_host_alloc_queue(guest_consume_size);",
                        "\tif (entry->consume_q == NULL) {",
                        "\t\tresult = VMCI_ERROR_NO_MEM;",
                        "\t\tgoto error;",
                        "\t}",
                        "",
                        "\tqp_init_queue_mutex(entry->produce_q, entry->consume_q);",
                        "",
                        "\tINIT_LIST_HEAD(&entry->qp.list_item);",
                        "",
                        "\tif (is_local) {",
                        "\t\tu8 *tmp;",
                        "",
                        "\t\tentry->local_mem = kcalloc(QPE_NUM_PAGES(entry->qp),",
                        "\t\t\t\t\t   PAGE_SIZE, GFP_KERNEL);",
                        "\t\tif (entry->local_mem == NULL) {",
                        "\t\t\tresult = VMCI_ERROR_NO_MEM;",
                        "\t\t\tgoto error;",
                        "\t\t}",
                        "\t\tentry->state = VMCIQPB_CREATED_MEM;",
                        "\t\tentry->produce_q->q_header = entry->local_mem;",
                        "\t\ttmp = (u8 *)entry->local_mem + PAGE_SIZE *",
                        "\t\t    (DIV_ROUND_UP(entry->qp.produce_size, PAGE_SIZE) + 1);",
                        "\t\tentry->consume_q->q_header = (struct vmci_queue_header *)tmp;",
                        "\t} else if (page_store) {",
                        "\t\t/*",
                        "\t\t * The VMX already initialized the queue pair headers, so no",
                        "\t\t * need for the kernel side to do that.",
                        "\t\t */",
                        "\t\tresult = qp_host_register_user_memory(page_store,",
                        "\t\t\t\t\t\t      entry->produce_q,",
                        "\t\t\t\t\t\t      entry->consume_q);",
                        "\t\tif (result < VMCI_SUCCESS)",
                        "\t\t\tgoto error;",
                        "",
                        "\t\tentry->state = VMCIQPB_CREATED_MEM;",
                        "\t} else {",
                        "\t\t/*",
                        "\t\t * A create without a page_store may be either a host",
                        "\t\t * side create (in which case we are waiting for the",
                        "\t\t * guest side to supply the memory) or an old style",
                        "\t\t * queue pair create (in which case we will expect a",
                        "\t\t * set page store call as the next step).",
                        "\t\t */",
                        "\t\tentry->state = VMCIQPB_CREATED_NO_MEM;",
                        "\t}",
                        "",
                        "\tqp_list_add_entry(&qp_broker_list, &entry->qp);",
                        "\tif (ent != NULL)",
                        "\t\t*ent = entry;",
                        "",
                        "\t/* Add to resource obj */",
                        "\tresult = vmci_resource_add(&entry->resource,",
                        "\t\t\t\t   VMCI_RESOURCE_TYPE_QPAIR_HOST,",
                        "\t\t\t\t   handle);",
                        "\tif (result != VMCI_SUCCESS) {",
                        "\t\tpr_warn(\"Failed to add new resource (handle=0x%x:0x%x), error: %d\",",
                        "\t\t\thandle.context, handle.resource, result);",
                        "\t\tgoto error;",
                        "\t}",
                        "",
                        "\tentry->qp.handle = vmci_resource_handle(&entry->resource);",
                        "\tif (is_local) {",
                        "\t\tvmci_q_header_init(entry->produce_q->q_header,",
                        "\t\t\t\t   entry->qp.handle);",
                        "\t\tvmci_q_header_init(entry->consume_q->q_header,",
                        "\t\t\t\t   entry->qp.handle);",
                        "\t}",
                        "",
                        "\tvmci_ctx_qp_create(context, entry->qp.handle);",
                        "",
                        "\treturn VMCI_SUCCESS;",
                        "",
                        " error:",
                        "\tif (entry != NULL) {",
                        "\t\tqp_host_free_queue(entry->produce_q, guest_produce_size);",
                        "\t\tqp_host_free_queue(entry->consume_q, guest_consume_size);",
                        "\t\tkfree(entry);",
                        "\t}",
                        "",
                        "\treturn result;",
                        "}"
                    ],
                    "start": 1256,
                    "highlight": 1349
                },
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n1737",
                    "code": [
                        "/*",
                        " * queue_pair_Alloc for use when setting up queue pair endpoints",
                        " * on the host.",
                        " */",
                        "static int qp_broker_alloc(struct vmci_handle handle,",
                        "\t\t\t   u32 peer,",
                        "\t\t\t   u32 flags,",
                        "\t\t\t   u32 priv_flags,",
                        "\t\t\t   u64 produce_size,",
                        "\t\t\t   u64 consume_size,",
                        "\t\t\t   struct vmci_qp_page_store *page_store,",
                        "\t\t\t   struct vmci_ctx *context,",
                        "\t\t\t   vmci_event_release_cb wakeup_cb,",
                        "\t\t\t   void *client_data,",
                        "\t\t\t   struct qp_broker_entry **ent,",
                        "\t\t\t   bool *swap)",
                        "{",
                        "\tconst u32 context_id = vmci_ctx_get_id(context);",
                        "\tbool create;",
                        "\tstruct qp_broker_entry *entry = NULL;",
                        "\tbool is_local = flags & VMCI_QPFLAG_LOCAL;",
                        "\tint result;",
                        "",
                        "\tif (vmci_handle_is_invalid(handle) ||",
                        "\t    (flags & ~VMCI_QP_ALL_FLAGS) || is_local ||",
                        "\t    !(produce_size || consume_size) ||",
                        "\t    !context || context_id == VMCI_INVALID_ID ||",
                        "\t    handle.context == VMCI_INVALID_ID) {",
                        "\t\treturn VMCI_ERROR_INVALID_ARGS;",
                        "\t}",
                        "",
                        "\tif (page_store && !VMCI_QP_PAGESTORE_IS_WELLFORMED(page_store))",
                        "\t\treturn VMCI_ERROR_INVALID_ARGS;",
                        "",
                        "\t/*",
                        "\t * In the initial argument check, we ensure that non-vmkernel hosts",
                        "\t * are not allowed to create local queue pairs.",
                        "\t */",
                        "",
                        "\tmutex_lock(&qp_broker_list.mutex);",
                        "",
                        "\tif (!is_local && vmci_ctx_qp_exists(context, handle)) {",
                        "\t\tpr_devel(\"Context (ID=0x%x) already attached to queue pair (handle=0x%x:0x%x)\\n\",",
                        "\t\t\t context_id, handle.context, handle.resource);",
                        "\t\tmutex_unlock(&qp_broker_list.mutex);",
                        "\t\treturn VMCI_ERROR_ALREADY_EXISTS;",
                        "\t}",
                        "",
                        "\tif (handle.resource != VMCI_INVALID_ID)",
                        "\t\tentry = qp_broker_handle_to_entry(handle);",
                        "",
                        "\tif (!entry) {",
                        "\t\tcreate = true;",
                        "\t\tresult =",
                        "\t\t    qp_broker_create(handle, peer, flags, priv_flags,",
                        "\t\t\t\t     produce_size, consume_size, page_store,",
                        "\t\t\t\t     context, wakeup_cb, client_data, ent);",
                        "\t} else {",
                        "\t\tcreate = false;",
                        "\t\tresult =",
                        "\t\t    qp_broker_attach(entry, peer, flags, priv_flags,",
                        "\t\t\t\t     produce_size, consume_size, page_store,",
                        "\t\t\t\t     context, wakeup_cb, client_data, ent);",
                        "\t}",
                        "",
                        "\tmutex_unlock(&qp_broker_list.mutex);",
                        "",
                        "\tif (swap)",
                        "\t\t*swap = (context_id == VMCI_HOST_CONTEXT_ID) &&",
                        "\t\t    !(create && is_local);",
                        "",
                        "\treturn result;",
                        "}"
                    ],
                    "start": 1683,
                    "highlight": 1737
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff816b729e"
        },
        "161": {
            "name": "+0x44",
            "parent_idx": 158,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n633",
                    "code": [
                        "/*",
                        " * Helper function to release pages in the PageStoreAttachInfo",
                        " * previously obtained using get_user_pages.",
                        " */",
                        "static void qp_release_pages(struct page **pages,",
                        "\t\t\t     u64 num_pages, bool dirty)",
                        "{",
                        "\tint i;",
                        "",
                        "\tfor (i = 0; i < num_pages; i++) {",
                        "\t\tif (dirty)",
                        "\t\t\tset_page_dirty(pages[i]);",
                        "",
                        "\t\tput_page(pages[i]);",
                        "\t\tpages[i] = NULL;",
                        "\t}",
                        "}"
                    ],
                    "start": 622,
                    "highlight": 633
                }
            ],
            "ins_idx": 11,
            "addr": "0xffffffff816b5824"
        },
        "160": {
            "name": "+0xe",
            "parent_idx": 158,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n628",
                    "code": [
                        "/*",
                        " * Helper function to release pages in the PageStoreAttachInfo",
                        " * previously obtained using get_user_pages.",
                        " */",
                        "static void qp_release_pages(struct page **pages,",
                        "\t\t\t     u64 num_pages, bool dirty)",
                        "{",
                        "\tint i;",
                        "",
                        "\tfor (i = 0; i < num_pages; i++) {",
                        "\t\tif (dirty)",
                        "\t\t\tset_page_dirty(pages[i]);",
                        "",
                        "\t\tput_page(pages[i]);",
                        "\t\tpages[i] = NULL;",
                        "\t}",
                        "}"
                    ],
                    "start": 622,
                    "highlight": 628
                }
            ],
            "ins_idx": 18,
            "addr": "0xffffffff816b57ee"
        },
        "157": {
            "name": "+0x55",
            "parent_idx": 149,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n660",
                    "code": [
                        "/*",
                        " * Lock the user pages referenced by the {produce,consume}Buffer",
                        " * struct into memory and populate the {produce,consume}Pages",
                        " * arrays in the attach structure with them.",
                        " */",
                        "static int qp_host_get_user_memory(u64 produce_uva,",
                        "\t\t\t\t   u64 consume_uva,",
                        "\t\t\t\t   struct vmci_queue *produce_q,",
                        "\t\t\t\t   struct vmci_queue *consume_q)",
                        "{",
                        "\tint retval;",
                        "\tint err = VMCI_SUCCESS;",
                        "",
                        "\tretval = get_user_pages_fast((uintptr_t) produce_uva,",
                        "\t\t\t\t     produce_q->kernel_if->num_pages,",
                        "\t\t\t\t     FOLL_WRITE,",
                        "\t\t\t\t     produce_q->kernel_if->u.h.header_page);",
                        "\tif (retval < (int)produce_q->kernel_if->num_pages) {",
                        "\t\tpr_debug(\"get_user_pages_fast(produce) failed (retval=%d)\",",
                        "\t\t\tretval);",
                        "\t\tqp_release_pages(produce_q->kernel_if->u.h.header_page,",
                        "\t\t\t\t retval, false);",
                        "\t\terr = VMCI_ERROR_NO_MEM;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tretval = get_user_pages_fast((uintptr_t) consume_uva,",
                        "\t\t\t\t     consume_q->kernel_if->num_pages,",
                        "\t\t\t\t     FOLL_WRITE,",
                        "\t\t\t\t     consume_q->kernel_if->u.h.header_page);",
                        "\tif (retval < (int)consume_q->kernel_if->num_pages) {",
                        "\t\tpr_debug(\"get_user_pages_fast(consume) failed (retval=%d)\",",
                        "\t\t\tretval);",
                        "\t\tqp_release_pages(consume_q->kernel_if->u.h.header_page,",
                        "\t\t\t\t retval, false);",
                        "\t\tqp_release_pages(produce_q->kernel_if->u.h.header_page,",
                        "\t\t\t\t produce_q->kernel_if->num_pages, false);",
                        "\t\terr = VMCI_ERROR_NO_MEM;",
                        "\t}",
                        "",
                        " out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 640,
                    "highlight": 660
                }
            ],
            "ins_idx": 23,
            "addr": "0xffffffff816b58a5"
        },
        "146": {
            "name": "+0x45",
            "parent_idx": 137,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n549",
                    "code": [
                        "/*",
                        " * Allocates kernel VA space of specified size plus space for the queue",
                        " * and kernel interface.  This is different from the guest queue allocator,",
                        " * because we do not allocate our own queue header/data pages here but",
                        " * share those of the guest.",
                        " */",
                        "static struct vmci_queue *qp_host_alloc_queue(u64 size)",
                        "{",
                        "\tstruct vmci_queue *queue;",
                        "\tsize_t queue_page_size;",
                        "\tu64 num_pages;",
                        "\tconst size_t queue_size = sizeof(*queue) + sizeof(*(queue->kernel_if));",
                        "",
                        "\tif (size > SIZE_MAX - PAGE_SIZE)",
                        "\t\treturn NULL;",
                        "\tnum_pages = DIV_ROUND_UP(size, PAGE_SIZE) + 1;",
                        "\tif (num_pages > (SIZE_MAX - queue_size) /",
                        "\t\t sizeof(*queue->kernel_if->u.h.page))",
                        "\t\treturn NULL;",
                        "",
                        "\tqueue_page_size = num_pages * sizeof(*queue->kernel_if->u.h.page);",
                        "",
                        "\tqueue = kzalloc(queue_size + queue_page_size, GFP_KERNEL);",
                        "\tif (queue) {",
                        "\t\tqueue->q_header = NULL;",
                        "\t\tqueue->saved_header = NULL;",
                        "\t\tqueue->kernel_if = (struct vmci_queue_kern_if *)(queue + 1);",
                        "\t\tqueue->kernel_if->host = true;",
                        "\t\tqueue->kernel_if->mutex = NULL;",
                        "\t\tqueue->kernel_if->num_pages = num_pages;",
                        "\t\tqueue->kernel_if->u.h.header_page =",
                        "\t\t    (struct page **)((u8 *)queue + queue_size);",
                        "\t\tqueue->kernel_if->u.h.page =",
                        "\t\t\t&queue->kernel_if->u.h.header_page[1];",
                        "\t}",
                        "",
                        "\treturn queue;",
                        "}"
                    ],
                    "start": 518,
                    "highlight": 549
                }
            ],
            "ins_idx": 29,
            "addr": "0xffffffff816b57b5"
        },
        "145": {
            "name": "+0x41",
            "parent_idx": 137,
            "source_line": [
                {
                    "file": "drivers/misc/vmw_vmci/vmci_queue_pair.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/misc/vmw_vmci/vmci_queue_pair.c?id=3dd0130f2430#n549",
                    "code": [
                        "/*",
                        " * Allocates kernel VA space of specified size plus space for the queue",
                        " * and kernel interface.  This is different from the guest queue allocator,",
                        " * because we do not allocate our own queue header/data pages here but",
                        " * share those of the guest.",
                        " */",
                        "static struct vmci_queue *qp_host_alloc_queue(u64 size)",
                        "{",
                        "\tstruct vmci_queue *queue;",
                        "\tsize_t queue_page_size;",
                        "\tu64 num_pages;",
                        "\tconst size_t queue_size = sizeof(*queue) + sizeof(*(queue->kernel_if));",
                        "",
                        "\tif (size > SIZE_MAX - PAGE_SIZE)",
                        "\t\treturn NULL;",
                        "\tnum_pages = DIV_ROUND_UP(size, PAGE_SIZE) + 1;",
                        "\tif (num_pages > (SIZE_MAX - queue_size) /",
                        "\t\t sizeof(*queue->kernel_if->u.h.page))",
                        "\t\treturn NULL;",
                        "",
                        "\tqueue_page_size = num_pages * sizeof(*queue->kernel_if->u.h.page);",
                        "",
                        "\tqueue = kzalloc(queue_size + queue_page_size, GFP_KERNEL);",
                        "\tif (queue) {",
                        "\t\tqueue->q_header = NULL;",
                        "\t\tqueue->saved_header = NULL;",
                        "\t\tqueue->kernel_if = (struct vmci_queue_kern_if *)(queue + 1);",
                        "\t\tqueue->kernel_if->host = true;",
                        "\t\tqueue->kernel_if->mutex = NULL;",
                        "\t\tqueue->kernel_if->num_pages = num_pages;",
                        "\t\tqueue->kernel_if->u.h.header_page =",
                        "\t\t    (struct page **)((u8 *)queue + queue_size);",
                        "\t\tqueue->kernel_if->u.h.page =",
                        "\t\t\t&queue->kernel_if->u.h.header_page[1];",
                        "\t}",
                        "",
                        "\treturn queue;",
                        "}"
                    ],
                    "start": 518,
                    "highlight": 549
                }
            ],
            "ins_idx": 38,
            "addr": "0xffffffff816b57b1"
        }
    },
    "ins": {
        "1": {
            "name": "mov rax, qword ptr [rdi + 8]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x8",
            "call_idx": 163,
            "inputs": [
                253,
                254
            ],
            "outputs": [
                255
            ]
        },
        "6": {
            "name": "mov rdi, qword ptr [rbx]",
            "desc": "Heap Use Before Initialization",
            "call_idx": 162,
            "inputs": [
                250,
                251
            ],
            "outputs": [
                252
            ]
        },
        "12": {
            "name": "push r15",
            "desc": "Source of base address MEMALLOC 0x0",
            "call_idx": 142,
            "inputs": [],
            "outputs": [
                209
            ]
        },
        "11": {
            "name": "lea rbx, qword ptr [r13 + rax*8]",
            "desc": "",
            "call_idx": 161,
            "inputs": [
                247,
                248
            ],
            "outputs": [
                249
            ]
        },
        "18": {
            "name": "mov r13, rdi",
            "desc": "",
            "call_idx": 160,
            "inputs": [
                245
            ],
            "outputs": [
                246
            ]
        },
        "23": {
            "name": "mov rdi, qword ptr [rdx + 0x40]",
            "desc": "",
            "call_idx": 157,
            "inputs": [
                239,
                240
            ],
            "outputs": [
                241
            ]
        },
        "29": {
            "name": "mov qword ptr [rax + 0x58], rdx",
            "desc": "",
            "call_idx": 146,
            "inputs": [
                217,
                218
            ],
            "outputs": [
                219
            ]
        },
        "38": {
            "name": "lea rdx, qword ptr [rax + 0x60]",
            "desc": "",
            "call_idx": 145,
            "inputs": [
                215
            ],
            "outputs": [
                216
            ]
        }
    },
    "data": {
        "253": {
            "name": "RDI",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "254": {
            "name": "[0x8]",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "255": {
            "name": "RAX",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "250": {
            "name": "RBX",
            "ins_idx": 6,
            "value": "0xffff888235ead060",
            "sources": []
        },
        "251": {
            "name": "[0xffff888235ead060]",
            "ins_idx": 6,
            "value": "0x0",
            "sources": []
        },
        "252": {
            "name": "RDI",
            "ins_idx": 6,
            "value": "0x0",
            "sources": [
                253
            ]
        },
        "209": {
            "name": "RAX",
            "ins_idx": 12,
            "value": "0xffff888235ead000",
            "sources": [
                217,
                215
            ]
        },
        "247": {
            "name": "RAX",
            "ins_idx": 11,
            "value": "0x0",
            "sources": []
        },
        "248": {
            "name": "R13",
            "ins_idx": 11,
            "value": "0xffff888235ead060",
            "sources": []
        },
        "249": {
            "name": "RBX",
            "ins_idx": 11,
            "value": "0xffff888235ead060",
            "sources": [
                250
            ]
        },
        "245": {
            "name": "RDI",
            "ins_idx": 18,
            "value": "0xffff888235ead060",
            "sources": []
        },
        "246": {
            "name": "R13",
            "ins_idx": 18,
            "value": "0xffff888235ead060",
            "sources": [
                248
            ]
        },
        "239": {
            "name": "RDX",
            "ins_idx": 23,
            "value": "0xffff888235ead018",
            "sources": []
        },
        "240": {
            "name": "[0xffff888235ead058]",
            "ins_idx": 23,
            "value": "0xffff888235ead060",
            "sources": []
        },
        "241": {
            "name": "RDI",
            "ins_idx": 23,
            "value": "0xffff888235ead060",
            "sources": [
                245
            ]
        },
        "217": {
            "name": "RAX",
            "ins_idx": 29,
            "value": "0xffff888235ead000",
            "sources": []
        },
        "218": {
            "name": "RDX",
            "ins_idx": 29,
            "value": "0xffff888235ead060",
            "sources": []
        },
        "219": {
            "name": "[0xffff888235ead058]",
            "ins_idx": 29,
            "value": "0xffff888235ead060",
            "sources": [
                240
            ]
        },
        "215": {
            "name": "RAX",
            "ins_idx": 38,
            "value": "0xffff888235ead000",
            "sources": []
        },
        "216": {
            "name": "RDX",
            "ins_idx": 38,
            "value": "0xffff888235ead060",
            "sources": [
                218
            ]
        }
    },
    "chain": {
        "1": [
            6
        ],
        "6": [
            12,
            11
        ],
        "11": [
            18
        ],
        "18": [
            23
        ],
        "23": [
            29
        ],
        "29": [
            38,
            12
        ],
        "38": [
            12
        ]
    }
}