{
    "report": "https://syzkaller.appspot.com/bug?id=c580fc5378004988047cb13b9f312b3eaa44eda8",
    "title": "general protection fault in ip6_datagram_dst_update",
    "call": {
        "21": {
            "name": "+0x11b",
            "parent_idx": 8,
            "source_line": [
                {
                    "file": "net/ipv6/datagram.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/datagram.c?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n83",
                    "code": [
                        "int ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr)",
                        "{",
                        "\tstruct ip6_flowlabel *flowlabel = NULL;",
                        "\tstruct in6_addr *final_p, final;",
                        "\tstruct ipv6_txoptions *opt;",
                        "\tstruct dst_entry *dst;",
                        "\tstruct inet_sock *inet = inet_sk(sk);",
                        "\tstruct ipv6_pinfo *np = inet6_sk(sk);",
                        "\tstruct flowi6 fl6;",
                        "\tint err = 0;",
                        "",
                        "\tif (np->sndflow && (np->flow_label & IPV6_FLOWLABEL_MASK)) {",
                        "\t\tflowlabel = fl6_sock_lookup(sk, np->flow_label);",
                        "\t\tif (!flowlabel)",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "\tip6_datagram_flow_key_init(&fl6, sk);",
                        "",
                        "\trcu_read_lock();",
                        "\topt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);",
                        "\tfinal_p = fl6_update_dst(&fl6, opt, &final);",
                        "\trcu_read_unlock();",
                        "",
                        "\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);",
                        "\tif (IS_ERR(dst)) {",
                        "\t\terr = PTR_ERR(dst);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (fix_sk_saddr) {",
                        "\t\tif (ipv6_addr_any(&np->saddr))",
                        "\t\t\tnp->saddr = fl6.saddr;",
                        "",
                        "\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {",
                        "\t\t\tsk->sk_v6_rcv_saddr = fl6.saddr;",
                        "\t\t\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;",
                        "\t\t\tif (sk->sk_prot->rehash)",
                        "\t\t\t\tsk->sk_prot->rehash(sk);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tip6_sk_dst_store_flow(sk, dst, &fl6);",
                        "",
                        "out:",
                        "\tfl6_sock_release(flowlabel);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 64,
                    "highlight": 83
                }
            ],
            "ins_idx": 1,
            "addr": "0xffffffff81968cfb"
        },
        "8": {
            "name": "ip6_datagram_dst_update",
            "parent_idx": 7,
            "source_line": [
                {
                    "file": "net/ipv6/datagram.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/datagram.c?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n246",
                    "code": [
                        "int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr,",
                        "\t\t\t   int addr_len)",
                        "{",
                        "\tstruct sockaddr_in6\t*usin = (struct sockaddr_in6 *) uaddr;",
                        "\tstruct inet_sock\t*inet = inet_sk(sk);",
                        "\tstruct ipv6_pinfo\t*np = inet6_sk(sk);",
                        "\tstruct in6_addr\t\t*daddr, old_daddr;",
                        "\t__be32\t\t\tfl6_flowlabel = 0;",
                        "\t__be32\t\t\told_fl6_flowlabel;",
                        "\t__be16\t\t\told_dport;",
                        "\tint\t\t\taddr_type;",
                        "\tint\t\t\terr;",
                        "",
                        "\tif (usin->sin6_family == AF_INET) {",
                        "\t\tif (__ipv6_only_sock(sk))",
                        "\t\t\treturn -EAFNOSUPPORT;",
                        "\t\terr = __ip4_datagram_connect(sk, uaddr, addr_len);",
                        "\t\tgoto ipv4_connected;",
                        "\t}",
                        "",
                        "\tif (addr_len < SIN6_LEN_RFC2133)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (usin->sin6_family != AF_INET6)",
                        "\t\treturn -EAFNOSUPPORT;",
                        "",
                        "\tif (np->sndflow)",
                        "\t\tfl6_flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;",
                        "",
                        "\tif (ipv6_addr_any(&usin->sin6_addr)) {",
                        "\t\t/*",
                        "\t\t *\tconnect to self",
                        "\t\t */",
                        "\t\tif (ipv6_addr_v4mapped(&sk->sk_v6_rcv_saddr))",
                        "\t\t\tipv6_addr_set_v4mapped(htonl(INADDR_LOOPBACK),",
                        "\t\t\t\t\t       &usin->sin6_addr);",
                        "\t\telse",
                        "\t\t\tusin->sin6_addr = in6addr_loopback;",
                        "\t}",
                        "",
                        "\taddr_type = ipv6_addr_type(&usin->sin6_addr);",
                        "",
                        "\tdaddr = &usin->sin6_addr;",
                        "",
                        "\tif (addr_type & IPV6_ADDR_MAPPED) {",
                        "\t\tstruct sockaddr_in sin;",
                        "",
                        "\t\tif (__ipv6_only_sock(sk)) {",
                        "\t\t\terr = -ENETUNREACH;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tsin.sin_family = AF_INET;",
                        "\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];",
                        "\t\tsin.sin_port = usin->sin6_port;",
                        "",
                        "\t\terr = __ip4_datagram_connect(sk,",
                        "\t\t\t\t\t     (struct sockaddr *) &sin,",
                        "\t\t\t\t\t     sizeof(sin));",
                        "",
                        "ipv4_connected:",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tipv6_addr_set_v4mapped(inet->inet_daddr, &sk->sk_v6_daddr);",
                        "",
                        "\t\tif (ipv6_addr_any(&np->saddr) ||",
                        "\t\t    ipv6_mapped_addr_any(&np->saddr))",
                        "\t\t\tipv6_addr_set_v4mapped(inet->inet_saddr, &np->saddr);",
                        "",
                        "\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr) ||",
                        "\t\t    ipv6_mapped_addr_any(&sk->sk_v6_rcv_saddr)) {",
                        "\t\t\tipv6_addr_set_v4mapped(inet->inet_rcv_saddr,",
                        "\t\t\t\t\t       &sk->sk_v6_rcv_saddr);",
                        "\t\t\tif (sk->sk_prot->rehash)",
                        "\t\t\t\tsk->sk_prot->rehash(sk);",
                        "\t\t}",
                        "",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (__ipv6_addr_needs_scope_id(addr_type)) {",
                        "\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&",
                        "\t\t    usin->sin6_scope_id) {",
                        "\t\t\tif (!sk_dev_equal_l3scope(sk, usin->sin6_scope_id)) {",
                        "\t\t\t\terr = -EINVAL;",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;",
                        "\t\t}",
                        "",
                        "\t\tif (!sk->sk_bound_dev_if && (addr_type & IPV6_ADDR_MULTICAST))",
                        "\t\t\tsk->sk_bound_dev_if = np->mcast_oif;",
                        "",
                        "\t\t/* Connect to link-local address requires an interface */",
                        "\t\tif (!sk->sk_bound_dev_if) {",
                        "\t\t\terr = -EINVAL;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* save the current peer information before updating it */",
                        "\told_daddr = sk->sk_v6_daddr;",
                        "\told_fl6_flowlabel = np->flow_label;",
                        "\told_dport = inet->inet_dport;",
                        "",
                        "\tsk->sk_v6_daddr = *daddr;",
                        "\tnp->flow_label = fl6_flowlabel;",
                        "\tinet->inet_dport = usin->sin6_port;",
                        "",
                        "\t/*",
                        "\t *\tCheck for a route to destination an obtain the",
                        "\t *\tdestination cache for it.",
                        "\t */",
                        "",
                        "\terr = ip6_datagram_dst_update(sk, true);",
                        "\tif (err) {",
                        "\t\t/* Restore the socket peer info, to keep it consistent with",
                        "\t\t * the old socket state",
                        "\t\t */",
                        "\t\tsk->sk_v6_daddr = old_daddr;",
                        "\t\tnp->flow_label = old_fl6_flowlabel;",
                        "\t\tinet->inet_dport = old_dport;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tsk->sk_state = TCP_ESTABLISHED;",
                        "\tsk_set_txhash(sk);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 132,
                    "highlight": 246
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819691b0"
        },
        "7": {
            "name": "__ip6_datagram_connect",
            "parent_idx": 6,
            "source_line": [
                {
                    "file": "net/ipv6/datagram.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/datagram.c?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n269",
                    "code": [
                        "\tlock_sock(sk);",
                        "\tres = __ip6_datagram_connect(sk, uaddr, addr_len);",
                        "\trelease_sock(sk);",
                        "\treturn res;",
                        "}"
                    ],
                    "start": 268,
                    "highlight": 269
                },
                {
                    "file": "net/ipv6/datagram.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/datagram.c?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n281",
                    "code": [
                        "int ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *uaddr,",
                        "\t\t\t\t int addr_len)",
                        "{",
                        "\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, uaddr);",
                        "\tif (sin6->sin6_family != AF_INET6)",
                        "\t\treturn -EAFNOSUPPORT;",
                        "\treturn ip6_datagram_connect(sk, uaddr, addr_len);",
                        "}"
                    ],
                    "start": 275,
                    "highlight": 281
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81969284"
        },
        "6": {
            "name": "ip6_datagram_connect_v6_only(indirect)",
            "parent_idx": 5,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n1824",
                    "code": [
                        "int __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen)",
                        "{",
                        "\tstruct socket *sock;",
                        "\tstruct sockaddr_storage address;",
                        "\tint err, fput_needed;",
                        "",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (!sock)",
                        "\t\tgoto out;",
                        "\terr = move_addr_to_kernel(uservaddr, addrlen, &address);",
                        "\tif (err < 0)",
                        "\t\tgoto out_put;",
                        "",
                        "\terr =",
                        "\t    security_socket_connect(sock, (struct sockaddr *)&address, addrlen);",
                        "\tif (err)",
                        "\t\tgoto out_put;",
                        "",
                        "\terr = sock->ops->connect(sock, (struct sockaddr *)&address, addrlen,",
                        "\t\t\t\t sock->file->f_flags);",
                        "out_put:",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1806,
                    "highlight": 1824
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81815545"
        },
        "5": {
            "name": "__sys_connect",
            "parent_idx": 4,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n1835",
                    "code": [
                        "SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,",
                        "\t\tint, addrlen)",
                        "{",
                        "\treturn __sys_connect(fd, uservaddr, addrlen);",
                        "}"
                    ],
                    "start": 1832,
                    "highlight": 1835
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n1832",
                    "code": [
                        "int __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen)",
                        "{",
                        "\tstruct socket *sock;",
                        "\tstruct sockaddr_storage address;",
                        "\tint err, fput_needed;",
                        "",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (!sock)",
                        "\t\tgoto out;",
                        "\terr = move_addr_to_kernel(uservaddr, addrlen, &address);",
                        "\tif (err < 0)",
                        "\t\tgoto out_put;",
                        "",
                        "\terr =",
                        "\t    security_socket_connect(sock, (struct sockaddr *)&address, addrlen);",
                        "\tif (err)",
                        "\t\tgoto out_put;",
                        "",
                        "\terr = sock->ops->connect(sock, (struct sockaddr *)&address, addrlen,",
                        "\t\t\t\t sock->file->f_flags);",
                        "out_put:",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,",
                        "\t\tint, addrlen)",
                        "{",
                        "\treturn __sys_connect(fd, uservaddr, addrlen);",
                        "}"
                    ],
                    "start": 1806,
                    "highlight": 1832
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8181556c"
        },
        "4": {
            "name": "__x64_sys_connect(indirect)",
            "parent_idx": 3,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n301",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\t/*",
                        "\t * NB: Native and x32 syscalls are dispatched from the same",
                        "\t * table.  The only functional difference is the x32 bit in",
                        "\t * regs->orig_ax, which changes the behavior of some syscalls.",
                        "\t */",
                        "\tnr &= __SYSCALL_MASK;",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 282,
                    "highlight": 301
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8100252e"
        },
        "3": {
            "name": "do_syscall_64",
            "parent_idx": 2,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n175",
                    "code": [
                        "ENTRY(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "GLOBAL(entry_SYSCALL_64_after_hwframe)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "2": {
            "name": "36_syscall_5",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "14": {
            "name": "+0x25f",
            "parent_idx": 8,
            "source_line": [
                {
                    "file": "./include/net/ipv6.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/ipv6.h?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n400",
                    "code": [
                        "extern struct static_key_false_deferred ipv6_flowlabel_exclusive;",
                        "static inline struct ip6_flowlabel *fl6_sock_lookup(struct sock *sk,",
                        "\t\t\t\t\t\t    __be32 label)",
                        "{",
                        "\tif (static_branch_unlikely(&ipv6_flowlabel_exclusive.key))",
                        "\t\treturn __fl6_sock_lookup(sk, label) ? : ERR_PTR(-ENOENT);",
                        "",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 395,
                    "highlight": 400
                },
                {
                    "file": "net/ipv6/datagram.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/datagram.c?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n76",
                    "code": [
                        "int ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr)",
                        "{",
                        "\tstruct ip6_flowlabel *flowlabel = NULL;",
                        "\tstruct in6_addr *final_p, final;",
                        "\tstruct ipv6_txoptions *opt;",
                        "\tstruct dst_entry *dst;",
                        "\tstruct inet_sock *inet = inet_sk(sk);",
                        "\tstruct ipv6_pinfo *np = inet6_sk(sk);",
                        "\tstruct flowi6 fl6;",
                        "\tint err = 0;",
                        "",
                        "\tif (np->sndflow && (np->flow_label & IPV6_FLOWLABEL_MASK)) {",
                        "\t\tflowlabel = fl6_sock_lookup(sk, np->flow_label);",
                        "\t\tif (!flowlabel)",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "\tip6_datagram_flow_key_init(&fl6, sk);",
                        "",
                        "\trcu_read_lock();",
                        "\topt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);",
                        "\tfinal_p = fl6_update_dst(&fl6, opt, &final);",
                        "\trcu_read_unlock();",
                        "",
                        "\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);",
                        "\tif (IS_ERR(dst)) {",
                        "\t\terr = PTR_ERR(dst);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (fix_sk_saddr) {",
                        "\t\tif (ipv6_addr_any(&np->saddr))",
                        "\t\t\tnp->saddr = fl6.saddr;",
                        "",
                        "\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {",
                        "\t\t\tsk->sk_v6_rcv_saddr = fl6.saddr;",
                        "\t\t\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;",
                        "\t\t\tif (sk->sk_prot->rehash)",
                        "\t\t\t\tsk->sk_prot->rehash(sk);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tip6_sk_dst_store_flow(sk, dst, &fl6);",
                        "",
                        "out:",
                        "\tfl6_sock_release(flowlabel);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 64,
                    "highlight": 76
                }
            ],
            "ins_idx": 6,
            "addr": "0xffffffff81968e3f"
        },
        "13": {
            "name": "+0x258",
            "parent_idx": 8,
            "source_line": [
                {
                    "file": "./include/net/ipv6.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/ipv6.h?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n400",
                    "code": [
                        "extern struct static_key_false_deferred ipv6_flowlabel_exclusive;",
                        "static inline struct ip6_flowlabel *fl6_sock_lookup(struct sock *sk,",
                        "\t\t\t\t\t\t    __be32 label)",
                        "{",
                        "\tif (static_branch_unlikely(&ipv6_flowlabel_exclusive.key))",
                        "\t\treturn __fl6_sock_lookup(sk, label) ? : ERR_PTR(-ENOENT);",
                        "",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 395,
                    "highlight": 400
                },
                {
                    "file": "net/ipv6/datagram.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/datagram.c?id=59c820b2317f0ffe1ab9b5d2c0515cdbfe714e6e#n76",
                    "code": [
                        "int ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr)",
                        "{",
                        "\tstruct ip6_flowlabel *flowlabel = NULL;",
                        "\tstruct in6_addr *final_p, final;",
                        "\tstruct ipv6_txoptions *opt;",
                        "\tstruct dst_entry *dst;",
                        "\tstruct inet_sock *inet = inet_sk(sk);",
                        "\tstruct ipv6_pinfo *np = inet6_sk(sk);",
                        "\tstruct flowi6 fl6;",
                        "\tint err = 0;",
                        "",
                        "\tif (np->sndflow && (np->flow_label & IPV6_FLOWLABEL_MASK)) {",
                        "\t\tflowlabel = fl6_sock_lookup(sk, np->flow_label);",
                        "\t\tif (!flowlabel)",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "\tip6_datagram_flow_key_init(&fl6, sk);",
                        "",
                        "\trcu_read_lock();",
                        "\topt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);",
                        "\tfinal_p = fl6_update_dst(&fl6, opt, &final);",
                        "\trcu_read_unlock();",
                        "",
                        "\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);",
                        "\tif (IS_ERR(dst)) {",
                        "\t\terr = PTR_ERR(dst);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (fix_sk_saddr) {",
                        "\t\tif (ipv6_addr_any(&np->saddr))",
                        "\t\t\tnp->saddr = fl6.saddr;",
                        "",
                        "\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {",
                        "\t\t\tsk->sk_v6_rcv_saddr = fl6.saddr;",
                        "\t\t\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;",
                        "\t\t\tif (sk->sk_prot->rehash)",
                        "\t\t\t\tsk->sk_prot->rehash(sk);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tip6_sk_dst_store_flow(sk, dst, &fl6);",
                        "",
                        "out:",
                        "\tfl6_sock_release(flowlabel);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 64,
                    "highlight": 76
                }
            ],
            "ins_idx": 8,
            "addr": "0xffffffff81968e38"
        }
    },
    "ins": {
        "1": {
            "name": "mov rsi, qword ptr [rbx + 0x20]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x1e\nError code as addr: -2",
            "call_idx": 21,
            "inputs": [
                21,
                22
            ],
            "outputs": [
                23
            ]
        },
        "6": {
            "name": "cmove rbx, rax",
            "desc": "",
            "call_idx": 14,
            "inputs": [
                10,
                11
            ],
            "outputs": [
                12
            ]
        },
        "8": {
            "name": "mov rax, -2",
            "desc": "Error code -2 generated",
            "call_idx": 13,
            "inputs": [],
            "outputs": [
                9
            ]
        }
    },
    "data": {
        "21": {
            "name": "RBX",
            "ins_idx": 1,
            "value": "0xfffffffffffffffe",
            "sources": []
        },
        "22": {
            "name": "[0x1e]",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "23": {
            "name": "RSI",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "10": {
            "name": "CC_DEP1",
            "ins_idx": 6,
            "value": "0x0",
            "sources": []
        },
        "11": {
            "name": "RAX",
            "ins_idx": 6,
            "value": "0xfffffffffffffffe",
            "sources": []
        },
        "12": {
            "name": "RBX",
            "ins_idx": 6,
            "value": "0xfffffffffffffffe",
            "sources": [
                21
            ]
        },
        "9": {
            "name": "RAX",
            "ins_idx": 8,
            "value": "0xfffffffffffffffe",
            "sources": [
                11
            ]
        }
    },
    "chain": {
        "1": [
            6
        ],
        "6": [
            8
        ]
    }
}