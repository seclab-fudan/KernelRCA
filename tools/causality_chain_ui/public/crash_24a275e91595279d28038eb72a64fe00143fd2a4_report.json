{
    "report": "https://syzkaller.appspot.com/bug?id=24a275e91595279d28038eb72a64fe00143fd2a4",
    "title": "KASAN: slab-out-of-bounds Read in squashfs_export_iget",
    "call": {
        "14953": {
            "name": "+0xb5",
            "parent_idx": 14940,
            "source_line": [
                {
                    "file": "fs/squashfs/export.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/export.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n44",
                    "code": [
                        "/*",
                        " * Look-up inode number (ino) in table, returning the inode location.",
                        " */",
                        "static long long squashfs_inode_lookup(struct super_block *sb, int ino_num)",
                        "{",
                        "\tstruct squashfs_sb_info *msblk = sb->s_fs_info;",
                        "\tint blk = SQUASHFS_LOOKUP_BLOCK(ino_num - 1);",
                        "\tint offset = SQUASHFS_LOOKUP_BLOCK_OFFSET(ino_num - 1);",
                        "\tu64 start = le64_to_cpu(msblk->inode_lookup_table[blk]);",
                        "\t__le64 ino;",
                        "\tint err;",
                        "",
                        "\tTRACE(\"Entered squashfs_inode_lookup, inode_number = %d\\n\", ino_num);",
                        "",
                        "\terr = squashfs_read_metadata(sb, &ino, &start, &offset, sizeof(ino));",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tTRACE(\"squashfs_inode_lookup, inode = 0x%llx\\n\",",
                        "\t\t(u64) le64_to_cpu(ino));",
                        "",
                        "\treturn le64_to_cpu(ino);",
                        "}"
                    ],
                    "start": 36,
                    "highlight": 44
                },
                {
                    "file": "fs/squashfs/export.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/export.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n69",
                    "code": [
                        "static struct dentry *squashfs_export_iget(struct super_block *sb,",
                        "\tunsigned int ino_num)",
                        "{",
                        "\tlong long ino;",
                        "\tstruct dentry *dentry = ERR_PTR(-ENOENT);",
                        "",
                        "\tTRACE(\"Entered squashfs_export_iget\\n\");",
                        "",
                        "\tino = squashfs_inode_lookup(sb, ino_num);",
                        "\tif (ino >= 0)",
                        "\t\tdentry = d_obtain_alias(squashfs_iget(sb, ino, ino_num));",
                        "",
                        "\treturn dentry;",
                        "}"
                    ],
                    "start": 61,
                    "highlight": 69
                }
            ],
            "ins_idx": 154,
            "addr": "0xffffffff814faf95"
        },
        "14940": {
            "name": "squashfs_fh_to_dentry(indirect)",
            "parent_idx": 14932,
            "source_line": [
                {
                    "file": "fs/exportfs/expfs.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/exportfs/expfs.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n436",
                    "code": [
                        "struct dentry *",
                        "exportfs_decode_fh_raw(struct vfsmount *mnt, struct fid *fid, int fh_len,",
                        "\t\t       int fileid_type,",
                        "\t\t       int (*acceptable)(void *, struct dentry *),",
                        "\t\t       void *context)",
                        "{",
                        "\tconst struct export_operations *nop = mnt->mnt_sb->s_export_op;",
                        "\tstruct dentry *result, *alias;",
                        "\tchar nbuf[NAME_MAX+1];",
                        "\tint err;",
                        "",
                        "\t/*",
                        "\t * Try to get any dentry for the given file handle from the filesystem.",
                        "\t */",
                        "\tif (!nop || !nop->fh_to_dentry)",
                        "\t\treturn ERR_PTR(-ESTALE);",
                        "\tresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);",
                        "\tif (IS_ERR_OR_NULL(result))",
                        "\t\treturn result;",
                        "",
                        "\t/*",
                        "\t * If no acceptance criteria was specified by caller, a disconnected",
                        "\t * dentry is also accepatable. Callers may use this mode to query if",
                        "\t * file handle is stale or to get a reference to an inode without",
                        "\t * risking the high overhead caused by directory reconnect.",
                        "\t */",
                        "\tif (!acceptable)",
                        "\t\treturn result;",
                        "",
                        "\tif (d_is_dir(result)) {",
                        "\t\t/*",
                        "\t\t * This request is for a directory.",
                        "\t\t *",
                        "\t\t * On the positive side there is only one dentry for each",
                        "\t\t * directory inode.  On the negative side this implies that we",
                        "\t\t * to ensure our dentry is connected all the way up to the",
                        "\t\t * filesystem root.",
                        "\t\t */",
                        "\t\tif (result->d_flags & DCACHE_DISCONNECTED) {",
                        "\t\t\terr = reconnect_path(mnt, result, nbuf);",
                        "\t\t\tif (err)",
                        "\t\t\t\tgoto err_result;",
                        "\t\t}",
                        "",
                        "\t\tif (!acceptable(context, result)) {",
                        "\t\t\terr = -EACCES;",
                        "\t\t\tgoto err_result;",
                        "\t\t}",
                        "",
                        "\t\treturn result;",
                        "\t} else {",
                        "\t\t/*",
                        "\t\t * It's not a directory.  Life is a little more complicated.",
                        "\t\t */",
                        "\t\tstruct dentry *target_dir, *nresult;",
                        "",
                        "\t\t/*",
                        "\t\t * See if either the dentry we just got from the filesystem",
                        "\t\t * or any alias for it is acceptable.  This is always true",
                        "\t\t * if this filesystem is exported without the subtreecheck",
                        "\t\t * option.  If the filesystem is exported with the subtree",
                        "\t\t * check option there's a fair chance we need to look at",
                        "\t\t * the parent directory in the file handle and make sure",
                        "\t\t * it's connected to the filesystem root.",
                        "\t\t */",
                        "\t\talias = find_acceptable_alias(result, acceptable, context);",
                        "\t\tif (alias)",
                        "\t\t\treturn alias;",
                        "",
                        "\t\t/*",
                        "\t\t * Try to extract a dentry for the parent directory from the",
                        "\t\t * file handle.  If this fails we'll have to give up.",
                        "\t\t */",
                        "\t\terr = -ESTALE;",
                        "\t\tif (!nop->fh_to_parent)",
                        "\t\t\tgoto err_result;",
                        "",
                        "\t\ttarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,",
                        "\t\t\t\tfh_len, fileid_type);",
                        "\t\tif (!target_dir)",
                        "\t\t\tgoto err_result;",
                        "\t\terr = PTR_ERR(target_dir);",
                        "\t\tif (IS_ERR(target_dir))",
                        "\t\t\tgoto err_result;",
                        "",
                        "\t\t/*",
                        "\t\t * And as usual we need to make sure the parent directory is",
                        "\t\t * connected to the filesystem root.  The VFS really doesn't",
                        "\t\t * like disconnected directories..",
                        "\t\t */",
                        "\t\terr = reconnect_path(mnt, target_dir, nbuf);",
                        "\t\tif (err) {",
                        "\t\t\tdput(target_dir);",
                        "\t\t\tgoto err_result;",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * Now that we've got both a well-connected parent and a",
                        "\t\t * dentry for the inode we're after, make sure that our",
                        "\t\t * inode is actually connected to the parent.",
                        "\t\t */",
                        "\t\terr = exportfs_get_name(mnt, target_dir, nbuf, result);",
                        "\t\tif (err) {",
                        "\t\t\tdput(target_dir);",
                        "\t\t\tgoto err_result;",
                        "\t\t}",
                        "",
                        "\t\tinode_lock(target_dir->d_inode);",
                        "\t\tnresult = lookup_one_len(nbuf, target_dir, strlen(nbuf));",
                        "\t\tif (!IS_ERR(nresult)) {",
                        "\t\t\tif (unlikely(nresult->d_inode != result->d_inode)) {",
                        "\t\t\t\tdput(nresult);",
                        "\t\t\t\tnresult = ERR_PTR(-ESTALE);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tinode_unlock(target_dir->d_inode);",
                        "\t\t/*",
                        "\t\t * At this point we are done with the parent, but it's pinned",
                        "\t\t * by the child dentry anyway.",
                        "\t\t */",
                        "\t\tdput(target_dir);",
                        "",
                        "\t\tif (IS_ERR(nresult)) {",
                        "\t\t\terr = PTR_ERR(nresult);",
                        "\t\t\tgoto err_result;",
                        "\t\t}",
                        "\t\tdput(result);",
                        "\t\tresult = nresult;",
                        "",
                        "\t\t/*",
                        "\t\t * And finally make sure the dentry is actually acceptable",
                        "\t\t * to NFSD.",
                        "\t\t */",
                        "\t\talias = find_acceptable_alias(result, acceptable, context);",
                        "\t\tif (!alias) {",
                        "\t\t\terr = -EACCES;",
                        "\t\t\tgoto err_result;",
                        "\t\t}",
                        "",
                        "\t\treturn alias;",
                        "\t}",
                        "",
                        " err_result:",
                        "\tdput(result);",
                        "\treturn ERR_PTR(err);",
                        "}"
                    ],
                    "start": 420,
                    "highlight": 436
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff815a7b85"
        },
        "14932": {
            "name": "exportfs_decode_fh_raw",
            "parent_idx": 14931,
            "source_line": [
                {
                    "file": "fs/exportfs/expfs.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/exportfs/expfs.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n575",
                    "code": [
                        "struct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,",
                        "\t\t\t\t  int fh_len, int fileid_type,",
                        "\t\t\t\t  int (*acceptable)(void *, struct dentry *),",
                        "\t\t\t\t  void *context)",
                        "{",
                        "\tstruct dentry *ret;",
                        "",
                        "\tret = exportfs_decode_fh_raw(mnt, fid, fh_len, fileid_type,",
                        "\t\t\t\t     acceptable, context);",
                        "\tif (IS_ERR_OR_NULL(ret)) {",
                        "\t\tif (ret == ERR_PTR(-ENOMEM))",
                        "\t\t\treturn ret;",
                        "\t\treturn ERR_PTR(-ESTALE);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 568,
                    "highlight": 575
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff815a7f70"
        },
        "14931": {
            "name": "exportfs_decode_fh",
            "parent_idx": 14857,
            "source_line": [
                {
                    "file": "fs/fhandle.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fhandle.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n152",
                    "code": [
                        "static int do_handle_to_path(int mountdirfd, struct file_handle *handle,",
                        "\t\t\t     struct path *path)",
                        "{",
                        "\tint retval = 0;",
                        "\tint handle_dwords;",
                        "",
                        "\tpath->mnt = get_vfsmount_from_fd(mountdirfd);",
                        "\tif (IS_ERR(path->mnt)) {",
                        "\t\tretval = PTR_ERR(path->mnt);",
                        "\t\tgoto out_err;",
                        "\t}",
                        "\t/* change the handle size to multiple of sizeof(u32) */",
                        "\thandle_dwords = handle->handle_bytes >> 2;",
                        "\tpath->dentry = exportfs_decode_fh(path->mnt,",
                        "\t\t\t\t\t  (struct fid *)handle->f_handle,",
                        "\t\t\t\t\t  handle_dwords, handle->handle_type,",
                        "\t\t\t\t\t  vfs_dentry_acceptable, NULL);",
                        "\tif (IS_ERR(path->dentry)) {",
                        "\t\tretval = PTR_ERR(path->dentry);",
                        "\t\tgoto out_mnt;",
                        "\t}",
                        "\treturn 0;",
                        "out_mnt:",
                        "\tmntput(path->mnt);",
                        "out_err:",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 139,
                    "highlight": 152
                },
                {
                    "file": "fs/fhandle.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fhandle.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n207",
                    "code": [
                        "\tretval = do_handle_to_path(mountdirfd, handle, path);",
                        "",
                        "out_handle:",
                        "\tkfree(handle);",
                        "out_err:",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 207,
                    "highlight": 207
                },
                {
                    "file": "fs/fhandle.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fhandle.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n223",
                    "code": [
                        "static long do_handle_open(int mountdirfd, struct file_handle __user *ufh,",
                        "\t\t\t   int open_flag)",
                        "{",
                        "\tlong retval = 0;",
                        "\tstruct path path;",
                        "\tstruct file *file;",
                        "\tint fd;",
                        "",
                        "\tretval = handle_to_path(mountdirfd, ufh, &path);",
                        "\tif (retval)",
                        "\t\treturn retval;",
                        "",
                        "\tfd = get_unused_fd_flags(open_flag);",
                        "\tif (fd < 0) {",
                        "\t\tpath_put(&path);",
                        "\t\treturn fd;",
                        "\t}",
                        "\tfile = file_open_root(path.dentry, path.mnt, \"\", open_flag, 0);",
                        "\tif (IS_ERR(file)) {",
                        "\t\tput_unused_fd(fd);",
                        "\t\tretval =  PTR_ERR(file);",
                        "\t} else {",
                        "\t\tretval = fd;",
                        "\t\tfsnotify_open(file);",
                        "\t\tfd_install(fd, file);",
                        "\t}",
                        "\tpath_put(&path);",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 215,
                    "highlight": 223
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff813e9b9a"
        },
        "14857": {
            "name": "__x64_sys_open_by_handle_at(indirect)",
            "parent_idx": 14854,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8233d79e"
        },
        "14854": {
            "name": "do_syscall_64",
            "parent_idx": 14844,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "14844": {
            "name": "775_syscall_15",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "14952": {
            "name": "+0xa9",
            "parent_idx": 14940,
            "source_line": [
                {
                    "file": "fs/squashfs/export.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/export.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n44",
                    "code": [
                        "/*",
                        " * Look-up inode number (ino) in table, returning the inode location.",
                        " */",
                        "static long long squashfs_inode_lookup(struct super_block *sb, int ino_num)",
                        "{",
                        "\tstruct squashfs_sb_info *msblk = sb->s_fs_info;",
                        "\tint blk = SQUASHFS_LOOKUP_BLOCK(ino_num - 1);",
                        "\tint offset = SQUASHFS_LOOKUP_BLOCK_OFFSET(ino_num - 1);",
                        "\tu64 start = le64_to_cpu(msblk->inode_lookup_table[blk]);",
                        "\t__le64 ino;",
                        "\tint err;",
                        "",
                        "\tTRACE(\"Entered squashfs_inode_lookup, inode_number = %d\\n\", ino_num);",
                        "",
                        "\terr = squashfs_read_metadata(sb, &ino, &start, &offset, sizeof(ino));",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tTRACE(\"squashfs_inode_lookup, inode = 0x%llx\\n\",",
                        "\t\t(u64) le64_to_cpu(ino));",
                        "",
                        "\treturn le64_to_cpu(ino);",
                        "}"
                    ],
                    "start": 36,
                    "highlight": 44
                },
                {
                    "file": "fs/squashfs/export.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/export.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n69",
                    "code": [
                        "static struct dentry *squashfs_export_iget(struct super_block *sb,",
                        "\tunsigned int ino_num)",
                        "{",
                        "\tlong long ino;",
                        "\tstruct dentry *dentry = ERR_PTR(-ENOENT);",
                        "",
                        "\tTRACE(\"Entered squashfs_export_iget\\n\");",
                        "",
                        "\tino = squashfs_inode_lookup(sb, ino_num);",
                        "\tif (ino >= 0)",
                        "\t\tdentry = d_obtain_alias(squashfs_iget(sb, ino, ino_num));",
                        "",
                        "\treturn dentry;",
                        "}"
                    ],
                    "start": 61,
                    "highlight": 69
                }
            ],
            "ins_idx": 309,
            "addr": "0xffffffff814faf89"
        },
        "14951": {
            "name": "+0xa5",
            "parent_idx": 14940,
            "source_line": [
                {
                    "file": "fs/squashfs/export.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/export.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n44",
                    "code": [
                        "/*",
                        " * Look-up inode number (ino) in table, returning the inode location.",
                        " */",
                        "static long long squashfs_inode_lookup(struct super_block *sb, int ino_num)",
                        "{",
                        "\tstruct squashfs_sb_info *msblk = sb->s_fs_info;",
                        "\tint blk = SQUASHFS_LOOKUP_BLOCK(ino_num - 1);",
                        "\tint offset = SQUASHFS_LOOKUP_BLOCK_OFFSET(ino_num - 1);",
                        "\tu64 start = le64_to_cpu(msblk->inode_lookup_table[blk]);",
                        "\t__le64 ino;",
                        "\tint err;",
                        "",
                        "\tTRACE(\"Entered squashfs_inode_lookup, inode_number = %d\\n\", ino_num);",
                        "",
                        "\terr = squashfs_read_metadata(sb, &ino, &start, &offset, sizeof(ino));",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tTRACE(\"squashfs_inode_lookup, inode = 0x%llx\\n\",",
                        "\t\t(u64) le64_to_cpu(ino));",
                        "",
                        "\treturn le64_to_cpu(ino);",
                        "}"
                    ],
                    "start": 36,
                    "highlight": 44
                },
                {
                    "file": "fs/squashfs/export.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/export.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n69",
                    "code": [
                        "static struct dentry *squashfs_export_iget(struct super_block *sb,",
                        "\tunsigned int ino_num)",
                        "{",
                        "\tlong long ino;",
                        "\tstruct dentry *dentry = ERR_PTR(-ENOENT);",
                        "",
                        "\tTRACE(\"Entered squashfs_export_iget\\n\");",
                        "",
                        "\tino = squashfs_inode_lookup(sb, ino_num);",
                        "\tif (ino >= 0)",
                        "\t\tdentry = d_obtain_alias(squashfs_iget(sb, ino, ino_num));",
                        "",
                        "\treturn dentry;",
                        "}"
                    ],
                    "start": 61,
                    "highlight": 69
                }
            ],
            "ins_idx": 467,
            "addr": "0xffffffff814faf85"
        },
        "6261": {
            "name": "+0x74f",
            "parent_idx": 5094,
            "source_line": [
                {
                    "file": "fs/squashfs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/super.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n255",
                    "code": [
                        "static int squashfs_fill_super(struct super_block *sb, struct fs_context *fc)",
                        "{",
                        "\tstruct squashfs_sb_info *msblk;",
                        "\tstruct squashfs_super_block *sblk = NULL;",
                        "\tstruct inode *root;",
                        "\tlong long root_inode;",
                        "\tunsigned short flags;",
                        "\tunsigned int fragments;",
                        "\tu64 lookup_table_start, xattr_id_table_start, next_table;",
                        "\tint err;",
                        "",
                        "\tTRACE(\"Entered squashfs_fill_superblock\\n\");",
                        "",
                        "\tsb->s_fs_info = kzalloc(sizeof(*msblk), GFP_KERNEL);",
                        "\tif (sb->s_fs_info == NULL) {",
                        "\t\tERROR(\"Failed to allocate squashfs_sb_info\\n\");",
                        "\t\treturn -ENOMEM;",
                        "\t}",
                        "\tmsblk = sb->s_fs_info;",
                        "",
                        "\tmsblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);",
                        "\tmsblk->devblksize_log2 = ffz(~msblk->devblksize);",
                        "",
                        "\tmutex_init(&msblk->meta_index_mutex);",
                        "",
                        "\t/*",
                        "\t * msblk->bytes_used is checked in squashfs_read_table to ensure reads",
                        "\t * are not beyond filesystem end.  But as we're using",
                        "\t * squashfs_read_table here to read the superblock (including the value",
                        "\t * of bytes_used) we need to set it to an initial sensible dummy value",
                        "\t */",
                        "\tmsblk->bytes_used = sizeof(*sblk);",
                        "\tsblk = squashfs_read_table(sb, SQUASHFS_START, sizeof(*sblk));",
                        "",
                        "\tif (IS_ERR(sblk)) {",
                        "\t\terrorf(fc, \"unable to read squashfs_super_block\");",
                        "\t\terr = PTR_ERR(sblk);",
                        "\t\tsblk = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\terr = -EINVAL;",
                        "",
                        "\t/* Check it is a SQUASHFS superblock */",
                        "\tsb->s_magic = le32_to_cpu(sblk->s_magic);",
                        "\tif (sb->s_magic != SQUASHFS_MAGIC) {",
                        "\t\tif (!(fc->sb_flags & SB_SILENT))",
                        "\t\t\terrorf(fc, \"Can't find a SQUASHFS superblock on %pg\",",
                        "\t\t\t       sb->s_bdev);",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\t/* Check the MAJOR & MINOR versions and lookup compression type */",
                        "\tmsblk->decompressor = supported_squashfs_filesystem(",
                        "\t\t\tfc,",
                        "\t\t\tle16_to_cpu(sblk->s_major),",
                        "\t\t\tle16_to_cpu(sblk->s_minor),",
                        "\t\t\tle16_to_cpu(sblk->compression));",
                        "\tif (msblk->decompressor == NULL)",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Check the filesystem does not extend beyond the end of the",
                        "\t   block device */",
                        "\tmsblk->bytes_used = le64_to_cpu(sblk->bytes_used);",
                        "\tif (msblk->bytes_used < 0 || msblk->bytes_used >",
                        "\t\t\ti_size_read(sb->s_bdev->bd_inode))",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Check block size for sanity */",
                        "\tmsblk->block_size = le32_to_cpu(sblk->block_size);",
                        "\tif (msblk->block_size > SQUASHFS_FILE_MAX_SIZE)",
                        "\t\tgoto insanity;",
                        "",
                        "\t/*",
                        "\t * Check the system page size is not larger than the filesystem",
                        "\t * block size (by default 128K).  This is currently not supported.",
                        "\t */",
                        "\tif (PAGE_SIZE > msblk->block_size) {",
                        "\t\terrorf(fc, \"Page size > filesystem block size (%d).  This is \"",
                        "\t\t       \"currently not supported!\", msblk->block_size);",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\t/* Check block log for sanity */",
                        "\tmsblk->block_log = le16_to_cpu(sblk->block_log);",
                        "\tif (msblk->block_log > SQUASHFS_FILE_MAX_LOG)",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Check that block_size and block_log match */",
                        "\tif (msblk->block_size != (1 << msblk->block_log))",
                        "\t\tgoto insanity;",
                        "",
                        "\t/* Check the root inode for sanity */",
                        "\troot_inode = le64_to_cpu(sblk->root_inode);",
                        "\tif (SQUASHFS_INODE_OFFSET(root_inode) > SQUASHFS_METADATA_SIZE)",
                        "\t\tgoto insanity;",
                        "",
                        "\tmsblk->inode_table = le64_to_cpu(sblk->inode_table_start);",
                        "\tmsblk->directory_table = le64_to_cpu(sblk->directory_table_start);",
                        "\tmsblk->inodes = le32_to_cpu(sblk->inodes);",
                        "\tmsblk->fragments = le32_to_cpu(sblk->fragments);",
                        "\tflags = le16_to_cpu(sblk->flags);",
                        "",
                        "\tTRACE(\"Found valid superblock on %pg\\n\", sb->s_bdev);",
                        "\tTRACE(\"Inodes are %scompressed\\n\", SQUASHFS_UNCOMPRESSED_INODES(flags)",
                        "\t\t\t\t? \"un\" : \"\");",
                        "\tTRACE(\"Data is %scompressed\\n\", SQUASHFS_UNCOMPRESSED_DATA(flags)",
                        "\t\t\t\t? \"un\" : \"\");",
                        "\tTRACE(\"Filesystem size %lld bytes\\n\", msblk->bytes_used);",
                        "\tTRACE(\"Block size %d\\n\", msblk->block_size);",
                        "\tTRACE(\"Number of inodes %d\\n\", msblk->inodes);",
                        "\tTRACE(\"Number of fragments %d\\n\", msblk->fragments);",
                        "\tTRACE(\"Number of ids %d\\n\", le16_to_cpu(sblk->no_ids));",
                        "\tTRACE(\"sblk->inode_table_start %llx\\n\", msblk->inode_table);",
                        "\tTRACE(\"sblk->directory_table_start %llx\\n\", msblk->directory_table);",
                        "\tTRACE(\"sblk->fragment_table_start %llx\\n\",",
                        "\t\t(u64) le64_to_cpu(sblk->fragment_table_start));",
                        "\tTRACE(\"sblk->id_table_start %llx\\n\",",
                        "\t\t(u64) le64_to_cpu(sblk->id_table_start));",
                        "",
                        "\tsb->s_maxbytes = MAX_LFS_FILESIZE;",
                        "\tsb->s_time_min = 0;",
                        "\tsb->s_time_max = U32_MAX;",
                        "\tsb->s_flags |= SB_RDONLY;",
                        "\tsb->s_op = &squashfs_super_ops;",
                        "",
                        "\terr = -ENOMEM;",
                        "",
                        "\tmsblk->block_cache = squashfs_cache_init(\"metadata\",",
                        "\t\t\tSQUASHFS_CACHED_BLKS, SQUASHFS_METADATA_SIZE);",
                        "\tif (msblk->block_cache == NULL)",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Allocate read_page block */",
                        "\tmsblk->read_page = squashfs_cache_init(\"data\",",
                        "\t\tsquashfs_max_decompressors(), msblk->block_size);",
                        "\tif (msblk->read_page == NULL) {",
                        "\t\terrorf(fc, \"Failed to allocate read_page block\");",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\tmsblk->stream = squashfs_decompressor_setup(sb, flags);",
                        "\tif (IS_ERR(msblk->stream)) {",
                        "\t\terr = PTR_ERR(msblk->stream);",
                        "\t\tmsblk->stream = NULL;",
                        "\t\tgoto insanity;",
                        "\t}",
                        "",
                        "\t/* Handle xattrs */",
                        "\tsb->s_xattr = squashfs_xattr_handlers;",
                        "\txattr_id_table_start = le64_to_cpu(sblk->xattr_id_table_start);",
                        "\tif (xattr_id_table_start == SQUASHFS_INVALID_BLK) {",
                        "\t\tnext_table = msblk->bytes_used;",
                        "\t\tgoto allocate_id_index_table;",
                        "\t}",
                        "",
                        "\t/* Allocate and read xattr id lookup table */",
                        "\tmsblk->xattr_id_table = squashfs_read_xattr_id_table(sb,",
                        "\t\txattr_id_table_start, &msblk->xattr_table, &msblk->xattr_ids);",
                        "\tif (IS_ERR(msblk->xattr_id_table)) {",
                        "\t\terrorf(fc, \"unable to read xattr id index table\");",
                        "\t\terr = PTR_ERR(msblk->xattr_id_table);",
                        "\t\tmsblk->xattr_id_table = NULL;",
                        "\t\tif (err != -ENOTSUPP)",
                        "\t\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = msblk->xattr_table;",
                        "",
                        "allocate_id_index_table:",
                        "\t/* Allocate and read id index table */",
                        "\tmsblk->id_table = squashfs_read_id_index_table(sb,",
                        "\t\tle64_to_cpu(sblk->id_table_start), next_table,",
                        "\t\tle16_to_cpu(sblk->no_ids));",
                        "\tif (IS_ERR(msblk->id_table)) {",
                        "\t\terrorf(fc, \"unable to read id index table\");",
                        "\t\terr = PTR_ERR(msblk->id_table);",
                        "\t\tmsblk->id_table = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = le64_to_cpu(msblk->id_table[0]);",
                        "",
                        "\t/* Handle inode lookup table */",
                        "\tlookup_table_start = le64_to_cpu(sblk->lookup_table_start);",
                        "\tif (lookup_table_start == SQUASHFS_INVALID_BLK)",
                        "\t\tgoto handle_fragments;",
                        "",
                        "\t/* Allocate and read inode lookup table */",
                        "\tmsblk->inode_lookup_table = squashfs_read_inode_lookup_table(sb,",
                        "\t\tlookup_table_start, next_table, msblk->inodes);",
                        "\tif (IS_ERR(msblk->inode_lookup_table)) {",
                        "\t\terrorf(fc, \"unable to read inode lookup table\");",
                        "\t\terr = PTR_ERR(msblk->inode_lookup_table);",
                        "\t\tmsblk->inode_lookup_table = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = le64_to_cpu(msblk->inode_lookup_table[0]);",
                        "",
                        "\tsb->s_export_op = &squashfs_export_ops;",
                        "",
                        "handle_fragments:",
                        "\tfragments = msblk->fragments;",
                        "\tif (fragments == 0)",
                        "\t\tgoto check_directory_table;",
                        "",
                        "\tmsblk->fragment_cache = squashfs_cache_init(\"fragment\",",
                        "\t\tSQUASHFS_CACHED_FRAGMENTS, msblk->block_size);",
                        "\tif (msblk->fragment_cache == NULL) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\t/* Allocate and read fragment index table */",
                        "\tmsblk->fragment_index = squashfs_read_fragment_index_table(sb,",
                        "\t\tle64_to_cpu(sblk->fragment_table_start), next_table, fragments);",
                        "\tif (IS_ERR(msblk->fragment_index)) {",
                        "\t\terrorf(fc, \"unable to read fragment index table\");",
                        "\t\terr = PTR_ERR(msblk->fragment_index);",
                        "\t\tmsblk->fragment_index = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = le64_to_cpu(msblk->fragment_index[0]);",
                        "",
                        "check_directory_table:",
                        "\t/* Sanity check directory_table */",
                        "\tif (msblk->directory_table > next_table) {",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto insanity;",
                        "\t}",
                        "",
                        "\t/* Sanity check inode_table */",
                        "\tif (msblk->inode_table >= msblk->directory_table) {",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto insanity;",
                        "\t}",
                        "",
                        "\t/* allocate root */",
                        "\troot = new_inode(sb);",
                        "\tif (!root) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\terr = squashfs_read_inode(root, root_inode);",
                        "\tif (err) {",
                        "\t\tmake_bad_inode(root);",
                        "\t\tiput(root);",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tinsert_inode_hash(root);",
                        "",
                        "\tsb->s_root = d_make_root(root);",
                        "\tif (sb->s_root == NULL) {",
                        "\t\tERROR(\"Root inode create failed\\n\");",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\tTRACE(\"Leaving squashfs_fill_super\\n\");",
                        "\tkfree(sblk);",
                        "\treturn 0;",
                        "",
                        "insanity:",
                        "\terrorf(fc, \"squashfs image failed sanity check\");",
                        "failed_mount:",
                        "\tsquashfs_cache_delete(msblk->block_cache);",
                        "\tsquashfs_cache_delete(msblk->fragment_cache);",
                        "\tsquashfs_cache_delete(msblk->read_page);",
                        "\tsquashfs_decompressor_destroy(msblk);",
                        "\tkfree(msblk->inode_lookup_table);",
                        "\tkfree(msblk->fragment_index);",
                        "\tkfree(msblk->id_table);",
                        "\tkfree(msblk->xattr_id_table);",
                        "\tkfree(sb->s_fs_info);",
                        "\tsb->s_fs_info = NULL;",
                        "\tkfree(sblk);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 68,
                    "highlight": 255
                }
            ],
            "ins_idx": 654,
            "addr": "0xffffffff814fe0ff"
        },
        "5094": {
            "name": "squashfs_fill_super(indirect)",
            "parent_idx": 4427,
            "source_line": [
                {
                    "file": "fs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/super.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n1291",
                    "code": [
                        "/**",
                        " * get_tree_bdev - Get a superblock based on a single block device",
                        " * @fc: The filesystem context holding the parameters",
                        " * @fill_super: Helper to initialise a new superblock",
                        " */",
                        "int get_tree_bdev(struct fs_context *fc,",
                        "\t\tint (*fill_super)(struct super_block *,",
                        "\t\t\t\t  struct fs_context *))",
                        "{",
                        "\tstruct block_device *bdev;",
                        "\tstruct super_block *s;",
                        "\tfmode_t mode = FMODE_READ | FMODE_EXCL;",
                        "\tint error = 0;",
                        "",
                        "\tif (!(fc->sb_flags & SB_RDONLY))",
                        "\t\tmode |= FMODE_WRITE;",
                        "",
                        "\tif (!fc->source)",
                        "\t\treturn invalf(fc, \"No source specified\");",
                        "",
                        "\tbdev = blkdev_get_by_path(fc->source, mode, fc->fs_type);",
                        "\tif (IS_ERR(bdev)) {",
                        "\t\terrorf(fc, \"%s: Can't open blockdev\", fc->source);",
                        "\t\treturn PTR_ERR(bdev);",
                        "\t}",
                        "",
                        "\t/* Once the superblock is inserted into the list by sget_fc(), s_umount",
                        "\t * will protect the lockfs code from trying to start a snapshot while",
                        "\t * we are mounting",
                        "\t */",
                        "\tmutex_lock(&bdev->bd_fsfreeze_mutex);",
                        "\tif (bdev->bd_fsfreeze_count > 0) {",
                        "\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);",
                        "\t\twarnf(fc, \"%pg: Can't mount, blockdev is frozen\", bdev);",
                        "\t\tblkdev_put(bdev, mode);",
                        "\t\treturn -EBUSY;",
                        "\t}",
                        "",
                        "\tfc->sb_flags |= SB_NOSEC;",
                        "\tfc->sget_key = bdev;",
                        "\ts = sget_fc(fc, test_bdev_super_fc, set_bdev_super_fc);",
                        "\tmutex_unlock(&bdev->bd_fsfreeze_mutex);",
                        "\tif (IS_ERR(s)) {",
                        "\t\tblkdev_put(bdev, mode);",
                        "\t\treturn PTR_ERR(s);",
                        "\t}",
                        "",
                        "\tif (s->s_root) {",
                        "\t\t/* Don't summarily change the RO/RW state. */",
                        "\t\tif ((fc->sb_flags ^ s->s_flags) & SB_RDONLY) {",
                        "\t\t\twarnf(fc, \"%pg: Can't mount, would change RO state\", bdev);",
                        "\t\t\tdeactivate_locked_super(s);",
                        "\t\t\tblkdev_put(bdev, mode);",
                        "\t\t\treturn -EBUSY;",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * s_umount nests inside bd_mutex during",
                        "\t\t * __invalidate_device().  blkdev_put() acquires",
                        "\t\t * bd_mutex and can't be called under s_umount.  Drop",
                        "\t\t * s_umount temporarily.  This is safe as we're",
                        "\t\t * holding an active reference.",
                        "\t\t */",
                        "\t\tup_write(&s->s_umount);",
                        "\t\tblkdev_put(bdev, mode);",
                        "\t\tdown_write(&s->s_umount);",
                        "\t} else {",
                        "\t\ts->s_mode = mode;",
                        "\t\tsnprintf(s->s_id, sizeof(s->s_id), \"%pg\", bdev);",
                        "\t\tsb_set_blocksize(s, block_size(bdev));",
                        "\t\terror = fill_super(s, fc);",
                        "\t\tif (error) {",
                        "\t\t\tdeactivate_locked_super(s);",
                        "\t\t\treturn error;",
                        "\t\t}",
                        "",
                        "\t\ts->s_flags |= SB_ACTIVE;",
                        "\t\tbdev->bd_super = s;",
                        "\t}",
                        "",
                        "\tBUG_ON(fc->root);",
                        "\tfc->root = dget(s->s_root);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1221,
                    "highlight": 1291
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8132580f"
        },
        "4427": {
            "name": "get_tree_bdev(indirect)",
            "parent_idx": 4422,
            "source_line": [
                {
                    "file": "fs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/super.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n1496",
                    "code": [
                        "/**",
                        " * vfs_get_tree - Get the mountable root",
                        " * @fc: The superblock configuration context.",
                        " *",
                        " * The filesystem is invoked to get or create a superblock which can then later",
                        " * be used for mounting.  The filesystem places a pointer to the root to be",
                        " * used for mounting in @fc->root.",
                        " */",
                        "int vfs_get_tree(struct fs_context *fc)",
                        "{",
                        "\tstruct super_block *sb;",
                        "\tint error;",
                        "",
                        "\tif (fc->root)",
                        "\t\treturn -EBUSY;",
                        "",
                        "\t/* Get the mountable root in fc->root, with a ref on the root and a ref",
                        "\t * on the superblock.",
                        "\t */",
                        "\terror = fc->ops->get_tree(fc);",
                        "\tif (error < 0)",
                        "\t\treturn error;",
                        "",
                        "\tif (!fc->root) {",
                        "\t\tpr_err(\"Filesystem %s get_tree() didn't set fc->root\\n\",",
                        "\t\t       fc->fs_type->name);",
                        "\t\t/* We don't know what the locking state of the superblock is -",
                        "\t\t * if there is a superblock.",
                        "\t\t */",
                        "\t\tBUG();",
                        "\t}",
                        "",
                        "\tsb = fc->root->d_sb;",
                        "\tWARN_ON(!sb->s_bdi);",
                        "",
                        "\t/*",
                        "\t * Write barrier is for super_cache_count(). We place it before setting",
                        "\t * SB_BORN as the data dependency between the two functions is the",
                        "\t * superblock structure contents that we just set up, not the SB_BORN",
                        "\t * flag.",
                        "\t */",
                        "\tsmp_wmb();",
                        "\tsb->s_flags |= SB_BORN;",
                        "",
                        "\terror = security_sb_set_mnt_opts(sb, fc->security, 0, NULL);",
                        "\tif (unlikely(error)) {",
                        "\t\tfc_drop_locked(fc);",
                        "\t\treturn error;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * filesystems should never set s_maxbytes larger than MAX_LFS_FILESIZE",
                        "\t * but s_maxbytes was an unsigned long long for many releases. Throw",
                        "\t * this warning for a little while to try and catch filesystems that",
                        "\t * violate this rule.",
                        "\t */",
                        "\tWARN((sb->s_maxbytes < 0), \"%s set sb->s_maxbytes to \"",
                        "\t\t\"negative value (%lld)\\n\", fc->fs_type->name, sb->s_maxbytes);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1477,
                    "highlight": 1496
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81323d2c"
        },
        "4422": {
            "name": "vfs_get_tree",
            "parent_idx": 4230,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n2878",
                    "code": [
                        "/*",
                        " * create a new mount for userspace and request it to be added into the",
                        " * namespace's tree",
                        " */",
                        "static int do_new_mount(struct path *path, const char *fstype, int sb_flags,",
                        "\t\t\tint mnt_flags, const char *name, void *data)",
                        "{",
                        "\tstruct file_system_type *type;",
                        "\tstruct fs_context *fc;",
                        "\tconst char *subtype = NULL;",
                        "\tint err = 0;",
                        "",
                        "\tif (!fstype)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\ttype = get_fs_type(fstype);",
                        "\tif (!type)",
                        "\t\treturn -ENODEV;",
                        "",
                        "\tif (type->fs_flags & FS_HAS_SUBTYPE) {",
                        "\t\tsubtype = strchr(fstype, '.');",
                        "\t\tif (subtype) {",
                        "\t\t\tsubtype++;",
                        "\t\t\tif (!*subtype) {",
                        "\t\t\t\tput_filesystem(type);",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tfc = fs_context_for_mount(type, sb_flags);",
                        "\tput_filesystem(type);",
                        "\tif (IS_ERR(fc))",
                        "\t\treturn PTR_ERR(fc);",
                        "",
                        "\tif (subtype)",
                        "\t\terr = vfs_parse_fs_string(fc, \"subtype\",",
                        "\t\t\t\t\t  subtype, strlen(subtype));",
                        "\tif (!err && name)",
                        "\t\terr = vfs_parse_fs_string(fc, \"source\", name, strlen(name));",
                        "\tif (!err)",
                        "\t\terr = parse_monolithic_mount_data(fc, data);",
                        "\tif (!err && !mount_capable(fc))",
                        "\t\terr = -EPERM;",
                        "\tif (!err)",
                        "\t\terr = vfs_get_tree(fc);",
                        "\tif (!err)",
                        "\t\terr = do_new_mount_fc(fc, path, mnt_flags);",
                        "",
                        "\tput_fs_context(fc);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2833,
                    "highlight": 2878
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n3208",
                    "code": [
                        "/*",
                        " * Flags is a 32-bit value that allows up to 31 non-fs dependent flags to",
                        " * be given to the mount() call (ie: read-only, no-dev, no-suid etc).",
                        " *",
                        " * data is a (void *) that can point to any structure up to",
                        " * PAGE_SIZE-1 bytes, which can contain arbitrary fs-dependent",
                        " * information (or be NULL).",
                        " *",
                        " * Pre-0.97 versions of mount() didn't have a flags word.",
                        " * When the flags word was introduced its top half was required",
                        " * to have the magic value 0xC0ED, and this remained so until 2.4.0-test9.",
                        " * Therefore, if this magic number is present, it carries no information",
                        " * and must be discarded.",
                        " */",
                        "int path_mount(const char *dev_name, struct path *path,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tunsigned int mnt_flags = 0, sb_flags;",
                        "\tint ret;",
                        "",
                        "\t/* Discard magic */",
                        "\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)",
                        "\t\tflags &= ~MS_MGC_MSK;",
                        "",
                        "\t/* Basic sanity checks */",
                        "\tif (data_page)",
                        "\t\t((char *)data_page)[PAGE_SIZE - 1] = 0;",
                        "",
                        "\tif (flags & MS_NOUSER)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tret = security_sb_mount(dev_name, path, type_page, flags, data_page);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tif (!may_mount())",
                        "\t\treturn -EPERM;",
                        "\tif ((flags & SB_MANDLOCK) && !may_mandlock())",
                        "\t\treturn -EPERM;",
                        "",
                        "\t/* Default to relatime unless overriden */",
                        "\tif (!(flags & MS_NOATIME))",
                        "\t\tmnt_flags |= MNT_RELATIME;",
                        "",
                        "\t/* Separate the per-mountpoint flags */",
                        "\tif (flags & MS_NOSUID)",
                        "\t\tmnt_flags |= MNT_NOSUID;",
                        "\tif (flags & MS_NODEV)",
                        "\t\tmnt_flags |= MNT_NODEV;",
                        "\tif (flags & MS_NOEXEC)",
                        "\t\tmnt_flags |= MNT_NOEXEC;",
                        "\tif (flags & MS_NOATIME)",
                        "\t\tmnt_flags |= MNT_NOATIME;",
                        "\tif (flags & MS_NODIRATIME)",
                        "\t\tmnt_flags |= MNT_NODIRATIME;",
                        "\tif (flags & MS_STRICTATIME)",
                        "\t\tmnt_flags &= ~(MNT_RELATIME | MNT_NOATIME);",
                        "\tif (flags & MS_RDONLY)",
                        "\t\tmnt_flags |= MNT_READONLY;",
                        "\tif (flags & MS_NOSYMFOLLOW)",
                        "\t\tmnt_flags |= MNT_NOSYMFOLLOW;",
                        "",
                        "\t/* The default atime for remount is preservation */",
                        "\tif ((flags & MS_REMOUNT) &&",
                        "\t    ((flags & (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |",
                        "\t\t       MS_STRICTATIME)) == 0)) {",
                        "\t\tmnt_flags &= ~MNT_ATIME_MASK;",
                        "\t\tmnt_flags |= path->mnt->mnt_flags & MNT_ATIME_MASK;",
                        "\t}",
                        "",
                        "\tsb_flags = flags & (SB_RDONLY |",
                        "\t\t\t    SB_SYNCHRONOUS |",
                        "\t\t\t    SB_MANDLOCK |",
                        "\t\t\t    SB_DIRSYNC |",
                        "\t\t\t    SB_SILENT |",
                        "\t\t\t    SB_POSIXACL |",
                        "\t\t\t    SB_LAZYTIME |",
                        "\t\t\t    SB_I_VERSION);",
                        "",
                        "\tif ((flags & (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND))",
                        "\t\treturn do_reconfigure_mnt(path, mnt_flags);",
                        "\tif (flags & MS_REMOUNT)",
                        "\t\treturn do_remount(path, flags, sb_flags, mnt_flags, data_page);",
                        "\tif (flags & MS_BIND)",
                        "\t\treturn do_loopback(path, dev_name, flags & MS_REC);",
                        "\tif (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))",
                        "\t\treturn do_change_type(path, flags);",
                        "\tif (flags & MS_MOVE)",
                        "\t\treturn do_move_mount_old(path, dev_name);",
                        "",
                        "\treturn do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,",
                        "\t\t\t    data_page);",
                        "}"
                    ],
                    "start": 3119,
                    "highlight": 3208
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8135f72f"
        },
        "4230": {
            "name": "path_mount",
            "parent_idx": 3683,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n3221",
                    "code": [
                        "long do_mount(const char *dev_name, const char __user *dir_name,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tstruct path path;",
                        "\tint ret;",
                        "",
                        "\tret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &path);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tret = path_mount(dev_name, &path, type_page, flags, data_page);",
                        "\tpath_put(&path);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3212,
                    "highlight": 3221
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n3429",
                    "code": [
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3406,
                    "highlight": 3429
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n3406",
                    "code": [
                        "struct dentry *mount_subtree(struct vfsmount *m, const char *name)",
                        "{",
                        "\tstruct mount *mnt = real_mount(m);",
                        "\tstruct mnt_namespace *ns;",
                        "\tstruct super_block *s;",
                        "\tstruct path path;",
                        "\tint err;",
                        "",
                        "\tns = alloc_mnt_ns(&init_user_ns, true);",
                        "\tif (IS_ERR(ns)) {",
                        "\t\tmntput(m);",
                        "\t\treturn ERR_CAST(ns);",
                        "\t}",
                        "\tmnt->mnt_ns = ns;",
                        "\tns->root = mnt;",
                        "\tns->mounts++;",
                        "\tlist_add(&mnt->mnt_list, &ns->list);",
                        "",
                        "\terr = vfs_path_lookup(m->mnt_root, m,",
                        "\t\t\tname, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);",
                        "",
                        "\tput_mnt_ns(ns);",
                        "",
                        "\tif (err)",
                        "\t\treturn ERR_PTR(err);",
                        "",
                        "\t/* trade a vfsmount reference for active sb one */",
                        "\ts = path.mnt->mnt_sb;",
                        "\tatomic_inc(&s->s_active);",
                        "\tmntput(path.mnt);",
                        "\t/* lock the sucker */",
                        "\tdown_write(&s->s_umount);",
                        "\t/* ... and return the root of (sub)tree on it */",
                        "\treturn path.dentry;",
                        "}",
                        "EXPORT_SYMBOL(mount_subtree);",
                        "",
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3369,
                    "highlight": 3406
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81360306"
        },
        "3683": {
            "name": "__x64_sys_mount(indirect)",
            "parent_idx": 3680,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8233d79e"
        },
        "3680": {
            "name": "do_syscall_64",
            "parent_idx": 3667,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "3667": {
            "name": "197_syscall_10",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "6260": {
            "name": "+0x738",
            "parent_idx": 5094,
            "source_line": [
                {
                    "file": "fs/squashfs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/super.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n255",
                    "code": [
                        "static int squashfs_fill_super(struct super_block *sb, struct fs_context *fc)",
                        "{",
                        "\tstruct squashfs_sb_info *msblk;",
                        "\tstruct squashfs_super_block *sblk = NULL;",
                        "\tstruct inode *root;",
                        "\tlong long root_inode;",
                        "\tunsigned short flags;",
                        "\tunsigned int fragments;",
                        "\tu64 lookup_table_start, xattr_id_table_start, next_table;",
                        "\tint err;",
                        "",
                        "\tTRACE(\"Entered squashfs_fill_superblock\\n\");",
                        "",
                        "\tsb->s_fs_info = kzalloc(sizeof(*msblk), GFP_KERNEL);",
                        "\tif (sb->s_fs_info == NULL) {",
                        "\t\tERROR(\"Failed to allocate squashfs_sb_info\\n\");",
                        "\t\treturn -ENOMEM;",
                        "\t}",
                        "\tmsblk = sb->s_fs_info;",
                        "",
                        "\tmsblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);",
                        "\tmsblk->devblksize_log2 = ffz(~msblk->devblksize);",
                        "",
                        "\tmutex_init(&msblk->meta_index_mutex);",
                        "",
                        "\t/*",
                        "\t * msblk->bytes_used is checked in squashfs_read_table to ensure reads",
                        "\t * are not beyond filesystem end.  But as we're using",
                        "\t * squashfs_read_table here to read the superblock (including the value",
                        "\t * of bytes_used) we need to set it to an initial sensible dummy value",
                        "\t */",
                        "\tmsblk->bytes_used = sizeof(*sblk);",
                        "\tsblk = squashfs_read_table(sb, SQUASHFS_START, sizeof(*sblk));",
                        "",
                        "\tif (IS_ERR(sblk)) {",
                        "\t\terrorf(fc, \"unable to read squashfs_super_block\");",
                        "\t\terr = PTR_ERR(sblk);",
                        "\t\tsblk = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\terr = -EINVAL;",
                        "",
                        "\t/* Check it is a SQUASHFS superblock */",
                        "\tsb->s_magic = le32_to_cpu(sblk->s_magic);",
                        "\tif (sb->s_magic != SQUASHFS_MAGIC) {",
                        "\t\tif (!(fc->sb_flags & SB_SILENT))",
                        "\t\t\terrorf(fc, \"Can't find a SQUASHFS superblock on %pg\",",
                        "\t\t\t       sb->s_bdev);",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\t/* Check the MAJOR & MINOR versions and lookup compression type */",
                        "\tmsblk->decompressor = supported_squashfs_filesystem(",
                        "\t\t\tfc,",
                        "\t\t\tle16_to_cpu(sblk->s_major),",
                        "\t\t\tle16_to_cpu(sblk->s_minor),",
                        "\t\t\tle16_to_cpu(sblk->compression));",
                        "\tif (msblk->decompressor == NULL)",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Check the filesystem does not extend beyond the end of the",
                        "\t   block device */",
                        "\tmsblk->bytes_used = le64_to_cpu(sblk->bytes_used);",
                        "\tif (msblk->bytes_used < 0 || msblk->bytes_used >",
                        "\t\t\ti_size_read(sb->s_bdev->bd_inode))",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Check block size for sanity */",
                        "\tmsblk->block_size = le32_to_cpu(sblk->block_size);",
                        "\tif (msblk->block_size > SQUASHFS_FILE_MAX_SIZE)",
                        "\t\tgoto insanity;",
                        "",
                        "\t/*",
                        "\t * Check the system page size is not larger than the filesystem",
                        "\t * block size (by default 128K).  This is currently not supported.",
                        "\t */",
                        "\tif (PAGE_SIZE > msblk->block_size) {",
                        "\t\terrorf(fc, \"Page size > filesystem block size (%d).  This is \"",
                        "\t\t       \"currently not supported!\", msblk->block_size);",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\t/* Check block log for sanity */",
                        "\tmsblk->block_log = le16_to_cpu(sblk->block_log);",
                        "\tif (msblk->block_log > SQUASHFS_FILE_MAX_LOG)",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Check that block_size and block_log match */",
                        "\tif (msblk->block_size != (1 << msblk->block_log))",
                        "\t\tgoto insanity;",
                        "",
                        "\t/* Check the root inode for sanity */",
                        "\troot_inode = le64_to_cpu(sblk->root_inode);",
                        "\tif (SQUASHFS_INODE_OFFSET(root_inode) > SQUASHFS_METADATA_SIZE)",
                        "\t\tgoto insanity;",
                        "",
                        "\tmsblk->inode_table = le64_to_cpu(sblk->inode_table_start);",
                        "\tmsblk->directory_table = le64_to_cpu(sblk->directory_table_start);",
                        "\tmsblk->inodes = le32_to_cpu(sblk->inodes);",
                        "\tmsblk->fragments = le32_to_cpu(sblk->fragments);",
                        "\tflags = le16_to_cpu(sblk->flags);",
                        "",
                        "\tTRACE(\"Found valid superblock on %pg\\n\", sb->s_bdev);",
                        "\tTRACE(\"Inodes are %scompressed\\n\", SQUASHFS_UNCOMPRESSED_INODES(flags)",
                        "\t\t\t\t? \"un\" : \"\");",
                        "\tTRACE(\"Data is %scompressed\\n\", SQUASHFS_UNCOMPRESSED_DATA(flags)",
                        "\t\t\t\t? \"un\" : \"\");",
                        "\tTRACE(\"Filesystem size %lld bytes\\n\", msblk->bytes_used);",
                        "\tTRACE(\"Block size %d\\n\", msblk->block_size);",
                        "\tTRACE(\"Number of inodes %d\\n\", msblk->inodes);",
                        "\tTRACE(\"Number of fragments %d\\n\", msblk->fragments);",
                        "\tTRACE(\"Number of ids %d\\n\", le16_to_cpu(sblk->no_ids));",
                        "\tTRACE(\"sblk->inode_table_start %llx\\n\", msblk->inode_table);",
                        "\tTRACE(\"sblk->directory_table_start %llx\\n\", msblk->directory_table);",
                        "\tTRACE(\"sblk->fragment_table_start %llx\\n\",",
                        "\t\t(u64) le64_to_cpu(sblk->fragment_table_start));",
                        "\tTRACE(\"sblk->id_table_start %llx\\n\",",
                        "\t\t(u64) le64_to_cpu(sblk->id_table_start));",
                        "",
                        "\tsb->s_maxbytes = MAX_LFS_FILESIZE;",
                        "\tsb->s_time_min = 0;",
                        "\tsb->s_time_max = U32_MAX;",
                        "\tsb->s_flags |= SB_RDONLY;",
                        "\tsb->s_op = &squashfs_super_ops;",
                        "",
                        "\terr = -ENOMEM;",
                        "",
                        "\tmsblk->block_cache = squashfs_cache_init(\"metadata\",",
                        "\t\t\tSQUASHFS_CACHED_BLKS, SQUASHFS_METADATA_SIZE);",
                        "\tif (msblk->block_cache == NULL)",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Allocate read_page block */",
                        "\tmsblk->read_page = squashfs_cache_init(\"data\",",
                        "\t\tsquashfs_max_decompressors(), msblk->block_size);",
                        "\tif (msblk->read_page == NULL) {",
                        "\t\terrorf(fc, \"Failed to allocate read_page block\");",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\tmsblk->stream = squashfs_decompressor_setup(sb, flags);",
                        "\tif (IS_ERR(msblk->stream)) {",
                        "\t\terr = PTR_ERR(msblk->stream);",
                        "\t\tmsblk->stream = NULL;",
                        "\t\tgoto insanity;",
                        "\t}",
                        "",
                        "\t/* Handle xattrs */",
                        "\tsb->s_xattr = squashfs_xattr_handlers;",
                        "\txattr_id_table_start = le64_to_cpu(sblk->xattr_id_table_start);",
                        "\tif (xattr_id_table_start == SQUASHFS_INVALID_BLK) {",
                        "\t\tnext_table = msblk->bytes_used;",
                        "\t\tgoto allocate_id_index_table;",
                        "\t}",
                        "",
                        "\t/* Allocate and read xattr id lookup table */",
                        "\tmsblk->xattr_id_table = squashfs_read_xattr_id_table(sb,",
                        "\t\txattr_id_table_start, &msblk->xattr_table, &msblk->xattr_ids);",
                        "\tif (IS_ERR(msblk->xattr_id_table)) {",
                        "\t\terrorf(fc, \"unable to read xattr id index table\");",
                        "\t\terr = PTR_ERR(msblk->xattr_id_table);",
                        "\t\tmsblk->xattr_id_table = NULL;",
                        "\t\tif (err != -ENOTSUPP)",
                        "\t\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = msblk->xattr_table;",
                        "",
                        "allocate_id_index_table:",
                        "\t/* Allocate and read id index table */",
                        "\tmsblk->id_table = squashfs_read_id_index_table(sb,",
                        "\t\tle64_to_cpu(sblk->id_table_start), next_table,",
                        "\t\tle16_to_cpu(sblk->no_ids));",
                        "\tif (IS_ERR(msblk->id_table)) {",
                        "\t\terrorf(fc, \"unable to read id index table\");",
                        "\t\terr = PTR_ERR(msblk->id_table);",
                        "\t\tmsblk->id_table = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = le64_to_cpu(msblk->id_table[0]);",
                        "",
                        "\t/* Handle inode lookup table */",
                        "\tlookup_table_start = le64_to_cpu(sblk->lookup_table_start);",
                        "\tif (lookup_table_start == SQUASHFS_INVALID_BLK)",
                        "\t\tgoto handle_fragments;",
                        "",
                        "\t/* Allocate and read inode lookup table */",
                        "\tmsblk->inode_lookup_table = squashfs_read_inode_lookup_table(sb,",
                        "\t\tlookup_table_start, next_table, msblk->inodes);",
                        "\tif (IS_ERR(msblk->inode_lookup_table)) {",
                        "\t\terrorf(fc, \"unable to read inode lookup table\");",
                        "\t\terr = PTR_ERR(msblk->inode_lookup_table);",
                        "\t\tmsblk->inode_lookup_table = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = le64_to_cpu(msblk->inode_lookup_table[0]);",
                        "",
                        "\tsb->s_export_op = &squashfs_export_ops;",
                        "",
                        "handle_fragments:",
                        "\tfragments = msblk->fragments;",
                        "\tif (fragments == 0)",
                        "\t\tgoto check_directory_table;",
                        "",
                        "\tmsblk->fragment_cache = squashfs_cache_init(\"fragment\",",
                        "\t\tSQUASHFS_CACHED_FRAGMENTS, msblk->block_size);",
                        "\tif (msblk->fragment_cache == NULL) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\t/* Allocate and read fragment index table */",
                        "\tmsblk->fragment_index = squashfs_read_fragment_index_table(sb,",
                        "\t\tle64_to_cpu(sblk->fragment_table_start), next_table, fragments);",
                        "\tif (IS_ERR(msblk->fragment_index)) {",
                        "\t\terrorf(fc, \"unable to read fragment index table\");",
                        "\t\terr = PTR_ERR(msblk->fragment_index);",
                        "\t\tmsblk->fragment_index = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = le64_to_cpu(msblk->fragment_index[0]);",
                        "",
                        "check_directory_table:",
                        "\t/* Sanity check directory_table */",
                        "\tif (msblk->directory_table > next_table) {",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto insanity;",
                        "\t}",
                        "",
                        "\t/* Sanity check inode_table */",
                        "\tif (msblk->inode_table >= msblk->directory_table) {",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto insanity;",
                        "\t}",
                        "",
                        "\t/* allocate root */",
                        "\troot = new_inode(sb);",
                        "\tif (!root) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\terr = squashfs_read_inode(root, root_inode);",
                        "\tif (err) {",
                        "\t\tmake_bad_inode(root);",
                        "\t\tiput(root);",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tinsert_inode_hash(root);",
                        "",
                        "\tsb->s_root = d_make_root(root);",
                        "\tif (sb->s_root == NULL) {",
                        "\t\tERROR(\"Root inode create failed\\n\");",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\tTRACE(\"Leaving squashfs_fill_super\\n\");",
                        "\tkfree(sblk);",
                        "\treturn 0;",
                        "",
                        "insanity:",
                        "\terrorf(fc, \"squashfs image failed sanity check\");",
                        "failed_mount:",
                        "\tsquashfs_cache_delete(msblk->block_cache);",
                        "\tsquashfs_cache_delete(msblk->fragment_cache);",
                        "\tsquashfs_cache_delete(msblk->read_page);",
                        "\tsquashfs_decompressor_destroy(msblk);",
                        "\tkfree(msblk->inode_lookup_table);",
                        "\tkfree(msblk->fragment_index);",
                        "\tkfree(msblk->id_table);",
                        "\tkfree(msblk->xattr_id_table);",
                        "\tkfree(sb->s_fs_info);",
                        "\tsb->s_fs_info = NULL;",
                        "\tkfree(sblk);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 68,
                    "highlight": 255
                }
            ],
            "ins_idx": 846,
            "addr": "0xffffffff814fe0e8"
        },
        "6256": {
            "name": "+0x34",
            "parent_idx": 6134,
            "source_line": [
                {
                    "file": "fs/squashfs/export.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/export.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n143",
                    "code": [
                        "/*",
                        " * Read uncompressed inode lookup table indexes off disk into memory",
                        " */",
                        "__le64 *squashfs_read_inode_lookup_table(struct super_block *sb,",
                        "\t\tu64 lookup_table_start, u64 next_table, unsigned int inodes)",
                        "{",
                        "\tunsigned int length = SQUASHFS_LOOKUP_BLOCK_BYTES(inodes);",
                        "\t__le64 *table;",
                        "",
                        "\tTRACE(\"In read_inode_lookup_table, length %d\\n\", length);",
                        "",
                        "\t/* Sanity check values */",
                        "",
                        "\t/* there should always be at least one inode */",
                        "\tif (inodes == 0)",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "",
                        "\t/* length bytes should not extend into the next table - this check",
                        "\t * also traps instances where lookup_table_start is incorrectly larger",
                        "\t * than the next table start",
                        "\t */",
                        "\tif (lookup_table_start + length > next_table)",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "",
                        "\ttable = squashfs_read_table(sb, lookup_table_start, length);",
                        "",
                        "\t/*",
                        "\t * table[0] points to the first inode lookup table metadata block,",
                        "\t * this should be less than lookup_table_start",
                        "\t */",
                        "\tif (!IS_ERR(table) && le64_to_cpu(table[0]) >= lookup_table_start) {",
                        "\t\tkfree(table);",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "\t}",
                        "",
                        "\treturn table;",
                        "}"
                    ],
                    "start": 107,
                    "highlight": 143
                }
            ],
            "ins_idx": 1037,
            "addr": "0xffffffff814fb104"
        },
        "6134": {
            "name": "squashfs_read_inode_lookup_table",
            "parent_idx": 5094,
            "source_line": [
                {
                    "file": "fs/squashfs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/super.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n255",
                    "code": [
                        "static int squashfs_fill_super(struct super_block *sb, struct fs_context *fc)",
                        "{",
                        "\tstruct squashfs_sb_info *msblk;",
                        "\tstruct squashfs_super_block *sblk = NULL;",
                        "\tstruct inode *root;",
                        "\tlong long root_inode;",
                        "\tunsigned short flags;",
                        "\tunsigned int fragments;",
                        "\tu64 lookup_table_start, xattr_id_table_start, next_table;",
                        "\tint err;",
                        "",
                        "\tTRACE(\"Entered squashfs_fill_superblock\\n\");",
                        "",
                        "\tsb->s_fs_info = kzalloc(sizeof(*msblk), GFP_KERNEL);",
                        "\tif (sb->s_fs_info == NULL) {",
                        "\t\tERROR(\"Failed to allocate squashfs_sb_info\\n\");",
                        "\t\treturn -ENOMEM;",
                        "\t}",
                        "\tmsblk = sb->s_fs_info;",
                        "",
                        "\tmsblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);",
                        "\tmsblk->devblksize_log2 = ffz(~msblk->devblksize);",
                        "",
                        "\tmutex_init(&msblk->meta_index_mutex);",
                        "",
                        "\t/*",
                        "\t * msblk->bytes_used is checked in squashfs_read_table to ensure reads",
                        "\t * are not beyond filesystem end.  But as we're using",
                        "\t * squashfs_read_table here to read the superblock (including the value",
                        "\t * of bytes_used) we need to set it to an initial sensible dummy value",
                        "\t */",
                        "\tmsblk->bytes_used = sizeof(*sblk);",
                        "\tsblk = squashfs_read_table(sb, SQUASHFS_START, sizeof(*sblk));",
                        "",
                        "\tif (IS_ERR(sblk)) {",
                        "\t\terrorf(fc, \"unable to read squashfs_super_block\");",
                        "\t\terr = PTR_ERR(sblk);",
                        "\t\tsblk = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\terr = -EINVAL;",
                        "",
                        "\t/* Check it is a SQUASHFS superblock */",
                        "\tsb->s_magic = le32_to_cpu(sblk->s_magic);",
                        "\tif (sb->s_magic != SQUASHFS_MAGIC) {",
                        "\t\tif (!(fc->sb_flags & SB_SILENT))",
                        "\t\t\terrorf(fc, \"Can't find a SQUASHFS superblock on %pg\",",
                        "\t\t\t       sb->s_bdev);",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\t/* Check the MAJOR & MINOR versions and lookup compression type */",
                        "\tmsblk->decompressor = supported_squashfs_filesystem(",
                        "\t\t\tfc,",
                        "\t\t\tle16_to_cpu(sblk->s_major),",
                        "\t\t\tle16_to_cpu(sblk->s_minor),",
                        "\t\t\tle16_to_cpu(sblk->compression));",
                        "\tif (msblk->decompressor == NULL)",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Check the filesystem does not extend beyond the end of the",
                        "\t   block device */",
                        "\tmsblk->bytes_used = le64_to_cpu(sblk->bytes_used);",
                        "\tif (msblk->bytes_used < 0 || msblk->bytes_used >",
                        "\t\t\ti_size_read(sb->s_bdev->bd_inode))",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Check block size for sanity */",
                        "\tmsblk->block_size = le32_to_cpu(sblk->block_size);",
                        "\tif (msblk->block_size > SQUASHFS_FILE_MAX_SIZE)",
                        "\t\tgoto insanity;",
                        "",
                        "\t/*",
                        "\t * Check the system page size is not larger than the filesystem",
                        "\t * block size (by default 128K).  This is currently not supported.",
                        "\t */",
                        "\tif (PAGE_SIZE > msblk->block_size) {",
                        "\t\terrorf(fc, \"Page size > filesystem block size (%d).  This is \"",
                        "\t\t       \"currently not supported!\", msblk->block_size);",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\t/* Check block log for sanity */",
                        "\tmsblk->block_log = le16_to_cpu(sblk->block_log);",
                        "\tif (msblk->block_log > SQUASHFS_FILE_MAX_LOG)",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Check that block_size and block_log match */",
                        "\tif (msblk->block_size != (1 << msblk->block_log))",
                        "\t\tgoto insanity;",
                        "",
                        "\t/* Check the root inode for sanity */",
                        "\troot_inode = le64_to_cpu(sblk->root_inode);",
                        "\tif (SQUASHFS_INODE_OFFSET(root_inode) > SQUASHFS_METADATA_SIZE)",
                        "\t\tgoto insanity;",
                        "",
                        "\tmsblk->inode_table = le64_to_cpu(sblk->inode_table_start);",
                        "\tmsblk->directory_table = le64_to_cpu(sblk->directory_table_start);",
                        "\tmsblk->inodes = le32_to_cpu(sblk->inodes);",
                        "\tmsblk->fragments = le32_to_cpu(sblk->fragments);",
                        "\tflags = le16_to_cpu(sblk->flags);",
                        "",
                        "\tTRACE(\"Found valid superblock on %pg\\n\", sb->s_bdev);",
                        "\tTRACE(\"Inodes are %scompressed\\n\", SQUASHFS_UNCOMPRESSED_INODES(flags)",
                        "\t\t\t\t? \"un\" : \"\");",
                        "\tTRACE(\"Data is %scompressed\\n\", SQUASHFS_UNCOMPRESSED_DATA(flags)",
                        "\t\t\t\t? \"un\" : \"\");",
                        "\tTRACE(\"Filesystem size %lld bytes\\n\", msblk->bytes_used);",
                        "\tTRACE(\"Block size %d\\n\", msblk->block_size);",
                        "\tTRACE(\"Number of inodes %d\\n\", msblk->inodes);",
                        "\tTRACE(\"Number of fragments %d\\n\", msblk->fragments);",
                        "\tTRACE(\"Number of ids %d\\n\", le16_to_cpu(sblk->no_ids));",
                        "\tTRACE(\"sblk->inode_table_start %llx\\n\", msblk->inode_table);",
                        "\tTRACE(\"sblk->directory_table_start %llx\\n\", msblk->directory_table);",
                        "\tTRACE(\"sblk->fragment_table_start %llx\\n\",",
                        "\t\t(u64) le64_to_cpu(sblk->fragment_table_start));",
                        "\tTRACE(\"sblk->id_table_start %llx\\n\",",
                        "\t\t(u64) le64_to_cpu(sblk->id_table_start));",
                        "",
                        "\tsb->s_maxbytes = MAX_LFS_FILESIZE;",
                        "\tsb->s_time_min = 0;",
                        "\tsb->s_time_max = U32_MAX;",
                        "\tsb->s_flags |= SB_RDONLY;",
                        "\tsb->s_op = &squashfs_super_ops;",
                        "",
                        "\terr = -ENOMEM;",
                        "",
                        "\tmsblk->block_cache = squashfs_cache_init(\"metadata\",",
                        "\t\t\tSQUASHFS_CACHED_BLKS, SQUASHFS_METADATA_SIZE);",
                        "\tif (msblk->block_cache == NULL)",
                        "\t\tgoto failed_mount;",
                        "",
                        "\t/* Allocate read_page block */",
                        "\tmsblk->read_page = squashfs_cache_init(\"data\",",
                        "\t\tsquashfs_max_decompressors(), msblk->block_size);",
                        "\tif (msblk->read_page == NULL) {",
                        "\t\terrorf(fc, \"Failed to allocate read_page block\");",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\tmsblk->stream = squashfs_decompressor_setup(sb, flags);",
                        "\tif (IS_ERR(msblk->stream)) {",
                        "\t\terr = PTR_ERR(msblk->stream);",
                        "\t\tmsblk->stream = NULL;",
                        "\t\tgoto insanity;",
                        "\t}",
                        "",
                        "\t/* Handle xattrs */",
                        "\tsb->s_xattr = squashfs_xattr_handlers;",
                        "\txattr_id_table_start = le64_to_cpu(sblk->xattr_id_table_start);",
                        "\tif (xattr_id_table_start == SQUASHFS_INVALID_BLK) {",
                        "\t\tnext_table = msblk->bytes_used;",
                        "\t\tgoto allocate_id_index_table;",
                        "\t}",
                        "",
                        "\t/* Allocate and read xattr id lookup table */",
                        "\tmsblk->xattr_id_table = squashfs_read_xattr_id_table(sb,",
                        "\t\txattr_id_table_start, &msblk->xattr_table, &msblk->xattr_ids);",
                        "\tif (IS_ERR(msblk->xattr_id_table)) {",
                        "\t\terrorf(fc, \"unable to read xattr id index table\");",
                        "\t\terr = PTR_ERR(msblk->xattr_id_table);",
                        "\t\tmsblk->xattr_id_table = NULL;",
                        "\t\tif (err != -ENOTSUPP)",
                        "\t\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = msblk->xattr_table;",
                        "",
                        "allocate_id_index_table:",
                        "\t/* Allocate and read id index table */",
                        "\tmsblk->id_table = squashfs_read_id_index_table(sb,",
                        "\t\tle64_to_cpu(sblk->id_table_start), next_table,",
                        "\t\tle16_to_cpu(sblk->no_ids));",
                        "\tif (IS_ERR(msblk->id_table)) {",
                        "\t\terrorf(fc, \"unable to read id index table\");",
                        "\t\terr = PTR_ERR(msblk->id_table);",
                        "\t\tmsblk->id_table = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = le64_to_cpu(msblk->id_table[0]);",
                        "",
                        "\t/* Handle inode lookup table */",
                        "\tlookup_table_start = le64_to_cpu(sblk->lookup_table_start);",
                        "\tif (lookup_table_start == SQUASHFS_INVALID_BLK)",
                        "\t\tgoto handle_fragments;",
                        "",
                        "\t/* Allocate and read inode lookup table */",
                        "\tmsblk->inode_lookup_table = squashfs_read_inode_lookup_table(sb,",
                        "\t\tlookup_table_start, next_table, msblk->inodes);",
                        "\tif (IS_ERR(msblk->inode_lookup_table)) {",
                        "\t\terrorf(fc, \"unable to read inode lookup table\");",
                        "\t\terr = PTR_ERR(msblk->inode_lookup_table);",
                        "\t\tmsblk->inode_lookup_table = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = le64_to_cpu(msblk->inode_lookup_table[0]);",
                        "",
                        "\tsb->s_export_op = &squashfs_export_ops;",
                        "",
                        "handle_fragments:",
                        "\tfragments = msblk->fragments;",
                        "\tif (fragments == 0)",
                        "\t\tgoto check_directory_table;",
                        "",
                        "\tmsblk->fragment_cache = squashfs_cache_init(\"fragment\",",
                        "\t\tSQUASHFS_CACHED_FRAGMENTS, msblk->block_size);",
                        "\tif (msblk->fragment_cache == NULL) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\t/* Allocate and read fragment index table */",
                        "\tmsblk->fragment_index = squashfs_read_fragment_index_table(sb,",
                        "\t\tle64_to_cpu(sblk->fragment_table_start), next_table, fragments);",
                        "\tif (IS_ERR(msblk->fragment_index)) {",
                        "\t\terrorf(fc, \"unable to read fragment index table\");",
                        "\t\terr = PTR_ERR(msblk->fragment_index);",
                        "\t\tmsblk->fragment_index = NULL;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tnext_table = le64_to_cpu(msblk->fragment_index[0]);",
                        "",
                        "check_directory_table:",
                        "\t/* Sanity check directory_table */",
                        "\tif (msblk->directory_table > next_table) {",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto insanity;",
                        "\t}",
                        "",
                        "\t/* Sanity check inode_table */",
                        "\tif (msblk->inode_table >= msblk->directory_table) {",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto insanity;",
                        "\t}",
                        "",
                        "\t/* allocate root */",
                        "\troot = new_inode(sb);",
                        "\tif (!root) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\terr = squashfs_read_inode(root, root_inode);",
                        "\tif (err) {",
                        "\t\tmake_bad_inode(root);",
                        "\t\tiput(root);",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "\tinsert_inode_hash(root);",
                        "",
                        "\tsb->s_root = d_make_root(root);",
                        "\tif (sb->s_root == NULL) {",
                        "\t\tERROR(\"Root inode create failed\\n\");",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto failed_mount;",
                        "\t}",
                        "",
                        "\tTRACE(\"Leaving squashfs_fill_super\\n\");",
                        "\tkfree(sblk);",
                        "\treturn 0;",
                        "",
                        "insanity:",
                        "\terrorf(fc, \"squashfs image failed sanity check\");",
                        "failed_mount:",
                        "\tsquashfs_cache_delete(msblk->block_cache);",
                        "\tsquashfs_cache_delete(msblk->fragment_cache);",
                        "\tsquashfs_cache_delete(msblk->read_page);",
                        "\tsquashfs_decompressor_destroy(msblk);",
                        "\tkfree(msblk->inode_lookup_table);",
                        "\tkfree(msblk->fragment_index);",
                        "\tkfree(msblk->id_table);",
                        "\tkfree(msblk->xattr_id_table);",
                        "\tkfree(sb->s_fs_info);",
                        "\tsb->s_fs_info = NULL;",
                        "\tkfree(sblk);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 68,
                    "highlight": 255
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff814fe0df"
        },
        "6254": {
            "name": "+0x40",
            "parent_idx": 6134,
            "source_line": [
                {
                    "file": "fs/squashfs/export.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/export.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n131",
                    "code": [
                        "/*",
                        " * Read uncompressed inode lookup table indexes off disk into memory",
                        " */",
                        "__le64 *squashfs_read_inode_lookup_table(struct super_block *sb,",
                        "\t\tu64 lookup_table_start, u64 next_table, unsigned int inodes)",
                        "{",
                        "\tunsigned int length = SQUASHFS_LOOKUP_BLOCK_BYTES(inodes);",
                        "\t__le64 *table;",
                        "",
                        "\tTRACE(\"In read_inode_lookup_table, length %d\\n\", length);",
                        "",
                        "\t/* Sanity check values */",
                        "",
                        "\t/* there should always be at least one inode */",
                        "\tif (inodes == 0)",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "",
                        "\t/* length bytes should not extend into the next table - this check",
                        "\t * also traps instances where lookup_table_start is incorrectly larger",
                        "\t * than the next table start",
                        "\t */",
                        "\tif (lookup_table_start + length > next_table)",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "",
                        "\ttable = squashfs_read_table(sb, lookup_table_start, length);",
                        "",
                        "\t/*",
                        "\t * table[0] points to the first inode lookup table metadata block,",
                        "\t * this should be less than lookup_table_start",
                        "\t */",
                        "\tif (!IS_ERR(table) && le64_to_cpu(table[0]) >= lookup_table_start) {",
                        "\t\tkfree(table);",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "\t}",
                        "",
                        "\treturn table;",
                        "}"
                    ],
                    "start": 107,
                    "highlight": 131
                }
            ],
            "ins_idx": 1286,
            "addr": "0xffffffff814fb110"
        },
        "6251": {
            "name": "+0x14d",
            "parent_idx": 6143,
            "source_line": [
                {
                    "file": "fs/squashfs/cache.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/cache.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n448",
                    "code": [
                        "/*",
                        " * Read a filesystem table (uncompressed sequence of bytes) from disk",
                        " */",
                        "void *squashfs_read_table(struct super_block *sb, u64 block, int length)",
                        "{",
                        "\tint pages = (length + PAGE_SIZE - 1) >> PAGE_SHIFT;",
                        "\tint i, res;",
                        "\tvoid *table, *buffer, **data;",
                        "\tstruct squashfs_page_actor *actor;",
                        "",
                        "\ttable = buffer = kmalloc(length, GFP_KERNEL);",
                        "\tif (table == NULL)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tdata = kcalloc(pages, sizeof(void *), GFP_KERNEL);",
                        "\tif (data == NULL) {",
                        "\t\tres = -ENOMEM;",
                        "\t\tgoto failed;",
                        "\t}",
                        "",
                        "\tactor = squashfs_page_actor_init(data, pages, length);",
                        "\tif (actor == NULL) {",
                        "\t\tres = -ENOMEM;",
                        "\t\tgoto failed2;",
                        "\t}",
                        "",
                        "\tfor (i = 0; i < pages; i++, buffer += PAGE_SIZE)",
                        "\t\tdata[i] = buffer;",
                        "",
                        "\tres = squashfs_read_data(sb, block, length |",
                        "\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, actor);",
                        "",
                        "\tkfree(data);",
                        "\tkfree(actor);",
                        "",
                        "\tif (res < 0)",
                        "\t\tgoto failed;",
                        "",
                        "\treturn table;",
                        "",
                        "failed2:",
                        "\tkfree(data);",
                        "failed:",
                        "\tkfree(table);",
                        "\treturn ERR_PTR(res);",
                        "}"
                    ],
                    "start": 403,
                    "highlight": 448
                }
            ],
            "ins_idx": 1550,
            "addr": "0xffffffff814fa81d"
        },
        "6143": {
            "name": "squashfs_read_table",
            "parent_idx": 6134,
            "source_line": [
                {
                    "file": "fs/squashfs/export.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/export.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n131",
                    "code": [
                        "/*",
                        " * Read uncompressed inode lookup table indexes off disk into memory",
                        " */",
                        "__le64 *squashfs_read_inode_lookup_table(struct super_block *sb,",
                        "\t\tu64 lookup_table_start, u64 next_table, unsigned int inodes)",
                        "{",
                        "\tunsigned int length = SQUASHFS_LOOKUP_BLOCK_BYTES(inodes);",
                        "\t__le64 *table;",
                        "",
                        "\tTRACE(\"In read_inode_lookup_table, length %d\\n\", length);",
                        "",
                        "\t/* Sanity check values */",
                        "",
                        "\t/* there should always be at least one inode */",
                        "\tif (inodes == 0)",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "",
                        "\t/* length bytes should not extend into the next table - this check",
                        "\t * also traps instances where lookup_table_start is incorrectly larger",
                        "\t * than the next table start",
                        "\t */",
                        "\tif (lookup_table_start + length > next_table)",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "",
                        "\ttable = squashfs_read_table(sb, lookup_table_start, length);",
                        "",
                        "\t/*",
                        "\t * table[0] points to the first inode lookup table metadata block,",
                        "\t * this should be less than lookup_table_start",
                        "\t */",
                        "\tif (!IS_ERR(table) && le64_to_cpu(table[0]) >= lookup_table_start) {",
                        "\t\tkfree(table);",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "\t}",
                        "",
                        "\treturn table;",
                        "}"
                    ],
                    "start": 107,
                    "highlight": 131
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff814fb10b"
        },
        "6151": {
            "name": "+0x3d",
            "parent_idx": 6143,
            "source_line": [
                {
                    "file": "fs/squashfs/cache.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/cache.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n414",
                    "code": [
                        "/*",
                        " * Read a filesystem table (uncompressed sequence of bytes) from disk",
                        " */",
                        "void *squashfs_read_table(struct super_block *sb, u64 block, int length)",
                        "{",
                        "\tint pages = (length + PAGE_SIZE - 1) >> PAGE_SHIFT;",
                        "\tint i, res;",
                        "\tvoid *table, *buffer, **data;",
                        "\tstruct squashfs_page_actor *actor;",
                        "",
                        "\ttable = buffer = kmalloc(length, GFP_KERNEL);",
                        "\tif (table == NULL)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tdata = kcalloc(pages, sizeof(void *), GFP_KERNEL);",
                        "\tif (data == NULL) {",
                        "\t\tres = -ENOMEM;",
                        "\t\tgoto failed;",
                        "\t}",
                        "",
                        "\tactor = squashfs_page_actor_init(data, pages, length);",
                        "\tif (actor == NULL) {",
                        "\t\tres = -ENOMEM;",
                        "\t\tgoto failed2;",
                        "\t}",
                        "",
                        "\tfor (i = 0; i < pages; i++, buffer += PAGE_SIZE)",
                        "\t\tdata[i] = buffer;",
                        "",
                        "\tres = squashfs_read_data(sb, block, length |",
                        "\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, actor);",
                        "",
                        "\tkfree(data);",
                        "\tkfree(actor);",
                        "",
                        "\tif (res < 0)",
                        "\t\tgoto failed;",
                        "",
                        "\treturn table;",
                        "",
                        "failed2:",
                        "\tkfree(data);",
                        "failed:",
                        "\tkfree(table);",
                        "\treturn ERR_PTR(res);",
                        "}"
                    ],
                    "start": 403,
                    "highlight": 414
                }
            ],
            "ins_idx": 2604,
            "addr": "0xffffffff814fa70d"
        },
        "6150": {
            "name": "+0x162",
            "parent_idx": 6149,
            "source_line": [
                {
                    "file": "lib/stackdepot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/stackdepot.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n317",
                    "code": [
                        "/**",
                        " * stack_depot_save - Save a stack trace from an array",
                        " *",
                        " * @entries:\t\tPointer to storage array",
                        " * @nr_entries:\t\tSize of the storage array",
                        " * @alloc_flags:\tAllocation gfp flags",
                        " *",
                        " * Return: The handle of the stack struct stored in depot",
                        " */",
                        "depot_stack_handle_t stack_depot_save(unsigned long *entries,",
                        "\t\t\t\t      unsigned int nr_entries,",
                        "\t\t\t\t      gfp_t alloc_flags)",
                        "{",
                        "\tstruct stack_record *found = NULL, **bucket;",
                        "\tdepot_stack_handle_t retval = 0;",
                        "\tstruct page *page = NULL;",
                        "\tvoid *prealloc = NULL;",
                        "\tunsigned long flags;",
                        "\tu32 hash;",
                        "",
                        "\tif (unlikely(nr_entries == 0))",
                        "\t\tgoto fast_exit;",
                        "",
                        "\thash = hash_stack(entries, nr_entries);",
                        "\tbucket = &stack_table[hash & STACK_HASH_MASK];",
                        "",
                        "\t/*",
                        "\t * Fast path: look the stack trace up without locking.",
                        "\t * The smp_load_acquire() here pairs with smp_store_release() to",
                        "\t * |bucket| below.",
                        "\t */",
                        "\tfound = find_stack(smp_load_acquire(bucket), entries,",
                        "\t\t\t   nr_entries, hash);",
                        "\tif (found)",
                        "\t\tgoto exit;",
                        "",
                        "\t/*",
                        "\t * Check if the current or the next stack slab need to be initialized.",
                        "\t * If so, allocate the memory - we won't be able to do that under the",
                        "\t * lock.",
                        "\t *",
                        "\t * The smp_load_acquire() here pairs with smp_store_release() to",
                        "\t * |next_slab_inited| in depot_alloc_stack() and init_stack_slab().",
                        "\t */",
                        "\tif (unlikely(!smp_load_acquire(&next_slab_inited))) {",
                        "\t\t/*",
                        "\t\t * Zero out zone modifiers, as we don't have specific zone",
                        "\t\t * requirements. Keep the flags related to allocation in atomic",
                        "\t\t * contexts and I/O.",
                        "\t\t */",
                        "\t\talloc_flags &= ~GFP_ZONEMASK;",
                        "\t\talloc_flags &= (GFP_ATOMIC | GFP_KERNEL);",
                        "\t\talloc_flags |= __GFP_NOWARN;",
                        "\t\tpage = alloc_pages(alloc_flags, STACK_ALLOC_ORDER);",
                        "\t\tif (page)",
                        "\t\t\tprealloc = page_address(page);",
                        "\t}",
                        "",
                        "\tspin_lock_irqsave(&depot_lock, flags);",
                        "",
                        "\tfound = find_stack(*bucket, entries, nr_entries, hash);",
                        "\tif (!found) {",
                        "\t\tstruct stack_record *new =",
                        "\t\t\tdepot_alloc_stack(entries, nr_entries,",
                        "\t\t\t\t\t  hash, &prealloc, alloc_flags);",
                        "\t\tif (new) {",
                        "\t\t\tnew->next = *bucket;",
                        "\t\t\t/*",
                        "\t\t\t * This smp_store_release() pairs with",
                        "\t\t\t * smp_load_acquire() from |bucket| above.",
                        "\t\t\t */",
                        "\t\t\tsmp_store_release(bucket, new);",
                        "\t\t\tfound = new;",
                        "\t\t}",
                        "\t} else if (prealloc) {",
                        "\t\t/*",
                        "\t\t * We didn't need to store this stack trace, but let's keep",
                        "\t\t * the preallocated memory for the future.",
                        "\t\t */",
                        "\t\tWARN_ON(!init_stack_slab(&prealloc));",
                        "\t}",
                        "",
                        "\tspin_unlock_irqrestore(&depot_lock, flags);",
                        "exit:",
                        "\tif (prealloc) {",
                        "\t\t/* Nobody used this memory, ok to free it. */",
                        "\t\tfree_pages((unsigned long)prealloc, STACK_ALLOC_ORDER);",
                        "\t}",
                        "\tif (found)",
                        "\t\tretval = found->handle.handle;",
                        "fast_exit:",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 225,
                    "highlight": 317
                }
            ],
            "ins_idx": 2905,
            "addr": "0xffffffff816f27d2"
        },
        "6149": {
            "name": "__kmalloc",
            "parent_idx": 6143,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n557",
                    "code": [
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 552,
                    "highlight": 557
                },
                {
                    "file": "fs/squashfs/cache.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/squashfs/cache.c?id=5c8fe583cce542aa0b84adc939ce85293de36e5e#n413",
                    "code": [
                        "/*",
                        " * Read a filesystem table (uncompressed sequence of bytes) from disk",
                        " */",
                        "void *squashfs_read_table(struct super_block *sb, u64 block, int length)",
                        "{",
                        "\tint pages = (length + PAGE_SIZE - 1) >> PAGE_SHIFT;",
                        "\tint i, res;",
                        "\tvoid *table, *buffer, **data;",
                        "\tstruct squashfs_page_actor *actor;",
                        "",
                        "\ttable = buffer = kmalloc(length, GFP_KERNEL);",
                        "\tif (table == NULL)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tdata = kcalloc(pages, sizeof(void *), GFP_KERNEL);",
                        "\tif (data == NULL) {",
                        "\t\tres = -ENOMEM;",
                        "\t\tgoto failed;",
                        "\t}",
                        "",
                        "\tactor = squashfs_page_actor_init(data, pages, length);",
                        "\tif (actor == NULL) {",
                        "\t\tres = -ENOMEM;",
                        "\t\tgoto failed2;",
                        "\t}",
                        "",
                        "\tfor (i = 0; i < pages; i++, buffer += PAGE_SIZE)",
                        "\t\tdata[i] = buffer;",
                        "",
                        "\tres = squashfs_read_data(sb, block, length |",
                        "\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, actor);",
                        "",
                        "\tkfree(data);",
                        "\tkfree(actor);",
                        "",
                        "\tif (res < 0)",
                        "\t\tgoto failed;",
                        "",
                        "\treturn table;",
                        "",
                        "failed2:",
                        "\tkfree(data);",
                        "failed:",
                        "\tkfree(table);",
                        "\treturn ERR_PTR(res);",
                        "}"
                    ],
                    "start": 403,
                    "highlight": 413
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff814fa6ff"
        }
    },
    "ins": {
        "154": {
            "name": "mov rax, qword ptr [r13]",
            "desc": "Invalid Memory Access\nOut of Bound Access.",
            "call_idx": 14953,
            "inputs": [
                27557,
                27558
            ],
            "outputs": [
                27559
            ]
        },
        "309": {
            "name": "lea r13, qword ptr [rax + r13*8]",
            "desc": "",
            "call_idx": 14952,
            "inputs": [
                27554,
                27555
            ],
            "outputs": [
                27556
            ]
        },
        "467": {
            "name": "mov rax, qword ptr [r14 + 0x78]",
            "desc": "",
            "call_idx": 14951,
            "inputs": [
                27551,
                27552
            ],
            "outputs": [
                27553
            ]
        },
        "654": {
            "name": "mov qword ptr [rbx + 0x78], r14",
            "desc": "",
            "call_idx": 6261,
            "inputs": [
                11681,
                11682
            ],
            "outputs": [
                11683
            ]
        },
        "846": {
            "name": "mov r14, rax",
            "desc": "",
            "call_idx": 6260,
            "inputs": [
                11679
            ],
            "outputs": [
                11680
            ]
        },
        "1037": {
            "name": "mov rax, r12",
            "desc": "",
            "call_idx": 6256,
            "inputs": [
                11670
            ],
            "outputs": [
                11671
            ]
        },
        "1286": {
            "name": "mov r12, rax",
            "desc": "",
            "call_idx": 6254,
            "inputs": [
                11667
            ],
            "outputs": [
                11668
            ]
        },
        "1550": {
            "name": "mov rax, r13",
            "desc": "",
            "call_idx": 6251,
            "inputs": [
                11661
            ],
            "outputs": [
                11662
            ]
        },
        "2604": {
            "name": "mov r13, rax",
            "desc": "",
            "call_idx": 6151,
            "inputs": [
                11492
            ],
            "outputs": [
                11493
            ]
        },
        "2905": {
            "name": "ret ",
            "desc": "",
            "call_idx": 6150,
            "inputs": [],
            "outputs": [
                11491
            ]
        }
    },
    "data": {
        "27557": {
            "name": "R13",
            "ins_idx": 154,
            "value": "0xffff88810d7e07a0",
            "sources": []
        },
        "27558": {
            "name": "[0xffff88810d7e07a0]",
            "ins_idx": 154,
            "value": "0x0",
            "sources": []
        },
        "27559": {
            "name": "RAX",
            "ins_idx": 154,
            "value": "0x0",
            "sources": []
        },
        "27554": {
            "name": "R13",
            "ins_idx": 309,
            "value": "0xffffffffffffffff",
            "sources": []
        },
        "27555": {
            "name": "RAX",
            "ins_idx": 309,
            "value": "0xffff88810d7e07a8",
            "sources": []
        },
        "27556": {
            "name": "R13",
            "ins_idx": 309,
            "value": "0xffff88810d7e07a0",
            "sources": [
                27557
            ]
        },
        "27551": {
            "name": "R14",
            "ins_idx": 467,
            "value": "0xffff88810e6d7500",
            "sources": []
        },
        "27552": {
            "name": "[0xffff88810e6d7578]",
            "ins_idx": 467,
            "value": "0xffff88810d7e07a8",
            "sources": []
        },
        "27553": {
            "name": "RAX",
            "ins_idx": 467,
            "value": "0xffff88810d7e07a8",
            "sources": [
                27555
            ]
        },
        "11681": {
            "name": "RBX",
            "ins_idx": 654,
            "value": "0xffff88810e6d7500",
            "sources": []
        },
        "11682": {
            "name": "R14",
            "ins_idx": 654,
            "value": "0xffff88810d7e07a8",
            "sources": []
        },
        "11683": {
            "name": "[0xffff88810e6d7578]",
            "ins_idx": 654,
            "value": "0xffff88810d7e07a8",
            "sources": [
                27552
            ]
        },
        "11679": {
            "name": "RAX",
            "ins_idx": 846,
            "value": "0xffff88810d7e07a8",
            "sources": []
        },
        "11680": {
            "name": "R14",
            "ins_idx": 846,
            "value": "0xffff88810d7e07a8",
            "sources": [
                11682
            ]
        },
        "11670": {
            "name": "R12",
            "ins_idx": 1037,
            "value": "0xffff88810d7e07a8",
            "sources": []
        },
        "11671": {
            "name": "RAX",
            "ins_idx": 1037,
            "value": "0xffff88810d7e07a8",
            "sources": [
                11679
            ]
        },
        "11667": {
            "name": "RAX",
            "ins_idx": 1286,
            "value": "0xffff88810d7e07a8",
            "sources": []
        },
        "11668": {
            "name": "R12",
            "ins_idx": 1286,
            "value": "0xffff88810d7e07a8",
            "sources": [
                11670
            ]
        },
        "11661": {
            "name": "R13",
            "ins_idx": 1550,
            "value": "0xffff88810d7e07a8",
            "sources": []
        },
        "11662": {
            "name": "RAX",
            "ins_idx": 1550,
            "value": "0xffff88810d7e07a8",
            "sources": [
                11667
            ]
        },
        "11492": {
            "name": "RAX",
            "ins_idx": 2604,
            "value": "0xffff88810d7e07a8",
            "sources": []
        },
        "11493": {
            "name": "R13",
            "ins_idx": 2604,
            "value": "0xffff88810d7e07a8",
            "sources": [
                11661
            ]
        },
        "11491": {
            "name": "RAX",
            "ins_idx": 2905,
            "value": "0xffff88810d7e07a8",
            "sources": [
                11492
            ]
        }
    },
    "chain": {
        "154": [
            309
        ],
        "309": [
            467
        ],
        "467": [
            654
        ],
        "654": [
            846
        ],
        "846": [
            1037
        ],
        "1037": [
            1286
        ],
        "1286": [
            1550
        ],
        "1550": [
            2604
        ],
        "2604": [
            2905
        ]
    }
}