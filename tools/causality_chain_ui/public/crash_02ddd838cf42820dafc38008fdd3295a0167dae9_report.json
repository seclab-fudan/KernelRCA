{
    "report": "https://syzkaller.appspot.com/bug?id=02ddd838cf42820dafc38008fdd3295a0167dae9",
    "title": "general protection fault in wext_handle_ioctl",
    "call": {
        "74747": {
            "name": "+0xb2",
            "parent_idx": 74695,
            "source_line": [
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n900",
                    "code": [
                        "/*",
                        " * Call the commit handler in the driver",
                        " * (if exist and if conditions are right)",
                        " *",
                        " * Note : our current commit strategy is currently pretty dumb,",
                        " * but we will be able to improve on that...",
                        " * The goal is to try to agreagate as many changes as possible",
                        " * before doing the commit. Drivers that will define a commit handler",
                        " * are usually those that need a reset after changing parameters, so",
                        " * we want to minimise the number of reset.",
                        " * A cool idea is to use a timer : at each \"set\" command, we re-set the",
                        " * timer, when the timer eventually fires, we call the driver.",
                        " * Hopefully, more on that later.",
                        " *",
                        " * Also, I'm waiting to see how many people will complain about the",
                        " * netif_running(dev) test. I'm open on that one...",
                        " * Hopefully, the driver will remember to do a commit in \"open()\" ;-)",
                        " */",
                        "int call_commit_handler(struct net_device *dev)",
                        "{",
                        "#ifdef CONFIG_WIRELESS_EXT",
                        "\tif ((netif_running(dev)) &&",
                        "\t   (dev->wireless_handlers->standard[0] != NULL))",
                        "\t\t/* Call the commit handler on the driver */",
                        "\t\treturn dev->wireless_handlers->standard[0](dev, NULL,",
                        "\t\t\t\t\t\t\t   NULL, NULL);",
                        "\telse",
                        "\t\treturn 0;\t\t/* Command completed successfully */",
                        "#else",
                        "\t/* cfg80211 has no commit */",
                        "\treturn 0;",
                        "#endif",
                        "}"
                    ],
                    "start": 878,
                    "highlight": 900
                },
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1029",
                    "code": [
                        "/*",
                        " * Wrapper to call a standard Wireless Extension handler.",
                        " * We do various checks and also take care of moving data between",
                        " * user space and kernel space.",
                        " */",
                        "static int ioctl_standard_call(struct net_device *\tdev,",
                        "\t\t\t       struct iwreq\t\t*iwr,",
                        "\t\t\t       unsigned int\t\tcmd,",
                        "\t\t\t       struct iw_request_info\t*info,",
                        "\t\t\t       iw_handler\t\thandler)",
                        "{",
                        "\tconst struct iw_ioctl_description *\tdescr;",
                        "\tint\t\t\t\t\tret = -EINVAL;",
                        "",
                        "\t/* Get the description of the IOCTL */",
                        "\tif (IW_IOCTL_IDX(cmd) >= standard_ioctl_num)",
                        "\t\treturn -EOPNOTSUPP;",
                        "\tdescr = &(standard_ioctl[IW_IOCTL_IDX(cmd)]);",
                        "",
                        "\t/* Check if we have a pointer to user space data or not */",
                        "\tif (descr->header_type != IW_HEADER_TYPE_POINT) {",
                        "",
                        "\t\t/* No extra arguments. Trivial to handle */",
                        "\t\tret = handler(dev, info, &(iwr->u), NULL);",
                        "",
                        "\t\t/* Generate an event to notify listeners of the change */",
                        "\t\tif ((descr->flags & IW_DESCR_FLAG_EVENT) &&",
                        "\t\t   ((ret == 0) || (ret == -EIWCOMMIT)))",
                        "\t\t\twireless_send_event(dev, cmd, &(iwr->u), NULL);",
                        "\t} else {",
                        "\t\tret = ioctl_standard_iw_point(&iwr->u.data, cmd, descr,",
                        "\t\t\t\t\t      handler, dev, info);",
                        "\t}",
                        "",
                        "\t/* Call commit handler if needed and defined */",
                        "\tif (ret == -EIWCOMMIT)",
                        "\t\tret = call_commit_handler(dev);",
                        "",
                        "\t/* Here, we will generate the appropriate event if needed */",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 993,
                    "highlight": 1029
                }
            ],
            "ins_idx": 1385,
            "addr": "0xffffffff81c0e472"
        },
        "74695": {
            "name": "wireless_process_ioctl",
            "parent_idx": 74664,
            "source_line": [
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n987",
                    "code": [
                        "/* entry point from dev ioctl */",
                        "static int wext_ioctl_dispatch(struct net *net, struct iwreq *iwr,",
                        "\t\t\t       unsigned int cmd, struct iw_request_info *info,",
                        "\t\t\t       wext_ioctl_func standard,",
                        "\t\t\t       wext_ioctl_func private)",
                        "{",
                        "\tint ret = wext_permission_check(cmd);",
                        "",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\tdev_load(net, iwr->ifr_name);",
                        "\trtnl_lock();",
                        "\tret = wireless_process_ioctl(net, iwr, cmd, info, standard, private);",
                        "\trtnl_unlock();",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 974,
                    "highlight": 987
                },
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n975",
                    "code": [
                        "/* entry point from dev ioctl */",
                        "static int wext_ioctl_dispatch(struct net *net, struct iwreq *iwr,",
                        "\t\t\t       unsigned int cmd, struct iw_request_info *info,",
                        "\t\t\t       wext_ioctl_func standard,",
                        "\t\t\t       wext_ioctl_func private)",
                        "{",
                        "\tint ret = wext_permission_check(cmd);",
                        "",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\tdev_load(net, iwr->ifr_name);",
                        "\trtnl_lock();",
                        "\tret = wireless_process_ioctl(net, iwr, cmd, info, standard, private);",
                        "\trtnl_unlock();",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 974,
                    "highlight": 975
                },
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1048",
                    "code": [
                        "int wext_handle_ioctl(struct net *net, unsigned int cmd, void __user *arg)",
                        "{",
                        "\tstruct iw_request_info info = { .cmd = cmd, .flags = 0 };",
                        "\tstruct iwreq iwr;",
                        "\tint ret;",
                        "",
                        "\tif (copy_from_user(&iwr, arg, sizeof(iwr)))",
                        "\t\treturn -EFAULT;",
                        "",
                        "\tiwr.ifr_name[sizeof(iwr.ifr_name) - 1] = 0;",
                        "",
                        "\tret = wext_ioctl_dispatch(net, &iwr, cmd, &info,",
                        "\t\t\t\t  ioctl_standard_call,",
                        "\t\t\t\t  ioctl_private_call);",
                        "\tif (ret >= 0 &&",
                        "\t    IW_IS_GET(cmd) &&",
                        "\t    copy_to_user(arg, &iwr, sizeof(struct iwreq)))",
                        "\t\treturn -EFAULT;",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1037,
                    "highlight": 1048
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c0e755"
        },
        "74664": {
            "name": "wext_handle_ioctl",
            "parent_idx": 74659,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1119",
                    "code": [
                        "static long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)",
                        "{",
                        "\tstruct socket *sock;",
                        "\tstruct sock *sk;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint pid, err;",
                        "\tstruct net *net;",
                        "",
                        "\tsock = file->private_data;",
                        "\tsk = sock->sk;",
                        "\tnet = sock_net(sk);",
                        "\tif (unlikely(cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))) {",
                        "\t\tstruct ifreq ifr;",
                        "\t\tbool need_copyout;",
                        "\t\tif (copy_from_user(&ifr, argp, sizeof(struct ifreq)))",
                        "\t\t\treturn -EFAULT;",
                        "\t\terr = dev_ioctl(net, cmd, &ifr, &need_copyout);",
                        "\t\tif (!err && need_copyout)",
                        "\t\t\tif (copy_to_user(argp, &ifr, sizeof(struct ifreq)))",
                        "\t\t\t\treturn -EFAULT;",
                        "\t} else",
                        "#ifdef CONFIG_WEXT_CORE",
                        "\tif (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) {",
                        "\t\terr = wext_handle_ioctl(net, cmd, argp);",
                        "\t} else",
                        "#endif",
                        "\t\tswitch (cmd) {",
                        "\t\tcase FIOSETOWN:",
                        "\t\tcase SIOCSPGRP:",
                        "\t\t\terr = -EFAULT;",
                        "\t\t\tif (get_user(pid, (int __user *)argp))",
                        "\t\t\t\tbreak;",
                        "\t\t\terr = f_setown(sock->file, pid, 1);",
                        "\t\t\tbreak;",
                        "\t\tcase FIOGETOWN:",
                        "\t\tcase SIOCGPGRP:",
                        "\t\t\terr = put_user(f_getown(sock->file),",
                        "\t\t\t\t       (int __user *)argp);",
                        "\t\t\tbreak;",
                        "\t\tcase SIOCGIFBR:",
                        "\t\tcase SIOCSIFBR:",
                        "\t\tcase SIOCBRADDBR:",
                        "\t\tcase SIOCBRDELBR:",
                        "\t\t\terr = -ENOPKG;",
                        "\t\t\tif (!br_ioctl_hook)",
                        "\t\t\t\trequest_module(\"bridge\");",
                        "",
                        "\t\t\tmutex_lock(&br_ioctl_mutex);",
                        "\t\t\tif (br_ioctl_hook)",
                        "\t\t\t\terr = br_ioctl_hook(net, cmd, argp);",
                        "\t\t\tmutex_unlock(&br_ioctl_mutex);",
                        "\t\t\tbreak;",
                        "\t\tcase SIOCGIFVLAN:",
                        "\t\tcase SIOCSIFVLAN:",
                        "\t\t\terr = -ENOPKG;",
                        "\t\t\tif (!vlan_ioctl_hook)",
                        "\t\t\t\trequest_module(\"8021q\");",
                        "",
                        "\t\t\tmutex_lock(&vlan_ioctl_mutex);",
                        "\t\t\tif (vlan_ioctl_hook)",
                        "\t\t\t\terr = vlan_ioctl_hook(net, argp);",
                        "\t\t\tmutex_unlock(&vlan_ioctl_mutex);",
                        "\t\t\tbreak;",
                        "\t\tcase SIOCADDDLCI:",
                        "\t\tcase SIOCDELDLCI:",
                        "\t\t\terr = -ENOPKG;",
                        "\t\t\tif (!dlci_ioctl_hook)",
                        "\t\t\t\trequest_module(\"dlci\");",
                        "",
                        "\t\t\tmutex_lock(&dlci_ioctl_mutex);",
                        "\t\t\tif (dlci_ioctl_hook)",
                        "\t\t\t\terr = dlci_ioctl_hook(cmd, argp);",
                        "\t\t\tmutex_unlock(&dlci_ioctl_mutex);",
                        "\t\t\tbreak;",
                        "\t\tcase SIOCGSKNS:",
                        "\t\t\terr = -EPERM;",
                        "\t\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))",
                        "\t\t\t\tbreak;",
                        "",
                        "\t\t\terr = open_related_ns(&net->ns, get_net_ns);",
                        "\t\t\tbreak;",
                        "\t\tcase SIOCGSTAMP_OLD:",
                        "\t\tcase SIOCGSTAMPNS_OLD:",
                        "\t\t\tif (!sock->ops->gettstamp) {",
                        "\t\t\t\terr = -ENOIOCTLCMD;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\terr = sock->ops->gettstamp(sock, argp,",
                        "\t\t\t\t\t\t   cmd == SIOCGSTAMP_OLD,",
                        "\t\t\t\t\t\t   !IS_ENABLED(CONFIG_64BIT));",
                        "\t\t\tbreak;",
                        "\t\tcase SIOCGSTAMP_NEW:",
                        "\t\tcase SIOCGSTAMPNS_NEW:",
                        "\t\t\tif (!sock->ops->gettstamp) {",
                        "\t\t\t\terr = -ENOIOCTLCMD;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\terr = sock->ops->gettstamp(sock, argp,",
                        "\t\t\t\t\t\t   cmd == SIOCGSTAMP_NEW,",
                        "\t\t\t\t\t\t   false);",
                        "\t\t\tbreak;",
                        "\t\tdefault:",
                        "\t\t\terr = sock_do_ioctl(net, sock, cmd, arg);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1096,
                    "highlight": 1119
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819d5667"
        },
        "74659": {
            "name": "sock_ioctl(indirect)",
            "parent_idx": 74618,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=e28c0d7c92c89016c12a677616668957351e7542#n48",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 30,
                    "highlight": 48
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=e28c0d7c92c89016c12a677616668957351e7542#n753",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 739,
                    "highlight": 753
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=e28c0d7c92c89016c12a677616668957351e7542#n739",
                    "code": [
                        "/*",
                        " * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.",
                        " * It's just a simple helper for sys_ioctl and compat_sys_ioctl.",
                        " *",
                        " * When you add any new common ioctls to the switches above and below,",
                        " * please ensure they have compatible arguments in compat mode.",
                        " */",
                        "static int do_vfs_ioctl(struct file *filp, unsigned int fd,",
                        "\t\t\tunsigned int cmd, unsigned long arg)",
                        "{",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tstruct inode *inode = file_inode(filp);",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIOCLEX:",
                        "\t\tset_close_on_exec(fd, 1);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONCLEX:",
                        "\t\tset_close_on_exec(fd, 0);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONBIO:",
                        "\t\treturn ioctl_fionbio(filp, argp);",
                        "",
                        "\tcase FIOASYNC:",
                        "\t\treturn ioctl_fioasync(fd, filp, argp);",
                        "",
                        "\tcase FIOQSIZE:",
                        "\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||",
                        "\t\t    S_ISLNK(inode->i_mode)) {",
                        "\t\t\tloff_t res = inode_get_bytes(inode);",
                        "\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?",
                        "\t\t\t\t\t    -EFAULT : 0;",
                        "\t\t}",
                        "",
                        "\t\treturn -ENOTTY;",
                        "",
                        "\tcase FIFREEZE:",
                        "\t\treturn ioctl_fsfreeze(filp);",
                        "",
                        "\tcase FITHAW:",
                        "\t\treturn ioctl_fsthaw(filp);",
                        "",
                        "\tcase FS_IOC_FIEMAP:",
                        "\t\treturn ioctl_fiemap(filp, argp);",
                        "",
                        "\tcase FIGETBSZ:",
                        "\t\t/* anon_bdev filesystems may not have a block size */",
                        "\t\tif (!inode->i_sb->s_blocksize)",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
                        "",
                        "\tcase FICLONE:",
                        "\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);",
                        "",
                        "\tcase FICLONERANGE:",
                        "\t\treturn ioctl_file_clone_range(filp, argp);",
                        "",
                        "\tcase FIDEDUPERANGE:",
                        "\t\treturn ioctl_file_dedupe_range(filp, argp);",
                        "",
                        "\tcase FIONREAD:",
                        "\t\tif (!S_ISREG(inode->i_mode))",
                        "\t\t\treturn vfs_ioctl(filp, cmd, arg);",
                        "",
                        "\t\treturn put_user(i_size_read(inode) - filp->f_pos,",
                        "\t\t\t\t(int __user *)argp);",
                        "",
                        "\tdefault:",
                        "\t\tif (S_ISREG(inode->i_mode))",
                        "\t\t\treturn file_ioctl(filp, cmd, argp);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn -ENOIOCTLCMD;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 660,
                    "highlight": 739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8122bff9"
        },
        "74618": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 74615,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=e28c0d7c92c89016c12a677616668957351e7542#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81cf68ee"
        },
        "74615": {
            "name": "do_syscall_64",
            "parent_idx": 74605,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=e28c0d7c92c89016c12a677616668957351e7542#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e00077"
        },
        "74605": {
            "name": "1441_syscall_101",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "74746": {
            "name": "+0xaa",
            "parent_idx": 74695,
            "source_line": [
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n900",
                    "code": [
                        "/*",
                        " * Call the commit handler in the driver",
                        " * (if exist and if conditions are right)",
                        " *",
                        " * Note : our current commit strategy is currently pretty dumb,",
                        " * but we will be able to improve on that...",
                        " * The goal is to try to agreagate as many changes as possible",
                        " * before doing the commit. Drivers that will define a commit handler",
                        " * are usually those that need a reset after changing parameters, so",
                        " * we want to minimise the number of reset.",
                        " * A cool idea is to use a timer : at each \"set\" command, we re-set the",
                        " * timer, when the timer eventually fires, we call the driver.",
                        " * Hopefully, more on that later.",
                        " *",
                        " * Also, I'm waiting to see how many people will complain about the",
                        " * netif_running(dev) test. I'm open on that one...",
                        " * Hopefully, the driver will remember to do a commit in \"open()\" ;-)",
                        " */",
                        "int call_commit_handler(struct net_device *dev)",
                        "{",
                        "#ifdef CONFIG_WIRELESS_EXT",
                        "\tif ((netif_running(dev)) &&",
                        "\t   (dev->wireless_handlers->standard[0] != NULL))",
                        "\t\t/* Call the commit handler on the driver */",
                        "\t\treturn dev->wireless_handlers->standard[0](dev, NULL,",
                        "\t\t\t\t\t\t\t   NULL, NULL);",
                        "\telse",
                        "\t\treturn 0;\t\t/* Command completed successfully */",
                        "#else",
                        "\t/* cfg80211 has no commit */",
                        "\treturn 0;",
                        "#endif",
                        "}"
                    ],
                    "start": 878,
                    "highlight": 900
                },
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1029",
                    "code": [
                        "/*",
                        " * Wrapper to call a standard Wireless Extension handler.",
                        " * We do various checks and also take care of moving data between",
                        " * user space and kernel space.",
                        " */",
                        "static int ioctl_standard_call(struct net_device *\tdev,",
                        "\t\t\t       struct iwreq\t\t*iwr,",
                        "\t\t\t       unsigned int\t\tcmd,",
                        "\t\t\t       struct iw_request_info\t*info,",
                        "\t\t\t       iw_handler\t\thandler)",
                        "{",
                        "\tconst struct iw_ioctl_description *\tdescr;",
                        "\tint\t\t\t\t\tret = -EINVAL;",
                        "",
                        "\t/* Get the description of the IOCTL */",
                        "\tif (IW_IOCTL_IDX(cmd) >= standard_ioctl_num)",
                        "\t\treturn -EOPNOTSUPP;",
                        "\tdescr = &(standard_ioctl[IW_IOCTL_IDX(cmd)]);",
                        "",
                        "\t/* Check if we have a pointer to user space data or not */",
                        "\tif (descr->header_type != IW_HEADER_TYPE_POINT) {",
                        "",
                        "\t\t/* No extra arguments. Trivial to handle */",
                        "\t\tret = handler(dev, info, &(iwr->u), NULL);",
                        "",
                        "\t\t/* Generate an event to notify listeners of the change */",
                        "\t\tif ((descr->flags & IW_DESCR_FLAG_EVENT) &&",
                        "\t\t   ((ret == 0) || (ret == -EIWCOMMIT)))",
                        "\t\t\twireless_send_event(dev, cmd, &(iwr->u), NULL);",
                        "\t} else {",
                        "\t\tret = ioctl_standard_iw_point(&iwr->u.data, cmd, descr,",
                        "\t\t\t\t\t      handler, dev, info);",
                        "\t}",
                        "",
                        "\t/* Call commit handler if needed and defined */",
                        "\tif (ret == -EIWCOMMIT)",
                        "\t\tret = call_commit_handler(dev);",
                        "",
                        "\t/* Here, we will generate the appropriate event if needed */",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 993,
                    "highlight": 1029
                }
            ],
            "ins_idx": 2795,
            "addr": "0xffffffff81c0e46a"
        },
        "47941": {
            "name": "+0x77",
            "parent_idx": 47940,
            "source_line": [
                {
                    "file": "mm/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/util.c?id=e28c0d7c92c89016c12a677616668957351e7542#n596",
                    "code": [
                        "/**",
                        " * kvmalloc_node - attempt to allocate physically contiguous memory, but upon",
                        " * failure, fall back to non-contiguous (vmalloc) allocation.",
                        " * @size: size of the request.",
                        " * @flags: gfp mask for the allocation - must be compatible (superset) with GFP_KERNEL.",
                        " * @node: numa node to allocate from",
                        " *",
                        " * Uses kmalloc to get the memory but if the allocation fails then falls back",
                        " * to the vmalloc allocator. Use kvfree for freeing the memory.",
                        " *",
                        " * Reclaim modifiers - __GFP_NORETRY and __GFP_NOFAIL are not supported.",
                        " * __GFP_RETRY_MAYFAIL is supported, and it should be used only if kmalloc is",
                        " * preferable to the vmalloc fallback, due to visible performance drawbacks.",
                        " *",
                        " * Please note that any use of gfp flags outside of GFP_KERNEL is careful to not",
                        " * fall back to vmalloc.",
                        " *",
                        " * Return: pointer to the allocated memory of %NULL in case of failure",
                        " */",
                        "void *kvmalloc_node(size_t size, gfp_t flags, int node)",
                        "{",
                        "\tgfp_t kmalloc_flags = flags;",
                        "\tvoid *ret;",
                        "",
                        "\t/*",
                        "\t * vmalloc uses GFP_KERNEL for some internal allocations (e.g page tables)",
                        "\t * so the given set of flags has to be compatible.",
                        "\t */",
                        "\tif ((flags & GFP_KERNEL) != GFP_KERNEL)",
                        "\t\treturn kmalloc_node(size, flags, node);",
                        "",
                        "\t/*",
                        "\t * We want to attempt a large physically contiguous block first because",
                        "\t * it is less likely to fragment multiple larger blocks and therefore",
                        "\t * contribute to a long term fragmentation less than vmalloc fallback.",
                        "\t * However make sure that larger requests are not too disruptive - no",
                        "\t * OOM killer and no allocation failure warnings as we have a fallback.",
                        "\t */",
                        "\tif (size > PAGE_SIZE) {",
                        "\t\tkmalloc_flags |= __GFP_NOWARN;",
                        "",
                        "\t\tif (!(kmalloc_flags & __GFP_RETRY_MAYFAIL))",
                        "\t\t\tkmalloc_flags |= __GFP_NORETRY;",
                        "\t}",
                        "",
                        "\tret = kmalloc_node(size, kmalloc_flags, node);",
                        "",
                        "\t/*",
                        "\t * It doesn't really make sense to fallback to vmalloc for sub page",
                        "\t * requests",
                        "\t */",
                        "\tif (ret || size <= PAGE_SIZE)",
                        "\t\treturn ret;",
                        "",
                        "\treturn __vmalloc_node(size, 1, flags, node,",
                        "\t\t\t__builtin_return_address(0));",
                        "}",
                        "EXPORT_SYMBOL(kvmalloc_node);",
                        "",
                        "/**",
                        " * kvfree() - Free memory.",
                        " * @addr: Pointer to allocated memory.",
                        " *",
                        " * kvfree frees memory allocated by any of vmalloc(), kmalloc() or kvmalloc().",
                        " * It is slightly more efficient to use kfree() or vfree() if you are certain",
                        " * that you know which one to use.",
                        " *",
                        " * Context: Either preemptible task context or not-NMI interrupt.",
                        " */",
                        "void kvfree(const void *addr)",
                        "{",
                        "\tif (is_vmalloc_addr(addr))",
                        "\t\tvfree(addr);",
                        "\telse",
                        "\t\tkfree(addr);",
                        "}"
                    ],
                    "start": 530,
                    "highlight": 596
                }
            ],
            "ins_idx": 4350,
            "addr": "0xffffffff811bcac7"
        },
        "47940": {
            "name": "kvmalloc_node",
            "parent_idx": 47933,
            "source_line": [
                {
                    "file": "./include/linux/mm.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/mm.h?id=e28c0d7c92c89016c12a677616668957351e7542#n765",
                    "code": [
                        "extern void *kvmalloc_node(size_t size, gfp_t flags, int node);",
                        "static inline void *kvmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kvmalloc_node(size, flags, NUMA_NO_NODE);",
                        "}"
                    ],
                    "start": 762,
                    "highlight": 765
                },
                {
                    "file": "./include/linux/mm.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/mm.h?id=e28c0d7c92c89016c12a677616668957351e7542#n773",
                    "code": [
                        "extern void *kvmalloc_node(size_t size, gfp_t flags, int node);",
                        "static inline void *kvmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kvmalloc_node(size, flags, NUMA_NO_NODE);",
                        "}",
                        "static inline void *kvzalloc_node(size_t size, gfp_t flags, int node)",
                        "{",
                        "\treturn kvmalloc_node(size, flags | __GFP_ZERO, node);",
                        "}",
                        "static inline void *kvzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kvmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 762,
                    "highlight": 773
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n10447",
                    "code": [
                        "/**",
                        " * alloc_netdev_mqs - allocate network device",
                        " * @sizeof_priv: size of private data to allocate space for",
                        " * @name: device name format string",
                        " * @name_assign_type: origin of device name",
                        " * @setup: callback to initialize device",
                        " * @txqs: the number of TX subqueues to allocate",
                        " * @rxqs: the number of RX subqueues to allocate",
                        " *",
                        " * Allocates a struct net_device with private data area for driver use",
                        " * and performs basic initialization.  Also allocates subqueue structs",
                        " * for each queue on the device.",
                        " */",
                        "struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,",
                        "\t\tunsigned char name_assign_type,",
                        "\t\tvoid (*setup)(struct net_device *),",
                        "\t\tunsigned int txqs, unsigned int rxqs)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tunsigned int alloc_size;",
                        "\tstruct net_device *p;",
                        "",
                        "\tBUG_ON(strlen(name) >= sizeof(dev->name));",
                        "",
                        "\tif (txqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\tif (rxqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero RX queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\talloc_size = sizeof(struct net_device);",
                        "\tif (sizeof_priv) {",
                        "\t\t/* ensure 32-byte alignment of private area */",
                        "\t\talloc_size = ALIGN(alloc_size, NETDEV_ALIGN);",
                        "\t\talloc_size += sizeof_priv;",
                        "\t}",
                        "\t/* ensure 32-byte alignment of whole construct */",
                        "\talloc_size += NETDEV_ALIGN - 1;",
                        "",
                        "\tp = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);",
                        "\tif (!p)",
                        "\t\treturn NULL;",
                        "",
                        "\tdev = PTR_ALIGN(p, NETDEV_ALIGN);",
                        "\tdev->padded = (char *)dev - (char *)p;",
                        "",
                        "\tdev->pcpu_refcnt = alloc_percpu(int);",
                        "\tif (!dev->pcpu_refcnt)",
                        "\t\tgoto free_dev;",
                        "",
                        "\tif (dev_addr_init(dev))",
                        "\t\tgoto free_pcpu;",
                        "",
                        "\tdev_mc_init(dev);",
                        "\tdev_uc_init(dev);",
                        "",
                        "\tdev_net_set(dev, &init_net);",
                        "",
                        "\tdev->gso_max_size = GSO_MAX_SIZE;",
                        "\tdev->gso_max_segs = GSO_MAX_SEGS;",
                        "\tdev->upper_level = 1;",
                        "\tdev->lower_level = 1;",
                        "#ifdef CONFIG_LOCKDEP",
                        "\tdev->nested_level = 0;",
                        "\tINIT_LIST_HEAD(&dev->unlink_list);",
                        "#endif",
                        "",
                        "\tINIT_LIST_HEAD(&dev->napi_list);",
                        "\tINIT_LIST_HEAD(&dev->unreg_list);",
                        "\tINIT_LIST_HEAD(&dev->close_list);",
                        "\tINIT_LIST_HEAD(&dev->link_watch_list);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.upper);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.lower);",
                        "\tINIT_LIST_HEAD(&dev->ptype_all);",
                        "\tINIT_LIST_HEAD(&dev->ptype_specific);",
                        "\tINIT_LIST_HEAD(&dev->net_notifier_list);",
                        "#ifdef CONFIG_NET_SCHED",
                        "\thash_init(dev->qdisc_hash);",
                        "#endif",
                        "\tdev->priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;",
                        "\tsetup(dev);",
                        "",
                        "\tif (!dev->tx_queue_len) {",
                        "\t\tdev->priv_flags |= IFF_NO_QUEUE;",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t}",
                        "",
                        "\tdev->num_tx_queues = txqs;",
                        "\tdev->real_num_tx_queues = txqs;",
                        "\tif (netif_alloc_netdev_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tdev->num_rx_queues = rxqs;",
                        "\tdev->real_num_rx_queues = rxqs;",
                        "\tif (netif_alloc_rx_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tstrcpy(dev->name, name);",
                        "\tdev->name_assign_type = name_assign_type;",
                        "\tdev->group = INIT_NETDEV_GROUP;",
                        "\tif (!dev->ethtool_ops)",
                        "\t\tdev->ethtool_ops = &default_ethtool_ops;",
                        "",
                        "\tnf_hook_ingress_init(dev);",
                        "",
                        "\treturn dev;",
                        "",
                        "free_all:",
                        "\tfree_netdev(dev);",
                        "\treturn NULL;",
                        "",
                        "free_pcpu:",
                        "\tfree_percpu(dev->pcpu_refcnt);",
                        "free_dev:",
                        "\tnetdev_freemem(dev);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 10404,
                    "highlight": 10447
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819f6c73"
        },
        "47933": {
            "name": "alloc_netdev_mqs",
            "parent_idx": 47917,
            "source_line": [
                {
                    "file": "net/mac80211/iface.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mac80211/iface.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1887",
                    "code": [
                        "int ieee80211_if_add(struct ieee80211_local *local, const char *name,",
                        "\t\t     unsigned char name_assign_type,",
                        "\t\t     struct wireless_dev **new_wdev, enum nl80211_iftype type,",
                        "\t\t     struct vif_params *params)",
                        "{",
                        "\tstruct net_device *ndev = NULL;",
                        "\tstruct ieee80211_sub_if_data *sdata = NULL;",
                        "\tstruct txq_info *txqi;",
                        "\tvoid (*if_setup)(struct net_device *dev);",
                        "\tint ret, i;",
                        "\tint txqs = 1;",
                        "",
                        "\tASSERT_RTNL();",
                        "",
                        "\tif (type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN) {",
                        "\t\tstruct wireless_dev *wdev;",
                        "",
                        "\t\tsdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size,",
                        "\t\t\t\tGFP_KERNEL);",
                        "\t\tif (!sdata)",
                        "\t\t\treturn -ENOMEM;",
                        "\t\twdev = &sdata->wdev;",
                        "",
                        "\t\tsdata->dev = NULL;",
                        "\t\tstrlcpy(sdata->name, name, IFNAMSIZ);",
                        "\t\tieee80211_assign_perm_addr(local, wdev->address, type);",
                        "\t\tmemcpy(sdata->vif.addr, wdev->address, ETH_ALEN);",
                        "\t} else {",
                        "\t\tint size = ALIGN(sizeof(*sdata) + local->hw.vif_data_size,",
                        "\t\t\t\t sizeof(void *));",
                        "\t\tint txq_size = 0;",
                        "",
                        "\t\tif (local->ops->wake_tx_queue &&",
                        "\t\t    type != NL80211_IFTYPE_AP_VLAN &&",
                        "\t\t    (type != NL80211_IFTYPE_MONITOR ||",
                        "\t\t     (params->flags & MONITOR_FLAG_ACTIVE)))",
                        "\t\t\ttxq_size += sizeof(struct txq_info) +",
                        "\t\t\t\t    local->hw.txq_data_size;",
                        "",
                        "\t\tif (local->ops->wake_tx_queue) {",
                        "\t\t\tif_setup = ieee80211_if_setup_no_queue;",
                        "\t\t} else {",
                        "\t\t\tif_setup = ieee80211_if_setup;",
                        "\t\t\tif (local->hw.queues >= IEEE80211_NUM_ACS)",
                        "\t\t\t\ttxqs = IEEE80211_NUM_ACS;",
                        "\t\t}",
                        "",
                        "\t\tndev = alloc_netdev_mqs(size + txq_size,",
                        "\t\t\t\t\tname, name_assign_type,",
                        "\t\t\t\t\tif_setup, txqs, 1);",
                        "\t\tif (!ndev)",
                        "\t\t\treturn -ENOMEM;",
                        "",
                        "\t\tif (!local->ops->wake_tx_queue && local->hw.wiphy->tx_queue_len)",
                        "\t\t\tndev->tx_queue_len = local->hw.wiphy->tx_queue_len;",
                        "",
                        "\t\tdev_net_set(ndev, wiphy_net(local->hw.wiphy));",
                        "",
                        "\t\tndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);",
                        "\t\tif (!ndev->tstats) {",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn -ENOMEM;",
                        "\t\t}",
                        "",
                        "\t\tndev->needed_headroom = local->tx_headroom +",
                        "\t\t\t\t\t4*6 /* four MAC addresses */",
                        "\t\t\t\t\t+ 2 + 2 + 2 + 2 /* ctl, dur, seq, qos */",
                        "\t\t\t\t\t+ 6 /* mesh */",
                        "\t\t\t\t\t+ 8 /* rfc1042/bridge tunnel */",
                        "\t\t\t\t\t- ETH_HLEN /* ethernet hard_header_len */",
                        "\t\t\t\t\t+ IEEE80211_ENCRYPT_HEADROOM;",
                        "\t\tndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;",
                        "",
                        "\t\tret = dev_alloc_name(ndev, ndev->name);",
                        "\t\tif (ret < 0) {",
                        "\t\t\tieee80211_if_free(ndev);",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "",
                        "\t\tieee80211_assign_perm_addr(local, ndev->perm_addr, type);",
                        "\t\tif (is_valid_ether_addr(params->macaddr))",
                        "\t\t\tmemcpy(ndev->dev_addr, params->macaddr, ETH_ALEN);",
                        "\t\telse",
                        "\t\t\tmemcpy(ndev->dev_addr, ndev->perm_addr, ETH_ALEN);",
                        "\t\tSET_NETDEV_DEV(ndev, wiphy_dev(local->hw.wiphy));",
                        "",
                        "\t\t/* don't use IEEE80211_DEV_TO_SUB_IF -- it checks too much */",
                        "\t\tsdata = netdev_priv(ndev);",
                        "\t\tndev->ieee80211_ptr = &sdata->wdev;",
                        "\t\tmemcpy(sdata->vif.addr, ndev->dev_addr, ETH_ALEN);",
                        "\t\tmemcpy(sdata->name, ndev->name, IFNAMSIZ);",
                        "",
                        "\t\tif (txq_size) {",
                        "\t\t\ttxqi = netdev_priv(ndev) + size;",
                        "\t\t\tieee80211_txq_init(sdata, NULL, txqi, 0);",
                        "\t\t}",
                        "",
                        "\t\tsdata->dev = ndev;",
                        "\t}",
                        "",
                        "\t/* initialise type-independent data */",
                        "\tsdata->wdev.wiphy = local->hw.wiphy;",
                        "\tsdata->local = local;",
                        "",
                        "\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)",
                        "\t\tskb_queue_head_init(&sdata->fragments[i].skb_list);",
                        "",
                        "\tINIT_LIST_HEAD(&sdata->key_list);",
                        "",
                        "\tINIT_DELAYED_WORK(&sdata->dfs_cac_timer_work,",
                        "\t\t\t  ieee80211_dfs_cac_timer_work);",
                        "\tINIT_DELAYED_WORK(&sdata->dec_tailroom_needed_wk,",
                        "\t\t\t  ieee80211_delayed_tailroom_dec);",
                        "",
                        "\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {",
                        "\t\tstruct ieee80211_supported_band *sband;",
                        "\t\tsband = local->hw.wiphy->bands[i];",
                        "\t\tsdata->rc_rateidx_mask[i] =",
                        "\t\t\tsband ? (1 << sband->n_bitrates) - 1 : 0;",
                        "\t\tif (sband) {",
                        "\t\t\t__le16 cap;",
                        "\t\t\tu16 *vht_rate_mask;",
                        "",
                        "\t\t\tmemcpy(sdata->rc_rateidx_mcs_mask[i],",
                        "\t\t\t       sband->ht_cap.mcs.rx_mask,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));",
                        "",
                        "\t\t\tcap = sband->vht_cap.vht_mcs.rx_mcs_map;",
                        "\t\t\tvht_rate_mask = sdata->rc_rateidx_vht_mcs_mask[i];",
                        "\t\t\tieee80211_get_vht_mask_from_cap(cap, vht_rate_mask);",
                        "\t\t} else {",
                        "\t\t\tmemset(sdata->rc_rateidx_mcs_mask[i], 0,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));",
                        "\t\t\tmemset(sdata->rc_rateidx_vht_mcs_mask[i], 0,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_vht_mcs_mask[i]));",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tieee80211_set_default_queues(sdata);",
                        "",
                        "\tsdata->ap_power_level = IEEE80211_UNSET_POWER_LEVEL;",
                        "\tsdata->user_power_level = local->user_power_level;",
                        "",
                        "\tsdata->encrypt_headroom = IEEE80211_ENCRYPT_HEADROOM;",
                        "",
                        "\t/* setup type-dependent data */",
                        "\tieee80211_setup_sdata(sdata, type);",
                        "",
                        "\tif (ndev) {",
                        "\t\tndev->ieee80211_ptr->use_4addr = params->use_4addr;",
                        "\t\tif (type == NL80211_IFTYPE_STATION)",
                        "\t\t\tsdata->u.mgd.use_4addr = params->use_4addr;",
                        "",
                        "\t\tndev->features |= local->hw.netdev_features;",
                        "\t\tndev->hw_features |= ndev->features &",
                        "\t\t\t\t\tMAC80211_SUPPORTED_FEATURES_TX;",
                        "",
                        "\t\tnetdev_set_default_ethtool_ops(ndev, &ieee80211_ethtool_ops);",
                        "",
                        "\t\t/* MTU range: 256 - 2304 */",
                        "\t\tndev->min_mtu = 256;",
                        "\t\tndev->max_mtu = local->hw.max_mtu;",
                        "",
                        "\t\tret = register_netdevice(ndev);",
                        "\t\tif (ret) {",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tmutex_lock(&local->iflist_mtx);",
                        "\tlist_add_tail_rcu(&sdata->list, &local->interfaces);",
                        "\tmutex_unlock(&local->iflist_mtx);",
                        "",
                        "\tif (new_wdev)",
                        "\t\t*new_wdev = &sdata->wdev;",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1840,
                    "highlight": 1887
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c29245"
        },
        "47917": {
            "name": "ieee80211_if_add",
            "parent_idx": 46935,
            "source_line": [
                {
                    "file": "net/mac80211/main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mac80211/main.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1293",
                    "code": [
                        "int ieee80211_register_hw(struct ieee80211_hw *hw)",
                        "{",
                        "\tstruct ieee80211_local *local = hw_to_local(hw);",
                        "\tint result, i;",
                        "\tenum nl80211_band band;",
                        "\tint channels, max_bitrates;",
                        "\tbool supp_ht, supp_vht, supp_he;",
                        "\tstruct cfg80211_chan_def dflt_chandef = {};",
                        "",
                        "\tif (ieee80211_hw_check(hw, QUEUE_CONTROL) &&",
                        "\t    (local->hw.offchannel_tx_hw_queue == IEEE80211_INVAL_HW_QUEUE ||",
                        "\t     local->hw.offchannel_tx_hw_queue >= local->hw.queues))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif ((hw->wiphy->features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH) &&",
                        "\t    (!local->ops->tdls_channel_switch ||",
                        "\t     !local->ops->tdls_cancel_channel_switch ||",
                        "\t     !local->ops->tdls_recv_channel_switch))",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tif (WARN_ON(ieee80211_hw_check(hw, SUPPORTS_TX_FRAG) &&",
                        "\t\t    !local->ops->set_frag_threshold))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (WARN_ON(local->hw.wiphy->interface_modes &",
                        "\t\t\tBIT(NL80211_IFTYPE_NAN) &&",
                        "\t\t    (!local->ops->start_nan || !local->ops->stop_nan)))",
                        "\t\treturn -EINVAL;",
                        "",
                        "#ifdef CONFIG_PM",
                        "\tif (hw->wiphy->wowlan && (!local->ops->suspend || !local->ops->resume))",
                        "\t\treturn -EINVAL;",
                        "#endif",
                        "",
                        "\tif (!local->use_chanctx) {",
                        "\t\tfor (i = 0; i < local->hw.wiphy->n_iface_combinations; i++) {",
                        "\t\t\tconst struct ieee80211_iface_combination *comb;",
                        "",
                        "\t\t\tcomb = &local->hw.wiphy->iface_combinations[i];",
                        "",
                        "\t\t\tif (comb->num_different_channels > 1)",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "\t} else {",
                        "\t\t/*",
                        "\t\t * WDS is currently prohibited when channel contexts are used",
                        "\t\t * because there's no clear definition of which channel WDS",
                        "\t\t * type interfaces use",
                        "\t\t */",
                        "\t\tif (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_WDS))",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\t/* DFS is not supported with multi-channel combinations yet */",
                        "\t\tfor (i = 0; i < local->hw.wiphy->n_iface_combinations; i++) {",
                        "\t\t\tconst struct ieee80211_iface_combination *comb;",
                        "",
                        "\t\t\tcomb = &local->hw.wiphy->iface_combinations[i];",
                        "",
                        "\t\t\tif (comb->radar_detect_widths &&",
                        "\t\t\t    comb->num_different_channels > 1)",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* Only HW csum features are currently compatible with mac80211 */",
                        "\tif (WARN_ON(hw->netdev_features & ~MAC80211_SUPPORTED_FEATURES))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (hw->max_report_rates == 0)",
                        "\t\thw->max_report_rates = hw->max_rates;",
                        "",
                        "\tlocal->rx_chains = 1;",
                        "",
                        "\t/*",
                        "\t * generic code guarantees at least one band,",
                        "\t * set this very early because much code assumes",
                        "\t * that hw.conf.channel is assigned",
                        "\t */",
                        "\tchannels = 0;",
                        "\tmax_bitrates = 0;",
                        "\tsupp_ht = false;",
                        "\tsupp_vht = false;",
                        "\tsupp_he = false;",
                        "\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {",
                        "\t\tstruct ieee80211_supported_band *sband;",
                        "",
                        "\t\tsband = local->hw.wiphy->bands[band];",
                        "\t\tif (!sband)",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tif (!dflt_chandef.chan) {",
                        "\t\t\tcfg80211_chandef_create(&dflt_chandef,",
                        "\t\t\t\t\t\t&sband->channels[0],",
                        "\t\t\t\t\t\tNL80211_CHAN_NO_HT);",
                        "\t\t\t/* init channel we're on */",
                        "\t\t\tif (!local->use_chanctx && !local->_oper_chandef.chan) {",
                        "\t\t\t\tlocal->hw.conf.chandef = dflt_chandef;",
                        "\t\t\t\tlocal->_oper_chandef = dflt_chandef;",
                        "\t\t\t}",
                        "\t\t\tlocal->monitor_chandef = dflt_chandef;",
                        "\t\t}",
                        "",
                        "\t\tchannels += sband->n_channels;",
                        "",
                        "\t\tif (max_bitrates < sband->n_bitrates)",
                        "\t\t\tmax_bitrates = sband->n_bitrates;",
                        "\t\tsupp_ht = supp_ht || sband->ht_cap.ht_supported;",
                        "\t\tsupp_vht = supp_vht || sband->vht_cap.vht_supported;",
                        "",
                        "\t\tif (!supp_he)",
                        "\t\t\tsupp_he = !!ieee80211_get_he_sta_cap(sband);",
                        "",
                        "\t\t/* HT, VHT, HE require QoS, thus >= 4 queues */",
                        "\t\tif (WARN_ON(local->hw.queues < IEEE80211_NUM_ACS &&",
                        "\t\t\t    (supp_ht || supp_vht || supp_he)))",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\tif (!sband->ht_cap.ht_supported)",
                        "\t\t\tcontinue;",
                        "",
                        "\t\t/* TODO: consider VHT for RX chains, hopefully it's the same */",
                        "\t\tlocal->rx_chains =",
                        "\t\t\tmax(ieee80211_mcs_to_chains(&sband->ht_cap.mcs),",
                        "\t\t\t    local->rx_chains);",
                        "",
                        "\t\t/* no need to mask, SM_PS_DISABLED has all bits set */",
                        "\t\tsband->ht_cap.cap |= WLAN_HT_CAP_SM_PS_DISABLED <<",
                        "\t\t\t             IEEE80211_HT_CAP_SM_PS_SHIFT;",
                        "\t}",
                        "",
                        "\t/* if low-level driver supports AP, we also support VLAN.",
                        "\t * drivers advertising SW_CRYPTO_CONTROL should enable AP_VLAN",
                        "\t * based on their support to transmit SW encrypted packets.",
                        "\t */",
                        "\tif (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_AP) &&",
                        "\t    !ieee80211_hw_check(&local->hw, SW_CRYPTO_CONTROL)) {",
                        "\t\thw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_AP_VLAN);",
                        "\t\thw->wiphy->software_iftypes |= BIT(NL80211_IFTYPE_AP_VLAN);",
                        "\t}",
                        "",
                        "\t/* mac80211 always supports monitor */",
                        "\thw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_MONITOR);",
                        "\thw->wiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);",
                        "",
                        "\t/* mac80211 doesn't support more than one IBSS interface right now */",
                        "\tfor (i = 0; i < hw->wiphy->n_iface_combinations; i++) {",
                        "\t\tconst struct ieee80211_iface_combination *c;",
                        "\t\tint j;",
                        "",
                        "\t\tc = &hw->wiphy->iface_combinations[i];",
                        "",
                        "\t\tfor (j = 0; j < c->n_limits; j++)",
                        "\t\t\tif ((c->limits[j].types & BIT(NL80211_IFTYPE_ADHOC)) &&",
                        "\t\t\t    c->limits[j].max > 1)",
                        "\t\t\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tlocal->int_scan_req = kzalloc(sizeof(*local->int_scan_req) +",
                        "\t\t\t\t      sizeof(void *) * channels, GFP_KERNEL);",
                        "\tif (!local->int_scan_req)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {",
                        "\t\tif (!local->hw.wiphy->bands[band])",
                        "\t\t\tcontinue;",
                        "\t\tlocal->int_scan_req->rates[band] = (u32) -1;",
                        "\t}",
                        "",
                        "#ifndef CONFIG_MAC80211_MESH",
                        "\t/* mesh depends on Kconfig, but drivers should set it if they want */",
                        "\tlocal->hw.wiphy->interface_modes &= ~BIT(NL80211_IFTYPE_MESH_POINT);",
                        "#endif",
                        "",
                        "\t/* if the underlying driver supports mesh, mac80211 will (at least)",
                        "\t * provide routing of mesh authentication frames to userspace */",
                        "\tif (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_MESH_POINT))",
                        "\t\tlocal->hw.wiphy->flags |= WIPHY_FLAG_MESH_AUTH;",
                        "",
                        "\t/* mac80211 supports control port protocol changing */",
                        "\tlocal->hw.wiphy->flags |= WIPHY_FLAG_CONTROL_PORT_PROTOCOL;",
                        "",
                        "\tif (ieee80211_hw_check(&local->hw, SIGNAL_DBM)) {",
                        "\t\tlocal->hw.wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;",
                        "\t} else if (ieee80211_hw_check(&local->hw, SIGNAL_UNSPEC)) {",
                        "\t\tlocal->hw.wiphy->signal_type = CFG80211_SIGNAL_TYPE_UNSPEC;",
                        "\t\tif (hw->max_signal <= 0) {",
                        "\t\t\tresult = -EINVAL;",
                        "\t\t\tgoto fail_workqueue;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* Mac80211 and therefore all drivers using SW crypto only",
                        "\t * are able to handle PTK rekeys and Extended Key ID.",
                        "\t */",
                        "\tif (!local->ops->set_key) {",
                        "\t\twiphy_ext_feature_set(local->hw.wiphy,",
                        "\t\t\t\t      NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);",
                        "\t\twiphy_ext_feature_set(local->hw.wiphy,",
                        "\t\t\t\t      NL80211_EXT_FEATURE_EXT_KEY_ID);",
                        "\t}",
                        "",
                        "\tif (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_ADHOC))",
                        "\t\twiphy_ext_feature_set(local->hw.wiphy,",
                        "\t\t\t\t      NL80211_EXT_FEATURE_DEL_IBSS_STA);",
                        "",
                        "\t/*",
                        "\t * Calculate scan IE length -- we need this to alloc",
                        "\t * memory and to subtract from the driver limit. It",
                        "\t * includes the DS Params, (extended) supported rates, and HT",
                        "\t * information -- SSID is the driver's responsibility.",
                        "\t */",
                        "\tlocal->scan_ies_len = 4 + max_bitrates /* (ext) supp rates */ +",
                        "\t\t3 /* DS Params */;",
                        "\tif (supp_ht)",
                        "\t\tlocal->scan_ies_len += 2 + sizeof(struct ieee80211_ht_cap);",
                        "",
                        "\tif (supp_vht)",
                        "\t\tlocal->scan_ies_len +=",
                        "\t\t\t2 + sizeof(struct ieee80211_vht_cap);",
                        "",
                        "\t/* HE cap element is variable in size - set len to allow max size */",
                        "\t/*",
                        "\t * TODO: 1 is added at the end of the calculation to accommodate for",
                        "\t *\tthe temporary placing of the HE capabilities IE under EXT.",
                        "\t *\tRemove it once it is placed in the final place.",
                        "\t */",
                        "\tif (supp_he)",
                        "\t\tlocal->scan_ies_len +=",
                        "\t\t\t2 + sizeof(struct ieee80211_he_cap_elem) +",
                        "\t\t\tsizeof(struct ieee80211_he_mcs_nss_supp) +",
                        "\t\t\tIEEE80211_HE_PPE_THRES_MAX_LEN + 1;",
                        "",
                        "\tif (!local->ops->hw_scan) {",
                        "\t\t/* For hw_scan, driver needs to set these up. */",
                        "\t\tlocal->hw.wiphy->max_scan_ssids = 4;",
                        "\t\tlocal->hw.wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * If the driver supports any scan IEs, then assume the",
                        "\t * limit includes the IEs mac80211 will add, otherwise",
                        "\t * leave it at zero and let the driver sort it out; we",
                        "\t * still pass our IEs to the driver but userspace will",
                        "\t * not be allowed to in that case.",
                        "\t */",
                        "\tif (local->hw.wiphy->max_scan_ie_len)",
                        "\t\tlocal->hw.wiphy->max_scan_ie_len -= local->scan_ies_len;",
                        "",
                        "\tWARN_ON(!ieee80211_cs_list_valid(local->hw.cipher_schemes,",
                        "\t\t\t\t\t local->hw.n_cipher_schemes));",
                        "",
                        "\tresult = ieee80211_init_cipher_suites(local);",
                        "\tif (result < 0)",
                        "\t\tgoto fail_workqueue;",
                        "",
                        "\tif (!local->ops->remain_on_channel)",
                        "\t\tlocal->hw.wiphy->max_remain_on_channel_duration = 5000;",
                        "",
                        "\t/* mac80211 based drivers don't support internal TDLS setup */",
                        "\tif (local->hw.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS)",
                        "\t\tlocal->hw.wiphy->flags |= WIPHY_FLAG_TDLS_EXTERNAL_SETUP;",
                        "",
                        "\t/* mac80211 supports eCSA, if the driver supports STA CSA at all */",
                        "\tif (ieee80211_hw_check(&local->hw, CHANCTX_STA_CSA))",
                        "\t\tlocal->ext_capa[0] |= WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING;",
                        "",
                        "\t/* mac80211 supports multi BSSID, if the driver supports it */",
                        "\tif (ieee80211_hw_check(&local->hw, SUPPORTS_MULTI_BSSID)) {",
                        "\t\tlocal->hw.wiphy->support_mbssid = true;",
                        "\t\tif (ieee80211_hw_check(&local->hw,",
                        "\t\t\t\t       SUPPORTS_ONLY_HE_MULTI_BSSID))",
                        "\t\t\tlocal->hw.wiphy->support_only_he_mbssid = true;",
                        "\t\telse",
                        "\t\t\tlocal->ext_capa[2] |=",
                        "\t\t\t\tWLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;",
                        "\t}",
                        "",
                        "\tlocal->hw.wiphy->max_num_csa_counters = IEEE80211_MAX_CNTDWN_COUNTERS_NUM;",
                        "",
                        "\t/*",
                        "\t * We use the number of queues for feature tests (QoS, HT) internally",
                        "\t * so restrict them appropriately.",
                        "\t */",
                        "\tif (hw->queues > IEEE80211_MAX_QUEUES)",
                        "\t\thw->queues = IEEE80211_MAX_QUEUES;",
                        "",
                        "\tlocal->workqueue =",
                        "\t\talloc_ordered_workqueue(\"%s\", 0, wiphy_name(local->hw.wiphy));",
                        "\tif (!local->workqueue) {",
                        "\t\tresult = -ENOMEM;",
                        "\t\tgoto fail_workqueue;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * The hardware needs headroom for sending the frame,",
                        "\t * and we need some headroom for passing the frame to monitor",
                        "\t * interfaces, but never both at the same time.",
                        "\t */",
                        "\tlocal->tx_headroom = max_t(unsigned int , local->hw.extra_tx_headroom,",
                        "\t\t\t\t   IEEE80211_TX_STATUS_HEADROOM);",
                        "",
                        "\t/*",
                        "\t * if the driver doesn't specify a max listen interval we",
                        "\t * use 5 which should be a safe default",
                        "\t */",
                        "\tif (local->hw.max_listen_interval == 0)",
                        "\t\tlocal->hw.max_listen_interval = 5;",
                        "",
                        "\tlocal->hw.conf.listen_interval = local->hw.max_listen_interval;",
                        "",
                        "\tlocal->dynamic_ps_forced_timeout = -1;",
                        "",
                        "\tif (!local->hw.max_nan_de_entries)",
                        "\t\tlocal->hw.max_nan_de_entries = IEEE80211_MAX_NAN_INSTANCE_ID;",
                        "",
                        "\tif (!local->hw.weight_multiplier)",
                        "\t\tlocal->hw.weight_multiplier = 1;",
                        "",
                        "\tieee80211_wep_init(local);",
                        "",
                        "\tlocal->hw.conf.flags = IEEE80211_CONF_IDLE;",
                        "",
                        "\tieee80211_led_init(local);",
                        "",
                        "\tresult = ieee80211_txq_setup_flows(local);",
                        "\tif (result)",
                        "\t\tgoto fail_flows;",
                        "",
                        "\trtnl_lock();",
                        "\tresult = ieee80211_init_rate_ctrl_alg(local,",
                        "\t\t\t\t\t      hw->rate_control_algorithm);",
                        "\trtnl_unlock();",
                        "\tif (result < 0) {",
                        "\t\twiphy_debug(local->hw.wiphy,",
                        "\t\t\t    \"Failed to initialize rate control algorithm\\n\");",
                        "\t\tgoto fail_rate;",
                        "\t}",
                        "",
                        "\tif (local->rate_ctrl) {",
                        "\t\tclear_bit(IEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW, hw->flags);",
                        "\t\tif (local->rate_ctrl->ops->capa & RATE_CTRL_CAPA_VHT_EXT_NSS_BW)",
                        "\t\t\tieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * If the VHT capabilities don't have IEEE80211_VHT_EXT_NSS_BW_CAPABLE,",
                        "\t * or have it when we don't, copy the sband structure and set/clear it.",
                        "\t * This is necessary because rate scaling algorithms could be switched",
                        "\t * and have different support values.",
                        "\t * Print a message so that in the common case the reallocation can be",
                        "\t * avoided.",
                        "\t */",
                        "\tBUILD_BUG_ON(NUM_NL80211_BANDS > 8 * sizeof(local->sband_allocated));",
                        "\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {",
                        "\t\tstruct ieee80211_supported_band *sband;",
                        "\t\tbool local_cap, ie_cap;",
                        "",
                        "\t\tlocal_cap = ieee80211_hw_check(hw, SUPPORTS_VHT_EXT_NSS_BW);",
                        "",
                        "\t\tsband = local->hw.wiphy->bands[band];",
                        "\t\tif (!sband || !sband->vht_cap.vht_supported)",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tie_cap = !!(sband->vht_cap.vht_mcs.tx_highest &",
                        "\t\t\t    cpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE));",
                        "",
                        "\t\tif (local_cap == ie_cap)",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tsband = kmemdup(sband, sizeof(*sband), GFP_KERNEL);",
                        "\t\tif (!sband) {",
                        "\t\t\tresult = -ENOMEM;",
                        "\t\t\tgoto fail_rate;",
                        "\t\t}",
                        "",
                        "\t\twiphy_dbg(hw->wiphy, \"copying sband (band %d) due to VHT EXT NSS BW flag\\n\",",
                        "\t\t\t  band);",
                        "",
                        "\t\tsband->vht_cap.vht_mcs.tx_highest ^=",
                        "\t\t\tcpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE);",
                        "",
                        "\t\tlocal->hw.wiphy->bands[band] = sband;",
                        "\t\tlocal->sband_allocated |= BIT(band);",
                        "\t}",
                        "",
                        "\tresult = wiphy_register(local->hw.wiphy);",
                        "\tif (result < 0)",
                        "\t\tgoto fail_wiphy_register;",
                        "",
                        "\tdebugfs_hw_add(local);",
                        "\trate_control_add_debugfs(local);",
                        "",
                        "\trtnl_lock();",
                        "",
                        "\t/* add one default STA interface if supported */",
                        "\tif (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_STATION) &&",
                        "\t    !ieee80211_hw_check(hw, NO_AUTO_VIF)) {",
                        "\t\tstruct vif_params params = {0};",
                        "",
                        "\t\tresult = ieee80211_if_add(local, \"wlan%d\", NET_NAME_ENUM, NULL,",
                        "\t\t\t\t\t  NL80211_IFTYPE_STATION, &params);",
                        "\t\tif (result)",
                        "\t\t\twiphy_warn(local->hw.wiphy,",
                        "\t\t\t\t   \"Failed to add default virtual iface\\n\");",
                        "\t}",
                        "",
                        "\trtnl_unlock();",
                        "",
                        "#ifdef CONFIG_INET",
                        "\tlocal->ifa_notifier.notifier_call = ieee80211_ifa_changed;",
                        "\tresult = register_inetaddr_notifier(&local->ifa_notifier);",
                        "\tif (result)",
                        "\t\tgoto fail_ifa;",
                        "#endif",
                        "",
                        "#if IS_ENABLED(CONFIG_IPV6)",
                        "\tlocal->ifa6_notifier.notifier_call = ieee80211_ifa6_changed;",
                        "\tresult = register_inet6addr_notifier(&local->ifa6_notifier);",
                        "\tif (result)",
                        "\t\tgoto fail_ifa6;",
                        "#endif",
                        "",
                        "\treturn 0;",
                        "",
                        "#if IS_ENABLED(CONFIG_IPV6)",
                        " fail_ifa6:",
                        "#ifdef CONFIG_INET",
                        "\tunregister_inetaddr_notifier(&local->ifa_notifier);",
                        "#endif",
                        "#endif",
                        "#if defined(CONFIG_INET) || defined(CONFIG_IPV6)",
                        " fail_ifa:",
                        "#endif",
                        "\twiphy_unregister(local->hw.wiphy);",
                        " fail_wiphy_register:",
                        "\trtnl_lock();",
                        "\trate_control_deinitialize(local);",
                        "\tieee80211_remove_interfaces(local);",
                        "\trtnl_unlock();",
                        " fail_rate:",
                        " fail_flows:",
                        "\tieee80211_led_exit(local);",
                        "\tdestroy_workqueue(local->workqueue);",
                        " fail_workqueue:",
                        "\tif (local->wiphy_ciphers_allocated)",
                        "\t\tkfree(local->hw.wiphy->cipher_suites);",
                        "\tkfree(local->int_scan_req);",
                        "\treturn result;",
                        "}"
                    ],
                    "start": 894,
                    "highlight": 1293
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c105cb"
        },
        "46935": {
            "name": "ieee80211_register_hw",
            "parent_idx": 46521,
            "source_line": [
                {
                    "file": "drivers/net/wireless/mac80211_hwsim.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/wireless/mac80211_hwsim.c?id=e28c0d7c92c89016c12a677616668957351e7542#n3261",
                    "code": [
                        "static int mac80211_hwsim_new_radio(struct genl_info *info,",
                        "\t\t\t\t    struct hwsim_new_radio_params *param)",
                        "{",
                        "\tint err;",
                        "\tu8 addr[ETH_ALEN];",
                        "\tstruct mac80211_hwsim_data *data;",
                        "\tstruct ieee80211_hw *hw;",
                        "\tenum nl80211_band band;",
                        "\tconst struct ieee80211_ops *ops = &mac80211_hwsim_ops;",
                        "\tstruct net *net;",
                        "\tint idx, i;",
                        "\tint n_limits = 0;",
                        "",
                        "\tif (WARN_ON(param->channels > 1 && !param->use_chanctx))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tspin_lock_bh(&hwsim_radio_lock);",
                        "\tidx = hwsim_radio_idx++;",
                        "\tspin_unlock_bh(&hwsim_radio_lock);",
                        "",
                        "\tif (param->use_chanctx)",
                        "\t\tops = &mac80211_hwsim_mchan_ops;",
                        "\thw = ieee80211_alloc_hw_nm(sizeof(*data), ops, param->hwname);",
                        "\tif (!hw) {",
                        "\t\tpr_debug(\"mac80211_hwsim: ieee80211_alloc_hw failed\\n\");",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto failed;",
                        "\t}",
                        "",
                        "\t/* ieee80211_alloc_hw_nm may have used a default name */",
                        "\tparam->hwname = wiphy_name(hw->wiphy);",
                        "",
                        "\tif (info)",
                        "\t\tnet = genl_info_net(info);",
                        "\telse",
                        "\t\tnet = &init_net;",
                        "\twiphy_net_set(hw->wiphy, net);",
                        "",
                        "\tdata = hw->priv;",
                        "\tdata->hw = hw;",
                        "",
                        "\tdata->dev = device_create(hwsim_class, NULL, 0, hw, \"hwsim%d\", idx);",
                        "\tif (IS_ERR(data->dev)) {",
                        "\t\tprintk(KERN_DEBUG",
                        "\t\t       \"mac80211_hwsim: device_create failed (%ld)\\n\",",
                        "\t\t       PTR_ERR(data->dev));",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto failed_drvdata;",
                        "\t}",
                        "\tdata->dev->driver = &mac80211_hwsim_driver.driver;",
                        "\terr = device_bind_driver(data->dev);",
                        "\tif (err != 0) {",
                        "\t\tpr_debug(\"mac80211_hwsim: device_bind_driver failed (%d)\\n\",",
                        "\t\t       err);",
                        "\t\tgoto failed_bind;",
                        "\t}",
                        "",
                        "\tskb_queue_head_init(&data->pending);",
                        "",
                        "\tSET_IEEE80211_DEV(hw, data->dev);",
                        "\tif (!param->perm_addr) {",
                        "\t\teth_zero_addr(addr);",
                        "\t\taddr[0] = 0x02;",
                        "\t\taddr[3] = idx >> 8;",
                        "\t\taddr[4] = idx;",
                        "\t\tmemcpy(data->addresses[0].addr, addr, ETH_ALEN);",
                        "\t\t/* Why need here second address ? */",
                        "\t\tmemcpy(data->addresses[1].addr, addr, ETH_ALEN);",
                        "\t\tdata->addresses[1].addr[0] |= 0x40;",
                        "\t\thw->wiphy->n_addresses = 2;",
                        "\t\thw->wiphy->addresses = data->addresses;",
                        "\t\t/* possible address clash is checked at hash table insertion */",
                        "\t} else {",
                        "\t\tmemcpy(data->addresses[0].addr, param->perm_addr, ETH_ALEN);",
                        "\t\t/* compatibility with automatically generated mac addr */",
                        "\t\tmemcpy(data->addresses[1].addr, param->perm_addr, ETH_ALEN);",
                        "\t\thw->wiphy->n_addresses = 2;",
                        "\t\thw->wiphy->addresses = data->addresses;",
                        "\t}",
                        "",
                        "\tdata->channels = param->channels;",
                        "\tdata->use_chanctx = param->use_chanctx;",
                        "\tdata->idx = idx;",
                        "\tdata->destroy_on_close = param->destroy_on_close;",
                        "\tif (info)",
                        "\t\tdata->portid = info->snd_portid;",
                        "",
                        "\t/* setup interface limits, only on interface types we support */",
                        "\tif (param->iftypes & BIT(NL80211_IFTYPE_ADHOC)) {",
                        "\t\tdata->if_limits[n_limits].max = 1;",
                        "\t\tdata->if_limits[n_limits].types = BIT(NL80211_IFTYPE_ADHOC);",
                        "\t\tn_limits++;",
                        "\t}",
                        "",
                        "\tif (param->iftypes & HWSIM_DEFAULT_IF_LIMIT) {",
                        "\t\tdata->if_limits[n_limits].max = 2048;",
                        "\t\t/*",
                        "\t\t * For this case, we may only support a subset of",
                        "\t\t * HWSIM_DEFAULT_IF_LIMIT, therefore we only want to add the",
                        "\t\t * bits that both param->iftype & HWSIM_DEFAULT_IF_LIMIT have.",
                        "\t\t */",
                        "\t\tdata->if_limits[n_limits].types =",
                        "\t\t\t\t\tHWSIM_DEFAULT_IF_LIMIT & param->iftypes;",
                        "\t\tn_limits++;",
                        "\t}",
                        "",
                        "\tif (param->iftypes & BIT(NL80211_IFTYPE_P2P_DEVICE)) {",
                        "\t\tdata->if_limits[n_limits].max = 1;",
                        "\t\tdata->if_limits[n_limits].types =",
                        "\t\t\t\t\t\tBIT(NL80211_IFTYPE_P2P_DEVICE);",
                        "\t\tn_limits++;",
                        "\t}",
                        "",
                        "\tif (data->use_chanctx) {",
                        "\t\thw->wiphy->max_scan_ssids = 255;",
                        "\t\thw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;",
                        "\t\thw->wiphy->max_remain_on_channel_duration = 1000;",
                        "\t\tdata->if_combination.radar_detect_widths = 0;",
                        "\t\tdata->if_combination.num_different_channels = data->channels;",
                        "\t} else {",
                        "\t\tdata->if_combination.num_different_channels = 1;",
                        "\t\tdata->if_combination.radar_detect_widths =",
                        "\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_5) |",
                        "\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_10) |",
                        "\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20_NOHT) |",
                        "\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |",
                        "\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_40) |",
                        "\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80) |",
                        "\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_160);",
                        "\t}",
                        "",
                        "\tif (!n_limits) {",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto failed_hw;",
                        "\t}",
                        "",
                        "\tdata->if_combination.max_interfaces = 0;",
                        "\tfor (i = 0; i < n_limits; i++)",
                        "\t\tdata->if_combination.max_interfaces +=",
                        "\t\t\tdata->if_limits[i].max;",
                        "",
                        "\tdata->if_combination.n_limits = n_limits;",
                        "\tdata->if_combination.limits = data->if_limits;",
                        "",
                        "\t/*",
                        "\t * If we actually were asked to support combinations,",
                        "\t * advertise them - if there's only a single thing like",
                        "\t * only IBSS then don't advertise it as combinations.",
                        "\t */",
                        "\tif (data->if_combination.max_interfaces > 1) {",
                        "\t\thw->wiphy->iface_combinations = &data->if_combination;",
                        "\t\thw->wiphy->n_iface_combinations = 1;",
                        "\t}",
                        "",
                        "\tif (param->ciphers) {",
                        "\t\tmemcpy(data->ciphers, param->ciphers,",
                        "\t\t       param->n_ciphers * sizeof(u32));",
                        "\t\thw->wiphy->cipher_suites = data->ciphers;",
                        "\t\thw->wiphy->n_cipher_suites = param->n_ciphers;",
                        "\t}",
                        "",
                        "\tINIT_DELAYED_WORK(&data->roc_start, hw_roc_start);",
                        "\tINIT_DELAYED_WORK(&data->roc_done, hw_roc_done);",
                        "\tINIT_DELAYED_WORK(&data->hw_scan, hw_scan_work);",
                        "",
                        "\thw->queues = 5;",
                        "\thw->offchannel_tx_hw_queue = 4;",
                        "",
                        "\tieee80211_hw_set(hw, SUPPORT_FAST_XMIT);",
                        "\tieee80211_hw_set(hw, CHANCTX_STA_CSA);",
                        "\tieee80211_hw_set(hw, SUPPORTS_HT_CCK_RATES);",
                        "\tieee80211_hw_set(hw, QUEUE_CONTROL);",
                        "\tieee80211_hw_set(hw, WANT_MONITOR_VIF);",
                        "\tieee80211_hw_set(hw, AMPDU_AGGREGATION);",
                        "\tieee80211_hw_set(hw, MFP_CAPABLE);",
                        "\tieee80211_hw_set(hw, SIGNAL_DBM);",
                        "\tieee80211_hw_set(hw, SUPPORTS_PS);",
                        "\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);",
                        "\tieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);",
                        "\tieee80211_hw_set(hw, PS_NULLFUNC_STACK);",
                        "\tieee80211_hw_set(hw, TDLS_WIDER_BW);",
                        "\tif (rctbl)",
                        "\t\tieee80211_hw_set(hw, SUPPORTS_RC_TABLE);",
                        "\tieee80211_hw_set(hw, SUPPORTS_MULTI_BSSID);",
                        "",
                        "\thw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;",
                        "\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS |",
                        "\t\t\t    WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |",
                        "\t\t\t    WIPHY_FLAG_AP_UAPSD |",
                        "\t\t\t    WIPHY_FLAG_SUPPORTS_5_10_MHZ |",
                        "\t\t\t    WIPHY_FLAG_HAS_CHANNEL_SWITCH;",
                        "\thw->wiphy->features |= NL80211_FEATURE_ACTIVE_MONITOR |",
                        "\t\t\t       NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |",
                        "\t\t\t       NL80211_FEATURE_STATIC_SMPS |",
                        "\t\t\t       NL80211_FEATURE_DYNAMIC_SMPS |",
                        "\t\t\t       NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;",
                        "\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_VHT_IBSS);",
                        "\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_BEACON_PROTECTION);",
                        "\twiphy_ext_feature_set(hw->wiphy,",
                        "\t\t\t      NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS);",
                        "\twiphy_ext_feature_set(hw->wiphy,",
                        "\t\t\t      NL80211_EXT_FEATURE_BEACON_RATE_LEGACY);",
                        "",
                        "\thw->wiphy->interface_modes = param->iftypes;",
                        "",
                        "\t/* ask mac80211 to reserve space for magic */",
                        "\thw->vif_data_size = sizeof(struct hwsim_vif_priv);",
                        "\thw->sta_data_size = sizeof(struct hwsim_sta_priv);",
                        "\thw->chanctx_data_size = sizeof(struct hwsim_chanctx_priv);",
                        "",
                        "\tmemcpy(data->channels_2ghz, hwsim_channels_2ghz,",
                        "\t\tsizeof(hwsim_channels_2ghz));",
                        "\tmemcpy(data->channels_5ghz, hwsim_channels_5ghz,",
                        "\t\tsizeof(hwsim_channels_5ghz));",
                        "\tmemcpy(data->channels_s1g, hwsim_channels_s1g,",
                        "\t       sizeof(hwsim_channels_s1g));",
                        "\tmemcpy(data->rates, hwsim_rates, sizeof(hwsim_rates));",
                        "",
                        "\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {",
                        "\t\tstruct ieee80211_supported_band *sband = &data->bands[band];",
                        "",
                        "\t\tsband->band = band;",
                        "",
                        "\t\tswitch (band) {",
                        "\t\tcase NL80211_BAND_2GHZ:",
                        "\t\t\tsband->channels = data->channels_2ghz;",
                        "\t\t\tsband->n_channels = ARRAY_SIZE(hwsim_channels_2ghz);",
                        "\t\t\tsband->bitrates = data->rates;",
                        "\t\t\tsband->n_bitrates = ARRAY_SIZE(hwsim_rates);",
                        "\t\t\tbreak;",
                        "\t\tcase NL80211_BAND_5GHZ:",
                        "\t\t\tsband->channels = data->channels_5ghz;",
                        "\t\t\tsband->n_channels = ARRAY_SIZE(hwsim_channels_5ghz);",
                        "\t\t\tsband->bitrates = data->rates + 4;",
                        "\t\t\tsband->n_bitrates = ARRAY_SIZE(hwsim_rates) - 4;",
                        "",
                        "\t\t\tsband->vht_cap.vht_supported = true;",
                        "\t\t\tsband->vht_cap.cap =",
                        "\t\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |",
                        "\t\t\t\tIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ |",
                        "\t\t\t\tIEEE80211_VHT_CAP_RXLDPC |",
                        "\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_80 |",
                        "\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_160 |",
                        "\t\t\t\tIEEE80211_VHT_CAP_TXSTBC |",
                        "\t\t\t\tIEEE80211_VHT_CAP_RXSTBC_4 |",
                        "\t\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;",
                        "\t\t\tsband->vht_cap.vht_mcs.rx_mcs_map =",
                        "\t\t\t\tcpu_to_le16(IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |",
                        "\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 2 |",
                        "\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 4 |",
                        "\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 6 |",
                        "\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 8 |",
                        "\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 10 |",
                        "\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 12 |",
                        "\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 14);",
                        "\t\t\tsband->vht_cap.vht_mcs.tx_mcs_map =",
                        "\t\t\t\tsband->vht_cap.vht_mcs.rx_mcs_map;",
                        "\t\t\tbreak;",
                        "\t\tcase NL80211_BAND_S1GHZ:",
                        "\t\t\tmemcpy(&sband->s1g_cap, &hwsim_s1g_cap,",
                        "\t\t\t       sizeof(sband->s1g_cap));",
                        "\t\t\tsband->channels = data->channels_s1g;",
                        "\t\t\tsband->n_channels = ARRAY_SIZE(hwsim_channels_s1g);",
                        "\t\t\tbreak;",
                        "\t\tdefault:",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "",
                        "\t\tsband->ht_cap.ht_supported = true;",
                        "\t\tsband->ht_cap.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |",
                        "\t\t\t\t    IEEE80211_HT_CAP_GRN_FLD |",
                        "\t\t\t\t    IEEE80211_HT_CAP_SGI_20 |",
                        "\t\t\t\t    IEEE80211_HT_CAP_SGI_40 |",
                        "\t\t\t\t    IEEE80211_HT_CAP_DSSSCCK40;",
                        "\t\tsband->ht_cap.ampdu_factor = 0x3;",
                        "\t\tsband->ht_cap.ampdu_density = 0x6;",
                        "\t\tmemset(&sband->ht_cap.mcs, 0,",
                        "\t\t       sizeof(sband->ht_cap.mcs));",
                        "\t\tsband->ht_cap.mcs.rx_mask[0] = 0xff;",
                        "\t\tsband->ht_cap.mcs.rx_mask[1] = 0xff;",
                        "\t\tsband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;",
                        "",
                        "\t\tmac80211_hwsim_he_capab(sband);",
                        "",
                        "\t\thw->wiphy->bands[band] = sband;",
                        "\t}",
                        "",
                        "\t/* By default all radios belong to the first group */",
                        "\tdata->group = 1;",
                        "\tmutex_init(&data->mutex);",
                        "",
                        "\tdata->netgroup = hwsim_net_get_netgroup(net);",
                        "\tdata->wmediumd = hwsim_net_get_wmediumd(net);",
                        "",
                        "\t/* Enable frame retransmissions for lossy channels */",
                        "\thw->max_rates = 4;",
                        "\thw->max_rate_tries = 11;",
                        "",
                        "\thw->wiphy->vendor_commands = mac80211_hwsim_vendor_commands;",
                        "\thw->wiphy->n_vendor_commands =",
                        "\t\tARRAY_SIZE(mac80211_hwsim_vendor_commands);",
                        "\thw->wiphy->vendor_events = mac80211_hwsim_vendor_events;",
                        "\thw->wiphy->n_vendor_events = ARRAY_SIZE(mac80211_hwsim_vendor_events);",
                        "",
                        "\tif (param->reg_strict)",
                        "\t\thw->wiphy->regulatory_flags |= REGULATORY_STRICT_REG;",
                        "\tif (param->regd) {",
                        "\t\tdata->regd = param->regd;",
                        "\t\thw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;",
                        "\t\twiphy_apply_custom_regulatory(hw->wiphy, param->regd);",
                        "\t\t/* give the regulatory workqueue a chance to run */",
                        "\t\tschedule_timeout_interruptible(1);",
                        "\t}",
                        "",
                        "\tif (param->no_vif)",
                        "\t\tieee80211_hw_set(hw, NO_AUTO_VIF);",
                        "",
                        "\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);",
                        "",
                        "\thrtimer_init(&data->beacon_timer, CLOCK_MONOTONIC,",
                        "\t\t     HRTIMER_MODE_ABS_SOFT);",
                        "\tdata->beacon_timer.function = mac80211_hwsim_beacon;",
                        "",
                        "\terr = ieee80211_register_hw(hw);",
                        "\tif (err < 0) {",
                        "\t\tpr_debug(\"mac80211_hwsim: ieee80211_register_hw failed (%d)\\n\",",
                        "\t\t       err);",
                        "\t\tgoto failed_hw;",
                        "\t}",
                        "",
                        "\twiphy_dbg(hw->wiphy, \"hwaddr %pM registered\\n\", hw->wiphy->perm_addr);",
                        "",
                        "\tif (param->reg_alpha2) {",
                        "\t\tdata->alpha2[0] = param->reg_alpha2[0];",
                        "\t\tdata->alpha2[1] = param->reg_alpha2[1];",
                        "\t\tregulatory_hint(hw->wiphy, param->reg_alpha2);",
                        "\t}",
                        "",
                        "\tdata->debugfs = debugfs_create_dir(\"hwsim\", hw->wiphy->debugfsdir);",
                        "\tdebugfs_create_file(\"ps\", 0666, data->debugfs, data, &hwsim_fops_ps);",
                        "\tdebugfs_create_file(\"group\", 0666, data->debugfs, data,",
                        "\t\t\t    &hwsim_fops_group);",
                        "\tif (!data->use_chanctx)",
                        "\t\tdebugfs_create_file(\"dfs_simulate_radar\", 0222,",
                        "\t\t\t\t    data->debugfs,",
                        "\t\t\t\t    data, &hwsim_simulate_radar);",
                        "",
                        "\tspin_lock_bh(&hwsim_radio_lock);",
                        "\terr = rhashtable_insert_fast(&hwsim_radios_rht, &data->rht,",
                        "\t\t\t\t     hwsim_rht_params);",
                        "\tif (err < 0) {",
                        "\t\tif (info) {",
                        "\t\t\tGENL_SET_ERR_MSG(info, \"perm addr already present\");",
                        "\t\t\tNL_SET_BAD_ATTR(info->extack,",
                        "\t\t\t\t\tinfo->attrs[HWSIM_ATTR_PERM_ADDR]);",
                        "\t\t}",
                        "\t\tspin_unlock_bh(&hwsim_radio_lock);",
                        "\t\tgoto failed_final_insert;",
                        "\t}",
                        "",
                        "\tlist_add_tail(&data->list, &hwsim_radios);",
                        "\thwsim_radios_generation++;",
                        "\tspin_unlock_bh(&hwsim_radio_lock);",
                        "",
                        "\thwsim_mcast_new_radio(idx, info, param);",
                        "",
                        "\treturn idx;",
                        "",
                        "failed_final_insert:",
                        "\tdebugfs_remove_recursive(data->debugfs);",
                        "\tieee80211_unregister_hw(data->hw);",
                        "failed_hw:",
                        "\tdevice_release_driver(data->dev);",
                        "failed_bind:",
                        "\tdevice_unregister(data->dev);",
                        "failed_drvdata:",
                        "\tieee80211_free_hw(hw);",
                        "failed:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2938,
                    "highlight": 3261
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818634cf"
        },
        "46521": {
            "name": "mac80211_hwsim_new_radio",
            "parent_idx": 46516,
            "source_line": [
                {
                    "file": "drivers/net/wireless/mac80211_hwsim.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/wireless/mac80211_hwsim.c?id=e28c0d7c92c89016c12a677616668957351e7542#n3822",
                    "code": [
                        "static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)",
                        "{",
                        "\tstruct hwsim_new_radio_params param = { 0 };",
                        "\tconst char *hwname = NULL;",
                        "\tint ret;",
                        "",
                        "\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];",
                        "\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];",
                        "\tparam.channels = channels;",
                        "\tparam.destroy_on_close =",
                        "\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];",
                        "",
                        "\tif (info->attrs[HWSIM_ATTR_CHANNELS])",
                        "\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);",
                        "",
                        "\tif (param.channels < 1) {",
                        "\t\tGENL_SET_ERR_MSG(info, \"must have at least one channel\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (param.channels > CFG80211_MAX_NUM_DIFFERENT_CHANNELS) {",
                        "\t\tGENL_SET_ERR_MSG(info, \"too many channels specified\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (info->attrs[HWSIM_ATTR_NO_VIF])",
                        "\t\tparam.no_vif = true;",
                        "",
                        "\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])",
                        "\t\tparam.use_chanctx = true;",
                        "\telse",
                        "\t\tparam.use_chanctx = (param.channels > 1);",
                        "",
                        "\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])",
                        "\t\tparam.reg_alpha2 =",
                        "\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);",
                        "",
                        "\tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {",
                        "\t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);",
                        "",
                        "\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\tidx = array_index_nospec(idx,",
                        "\t\t\t\t\t ARRAY_SIZE(hwsim_world_regdom_custom));",
                        "\t\tparam.regd = hwsim_world_regdom_custom[idx];",
                        "\t}",
                        "",
                        "\tif (info->attrs[HWSIM_ATTR_PERM_ADDR]) {",
                        "\t\tif (!is_valid_ether_addr(",
                        "\t\t\t\tnla_data(info->attrs[HWSIM_ATTR_PERM_ADDR]))) {",
                        "\t\t\tGENL_SET_ERR_MSG(info,\"MAC is no valid source addr\");",
                        "\t\t\tNL_SET_BAD_ATTR(info->extack,",
                        "\t\t\t\t\tinfo->attrs[HWSIM_ATTR_PERM_ADDR]);",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "",
                        "\t\tparam.perm_addr = nla_data(info->attrs[HWSIM_ATTR_PERM_ADDR]);",
                        "\t}",
                        "",
                        "\tif (info->attrs[HWSIM_ATTR_IFTYPE_SUPPORT]) {",
                        "\t\tparam.iftypes =",
                        "\t\t\tnla_get_u32(info->attrs[HWSIM_ATTR_IFTYPE_SUPPORT]);",
                        "",
                        "\t\tif (param.iftypes & ~HWSIM_IFTYPE_SUPPORT_MASK) {",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,",
                        "\t\t\t\t\t    info->attrs[HWSIM_ATTR_IFTYPE_SUPPORT],",
                        "\t\t\t\t\t    \"cannot support more iftypes than kernel\");",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "\t} else {",
                        "\t\tparam.iftypes = HWSIM_IFTYPE_SUPPORT_MASK;",
                        "\t}",
                        "",
                        "\t/* ensure both flag and iftype support is honored */",
                        "\tif (param.p2p_device ||",
                        "\t    param.iftypes & BIT(NL80211_IFTYPE_P2P_DEVICE)) {",
                        "\t\tparam.iftypes |= BIT(NL80211_IFTYPE_P2P_DEVICE);",
                        "\t\tparam.p2p_device = true;",
                        "\t}",
                        "",
                        "\tif (info->attrs[HWSIM_ATTR_CIPHER_SUPPORT]) {",
                        "\t\tu32 len = nla_len(info->attrs[HWSIM_ATTR_CIPHER_SUPPORT]);",
                        "",
                        "\t\tparam.ciphers =",
                        "\t\t\tnla_data(info->attrs[HWSIM_ATTR_CIPHER_SUPPORT]);",
                        "",
                        "\t\tif (len % sizeof(u32)) {",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,",
                        "\t\t\t\t\t    info->attrs[HWSIM_ATTR_CIPHER_SUPPORT],",
                        "\t\t\t\t\t    \"bad cipher list length\");",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "",
                        "\t\tparam.n_ciphers = len / sizeof(u32);",
                        "",
                        "\t\tif (param.n_ciphers > ARRAY_SIZE(hwsim_ciphers)) {",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,",
                        "\t\t\t\t\t    info->attrs[HWSIM_ATTR_CIPHER_SUPPORT],",
                        "\t\t\t\t\t    \"too many ciphers specified\");",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "",
                        "\t\tif (!hwsim_known_ciphers(param.ciphers, param.n_ciphers)) {",
                        "\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,",
                        "\t\t\t\t\t    info->attrs[HWSIM_ATTR_CIPHER_SUPPORT],",
                        "\t\t\t\t\t    \"unsupported ciphers specified\");",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {",
                        "\t\thwname = kstrndup((char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]),",
                        "\t\t\t\t  nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),",
                        "\t\t\t\t  GFP_KERNEL);",
                        "\t\tif (!hwname)",
                        "\t\t\treturn -ENOMEM;",
                        "\t\tparam.hwname = hwname;",
                        "\t}",
                        "",
                        "\tret = mac80211_hwsim_new_radio(info, &param);",
                        "\tkfree(hwname);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3702,
                    "highlight": 3822
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81863d90"
        },
        "46516": {
            "name": "hwsim_new_radio_nl(indirect)",
            "parent_idx": 46491,
            "source_line": [
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=e28c0d7c92c89016c12a677616668957351e7542#n739",
                    "code": [
                        "static int genl_family_rcv_msg_doit(const struct genl_family *family,",
                        "\t\t\t\t    struct sk_buff *skb,",
                        "\t\t\t\t    struct nlmsghdr *nlh,",
                        "\t\t\t\t    struct netlink_ext_ack *extack,",
                        "\t\t\t\t    const struct genl_ops *ops,",
                        "\t\t\t\t    int hdrlen, struct net *net)",
                        "{",
                        "\tstruct nlattr **attrbuf;",
                        "\tstruct genl_info info;",
                        "\tint err;",
                        "",
                        "\tif (!ops->doit)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tattrbuf = genl_family_rcv_msg_attrs_parse(family, nlh, extack,",
                        "\t\t\t\t\t\t  ops, hdrlen,",
                        "\t\t\t\t\t\t  GENL_DONT_VALIDATE_STRICT);",
                        "\tif (IS_ERR(attrbuf))",
                        "\t\treturn PTR_ERR(attrbuf);",
                        "",
                        "\tinfo.snd_seq = nlh->nlmsg_seq;",
                        "\tinfo.snd_portid = NETLINK_CB(skb).portid;",
                        "\tinfo.nlhdr = nlh;",
                        "\tinfo.genlhdr = nlmsg_data(nlh);",
                        "\tinfo.userhdr = nlmsg_data(nlh) + GENL_HDRLEN;",
                        "\tinfo.attrs = attrbuf;",
                        "\tinfo.extack = extack;",
                        "\tgenl_info_net_set(&info, net);",
                        "\tmemset(&info.user_ptr, 0, sizeof(info.user_ptr));",
                        "",
                        "\tif (family->pre_doit) {",
                        "\t\terr = family->pre_doit(ops, skb, &info);",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "",
                        "\terr = ops->doit(skb, &info);",
                        "",
                        "\tif (family->post_doit)",
                        "\t\tfamily->post_doit(ops, skb, &info);",
                        "",
                        "out:",
                        "\tgenl_family_rcv_msg_attrs_free(attrbuf);",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 703,
                    "highlight": 739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81a4f120"
        },
        "46491": {
            "name": "genl_family_rcv_msg_doit",
            "parent_idx": 46424,
            "source_line": [
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=e28c0d7c92c89016c12a677616668957351e7542#n783",
                    "code": [
                        "static int genl_family_rcv_msg(const struct genl_family *family,",
                        "\t\t\t       struct sk_buff *skb,",
                        "\t\t\t       struct nlmsghdr *nlh,",
                        "\t\t\t       struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct genlmsghdr *hdr = nlmsg_data(nlh);",
                        "\tstruct genl_ops op;",
                        "\tint hdrlen;",
                        "",
                        "\t/* this family doesn't exist in this netns */",
                        "\tif (!family->netnsok && !net_eq(net, &init_net))",
                        "\t\treturn -ENOENT;",
                        "",
                        "\thdrlen = GENL_HDRLEN + family->hdrsize;",
                        "\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (genl_get_cmd(hdr->cmd, family, &op))",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tif ((op.flags & GENL_ADMIN_PERM) &&",
                        "\t    !netlink_capable(skb, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\tif ((op.flags & GENL_UNS_ADMIN_PERM) &&",
                        "\t    !netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\tif ((nlh->nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP)",
                        "\t\treturn genl_family_rcv_msg_dumpit(family, skb, nlh, extack,",
                        "\t\t\t\t\t\t  &op, hdrlen, net);",
                        "\telse",
                        "\t\treturn genl_family_rcv_msg_doit(family, skb, nlh, extack,",
                        "\t\t\t\t\t\t&op, hdrlen, net);",
                        "}"
                    ],
                    "start": 750,
                    "highlight": 783
                },
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=e28c0d7c92c89016c12a677616668957351e7542#n800",
                    "code": [
                        "static int genl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\tstruct netlink_ext_ack *extack)",
                        "{",
                        "\tconst struct genl_family *family;",
                        "\tint err;",
                        "",
                        "\tfamily = genl_family_find_byid(nlh->nlmsg_type);",
                        "\tif (family == NULL)",
                        "\t\treturn -ENOENT;",
                        "",
                        "\tif (!family->parallel_ops)",
                        "\t\tgenl_lock();",
                        "",
                        "\terr = genl_family_rcv_msg(family, skb, nlh, extack);",
                        "",
                        "\tif (!family->parallel_ops)",
                        "\t\tgenl_unlock();",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 787,
                    "highlight": 800
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81a4f474"
        },
        "46424": {
            "name": "genl_rcv_msg(indirect)",
            "parent_idx": 46417,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=e28c0d7c92c89016c12a677616668957351e7542#n2494",
                    "code": [
                        "int netlink_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *,",
                        "\t\t\t\t\t\t   struct nlmsghdr *,",
                        "\t\t\t\t\t\t   struct netlink_ext_ack *))",
                        "{",
                        "\tstruct netlink_ext_ack extack;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tint err;",
                        "",
                        "\twhile (skb->len >= nlmsg_total_size(0)) {",
                        "\t\tint msglen;",
                        "",
                        "\t\tmemset(&extack, 0, sizeof(extack));",
                        "\t\tnlh = nlmsg_hdr(skb);",
                        "\t\terr = 0;",
                        "",
                        "\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len)",
                        "\t\t\treturn 0;",
                        "",
                        "\t\t/* Only requests are handled by the kernel */",
                        "\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST))",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\t/* Skip control messages */",
                        "\t\tif (nlh->nlmsg_type < NLMSG_MIN_TYPE)",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\terr = cb(skb, nlh, &extack);",
                        "\t\tif (err == -EINTR)",
                        "\t\t\tgoto skip;",
                        "",
                        "ack:",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err)",
                        "\t\t\tnetlink_ack(skb, nlh, err, &extack);",
                        "",
                        "skip:",
                        "\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);",
                        "\t\tif (msglen > skb->len)",
                        "\t\t\tmsglen = skb->len;",
                        "\t\tskb_pull(skb, msglen);",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 2468,
                    "highlight": 2494
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81a4e4e6"
        },
        "46417": {
            "name": "netlink_rcv_skb",
            "parent_idx": 46408,
            "source_line": [
                {
                    "file": "net/netlink/genetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/genetlink.c?id=e28c0d7c92c89016c12a677616668957351e7542#n811",
                    "code": [
                        "static void genl_rcv(struct sk_buff *skb)",
                        "{",
                        "\tdown_read(&cb_lock);",
                        "\tnetlink_rcv_skb(skb, &genl_rcv_msg);",
                        "\tup_read(&cb_lock);",
                        "}"
                    ],
                    "start": 808,
                    "highlight": 811
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81a4eafa"
        },
        "46408": {
            "name": "genl_rcv(indirect)",
            "parent_idx": 46310,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1304",
                    "code": [
                        "static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,",
                        "\t\t\t\t  struct sock *ssk)",
                        "{",
                        "\tint ret;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "",
                        "\tret = -ECONNREFUSED;",
                        "\tif (nlk->netlink_rcv != NULL) {",
                        "\t\tret = skb->len;",
                        "\t\tnetlink_skb_set_owner_r(skb, sk);",
                        "\t\tNETLINK_CB(skb).sk = ssk;",
                        "\t\tnetlink_deliver_tap_kernel(sk, ssk, skb);",
                        "\t\tnlk->netlink_rcv(skb);",
                        "\t\tconsume_skb(skb);",
                        "\t} else {",
                        "\t\tkfree_skb(skb);",
                        "\t}",
                        "\tsock_put(sk);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1292,
                    "highlight": 1304
                },
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1330",
                    "code": [
                        "int netlink_unicast(struct sock *ssk, struct sk_buff *skb,",
                        "\t\t    u32 portid, int nonblock)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tint err;",
                        "\tlong timeo;",
                        "",
                        "\tskb = netlink_trim(skb, gfp_any());",
                        "",
                        "\ttimeo = sock_sndtimeo(ssk, nonblock);",
                        "retry:",
                        "\tsk = netlink_getsockbyportid(ssk, portid);",
                        "\tif (IS_ERR(sk)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn PTR_ERR(sk);",
                        "\t}",
                        "\tif (netlink_is_kernel(sk))",
                        "\t\treturn netlink_unicast_kernel(sk, skb, ssk);",
                        "",
                        "\tif (sk_filter(sk, skb)) {",
                        "\t\terr = skb->len;",
                        "\t\tkfree_skb(skb);",
                        "\t\tsock_put(sk);",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = netlink_attachskb(sk, skb, &timeo, ssk);",
                        "\tif (err == 1)",
                        "\t\tgoto retry;",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\treturn netlink_sendskb(sk, skb);",
                        "}"
                    ],
                    "start": 1313,
                    "highlight": 1330
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81a4dc17"
        },
        "46310": {
            "name": "netlink_unicast",
            "parent_idx": 46221,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1919",
                    "code": [
                        "static int netlink_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "\tDECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);",
                        "\tu32 dst_portid;",
                        "\tu32 dst_group;",
                        "\tstruct sk_buff *skb;",
                        "\tint err;",
                        "\tstruct scm_cookie scm;",
                        "\tu32 netlink_skb_flags = 0;",
                        "",
                        "\tif (msg->msg_flags & MSG_OOB)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\terr = scm_send(sock, msg, &scm, true);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tif (msg->msg_namelen) {",
                        "\t\terr = -EINVAL;",
                        "\t\tif (msg->msg_namelen < sizeof(struct sockaddr_nl))",
                        "\t\t\tgoto out;",
                        "\t\tif (addr->nl_family != AF_NETLINK)",
                        "\t\t\tgoto out;",
                        "\t\tdst_portid = addr->nl_pid;",
                        "\t\tdst_group = ffs(addr->nl_groups);",
                        "\t\terr =  -EPERM;",
                        "\t\tif ((dst_group || dst_portid) &&",
                        "\t\t    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))",
                        "\t\t\tgoto out;",
                        "\t\tnetlink_skb_flags |= NETLINK_SKB_DST;",
                        "\t} else {",
                        "\t\tdst_portid = nlk->dst_portid;",
                        "\t\tdst_group = nlk->dst_group;",
                        "\t}",
                        "",
                        "\tif (!nlk->bound) {",
                        "\t\terr = netlink_autobind(sock);",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t} else {",
                        "\t\t/* Ensure nlk is hashed and visible. */",
                        "\t\tsmp_rmb();",
                        "\t}",
                        "",
                        "\terr = -EMSGSIZE;",
                        "\tif (len > sk->sk_sndbuf - 32)",
                        "\t\tgoto out;",
                        "\terr = -ENOBUFS;",
                        "\tskb = netlink_alloc_large_skb(len, dst_group);",
                        "\tif (skb == NULL)",
                        "\t\tgoto out;",
                        "",
                        "\tNETLINK_CB(skb).portid\t= nlk->portid;",
                        "\tNETLINK_CB(skb).dst_group = dst_group;",
                        "\tNETLINK_CB(skb).creds\t= scm.creds;",
                        "\tNETLINK_CB(skb).flags\t= netlink_skb_flags;",
                        "",
                        "\terr = -EFAULT;",
                        "\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\terr = security_netlink_send(sk, skb);",
                        "\tif (err) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (dst_group) {",
                        "\t\trefcount_inc(&skb->users);",
                        "\t\tnetlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);",
                        "\t}",
                        "\terr = netlink_unicast(sk, skb, dst_portid, msg->msg_flags & MSG_DONTWAIT);",
                        "",
                        "out:",
                        "\tscm_destroy(&scm);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1844,
                    "highlight": 1919
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81a4defb"
        },
        "46221": {
            "name": "netlink_sendmsg(indirect)",
            "parent_idx": 46206,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=e28c0d7c92c89016c12a677616668957351e7542#n651",
                    "code": [
                        "INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t   size_t));",
                        "INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t    size_t));",
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,",
                        "\t\t\t\t     inet_sendmsg, sock, msg,",
                        "\t\t\t\t     msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 645,
                    "highlight": 651
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=e28c0d7c92c89016c12a677616668957351e7542#n671",
                    "code": [
                        "/**",
                        " *\tsock_sendmsg - send a message through @sock",
                        " *\t@sock: socket",
                        " *\t@msg: message to send",
                        " *",
                        " *\tSends @msg through @sock, passing through LSM.",
                        " *\tReturns the number of bytes sent, or an error code.",
                        " */",
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 658,
                    "highlight": 671
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819d6984"
        },
        "46206": {
            "name": "sock_sendmsg",
            "parent_idx": 46133,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1992",
                    "code": [
                        "/*",
                        " *\tSend a datagram to a given address. We move the address into kernel",
                        " *\tspace and check the user space data area is readable before invoking",
                        " *\tthe protocol.",
                        " */",
                        "int __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags,",
                        "\t\t struct sockaddr __user *addr,  int addr_len)",
                        "{",
                        "\tstruct socket *sock;",
                        "\tstruct sockaddr_storage address;",
                        "\tint err;",
                        "\tstruct msghdr msg;",
                        "\tstruct iovec iov;",
                        "\tint fput_needed;",
                        "",
                        "\terr = import_single_range(WRITE, buff, len, &iov, &msg.msg_iter);",
                        "\tif (unlikely(err))",
                        "\t\treturn err;",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (!sock)",
                        "\t\tgoto out;",
                        "",
                        "\tmsg.msg_name = NULL;",
                        "\tmsg.msg_control = NULL;",
                        "\tmsg.msg_controllen = 0;",
                        "\tmsg.msg_namelen = 0;",
                        "\tif (addr) {",
                        "\t\terr = move_addr_to_kernel(addr, addr_len, &address);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto out_put;",
                        "\t\tmsg.msg_name = (struct sockaddr *)&address;",
                        "\t\tmsg.msg_namelen = addr_len;",
                        "\t}",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tflags |= MSG_DONTWAIT;",
                        "\tmsg.msg_flags = flags;",
                        "\terr = sock_sendmsg(sock, &msg);",
                        "",
                        "out_put:",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1956,
                    "highlight": 1992
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819d8844"
        },
        "46133": {
            "name": "__sys_sendto",
            "parent_idx": 46127,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=e28c0d7c92c89016c12a677616668957351e7542#n2004",
                    "code": [
                        "SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,",
                        "\t\tunsigned int, flags, struct sockaddr __user *, addr,",
                        "\t\tint, addr_len)",
                        "{",
                        "\treturn __sys_sendto(fd, buff, len, flags, addr, addr_len);",
                        "}"
                    ],
                    "start": 2000,
                    "highlight": 2004
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=e28c0d7c92c89016c12a677616668957351e7542#n2000",
                    "code": [
                        "/*",
                        " *\tSend a datagram to a given address. We move the address into kernel",
                        " *\tspace and check the user space data area is readable before invoking",
                        " *\tthe protocol.",
                        " */",
                        "int __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags,",
                        "\t\t struct sockaddr __user *addr,  int addr_len)",
                        "{",
                        "\tstruct socket *sock;",
                        "\tstruct sockaddr_storage address;",
                        "\tint err;",
                        "\tstruct msghdr msg;",
                        "\tstruct iovec iov;",
                        "\tint fput_needed;",
                        "",
                        "\terr = import_single_range(WRITE, buff, len, &iov, &msg.msg_iter);",
                        "\tif (unlikely(err))",
                        "\t\treturn err;",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (!sock)",
                        "\t\tgoto out;",
                        "",
                        "\tmsg.msg_name = NULL;",
                        "\tmsg.msg_control = NULL;",
                        "\tmsg.msg_controllen = 0;",
                        "\tmsg.msg_namelen = 0;",
                        "\tif (addr) {",
                        "\t\terr = move_addr_to_kernel(addr, addr_len, &address);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto out_put;",
                        "\t\tmsg.msg_name = (struct sockaddr *)&address;",
                        "\t\tmsg.msg_namelen = addr_len;",
                        "\t}",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tflags |= MSG_DONTWAIT;",
                        "\tmsg.msg_flags = flags;",
                        "\terr = sock_sendmsg(sock, &msg);",
                        "",
                        "out_put:",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}",
                        "",
                        "SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,",
                        "\t\tunsigned int, flags, struct sockaddr __user *, addr,",
                        "\t\tint, addr_len)",
                        "{",
                        "\treturn __sys_sendto(fd, buff, len, flags, addr, addr_len);",
                        "}"
                    ],
                    "start": 1956,
                    "highlight": 2000
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819d88cb"
        },
        "46127": {
            "name": "__x64_sys_sendto(indirect)",
            "parent_idx": 46124,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=e28c0d7c92c89016c12a677616668957351e7542#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81cf68ee"
        },
        "46124": {
            "name": "do_syscall_64",
            "parent_idx": 46108,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=e28c0d7c92c89016c12a677616668957351e7542#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e00077"
        },
        "46108": {
            "name": "1347_syscall_70",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "74745": {
            "name": "+0x261",
            "parent_idx": 74741,
            "source_line": [
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n633",
                    "code": [
                        "/*",
                        " * Main event dispatcher. Called from other parts and drivers.",
                        " * Send the event on the appropriate channels.",
                        " * May be called from interrupt context.",
                        " */",
                        "void wireless_send_event(struct net_device *\tdev,",
                        "\t\t\t unsigned int\t\tcmd,",
                        "\t\t\t union iwreq_data *\twrqu,",
                        "\t\t\t const char *\t\textra)",
                        "{",
                        "\tconst struct iw_ioctl_description *\tdescr = NULL;",
                        "\tint extra_len = 0;",
                        "\tstruct iw_event  *event;\t\t/* Mallocated whole event */",
                        "\tint event_len;\t\t\t\t/* Its size */",
                        "\tint hdr_len;\t\t\t\t/* Size of the event header */",
                        "\tint wrqu_off = 0;\t\t\t/* Offset in wrqu */",
                        "\t/* Don't \"optimise\" the following variable, it will crash */",
                        "\tunsigned int\tcmd_index;\t\t/* *MUST* be unsigned */",
                        "\tstruct sk_buff *skb;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tstruct nlattr *nla;",
                        "#ifdef CONFIG_COMPAT",
                        "\tstruct __compat_iw_event *compat_event;",
                        "\tstruct compat_iw_point compat_wrqu;",
                        "\tstruct sk_buff *compskb;",
                        "#endif",
                        "",
                        "\t/*",
                        "\t * Nothing in the kernel sends scan events with data, be safe.",
                        "\t * This is necessary because we cannot fix up scan event data",
                        "\t * for compat, due to being contained in 'extra', but normally",
                        "\t * applications are required to retrieve the scan data anyway",
                        "\t * and no data is included in the event, this codifies that",
                        "\t * practice.",
                        "\t */",
                        "\tif (WARN_ON(cmd == SIOCGIWSCAN && extra))",
                        "\t\textra = NULL;",
                        "",
                        "\t/* Get the description of the Event */",
                        "\tif (cmd <= SIOCIWLAST) {",
                        "\t\tcmd_index = IW_IOCTL_IDX(cmd);",
                        "\t\tif (cmd_index < standard_ioctl_num)",
                        "\t\t\tdescr = &(standard_ioctl[cmd_index]);",
                        "\t} else {",
                        "\t\tcmd_index = IW_EVENT_IDX(cmd);",
                        "\t\tif (cmd_index < standard_event_num)",
                        "\t\t\tdescr = &(standard_event[cmd_index]);",
                        "\t}",
                        "\t/* Don't accept unknown events */",
                        "\tif (descr == NULL) {",
                        "\t\t/* Note : we don't return an error to the driver, because",
                        "\t\t * the driver would not know what to do about it. It can't",
                        "\t\t * return an error to the user, because the event is not",
                        "\t\t * initiated by a user request.",
                        "\t\t * The best the driver could do is to log an error message.",
                        "\t\t * We will do it ourselves instead...",
                        "\t\t */",
                        "\t\tnetdev_err(dev, \"(WE) : Invalid/Unknown Wireless Event (0x%04X)\\n\",",
                        "\t\t\t   cmd);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* Check extra parameters and set extra_len */",
                        "\tif (descr->header_type == IW_HEADER_TYPE_POINT) {",
                        "\t\t/* Check if number of token fits within bounds */",
                        "\t\tif (wrqu->data.length > descr->max_tokens) {",
                        "\t\t\tnetdev_err(dev, \"(WE) : Wireless Event (cmd=0x%04X) too big (%d)\\n\",",
                        "\t\t\t\t   cmd, wrqu->data.length);",
                        "\t\t\treturn;",
                        "\t\t}",
                        "\t\tif (wrqu->data.length < descr->min_tokens) {",
                        "\t\t\tnetdev_err(dev, \"(WE) : Wireless Event (cmd=0x%04X) too small (%d)\\n\",",
                        "\t\t\t\t   cmd, wrqu->data.length);",
                        "\t\t\treturn;",
                        "\t\t}",
                        "\t\t/* Calculate extra_len - extra is NULL for restricted events */",
                        "\t\tif (extra != NULL)",
                        "\t\t\textra_len = wrqu->data.length * descr->token_size;",
                        "\t\t/* Always at an offset in wrqu */",
                        "\t\twrqu_off = IW_EV_POINT_OFF;",
                        "\t}",
                        "",
                        "\t/* Total length of the event */",
                        "\thdr_len = event_type_size[descr->header_type];",
                        "\tevent_len = hdr_len + extra_len;",
                        "",
                        "\t/*",
                        "\t * The problem for 64/32 bit.",
                        "\t *",
                        "\t * On 64-bit, a regular event is laid out as follows:",
                        "\t *      |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |",
                        "\t *      | event.len | event.cmd |     p a d d i n g     |",
                        "\t *      | wrqu data ... (with the correct size)         |",
                        "\t *",
                        "\t * This padding exists because we manipulate event->u,",
                        "\t * and 'event' is not packed.",
                        "\t *",
                        "\t * An iw_point event is laid out like this instead:",
                        "\t *      |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |",
                        "\t *      | event.len | event.cmd |     p a d d i n g     |",
                        "\t *      | iwpnt.len | iwpnt.flg |     p a d d i n g     |",
                        "\t *      | extra data  ...",
                        "\t *",
                        "\t * The second padding exists because struct iw_point is extended,",
                        "\t * but this depends on the platform...",
                        "\t *",
                        "\t * On 32-bit, all the padding shouldn't be there.",
                        "\t */",
                        "",
                        "\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);",
                        "\tif (!skb)",
                        "\t\treturn;",
                        "",
                        "\t/* Send via the RtNetlink event channel */",
                        "\tnlh = rtnetlink_ifinfo_prep(dev, skb);",
                        "\tif (WARN_ON(!nlh)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* Add the wireless events in the netlink packet */",
                        "\tnla = nla_reserve(skb, IFLA_WIRELESS, event_len);",
                        "\tif (!nla) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn;",
                        "\t}",
                        "\tevent = nla_data(nla);",
                        "",
                        "\t/* Fill event - first clear to avoid data leaking */",
                        "\tmemset(event, 0, hdr_len);",
                        "\tevent->len = event_len;",
                        "\tevent->cmd = cmd;",
                        "\tmemcpy(&event->u, ((char *) wrqu) + wrqu_off, hdr_len - IW_EV_LCP_LEN);",
                        "\tif (extra_len)",
                        "\t\tmemcpy(((char *) event) + hdr_len, extra, extra_len);",
                        "",
                        "\tnlmsg_end(skb, nlh);",
                        "#ifdef CONFIG_COMPAT",
                        "\thdr_len = compat_event_type_size[descr->header_type];",
                        "\tevent_len = hdr_len + extra_len;",
                        "",
                        "\tcompskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);",
                        "\tif (!compskb) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* Send via the RtNetlink event channel */",
                        "\tnlh = rtnetlink_ifinfo_prep(dev, compskb);",
                        "\tif (WARN_ON(!nlh)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tkfree_skb(compskb);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* Add the wireless events in the netlink packet */",
                        "\tnla = nla_reserve(compskb, IFLA_WIRELESS, event_len);",
                        "\tif (!nla) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tkfree_skb(compskb);",
                        "\t\treturn;",
                        "\t}",
                        "\tcompat_event = nla_data(nla);",
                        "",
                        "\tcompat_event->len = event_len;",
                        "\tcompat_event->cmd = cmd;",
                        "\tif (descr->header_type == IW_HEADER_TYPE_POINT) {",
                        "\t\tcompat_wrqu.length = wrqu->data.length;",
                        "\t\tcompat_wrqu.flags = wrqu->data.flags;",
                        "\t\tmemcpy(&compat_event->pointer,",
                        "\t\t\t((char *) &compat_wrqu) + IW_EV_COMPAT_POINT_OFF,",
                        "\t\t\thdr_len - IW_EV_COMPAT_LCP_LEN);",
                        "\t\tif (extra_len)",
                        "\t\t\tmemcpy(((char *) compat_event) + hdr_len,",
                        "\t\t\t\textra, extra_len);",
                        "\t} else {",
                        "\t\t/* extra_len must be zero, so no if (extra) needed */",
                        "\t\tmemcpy(&compat_event->pointer, wrqu,",
                        "\t\t\thdr_len - IW_EV_COMPAT_LCP_LEN);",
                        "\t}",
                        "",
                        "\tnlmsg_end(compskb, nlh);",
                        "",
                        "\tskb_shinfo(skb)->frag_list = compskb;",
                        "#endif",
                        "\tskb_queue_tail(&dev_net(dev)->wext_nlevents, skb);",
                        "\tschedule_work(&wireless_nlevent_work);",
                        "}"
                    ],
                    "start": 446,
                    "highlight": 633
                }
            ],
            "ins_idx": 4349,
            "addr": "0xffffffff81c0dcf1"
        },
        "74741": {
            "name": "wireless_send_event",
            "parent_idx": 74695,
            "source_line": [
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1021",
                    "code": [
                        "/*",
                        " * Wrapper to call a standard Wireless Extension handler.",
                        " * We do various checks and also take care of moving data between",
                        " * user space and kernel space.",
                        " */",
                        "static int ioctl_standard_call(struct net_device *\tdev,",
                        "\t\t\t       struct iwreq\t\t*iwr,",
                        "\t\t\t       unsigned int\t\tcmd,",
                        "\t\t\t       struct iw_request_info\t*info,",
                        "\t\t\t       iw_handler\t\thandler)",
                        "{",
                        "\tconst struct iw_ioctl_description *\tdescr;",
                        "\tint\t\t\t\t\tret = -EINVAL;",
                        "",
                        "\t/* Get the description of the IOCTL */",
                        "\tif (IW_IOCTL_IDX(cmd) >= standard_ioctl_num)",
                        "\t\treturn -EOPNOTSUPP;",
                        "\tdescr = &(standard_ioctl[IW_IOCTL_IDX(cmd)]);",
                        "",
                        "\t/* Check if we have a pointer to user space data or not */",
                        "\tif (descr->header_type != IW_HEADER_TYPE_POINT) {",
                        "",
                        "\t\t/* No extra arguments. Trivial to handle */",
                        "\t\tret = handler(dev, info, &(iwr->u), NULL);",
                        "",
                        "\t\t/* Generate an event to notify listeners of the change */",
                        "\t\tif ((descr->flags & IW_DESCR_FLAG_EVENT) &&",
                        "\t\t   ((ret == 0) || (ret == -EIWCOMMIT)))",
                        "\t\t\twireless_send_event(dev, cmd, &(iwr->u), NULL);",
                        "\t} else {",
                        "\t\tret = ioctl_standard_iw_point(&iwr->u.data, cmd, descr,",
                        "\t\t\t\t\t      handler, dev, info);",
                        "\t}",
                        "",
                        "\t/* Call commit handler if needed and defined */",
                        "\tif (ret == -EIWCOMMIT)",
                        "\t\tret = call_commit_handler(dev);",
                        "",
                        "\t/* Here, we will generate the appropriate event if needed */",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 993,
                    "highlight": 1021
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c0e428"
        },
        "74743": {
            "name": "+0x6",
            "parent_idx": 74741,
            "source_line": [
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n455",
                    "code": [
                        "/*",
                        " * Main event dispatcher. Called from other parts and drivers.",
                        " * Send the event on the appropriate channels.",
                        " * May be called from interrupt context.",
                        " */",
                        "void wireless_send_event(struct net_device *\tdev,",
                        "\t\t\t unsigned int\t\tcmd,",
                        "\t\t\t union iwreq_data *\twrqu,",
                        "\t\t\t const char *\t\textra)",
                        "{",
                        "\tconst struct iw_ioctl_description *\tdescr = NULL;",
                        "\tint extra_len = 0;",
                        "\tstruct iw_event  *event;\t\t/* Mallocated whole event */",
                        "\tint event_len;\t\t\t\t/* Its size */",
                        "\tint hdr_len;\t\t\t\t/* Size of the event header */",
                        "\tint wrqu_off = 0;\t\t\t/* Offset in wrqu */",
                        "\t/* Don't \"optimise\" the following variable, it will crash */",
                        "\tunsigned int\tcmd_index;\t\t/* *MUST* be unsigned */",
                        "\tstruct sk_buff *skb;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tstruct nlattr *nla;",
                        "#ifdef CONFIG_COMPAT",
                        "\tstruct __compat_iw_event *compat_event;",
                        "\tstruct compat_iw_point compat_wrqu;",
                        "\tstruct sk_buff *compskb;",
                        "#endif",
                        "",
                        "\t/*",
                        "\t * Nothing in the kernel sends scan events with data, be safe.",
                        "\t * This is necessary because we cannot fix up scan event data",
                        "\t * for compat, due to being contained in 'extra', but normally",
                        "\t * applications are required to retrieve the scan data anyway",
                        "\t * and no data is included in the event, this codifies that",
                        "\t * practice.",
                        "\t */",
                        "\tif (WARN_ON(cmd == SIOCGIWSCAN && extra))",
                        "\t\textra = NULL;",
                        "",
                        "\t/* Get the description of the Event */",
                        "\tif (cmd <= SIOCIWLAST) {",
                        "\t\tcmd_index = IW_IOCTL_IDX(cmd);",
                        "\t\tif (cmd_index < standard_ioctl_num)",
                        "\t\t\tdescr = &(standard_ioctl[cmd_index]);",
                        "\t} else {",
                        "\t\tcmd_index = IW_EVENT_IDX(cmd);",
                        "\t\tif (cmd_index < standard_event_num)",
                        "\t\t\tdescr = &(standard_event[cmd_index]);",
                        "\t}",
                        "\t/* Don't accept unknown events */",
                        "\tif (descr == NULL) {",
                        "\t\t/* Note : we don't return an error to the driver, because",
                        "\t\t * the driver would not know what to do about it. It can't",
                        "\t\t * return an error to the user, because the event is not",
                        "\t\t * initiated by a user request.",
                        "\t\t * The best the driver could do is to log an error message.",
                        "\t\t * We will do it ourselves instead...",
                        "\t\t */",
                        "\t\tnetdev_err(dev, \"(WE) : Invalid/Unknown Wireless Event (0x%04X)\\n\",",
                        "\t\t\t   cmd);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* Check extra parameters and set extra_len */",
                        "\tif (descr->header_type == IW_HEADER_TYPE_POINT) {",
                        "\t\t/* Check if number of token fits within bounds */",
                        "\t\tif (wrqu->data.length > descr->max_tokens) {",
                        "\t\t\tnetdev_err(dev, \"(WE) : Wireless Event (cmd=0x%04X) too big (%d)\\n\",",
                        "\t\t\t\t   cmd, wrqu->data.length);",
                        "\t\t\treturn;",
                        "\t\t}",
                        "\t\tif (wrqu->data.length < descr->min_tokens) {",
                        "\t\t\tnetdev_err(dev, \"(WE) : Wireless Event (cmd=0x%04X) too small (%d)\\n\",",
                        "\t\t\t\t   cmd, wrqu->data.length);",
                        "\t\t\treturn;",
                        "\t\t}",
                        "\t\t/* Calculate extra_len - extra is NULL for restricted events */",
                        "\t\tif (extra != NULL)",
                        "\t\t\textra_len = wrqu->data.length * descr->token_size;",
                        "\t\t/* Always at an offset in wrqu */",
                        "\t\twrqu_off = IW_EV_POINT_OFF;",
                        "\t}",
                        "",
                        "\t/* Total length of the event */",
                        "\thdr_len = event_type_size[descr->header_type];",
                        "\tevent_len = hdr_len + extra_len;",
                        "",
                        "\t/*",
                        "\t * The problem for 64/32 bit.",
                        "\t *",
                        "\t * On 64-bit, a regular event is laid out as follows:",
                        "\t *      |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |",
                        "\t *      | event.len | event.cmd |     p a d d i n g     |",
                        "\t *      | wrqu data ... (with the correct size)         |",
                        "\t *",
                        "\t * This padding exists because we manipulate event->u,",
                        "\t * and 'event' is not packed.",
                        "\t *",
                        "\t * An iw_point event is laid out like this instead:",
                        "\t *      |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |",
                        "\t *      | event.len | event.cmd |     p a d d i n g     |",
                        "\t *      | iwpnt.len | iwpnt.flg |     p a d d i n g     |",
                        "\t *      | extra data  ...",
                        "\t *",
                        "\t * The second padding exists because struct iw_point is extended,",
                        "\t * but this depends on the platform...",
                        "\t *",
                        "\t * On 32-bit, all the padding shouldn't be there.",
                        "\t */",
                        "",
                        "\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);",
                        "\tif (!skb)",
                        "\t\treturn;",
                        "",
                        "\t/* Send via the RtNetlink event channel */",
                        "\tnlh = rtnetlink_ifinfo_prep(dev, skb);",
                        "\tif (WARN_ON(!nlh)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* Add the wireless events in the netlink packet */",
                        "\tnla = nla_reserve(skb, IFLA_WIRELESS, event_len);",
                        "\tif (!nla) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn;",
                        "\t}",
                        "\tevent = nla_data(nla);",
                        "",
                        "\t/* Fill event - first clear to avoid data leaking */",
                        "\tmemset(event, 0, hdr_len);",
                        "\tevent->len = event_len;",
                        "\tevent->cmd = cmd;",
                        "\tmemcpy(&event->u, ((char *) wrqu) + wrqu_off, hdr_len - IW_EV_LCP_LEN);",
                        "\tif (extra_len)",
                        "\t\tmemcpy(((char *) event) + hdr_len, extra, extra_len);",
                        "",
                        "\tnlmsg_end(skb, nlh);",
                        "#ifdef CONFIG_COMPAT",
                        "\thdr_len = compat_event_type_size[descr->header_type];",
                        "\tevent_len = hdr_len + extra_len;",
                        "",
                        "\tcompskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);",
                        "\tif (!compskb) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* Send via the RtNetlink event channel */",
                        "\tnlh = rtnetlink_ifinfo_prep(dev, compskb);",
                        "\tif (WARN_ON(!nlh)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tkfree_skb(compskb);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* Add the wireless events in the netlink packet */",
                        "\tnla = nla_reserve(compskb, IFLA_WIRELESS, event_len);",
                        "\tif (!nla) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tkfree_skb(compskb);",
                        "\t\treturn;",
                        "\t}",
                        "\tcompat_event = nla_data(nla);",
                        "",
                        "\tcompat_event->len = event_len;",
                        "\tcompat_event->cmd = cmd;",
                        "\tif (descr->header_type == IW_HEADER_TYPE_POINT) {",
                        "\t\tcompat_wrqu.length = wrqu->data.length;",
                        "\t\tcompat_wrqu.flags = wrqu->data.flags;",
                        "\t\tmemcpy(&compat_event->pointer,",
                        "\t\t\t((char *) &compat_wrqu) + IW_EV_COMPAT_POINT_OFF,",
                        "\t\t\thdr_len - IW_EV_COMPAT_LCP_LEN);",
                        "\t\tif (extra_len)",
                        "\t\t\tmemcpy(((char *) compat_event) + hdr_len,",
                        "\t\t\t\textra, extra_len);",
                        "\t} else {",
                        "\t\t/* extra_len must be zero, so no if (extra) needed */",
                        "\t\tmemcpy(&compat_event->pointer, wrqu,",
                        "\t\t\thdr_len - IW_EV_COMPAT_LCP_LEN);",
                        "\t}",
                        "",
                        "\tnlmsg_end(compskb, nlh);",
                        "",
                        "\tskb_shinfo(skb)->frag_list = compskb;",
                        "#endif",
                        "\tskb_queue_tail(&dev_net(dev)->wext_nlevents, skb);",
                        "\tschedule_work(&wireless_nlevent_work);",
                        "}"
                    ],
                    "start": 446,
                    "highlight": 455
                }
            ],
            "ins_idx": 6152,
            "addr": "0xffffffff81c0da96"
        },
        "74735": {
            "name": "+0x19",
            "parent_idx": 74695,
            "source_line": [
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1003",
                    "code": [
                        "/*",
                        " * Wrapper to call a standard Wireless Extension handler.",
                        " * We do various checks and also take care of moving data between",
                        " * user space and kernel space.",
                        " */",
                        "static int ioctl_standard_call(struct net_device *\tdev,",
                        "\t\t\t       struct iwreq\t\t*iwr,",
                        "\t\t\t       unsigned int\t\tcmd,",
                        "\t\t\t       struct iw_request_info\t*info,",
                        "\t\t\t       iw_handler\t\thandler)",
                        "{",
                        "\tconst struct iw_ioctl_description *\tdescr;",
                        "\tint\t\t\t\t\tret = -EINVAL;",
                        "",
                        "\t/* Get the description of the IOCTL */",
                        "\tif (IW_IOCTL_IDX(cmd) >= standard_ioctl_num)",
                        "\t\treturn -EOPNOTSUPP;",
                        "\tdescr = &(standard_ioctl[IW_IOCTL_IDX(cmd)]);",
                        "",
                        "\t/* Check if we have a pointer to user space data or not */",
                        "\tif (descr->header_type != IW_HEADER_TYPE_POINT) {",
                        "",
                        "\t\t/* No extra arguments. Trivial to handle */",
                        "\t\tret = handler(dev, info, &(iwr->u), NULL);",
                        "",
                        "\t\t/* Generate an event to notify listeners of the change */",
                        "\t\tif ((descr->flags & IW_DESCR_FLAG_EVENT) &&",
                        "\t\t   ((ret == 0) || (ret == -EIWCOMMIT)))",
                        "\t\t\twireless_send_event(dev, cmd, &(iwr->u), NULL);",
                        "\t} else {",
                        "\t\tret = ioctl_standard_iw_point(&iwr->u.data, cmd, descr,",
                        "\t\t\t\t\t      handler, dev, info);",
                        "\t}",
                        "",
                        "\t/* Call commit handler if needed and defined */",
                        "\tif (ret == -EIWCOMMIT)",
                        "\t\tret = call_commit_handler(dev);",
                        "",
                        "\t/* Here, we will generate the appropriate event if needed */",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 993,
                    "highlight": 1003
                }
            ],
            "ins_idx": 13114,
            "addr": "0xffffffff81c0e3d9"
        },
        "74734": {
            "name": "+0x25",
            "parent_idx": 74695,
            "source_line": [
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n929",
                    "code": [
                        "/*",
                        " * Main IOCTl dispatcher.",
                        " * Check the type of IOCTL and call the appropriate wrapper...",
                        " */",
                        "static int wireless_process_ioctl(struct net *net, struct iwreq *iwr,",
                        "\t\t\t\t  unsigned int cmd,",
                        "\t\t\t\t  struct iw_request_info *info,",
                        "\t\t\t\t  wext_ioctl_func standard,",
                        "\t\t\t\t  wext_ioctl_func private)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tiw_handler\thandler;",
                        "",
                        "\t/* Permissions are already checked in dev_ioctl() before calling us.",
                        "\t * The copy_to/from_user() of ifr is also dealt with in there */",
                        "",
                        "\t/* Make sure the device exist */",
                        "\tif ((dev = __dev_get_by_name(net, iwr->ifr_name)) == NULL)",
                        "\t\treturn -ENODEV;",
                        "",
                        "\t/* A bunch of special cases, then the generic case...",
                        "\t * Note that 'cmd' is already filtered in dev_ioctl() with",
                        "\t * (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) */",
                        "\tif (cmd == SIOCGIWSTATS)",
                        "\t\treturn standard(dev, iwr, cmd, info,",
                        "\t\t\t\t&iw_handler_get_iwstats);",
                        "",
                        "#ifdef CONFIG_WEXT_PRIV",
                        "\tif (cmd == SIOCGIWPRIV && dev->wireless_handlers)",
                        "\t\treturn standard(dev, iwr, cmd, info,",
                        "\t\t\t\tiw_handler_get_private);",
                        "#endif",
                        "",
                        "\t/* Basic check */",
                        "\tif (!netif_device_present(dev))",
                        "\t\treturn -ENODEV;",
                        "",
                        "\t/* New driver API : try to find the handler */",
                        "\thandler = get_handler(dev, cmd);",
                        "\tif (handler) {",
                        "\t\t/* Standard and private are not the same */",
                        "\t\tif (cmd < SIOCIWFIRSTPRIV)",
                        "\t\t\treturn standard(dev, iwr, cmd, info, handler);",
                        "\t\telse if (private)",
                        "\t\t\treturn private(dev, iwr, cmd, info, handler);",
                        "\t}",
                        "\treturn -EOPNOTSUPP;",
                        "}"
                    ],
                    "start": 912,
                    "highlight": 929
                }
            ],
            "ins_idx": 14804,
            "addr": "0xffffffff81c0e265"
        },
        "74733": {
            "name": "+0xa",
            "parent_idx": 74696,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n866",
                    "code": [
                        "struct net_device *__dev_get_by_name(struct net *net, const char *name)",
                        "{",
                        "\tstruct netdev_name_node *node_name;",
                        "",
                        "\tnode_name = netdev_name_node_lookup(net, name);",
                        "\treturn node_name ? node_name->dev : NULL;",
                        "}"
                    ],
                    "start": 861,
                    "highlight": 866
                }
            ],
            "ins_idx": 16369,
            "addr": "0xffffffff819f5b5a"
        },
        "74696": {
            "name": "__dev_get_by_name",
            "parent_idx": 74695,
            "source_line": [
                {
                    "file": "net/wireless/wext-core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/wireless/wext-core.c?id=e28c0d7c92c89016c12a677616668957351e7542#n929",
                    "code": [
                        "/*",
                        " * Main IOCTl dispatcher.",
                        " * Check the type of IOCTL and call the appropriate wrapper...",
                        " */",
                        "static int wireless_process_ioctl(struct net *net, struct iwreq *iwr,",
                        "\t\t\t\t  unsigned int cmd,",
                        "\t\t\t\t  struct iw_request_info *info,",
                        "\t\t\t\t  wext_ioctl_func standard,",
                        "\t\t\t\t  wext_ioctl_func private)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tiw_handler\thandler;",
                        "",
                        "\t/* Permissions are already checked in dev_ioctl() before calling us.",
                        "\t * The copy_to/from_user() of ifr is also dealt with in there */",
                        "",
                        "\t/* Make sure the device exist */",
                        "\tif ((dev = __dev_get_by_name(net, iwr->ifr_name)) == NULL)",
                        "\t\treturn -ENODEV;",
                        "",
                        "\t/* A bunch of special cases, then the generic case...",
                        "\t * Note that 'cmd' is already filtered in dev_ioctl() with",
                        "\t * (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) */",
                        "\tif (cmd == SIOCGIWSTATS)",
                        "\t\treturn standard(dev, iwr, cmd, info,",
                        "\t\t\t\t&iw_handler_get_iwstats);",
                        "",
                        "#ifdef CONFIG_WEXT_PRIV",
                        "\tif (cmd == SIOCGIWPRIV && dev->wireless_handlers)",
                        "\t\treturn standard(dev, iwr, cmd, info,",
                        "\t\t\t\tiw_handler_get_private);",
                        "#endif",
                        "",
                        "\t/* Basic check */",
                        "\tif (!netif_device_present(dev))",
                        "\t\treturn -ENODEV;",
                        "",
                        "\t/* New driver API : try to find the handler */",
                        "\thandler = get_handler(dev, cmd);",
                        "\tif (handler) {",
                        "\t\t/* Standard and private are not the same */",
                        "\t\tif (cmd < SIOCIWFIRSTPRIV)",
                        "\t\t\treturn standard(dev, iwr, cmd, info, handler);",
                        "\t\telse if (private)",
                        "\t\t\treturn private(dev, iwr, cmd, info, handler);",
                        "\t}",
                        "\treturn -EOPNOTSUPP;",
                        "}"
                    ],
                    "start": 912,
                    "highlight": 929
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c0e257"
        },
        "49404": {
            "name": "+0xe0",
            "parent_idx": 49373,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n244",
                    "code": [
                        "static struct netdev_name_node *netdev_name_node_alloc(struct net_device *dev,",
                        "\t\t\t\t\t\t       const char *name)",
                        "{",
                        "\tstruct netdev_name_node *name_node;",
                        "",
                        "\tname_node = kmalloc(sizeof(*name_node), GFP_KERNEL);",
                        "\tif (!name_node)",
                        "\t\treturn NULL;",
                        "\tINIT_HLIST_NODE(&name_node->hlist);",
                        "\tname_node->dev = dev;",
                        "\tname_node->name = name;",
                        "\treturn name_node;",
                        "}"
                    ],
                    "start": 235,
                    "highlight": 244
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n254",
                    "code": [
                        "static struct netdev_name_node *",
                        "netdev_name_node_head_alloc(struct net_device *dev)",
                        "{",
                        "\tstruct netdev_name_node *name_node;",
                        "",
                        "\tname_node = netdev_name_node_alloc(dev, dev->name);",
                        "\tif (!name_node)",
                        "\t\treturn NULL;",
                        "\tINIT_LIST_HEAD(&name_node->list);",
                        "\treturn name_node;",
                        "}"
                    ],
                    "start": 249,
                    "highlight": 254
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n9892",
                    "code": [
                        "int register_netdevice(struct net_device *dev)",
                        "{",
                        "\tint ret;",
                        "\tstruct net *net = dev_net(dev);",
                        "",
                        "\tBUILD_BUG_ON(sizeof(netdev_features_t) * BITS_PER_BYTE <",
                        "\t\t     NETDEV_FEATURE_COUNT);",
                        "\tBUG_ON(dev_boot_phase);",
                        "\tASSERT_RTNL();",
                        "",
                        "\tmight_sleep();",
                        "",
                        "\t/* When net_device's are persistent, this will be fatal. */",
                        "\tBUG_ON(dev->reg_state != NETREG_UNINITIALIZED);",
                        "\tBUG_ON(!net);",
                        "",
                        "\tret = ethtool_check_ops(dev->ethtool_ops);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\tspin_lock_init(&dev->addr_list_lock);",
                        "\tnetdev_set_addr_lockdep_class(dev);",
                        "",
                        "\tret = dev_get_valid_name(net, dev, dev->name);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tret = -ENOMEM;",
                        "\tdev->name_node = netdev_name_node_head_alloc(dev);",
                        "\tif (!dev->name_node)",
                        "\t\tgoto out;",
                        "",
                        "\t/* Init, if this function is available */",
                        "\tif (dev->netdev_ops->ndo_init) {",
                        "\t\tret = dev->netdev_ops->ndo_init(dev);",
                        "\t\tif (ret) {",
                        "\t\t\tif (ret > 0)",
                        "\t\t\t\tret = -EIO;",
                        "\t\t\tgoto err_free_name;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (((dev->hw_features | dev->features) &",
                        "\t     NETIF_F_HW_VLAN_CTAG_FILTER) &&",
                        "\t    (!dev->netdev_ops->ndo_vlan_rx_add_vid ||",
                        "\t     !dev->netdev_ops->ndo_vlan_rx_kill_vid)) {",
                        "\t\tnetdev_WARN(dev, \"Buggy VLAN acceleration in driver!\\n\");",
                        "\t\tret = -EINVAL;",
                        "\t\tgoto err_uninit;",
                        "\t}",
                        "",
                        "\tret = -EBUSY;",
                        "\tif (!dev->ifindex)",
                        "\t\tdev->ifindex = dev_new_index(net);",
                        "\telse if (__dev_get_by_index(net, dev->ifindex))",
                        "\t\tgoto err_uninit;",
                        "",
                        "\t/* Transfer changeable features to wanted_features and enable",
                        "\t * software offloads (GSO and GRO).",
                        "\t */",
                        "\tdev->hw_features |= (NETIF_F_SOFT_FEATURES | NETIF_F_SOFT_FEATURES_OFF);",
                        "\tdev->features |= NETIF_F_SOFT_FEATURES;",
                        "",
                        "\tif (dev->netdev_ops->ndo_udp_tunnel_add) {",
                        "\t\tdev->features |= NETIF_F_RX_UDP_TUNNEL_PORT;",
                        "\t\tdev->hw_features |= NETIF_F_RX_UDP_TUNNEL_PORT;",
                        "\t}",
                        "",
                        "\tdev->wanted_features = dev->features & dev->hw_features;",
                        "",
                        "\tif (!(dev->flags & IFF_LOOPBACK))",
                        "\t\tdev->hw_features |= NETIF_F_NOCACHE_COPY;",
                        "",
                        "\t/* If IPv4 TCP segmentation offload is supported we should also",
                        "\t * allow the device to enable segmenting the frame with the option",
                        "\t * of ignoring a static IP ID value.  This doesn't enable the",
                        "\t * feature itself but allows the user to enable it later.",
                        "\t */",
                        "\tif (dev->hw_features & NETIF_F_TSO)",
                        "\t\tdev->hw_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->vlan_features & NETIF_F_TSO)",
                        "\t\tdev->vlan_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->mpls_features & NETIF_F_TSO)",
                        "\t\tdev->mpls_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->hw_enc_features & NETIF_F_TSO)",
                        "\t\tdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;",
                        "",
                        "\t/* Make NETIF_F_HIGHDMA inheritable to VLAN devices.",
                        "\t */",
                        "\tdev->vlan_features |= NETIF_F_HIGHDMA;",
                        "",
                        "\t/* Make NETIF_F_SG inheritable to tunnel devices.",
                        "\t */",
                        "\tdev->hw_enc_features |= NETIF_F_SG | NETIF_F_GSO_PARTIAL;",
                        "",
                        "\t/* Make NETIF_F_SG inheritable to MPLS.",
                        "\t */",
                        "\tdev->mpls_features |= NETIF_F_SG;",
                        "",
                        "\tret = call_netdevice_notifiers(NETDEV_POST_INIT, dev);",
                        "\tret = notifier_to_errno(ret);",
                        "\tif (ret)",
                        "\t\tgoto err_uninit;",
                        "",
                        "\tret = netdev_register_kobject(dev);",
                        "\tif (ret) {",
                        "\t\tdev->reg_state = NETREG_UNREGISTERED;",
                        "\t\tgoto err_uninit;",
                        "\t}",
                        "\tdev->reg_state = NETREG_REGISTERED;",
                        "",
                        "\t__netdev_update_features(dev);",
                        "",
                        "\t/*",
                        "\t *\tDefault initial state at registry is that the",
                        "\t *\tdevice is present.",
                        "\t */",
                        "",
                        "\tset_bit(__LINK_STATE_PRESENT, &dev->state);",
                        "",
                        "\tlinkwatch_init_dev(dev);",
                        "",
                        "\tdev_init_scheduler(dev);",
                        "\tdev_hold(dev);",
                        "\tlist_netdevice(dev);",
                        "\tadd_device_randomness(dev->dev_addr, dev->addr_len);",
                        "",
                        "\t/* If the device has permanent device address, driver should",
                        "\t * set dev_addr and also addr_assign_type should be set to",
                        "\t * NET_ADDR_PERM (default value).",
                        "\t */",
                        "\tif (dev->addr_assign_type == NET_ADDR_PERM)",
                        "\t\tmemcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);",
                        "",
                        "\t/* Notify protocols, that a new device appeared. */",
                        "\tret = call_netdevice_notifiers(NETDEV_REGISTER, dev);",
                        "\tret = notifier_to_errno(ret);",
                        "\tif (ret) {",
                        "\t\trollback_registered(dev);",
                        "\t\trcu_barrier();",
                        "",
                        "\t\tdev->reg_state = NETREG_UNREGISTERED;",
                        "\t\t/* We should put the kobject that hold in",
                        "\t\t * netdev_unregister_kobject(), otherwise",
                        "\t\t * the net device cannot be freed when",
                        "\t\t * driver calls free_netdev(), because the",
                        "\t\t * kobject is being hold.",
                        "\t\t */",
                        "\t\tkobject_put(&dev->dev.kobj);",
                        "\t}",
                        "\t/*",
                        "\t *\tPrevent userspace races by waiting until the network",
                        "\t *\tdevice is fully setup before sending notifications.",
                        "\t */",
                        "\tif (!dev->rtnl_link_ops ||",
                        "\t    dev->rtnl_link_state == RTNL_LINK_INITIALIZED)",
                        "\t\trtmsg_ifinfo(RTM_NEWLINK, dev, ~0U, GFP_KERNEL);",
                        "",
                        "out:",
                        "\treturn ret;",
                        "",
                        "err_uninit:",
                        "\tif (dev->netdev_ops->ndo_uninit)",
                        "\t\tdev->netdev_ops->ndo_uninit(dev);",
                        "\tif (dev->priv_destructor)",
                        "\t\tdev->priv_destructor(dev);",
                        "err_free_name:",
                        "\tnetdev_name_node_free(dev->name_node);",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 9864,
                    "highlight": 9892
                }
            ],
            "ins_idx": 17610,
            "addr": "0xffffffff81a01ae0"
        },
        "49373": {
            "name": "register_netdevice",
            "parent_idx": 47917,
            "source_line": [
                {
                    "file": "net/mac80211/iface.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mac80211/iface.c?id=e28c0d7c92c89016c12a677616668957351e7542#n2004",
                    "code": [
                        "int ieee80211_if_add(struct ieee80211_local *local, const char *name,",
                        "\t\t     unsigned char name_assign_type,",
                        "\t\t     struct wireless_dev **new_wdev, enum nl80211_iftype type,",
                        "\t\t     struct vif_params *params)",
                        "{",
                        "\tstruct net_device *ndev = NULL;",
                        "\tstruct ieee80211_sub_if_data *sdata = NULL;",
                        "\tstruct txq_info *txqi;",
                        "\tvoid (*if_setup)(struct net_device *dev);",
                        "\tint ret, i;",
                        "\tint txqs = 1;",
                        "",
                        "\tASSERT_RTNL();",
                        "",
                        "\tif (type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN) {",
                        "\t\tstruct wireless_dev *wdev;",
                        "",
                        "\t\tsdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size,",
                        "\t\t\t\tGFP_KERNEL);",
                        "\t\tif (!sdata)",
                        "\t\t\treturn -ENOMEM;",
                        "\t\twdev = &sdata->wdev;",
                        "",
                        "\t\tsdata->dev = NULL;",
                        "\t\tstrlcpy(sdata->name, name, IFNAMSIZ);",
                        "\t\tieee80211_assign_perm_addr(local, wdev->address, type);",
                        "\t\tmemcpy(sdata->vif.addr, wdev->address, ETH_ALEN);",
                        "\t} else {",
                        "\t\tint size = ALIGN(sizeof(*sdata) + local->hw.vif_data_size,",
                        "\t\t\t\t sizeof(void *));",
                        "\t\tint txq_size = 0;",
                        "",
                        "\t\tif (local->ops->wake_tx_queue &&",
                        "\t\t    type != NL80211_IFTYPE_AP_VLAN &&",
                        "\t\t    (type != NL80211_IFTYPE_MONITOR ||",
                        "\t\t     (params->flags & MONITOR_FLAG_ACTIVE)))",
                        "\t\t\ttxq_size += sizeof(struct txq_info) +",
                        "\t\t\t\t    local->hw.txq_data_size;",
                        "",
                        "\t\tif (local->ops->wake_tx_queue) {",
                        "\t\t\tif_setup = ieee80211_if_setup_no_queue;",
                        "\t\t} else {",
                        "\t\t\tif_setup = ieee80211_if_setup;",
                        "\t\t\tif (local->hw.queues >= IEEE80211_NUM_ACS)",
                        "\t\t\t\ttxqs = IEEE80211_NUM_ACS;",
                        "\t\t}",
                        "",
                        "\t\tndev = alloc_netdev_mqs(size + txq_size,",
                        "\t\t\t\t\tname, name_assign_type,",
                        "\t\t\t\t\tif_setup, txqs, 1);",
                        "\t\tif (!ndev)",
                        "\t\t\treturn -ENOMEM;",
                        "",
                        "\t\tif (!local->ops->wake_tx_queue && local->hw.wiphy->tx_queue_len)",
                        "\t\t\tndev->tx_queue_len = local->hw.wiphy->tx_queue_len;",
                        "",
                        "\t\tdev_net_set(ndev, wiphy_net(local->hw.wiphy));",
                        "",
                        "\t\tndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);",
                        "\t\tif (!ndev->tstats) {",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn -ENOMEM;",
                        "\t\t}",
                        "",
                        "\t\tndev->needed_headroom = local->tx_headroom +",
                        "\t\t\t\t\t4*6 /* four MAC addresses */",
                        "\t\t\t\t\t+ 2 + 2 + 2 + 2 /* ctl, dur, seq, qos */",
                        "\t\t\t\t\t+ 6 /* mesh */",
                        "\t\t\t\t\t+ 8 /* rfc1042/bridge tunnel */",
                        "\t\t\t\t\t- ETH_HLEN /* ethernet hard_header_len */",
                        "\t\t\t\t\t+ IEEE80211_ENCRYPT_HEADROOM;",
                        "\t\tndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;",
                        "",
                        "\t\tret = dev_alloc_name(ndev, ndev->name);",
                        "\t\tif (ret < 0) {",
                        "\t\t\tieee80211_if_free(ndev);",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "",
                        "\t\tieee80211_assign_perm_addr(local, ndev->perm_addr, type);",
                        "\t\tif (is_valid_ether_addr(params->macaddr))",
                        "\t\t\tmemcpy(ndev->dev_addr, params->macaddr, ETH_ALEN);",
                        "\t\telse",
                        "\t\t\tmemcpy(ndev->dev_addr, ndev->perm_addr, ETH_ALEN);",
                        "\t\tSET_NETDEV_DEV(ndev, wiphy_dev(local->hw.wiphy));",
                        "",
                        "\t\t/* don't use IEEE80211_DEV_TO_SUB_IF -- it checks too much */",
                        "\t\tsdata = netdev_priv(ndev);",
                        "\t\tndev->ieee80211_ptr = &sdata->wdev;",
                        "\t\tmemcpy(sdata->vif.addr, ndev->dev_addr, ETH_ALEN);",
                        "\t\tmemcpy(sdata->name, ndev->name, IFNAMSIZ);",
                        "",
                        "\t\tif (txq_size) {",
                        "\t\t\ttxqi = netdev_priv(ndev) + size;",
                        "\t\t\tieee80211_txq_init(sdata, NULL, txqi, 0);",
                        "\t\t}",
                        "",
                        "\t\tsdata->dev = ndev;",
                        "\t}",
                        "",
                        "\t/* initialise type-independent data */",
                        "\tsdata->wdev.wiphy = local->hw.wiphy;",
                        "\tsdata->local = local;",
                        "",
                        "\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)",
                        "\t\tskb_queue_head_init(&sdata->fragments[i].skb_list);",
                        "",
                        "\tINIT_LIST_HEAD(&sdata->key_list);",
                        "",
                        "\tINIT_DELAYED_WORK(&sdata->dfs_cac_timer_work,",
                        "\t\t\t  ieee80211_dfs_cac_timer_work);",
                        "\tINIT_DELAYED_WORK(&sdata->dec_tailroom_needed_wk,",
                        "\t\t\t  ieee80211_delayed_tailroom_dec);",
                        "",
                        "\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {",
                        "\t\tstruct ieee80211_supported_band *sband;",
                        "\t\tsband = local->hw.wiphy->bands[i];",
                        "\t\tsdata->rc_rateidx_mask[i] =",
                        "\t\t\tsband ? (1 << sband->n_bitrates) - 1 : 0;",
                        "\t\tif (sband) {",
                        "\t\t\t__le16 cap;",
                        "\t\t\tu16 *vht_rate_mask;",
                        "",
                        "\t\t\tmemcpy(sdata->rc_rateidx_mcs_mask[i],",
                        "\t\t\t       sband->ht_cap.mcs.rx_mask,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));",
                        "",
                        "\t\t\tcap = sband->vht_cap.vht_mcs.rx_mcs_map;",
                        "\t\t\tvht_rate_mask = sdata->rc_rateidx_vht_mcs_mask[i];",
                        "\t\t\tieee80211_get_vht_mask_from_cap(cap, vht_rate_mask);",
                        "\t\t} else {",
                        "\t\t\tmemset(sdata->rc_rateidx_mcs_mask[i], 0,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));",
                        "\t\t\tmemset(sdata->rc_rateidx_vht_mcs_mask[i], 0,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_vht_mcs_mask[i]));",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tieee80211_set_default_queues(sdata);",
                        "",
                        "\tsdata->ap_power_level = IEEE80211_UNSET_POWER_LEVEL;",
                        "\tsdata->user_power_level = local->user_power_level;",
                        "",
                        "\tsdata->encrypt_headroom = IEEE80211_ENCRYPT_HEADROOM;",
                        "",
                        "\t/* setup type-dependent data */",
                        "\tieee80211_setup_sdata(sdata, type);",
                        "",
                        "\tif (ndev) {",
                        "\t\tndev->ieee80211_ptr->use_4addr = params->use_4addr;",
                        "\t\tif (type == NL80211_IFTYPE_STATION)",
                        "\t\t\tsdata->u.mgd.use_4addr = params->use_4addr;",
                        "",
                        "\t\tndev->features |= local->hw.netdev_features;",
                        "\t\tndev->hw_features |= ndev->features &",
                        "\t\t\t\t\tMAC80211_SUPPORTED_FEATURES_TX;",
                        "",
                        "\t\tnetdev_set_default_ethtool_ops(ndev, &ieee80211_ethtool_ops);",
                        "",
                        "\t\t/* MTU range: 256 - 2304 */",
                        "\t\tndev->min_mtu = 256;",
                        "\t\tndev->max_mtu = local->hw.max_mtu;",
                        "",
                        "\t\tret = register_netdevice(ndev);",
                        "\t\tif (ret) {",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tmutex_lock(&local->iflist_mtx);",
                        "\tlist_add_tail_rcu(&sdata->list, &local->interfaces);",
                        "\tmutex_unlock(&local->iflist_mtx);",
                        "",
                        "\tif (new_wdev)",
                        "\t\t*new_wdev = &sdata->wdev;",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1840,
                    "highlight": 2004
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c295c8"
        },
        "74732": {
            "name": "+0x5a",
            "parent_idx": 74697,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n288",
                    "code": [
                        "static struct netdev_name_node *netdev_name_node_lookup(struct net *net,",
                        "\t\t\t\t\t\t\tconst char *name)",
                        "{",
                        "\tstruct hlist_head *head = dev_name_hash(net, name);",
                        "\tstruct netdev_name_node *name_node;",
                        "",
                        "\thlist_for_each_entry(name_node, head, hlist)",
                        "\t\tif (!strcmp(name_node->name, name))",
                        "\t\t\treturn name_node;",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 278,
                    "highlight": 288
                }
            ],
            "ins_idx": 17609,
            "addr": "0xffffffff819f5b3a"
        },
        "74697": {
            "name": "netdev_name_node_lookup",
            "parent_idx": 74696,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n865",
                    "code": [
                        "struct net_device *__dev_get_by_name(struct net *net, const char *name)",
                        "{",
                        "\tstruct netdev_name_node *node_name;",
                        "",
                        "\tnode_name = netdev_name_node_lookup(net, name);",
                        "\treturn node_name ? node_name->dev : NULL;",
                        "}"
                    ],
                    "start": 861,
                    "highlight": 865
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819f5b50"
        },
        "49375": {
            "name": "+0x2d",
            "parent_idx": 49373,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n9871",
                    "code": [
                        "int register_netdevice(struct net_device *dev)",
                        "{",
                        "\tint ret;",
                        "\tstruct net *net = dev_net(dev);",
                        "",
                        "\tBUILD_BUG_ON(sizeof(netdev_features_t) * BITS_PER_BYTE <",
                        "\t\t     NETDEV_FEATURE_COUNT);",
                        "\tBUG_ON(dev_boot_phase);",
                        "\tASSERT_RTNL();",
                        "",
                        "\tmight_sleep();",
                        "",
                        "\t/* When net_device's are persistent, this will be fatal. */",
                        "\tBUG_ON(dev->reg_state != NETREG_UNINITIALIZED);",
                        "\tBUG_ON(!net);",
                        "",
                        "\tret = ethtool_check_ops(dev->ethtool_ops);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\tspin_lock_init(&dev->addr_list_lock);",
                        "\tnetdev_set_addr_lockdep_class(dev);",
                        "",
                        "\tret = dev_get_valid_name(net, dev, dev->name);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tret = -ENOMEM;",
                        "\tdev->name_node = netdev_name_node_head_alloc(dev);",
                        "\tif (!dev->name_node)",
                        "\t\tgoto out;",
                        "",
                        "\t/* Init, if this function is available */",
                        "\tif (dev->netdev_ops->ndo_init) {",
                        "\t\tret = dev->netdev_ops->ndo_init(dev);",
                        "\t\tif (ret) {",
                        "\t\t\tif (ret > 0)",
                        "\t\t\t\tret = -EIO;",
                        "\t\t\tgoto err_free_name;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (((dev->hw_features | dev->features) &",
                        "\t     NETIF_F_HW_VLAN_CTAG_FILTER) &&",
                        "\t    (!dev->netdev_ops->ndo_vlan_rx_add_vid ||",
                        "\t     !dev->netdev_ops->ndo_vlan_rx_kill_vid)) {",
                        "\t\tnetdev_WARN(dev, \"Buggy VLAN acceleration in driver!\\n\");",
                        "\t\tret = -EINVAL;",
                        "\t\tgoto err_uninit;",
                        "\t}",
                        "",
                        "\tret = -EBUSY;",
                        "\tif (!dev->ifindex)",
                        "\t\tdev->ifindex = dev_new_index(net);",
                        "\telse if (__dev_get_by_index(net, dev->ifindex))",
                        "\t\tgoto err_uninit;",
                        "",
                        "\t/* Transfer changeable features to wanted_features and enable",
                        "\t * software offloads (GSO and GRO).",
                        "\t */",
                        "\tdev->hw_features |= (NETIF_F_SOFT_FEATURES | NETIF_F_SOFT_FEATURES_OFF);",
                        "\tdev->features |= NETIF_F_SOFT_FEATURES;",
                        "",
                        "\tif (dev->netdev_ops->ndo_udp_tunnel_add) {",
                        "\t\tdev->features |= NETIF_F_RX_UDP_TUNNEL_PORT;",
                        "\t\tdev->hw_features |= NETIF_F_RX_UDP_TUNNEL_PORT;",
                        "\t}",
                        "",
                        "\tdev->wanted_features = dev->features & dev->hw_features;",
                        "",
                        "\tif (!(dev->flags & IFF_LOOPBACK))",
                        "\t\tdev->hw_features |= NETIF_F_NOCACHE_COPY;",
                        "",
                        "\t/* If IPv4 TCP segmentation offload is supported we should also",
                        "\t * allow the device to enable segmenting the frame with the option",
                        "\t * of ignoring a static IP ID value.  This doesn't enable the",
                        "\t * feature itself but allows the user to enable it later.",
                        "\t */",
                        "\tif (dev->hw_features & NETIF_F_TSO)",
                        "\t\tdev->hw_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->vlan_features & NETIF_F_TSO)",
                        "\t\tdev->vlan_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->mpls_features & NETIF_F_TSO)",
                        "\t\tdev->mpls_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->hw_enc_features & NETIF_F_TSO)",
                        "\t\tdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;",
                        "",
                        "\t/* Make NETIF_F_HIGHDMA inheritable to VLAN devices.",
                        "\t */",
                        "\tdev->vlan_features |= NETIF_F_HIGHDMA;",
                        "",
                        "\t/* Make NETIF_F_SG inheritable to tunnel devices.",
                        "\t */",
                        "\tdev->hw_enc_features |= NETIF_F_SG | NETIF_F_GSO_PARTIAL;",
                        "",
                        "\t/* Make NETIF_F_SG inheritable to MPLS.",
                        "\t */",
                        "\tdev->mpls_features |= NETIF_F_SG;",
                        "",
                        "\tret = call_netdevice_notifiers(NETDEV_POST_INIT, dev);",
                        "\tret = notifier_to_errno(ret);",
                        "\tif (ret)",
                        "\t\tgoto err_uninit;",
                        "",
                        "\tret = netdev_register_kobject(dev);",
                        "\tif (ret) {",
                        "\t\tdev->reg_state = NETREG_UNREGISTERED;",
                        "\t\tgoto err_uninit;",
                        "\t}",
                        "\tdev->reg_state = NETREG_REGISTERED;",
                        "",
                        "\t__netdev_update_features(dev);",
                        "",
                        "\t/*",
                        "\t *\tDefault initial state at registry is that the",
                        "\t *\tdevice is present.",
                        "\t */",
                        "",
                        "\tset_bit(__LINK_STATE_PRESENT, &dev->state);",
                        "",
                        "\tlinkwatch_init_dev(dev);",
                        "",
                        "\tdev_init_scheduler(dev);",
                        "\tdev_hold(dev);",
                        "\tlist_netdevice(dev);",
                        "\tadd_device_randomness(dev->dev_addr, dev->addr_len);",
                        "",
                        "\t/* If the device has permanent device address, driver should",
                        "\t * set dev_addr and also addr_assign_type should be set to",
                        "\t * NET_ADDR_PERM (default value).",
                        "\t */",
                        "\tif (dev->addr_assign_type == NET_ADDR_PERM)",
                        "\t\tmemcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);",
                        "",
                        "\t/* Notify protocols, that a new device appeared. */",
                        "\tret = call_netdevice_notifiers(NETDEV_REGISTER, dev);",
                        "\tret = notifier_to_errno(ret);",
                        "\tif (ret) {",
                        "\t\trollback_registered(dev);",
                        "\t\trcu_barrier();",
                        "",
                        "\t\tdev->reg_state = NETREG_UNREGISTERED;",
                        "\t\t/* We should put the kobject that hold in",
                        "\t\t * netdev_unregister_kobject(), otherwise",
                        "\t\t * the net device cannot be freed when",
                        "\t\t * driver calls free_netdev(), because the",
                        "\t\t * kobject is being hold.",
                        "\t\t */",
                        "\t\tkobject_put(&dev->dev.kobj);",
                        "\t}",
                        "\t/*",
                        "\t *\tPrevent userspace races by waiting until the network",
                        "\t *\tdevice is fully setup before sending notifications.",
                        "\t */",
                        "\tif (!dev->rtnl_link_ops ||",
                        "\t    dev->rtnl_link_state == RTNL_LINK_INITIALIZED)",
                        "\t\trtmsg_ifinfo(RTM_NEWLINK, dev, ~0U, GFP_KERNEL);",
                        "",
                        "out:",
                        "\treturn ret;",
                        "",
                        "err_uninit:",
                        "\tif (dev->netdev_ops->ndo_uninit)",
                        "\t\tdev->netdev_ops->ndo_uninit(dev);",
                        "\tif (dev->priv_destructor)",
                        "\t\tdev->priv_destructor(dev);",
                        "err_free_name:",
                        "\tnetdev_name_node_free(dev->name_node);",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 9864,
                    "highlight": 9871
                }
            ],
            "ins_idx": 21374,
            "addr": "0xffffffff81a01a2d"
        },
        "74731": {
            "name": "+0x35",
            "parent_idx": 74697,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n284",
                    "code": [
                        "static struct netdev_name_node *netdev_name_node_lookup(struct net *net,",
                        "\t\t\t\t\t\t\tconst char *name)",
                        "{",
                        "\tstruct hlist_head *head = dev_name_hash(net, name);",
                        "\tstruct netdev_name_node *name_node;",
                        "",
                        "\thlist_for_each_entry(name_node, head, hlist)",
                        "\t\tif (!strcmp(name_node->name, name))",
                        "\t\t\treturn name_node;",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 278,
                    "highlight": 284
                }
            ],
            "ins_idx": 18983,
            "addr": "0xffffffff819f5b15"
        },
        "49372": {
            "name": "+0x40b",
            "parent_idx": 47917,
            "source_line": [
                {
                    "file": "net/mac80211/iface.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mac80211/iface.c?id=e28c0d7c92c89016c12a677616668957351e7542#n2004",
                    "code": [
                        "int ieee80211_if_add(struct ieee80211_local *local, const char *name,",
                        "\t\t     unsigned char name_assign_type,",
                        "\t\t     struct wireless_dev **new_wdev, enum nl80211_iftype type,",
                        "\t\t     struct vif_params *params)",
                        "{",
                        "\tstruct net_device *ndev = NULL;",
                        "\tstruct ieee80211_sub_if_data *sdata = NULL;",
                        "\tstruct txq_info *txqi;",
                        "\tvoid (*if_setup)(struct net_device *dev);",
                        "\tint ret, i;",
                        "\tint txqs = 1;",
                        "",
                        "\tASSERT_RTNL();",
                        "",
                        "\tif (type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN) {",
                        "\t\tstruct wireless_dev *wdev;",
                        "",
                        "\t\tsdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size,",
                        "\t\t\t\tGFP_KERNEL);",
                        "\t\tif (!sdata)",
                        "\t\t\treturn -ENOMEM;",
                        "\t\twdev = &sdata->wdev;",
                        "",
                        "\t\tsdata->dev = NULL;",
                        "\t\tstrlcpy(sdata->name, name, IFNAMSIZ);",
                        "\t\tieee80211_assign_perm_addr(local, wdev->address, type);",
                        "\t\tmemcpy(sdata->vif.addr, wdev->address, ETH_ALEN);",
                        "\t} else {",
                        "\t\tint size = ALIGN(sizeof(*sdata) + local->hw.vif_data_size,",
                        "\t\t\t\t sizeof(void *));",
                        "\t\tint txq_size = 0;",
                        "",
                        "\t\tif (local->ops->wake_tx_queue &&",
                        "\t\t    type != NL80211_IFTYPE_AP_VLAN &&",
                        "\t\t    (type != NL80211_IFTYPE_MONITOR ||",
                        "\t\t     (params->flags & MONITOR_FLAG_ACTIVE)))",
                        "\t\t\ttxq_size += sizeof(struct txq_info) +",
                        "\t\t\t\t    local->hw.txq_data_size;",
                        "",
                        "\t\tif (local->ops->wake_tx_queue) {",
                        "\t\t\tif_setup = ieee80211_if_setup_no_queue;",
                        "\t\t} else {",
                        "\t\t\tif_setup = ieee80211_if_setup;",
                        "\t\t\tif (local->hw.queues >= IEEE80211_NUM_ACS)",
                        "\t\t\t\ttxqs = IEEE80211_NUM_ACS;",
                        "\t\t}",
                        "",
                        "\t\tndev = alloc_netdev_mqs(size + txq_size,",
                        "\t\t\t\t\tname, name_assign_type,",
                        "\t\t\t\t\tif_setup, txqs, 1);",
                        "\t\tif (!ndev)",
                        "\t\t\treturn -ENOMEM;",
                        "",
                        "\t\tif (!local->ops->wake_tx_queue && local->hw.wiphy->tx_queue_len)",
                        "\t\t\tndev->tx_queue_len = local->hw.wiphy->tx_queue_len;",
                        "",
                        "\t\tdev_net_set(ndev, wiphy_net(local->hw.wiphy));",
                        "",
                        "\t\tndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);",
                        "\t\tif (!ndev->tstats) {",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn -ENOMEM;",
                        "\t\t}",
                        "",
                        "\t\tndev->needed_headroom = local->tx_headroom +",
                        "\t\t\t\t\t4*6 /* four MAC addresses */",
                        "\t\t\t\t\t+ 2 + 2 + 2 + 2 /* ctl, dur, seq, qos */",
                        "\t\t\t\t\t+ 6 /* mesh */",
                        "\t\t\t\t\t+ 8 /* rfc1042/bridge tunnel */",
                        "\t\t\t\t\t- ETH_HLEN /* ethernet hard_header_len */",
                        "\t\t\t\t\t+ IEEE80211_ENCRYPT_HEADROOM;",
                        "\t\tndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;",
                        "",
                        "\t\tret = dev_alloc_name(ndev, ndev->name);",
                        "\t\tif (ret < 0) {",
                        "\t\t\tieee80211_if_free(ndev);",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "",
                        "\t\tieee80211_assign_perm_addr(local, ndev->perm_addr, type);",
                        "\t\tif (is_valid_ether_addr(params->macaddr))",
                        "\t\t\tmemcpy(ndev->dev_addr, params->macaddr, ETH_ALEN);",
                        "\t\telse",
                        "\t\t\tmemcpy(ndev->dev_addr, ndev->perm_addr, ETH_ALEN);",
                        "\t\tSET_NETDEV_DEV(ndev, wiphy_dev(local->hw.wiphy));",
                        "",
                        "\t\t/* don't use IEEE80211_DEV_TO_SUB_IF -- it checks too much */",
                        "\t\tsdata = netdev_priv(ndev);",
                        "\t\tndev->ieee80211_ptr = &sdata->wdev;",
                        "\t\tmemcpy(sdata->vif.addr, ndev->dev_addr, ETH_ALEN);",
                        "\t\tmemcpy(sdata->name, ndev->name, IFNAMSIZ);",
                        "",
                        "\t\tif (txq_size) {",
                        "\t\t\ttxqi = netdev_priv(ndev) + size;",
                        "\t\t\tieee80211_txq_init(sdata, NULL, txqi, 0);",
                        "\t\t}",
                        "",
                        "\t\tsdata->dev = ndev;",
                        "\t}",
                        "",
                        "\t/* initialise type-independent data */",
                        "\tsdata->wdev.wiphy = local->hw.wiphy;",
                        "\tsdata->local = local;",
                        "",
                        "\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)",
                        "\t\tskb_queue_head_init(&sdata->fragments[i].skb_list);",
                        "",
                        "\tINIT_LIST_HEAD(&sdata->key_list);",
                        "",
                        "\tINIT_DELAYED_WORK(&sdata->dfs_cac_timer_work,",
                        "\t\t\t  ieee80211_dfs_cac_timer_work);",
                        "\tINIT_DELAYED_WORK(&sdata->dec_tailroom_needed_wk,",
                        "\t\t\t  ieee80211_delayed_tailroom_dec);",
                        "",
                        "\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {",
                        "\t\tstruct ieee80211_supported_band *sband;",
                        "\t\tsband = local->hw.wiphy->bands[i];",
                        "\t\tsdata->rc_rateidx_mask[i] =",
                        "\t\t\tsband ? (1 << sband->n_bitrates) - 1 : 0;",
                        "\t\tif (sband) {",
                        "\t\t\t__le16 cap;",
                        "\t\t\tu16 *vht_rate_mask;",
                        "",
                        "\t\t\tmemcpy(sdata->rc_rateidx_mcs_mask[i],",
                        "\t\t\t       sband->ht_cap.mcs.rx_mask,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));",
                        "",
                        "\t\t\tcap = sband->vht_cap.vht_mcs.rx_mcs_map;",
                        "\t\t\tvht_rate_mask = sdata->rc_rateidx_vht_mcs_mask[i];",
                        "\t\t\tieee80211_get_vht_mask_from_cap(cap, vht_rate_mask);",
                        "\t\t} else {",
                        "\t\t\tmemset(sdata->rc_rateidx_mcs_mask[i], 0,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));",
                        "\t\t\tmemset(sdata->rc_rateidx_vht_mcs_mask[i], 0,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_vht_mcs_mask[i]));",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tieee80211_set_default_queues(sdata);",
                        "",
                        "\tsdata->ap_power_level = IEEE80211_UNSET_POWER_LEVEL;",
                        "\tsdata->user_power_level = local->user_power_level;",
                        "",
                        "\tsdata->encrypt_headroom = IEEE80211_ENCRYPT_HEADROOM;",
                        "",
                        "\t/* setup type-dependent data */",
                        "\tieee80211_setup_sdata(sdata, type);",
                        "",
                        "\tif (ndev) {",
                        "\t\tndev->ieee80211_ptr->use_4addr = params->use_4addr;",
                        "\t\tif (type == NL80211_IFTYPE_STATION)",
                        "\t\t\tsdata->u.mgd.use_4addr = params->use_4addr;",
                        "",
                        "\t\tndev->features |= local->hw.netdev_features;",
                        "\t\tndev->hw_features |= ndev->features &",
                        "\t\t\t\t\tMAC80211_SUPPORTED_FEATURES_TX;",
                        "",
                        "\t\tnetdev_set_default_ethtool_ops(ndev, &ieee80211_ethtool_ops);",
                        "",
                        "\t\t/* MTU range: 256 - 2304 */",
                        "\t\tndev->min_mtu = 256;",
                        "\t\tndev->max_mtu = local->hw.max_mtu;",
                        "",
                        "\t\tret = register_netdevice(ndev);",
                        "\t\tif (ret) {",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tmutex_lock(&local->iflist_mtx);",
                        "\tlist_add_tail_rcu(&sdata->list, &local->interfaces);",
                        "\tmutex_unlock(&local->iflist_mtx);",
                        "",
                        "\tif (new_wdev)",
                        "\t\t*new_wdev = &sdata->wdev;",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1840,
                    "highlight": 2004
                }
            ],
            "ins_idx": 22450,
            "addr": "0xffffffff81c295ab"
        },
        "52604": {
            "name": "+0x47",
            "parent_idx": 52563,
            "source_line": [
                {
                    "file": "./include/linux/rculist.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/rculist.h?id=e28c0d7c92c89016c12a677616668957351e7542#n592",
                    "code": [
                        "/**",
                        " * hlist_add_head_rcu",
                        " * @n: the element to add to the hash list.",
                        " * @h: the list to add to.",
                        " *",
                        " * Description:",
                        " * Adds the specified element to the specified hlist,",
                        " * while permitting racing traversals.",
                        " *",
                        " * The caller must take whatever precautions are necessary",
                        " * (such as holding appropriate locks) to avoid racing",
                        " * with another list-mutation primitive, such as hlist_add_head_rcu()",
                        " * or hlist_del_rcu(), running on this same list.",
                        " * However, it is perfectly legal to run concurrently with",
                        " * the _rcu list-traversal primitives, such as",
                        " * hlist_for_each_entry_rcu(), used to prevent memory-consistency",
                        " * problems on Alpha CPUs.  Regardless of the type of CPU, the",
                        " * list-traversal primitive must be guarded by rcu_read_lock().",
                        " */",
                        "static inline void hlist_add_head_rcu(struct hlist_node *n,",
                        "\t\t\t\t\tstruct hlist_head *h)",
                        "{",
                        "\tstruct hlist_node *first = h->first;",
                        "",
                        "\tn->next = first;",
                        "\tWRITE_ONCE(n->pprev, &h->first);",
                        "\trcu_assign_pointer(hlist_first_rcu(h), n);",
                        "\tif (first)",
                        "\t\tWRITE_ONCE(first->pprev, &n->next);",
                        "}"
                    ],
                    "start": 566,
                    "highlight": 592
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n269",
                    "code": [
                        "static void netdev_name_node_add(struct net *net,",
                        "\t\t\t\t struct netdev_name_node *name_node)",
                        "{",
                        "\thlist_add_head_rcu(&name_node->hlist,",
                        "\t\t\t   dev_name_hash(net, name_node->name));",
                        "}"
                    ],
                    "start": 266,
                    "highlight": 269
                }
            ],
            "ins_idx": 20199,
            "addr": "0xffffffff819f58e7"
        },
        "52563": {
            "name": "netdev_name_node_add",
            "parent_idx": 52557,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n366",
                    "code": [
                        "/* Device list insertion */",
                        "static void list_netdevice(struct net_device *dev)",
                        "{",
                        "\tstruct net *net = dev_net(dev);",
                        "",
                        "\tASSERT_RTNL();",
                        "",
                        "\twrite_lock_bh(&dev_base_lock);",
                        "\tlist_add_tail_rcu(&dev->dev_list, &net->dev_base_head);",
                        "\tnetdev_name_node_add(net, dev->name_node);",
                        "\thlist_add_head_rcu(&dev->index_hlist,",
                        "\t\t\t   dev_index_hash(net, dev->ifindex));",
                        "\twrite_unlock_bh(&dev_base_lock);",
                        "",
                        "\tdev_base_seq_inc(net);",
                        "}"
                    ],
                    "start": 357,
                    "highlight": 366
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819f5950"
        },
        "52557": {
            "name": "list_netdevice",
            "parent_idx": 49373,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n9988",
                    "code": [
                        "int register_netdevice(struct net_device *dev)",
                        "{",
                        "\tint ret;",
                        "\tstruct net *net = dev_net(dev);",
                        "",
                        "\tBUILD_BUG_ON(sizeof(netdev_features_t) * BITS_PER_BYTE <",
                        "\t\t     NETDEV_FEATURE_COUNT);",
                        "\tBUG_ON(dev_boot_phase);",
                        "\tASSERT_RTNL();",
                        "",
                        "\tmight_sleep();",
                        "",
                        "\t/* When net_device's are persistent, this will be fatal. */",
                        "\tBUG_ON(dev->reg_state != NETREG_UNINITIALIZED);",
                        "\tBUG_ON(!net);",
                        "",
                        "\tret = ethtool_check_ops(dev->ethtool_ops);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\tspin_lock_init(&dev->addr_list_lock);",
                        "\tnetdev_set_addr_lockdep_class(dev);",
                        "",
                        "\tret = dev_get_valid_name(net, dev, dev->name);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tret = -ENOMEM;",
                        "\tdev->name_node = netdev_name_node_head_alloc(dev);",
                        "\tif (!dev->name_node)",
                        "\t\tgoto out;",
                        "",
                        "\t/* Init, if this function is available */",
                        "\tif (dev->netdev_ops->ndo_init) {",
                        "\t\tret = dev->netdev_ops->ndo_init(dev);",
                        "\t\tif (ret) {",
                        "\t\t\tif (ret > 0)",
                        "\t\t\t\tret = -EIO;",
                        "\t\t\tgoto err_free_name;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (((dev->hw_features | dev->features) &",
                        "\t     NETIF_F_HW_VLAN_CTAG_FILTER) &&",
                        "\t    (!dev->netdev_ops->ndo_vlan_rx_add_vid ||",
                        "\t     !dev->netdev_ops->ndo_vlan_rx_kill_vid)) {",
                        "\t\tnetdev_WARN(dev, \"Buggy VLAN acceleration in driver!\\n\");",
                        "\t\tret = -EINVAL;",
                        "\t\tgoto err_uninit;",
                        "\t}",
                        "",
                        "\tret = -EBUSY;",
                        "\tif (!dev->ifindex)",
                        "\t\tdev->ifindex = dev_new_index(net);",
                        "\telse if (__dev_get_by_index(net, dev->ifindex))",
                        "\t\tgoto err_uninit;",
                        "",
                        "\t/* Transfer changeable features to wanted_features and enable",
                        "\t * software offloads (GSO and GRO).",
                        "\t */",
                        "\tdev->hw_features |= (NETIF_F_SOFT_FEATURES | NETIF_F_SOFT_FEATURES_OFF);",
                        "\tdev->features |= NETIF_F_SOFT_FEATURES;",
                        "",
                        "\tif (dev->netdev_ops->ndo_udp_tunnel_add) {",
                        "\t\tdev->features |= NETIF_F_RX_UDP_TUNNEL_PORT;",
                        "\t\tdev->hw_features |= NETIF_F_RX_UDP_TUNNEL_PORT;",
                        "\t}",
                        "",
                        "\tdev->wanted_features = dev->features & dev->hw_features;",
                        "",
                        "\tif (!(dev->flags & IFF_LOOPBACK))",
                        "\t\tdev->hw_features |= NETIF_F_NOCACHE_COPY;",
                        "",
                        "\t/* If IPv4 TCP segmentation offload is supported we should also",
                        "\t * allow the device to enable segmenting the frame with the option",
                        "\t * of ignoring a static IP ID value.  This doesn't enable the",
                        "\t * feature itself but allows the user to enable it later.",
                        "\t */",
                        "\tif (dev->hw_features & NETIF_F_TSO)",
                        "\t\tdev->hw_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->vlan_features & NETIF_F_TSO)",
                        "\t\tdev->vlan_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->mpls_features & NETIF_F_TSO)",
                        "\t\tdev->mpls_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->hw_enc_features & NETIF_F_TSO)",
                        "\t\tdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;",
                        "",
                        "\t/* Make NETIF_F_HIGHDMA inheritable to VLAN devices.",
                        "\t */",
                        "\tdev->vlan_features |= NETIF_F_HIGHDMA;",
                        "",
                        "\t/* Make NETIF_F_SG inheritable to tunnel devices.",
                        "\t */",
                        "\tdev->hw_enc_features |= NETIF_F_SG | NETIF_F_GSO_PARTIAL;",
                        "",
                        "\t/* Make NETIF_F_SG inheritable to MPLS.",
                        "\t */",
                        "\tdev->mpls_features |= NETIF_F_SG;",
                        "",
                        "\tret = call_netdevice_notifiers(NETDEV_POST_INIT, dev);",
                        "\tret = notifier_to_errno(ret);",
                        "\tif (ret)",
                        "\t\tgoto err_uninit;",
                        "",
                        "\tret = netdev_register_kobject(dev);",
                        "\tif (ret) {",
                        "\t\tdev->reg_state = NETREG_UNREGISTERED;",
                        "\t\tgoto err_uninit;",
                        "\t}",
                        "\tdev->reg_state = NETREG_REGISTERED;",
                        "",
                        "\t__netdev_update_features(dev);",
                        "",
                        "\t/*",
                        "\t *\tDefault initial state at registry is that the",
                        "\t *\tdevice is present.",
                        "\t */",
                        "",
                        "\tset_bit(__LINK_STATE_PRESENT, &dev->state);",
                        "",
                        "\tlinkwatch_init_dev(dev);",
                        "",
                        "\tdev_init_scheduler(dev);",
                        "\tdev_hold(dev);",
                        "\tlist_netdevice(dev);",
                        "\tadd_device_randomness(dev->dev_addr, dev->addr_len);",
                        "",
                        "\t/* If the device has permanent device address, driver should",
                        "\t * set dev_addr and also addr_assign_type should be set to",
                        "\t * NET_ADDR_PERM (default value).",
                        "\t */",
                        "\tif (dev->addr_assign_type == NET_ADDR_PERM)",
                        "\t\tmemcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);",
                        "",
                        "\t/* Notify protocols, that a new device appeared. */",
                        "\tret = call_netdevice_notifiers(NETDEV_REGISTER, dev);",
                        "\tret = notifier_to_errno(ret);",
                        "\tif (ret) {",
                        "\t\trollback_registered(dev);",
                        "\t\trcu_barrier();",
                        "",
                        "\t\tdev->reg_state = NETREG_UNREGISTERED;",
                        "\t\t/* We should put the kobject that hold in",
                        "\t\t * netdev_unregister_kobject(), otherwise",
                        "\t\t * the net device cannot be freed when",
                        "\t\t * driver calls free_netdev(), because the",
                        "\t\t * kobject is being hold.",
                        "\t\t */",
                        "\t\tkobject_put(&dev->dev.kobj);",
                        "\t}",
                        "\t/*",
                        "\t *\tPrevent userspace races by waiting until the network",
                        "\t *\tdevice is fully setup before sending notifications.",
                        "\t */",
                        "\tif (!dev->rtnl_link_ops ||",
                        "\t    dev->rtnl_link_state == RTNL_LINK_INITIALIZED)",
                        "\t\trtmsg_ifinfo(RTM_NEWLINK, dev, ~0U, GFP_KERNEL);",
                        "",
                        "out:",
                        "\treturn ret;",
                        "",
                        "err_uninit:",
                        "\tif (dev->netdev_ops->ndo_uninit)",
                        "\t\tdev->netdev_ops->ndo_uninit(dev);",
                        "\tif (dev->priv_destructor)",
                        "\t\tdev->priv_destructor(dev);",
                        "err_free_name:",
                        "\tnetdev_name_node_free(dev->name_node);",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 9864,
                    "highlight": 9988
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81a01e70"
        },
        "48017": {
            "name": "+0xaa",
            "parent_idx": 47917,
            "source_line": [
                {
                    "file": "net/mac80211/iface.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/mac80211/iface.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1887",
                    "code": [
                        "int ieee80211_if_add(struct ieee80211_local *local, const char *name,",
                        "\t\t     unsigned char name_assign_type,",
                        "\t\t     struct wireless_dev **new_wdev, enum nl80211_iftype type,",
                        "\t\t     struct vif_params *params)",
                        "{",
                        "\tstruct net_device *ndev = NULL;",
                        "\tstruct ieee80211_sub_if_data *sdata = NULL;",
                        "\tstruct txq_info *txqi;",
                        "\tvoid (*if_setup)(struct net_device *dev);",
                        "\tint ret, i;",
                        "\tint txqs = 1;",
                        "",
                        "\tASSERT_RTNL();",
                        "",
                        "\tif (type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN) {",
                        "\t\tstruct wireless_dev *wdev;",
                        "",
                        "\t\tsdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size,",
                        "\t\t\t\tGFP_KERNEL);",
                        "\t\tif (!sdata)",
                        "\t\t\treturn -ENOMEM;",
                        "\t\twdev = &sdata->wdev;",
                        "",
                        "\t\tsdata->dev = NULL;",
                        "\t\tstrlcpy(sdata->name, name, IFNAMSIZ);",
                        "\t\tieee80211_assign_perm_addr(local, wdev->address, type);",
                        "\t\tmemcpy(sdata->vif.addr, wdev->address, ETH_ALEN);",
                        "\t} else {",
                        "\t\tint size = ALIGN(sizeof(*sdata) + local->hw.vif_data_size,",
                        "\t\t\t\t sizeof(void *));",
                        "\t\tint txq_size = 0;",
                        "",
                        "\t\tif (local->ops->wake_tx_queue &&",
                        "\t\t    type != NL80211_IFTYPE_AP_VLAN &&",
                        "\t\t    (type != NL80211_IFTYPE_MONITOR ||",
                        "\t\t     (params->flags & MONITOR_FLAG_ACTIVE)))",
                        "\t\t\ttxq_size += sizeof(struct txq_info) +",
                        "\t\t\t\t    local->hw.txq_data_size;",
                        "",
                        "\t\tif (local->ops->wake_tx_queue) {",
                        "\t\t\tif_setup = ieee80211_if_setup_no_queue;",
                        "\t\t} else {",
                        "\t\t\tif_setup = ieee80211_if_setup;",
                        "\t\t\tif (local->hw.queues >= IEEE80211_NUM_ACS)",
                        "\t\t\t\ttxqs = IEEE80211_NUM_ACS;",
                        "\t\t}",
                        "",
                        "\t\tndev = alloc_netdev_mqs(size + txq_size,",
                        "\t\t\t\t\tname, name_assign_type,",
                        "\t\t\t\t\tif_setup, txqs, 1);",
                        "\t\tif (!ndev)",
                        "\t\t\treturn -ENOMEM;",
                        "",
                        "\t\tif (!local->ops->wake_tx_queue && local->hw.wiphy->tx_queue_len)",
                        "\t\t\tndev->tx_queue_len = local->hw.wiphy->tx_queue_len;",
                        "",
                        "\t\tdev_net_set(ndev, wiphy_net(local->hw.wiphy));",
                        "",
                        "\t\tndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);",
                        "\t\tif (!ndev->tstats) {",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn -ENOMEM;",
                        "\t\t}",
                        "",
                        "\t\tndev->needed_headroom = local->tx_headroom +",
                        "\t\t\t\t\t4*6 /* four MAC addresses */",
                        "\t\t\t\t\t+ 2 + 2 + 2 + 2 /* ctl, dur, seq, qos */",
                        "\t\t\t\t\t+ 6 /* mesh */",
                        "\t\t\t\t\t+ 8 /* rfc1042/bridge tunnel */",
                        "\t\t\t\t\t- ETH_HLEN /* ethernet hard_header_len */",
                        "\t\t\t\t\t+ IEEE80211_ENCRYPT_HEADROOM;",
                        "\t\tndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;",
                        "",
                        "\t\tret = dev_alloc_name(ndev, ndev->name);",
                        "\t\tif (ret < 0) {",
                        "\t\t\tieee80211_if_free(ndev);",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "",
                        "\t\tieee80211_assign_perm_addr(local, ndev->perm_addr, type);",
                        "\t\tif (is_valid_ether_addr(params->macaddr))",
                        "\t\t\tmemcpy(ndev->dev_addr, params->macaddr, ETH_ALEN);",
                        "\t\telse",
                        "\t\t\tmemcpy(ndev->dev_addr, ndev->perm_addr, ETH_ALEN);",
                        "\t\tSET_NETDEV_DEV(ndev, wiphy_dev(local->hw.wiphy));",
                        "",
                        "\t\t/* don't use IEEE80211_DEV_TO_SUB_IF -- it checks too much */",
                        "\t\tsdata = netdev_priv(ndev);",
                        "\t\tndev->ieee80211_ptr = &sdata->wdev;",
                        "\t\tmemcpy(sdata->vif.addr, ndev->dev_addr, ETH_ALEN);",
                        "\t\tmemcpy(sdata->name, ndev->name, IFNAMSIZ);",
                        "",
                        "\t\tif (txq_size) {",
                        "\t\t\ttxqi = netdev_priv(ndev) + size;",
                        "\t\t\tieee80211_txq_init(sdata, NULL, txqi, 0);",
                        "\t\t}",
                        "",
                        "\t\tsdata->dev = ndev;",
                        "\t}",
                        "",
                        "\t/* initialise type-independent data */",
                        "\tsdata->wdev.wiphy = local->hw.wiphy;",
                        "\tsdata->local = local;",
                        "",
                        "\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)",
                        "\t\tskb_queue_head_init(&sdata->fragments[i].skb_list);",
                        "",
                        "\tINIT_LIST_HEAD(&sdata->key_list);",
                        "",
                        "\tINIT_DELAYED_WORK(&sdata->dfs_cac_timer_work,",
                        "\t\t\t  ieee80211_dfs_cac_timer_work);",
                        "\tINIT_DELAYED_WORK(&sdata->dec_tailroom_needed_wk,",
                        "\t\t\t  ieee80211_delayed_tailroom_dec);",
                        "",
                        "\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {",
                        "\t\tstruct ieee80211_supported_band *sband;",
                        "\t\tsband = local->hw.wiphy->bands[i];",
                        "\t\tsdata->rc_rateidx_mask[i] =",
                        "\t\t\tsband ? (1 << sband->n_bitrates) - 1 : 0;",
                        "\t\tif (sband) {",
                        "\t\t\t__le16 cap;",
                        "\t\t\tu16 *vht_rate_mask;",
                        "",
                        "\t\t\tmemcpy(sdata->rc_rateidx_mcs_mask[i],",
                        "\t\t\t       sband->ht_cap.mcs.rx_mask,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));",
                        "",
                        "\t\t\tcap = sband->vht_cap.vht_mcs.rx_mcs_map;",
                        "\t\t\tvht_rate_mask = sdata->rc_rateidx_vht_mcs_mask[i];",
                        "\t\t\tieee80211_get_vht_mask_from_cap(cap, vht_rate_mask);",
                        "\t\t} else {",
                        "\t\t\tmemset(sdata->rc_rateidx_mcs_mask[i], 0,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));",
                        "\t\t\tmemset(sdata->rc_rateidx_vht_mcs_mask[i], 0,",
                        "\t\t\t       sizeof(sdata->rc_rateidx_vht_mcs_mask[i]));",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tieee80211_set_default_queues(sdata);",
                        "",
                        "\tsdata->ap_power_level = IEEE80211_UNSET_POWER_LEVEL;",
                        "\tsdata->user_power_level = local->user_power_level;",
                        "",
                        "\tsdata->encrypt_headroom = IEEE80211_ENCRYPT_HEADROOM;",
                        "",
                        "\t/* setup type-dependent data */",
                        "\tieee80211_setup_sdata(sdata, type);",
                        "",
                        "\tif (ndev) {",
                        "\t\tndev->ieee80211_ptr->use_4addr = params->use_4addr;",
                        "\t\tif (type == NL80211_IFTYPE_STATION)",
                        "\t\t\tsdata->u.mgd.use_4addr = params->use_4addr;",
                        "",
                        "\t\tndev->features |= local->hw.netdev_features;",
                        "\t\tndev->hw_features |= ndev->features &",
                        "\t\t\t\t\tMAC80211_SUPPORTED_FEATURES_TX;",
                        "",
                        "\t\tnetdev_set_default_ethtool_ops(ndev, &ieee80211_ethtool_ops);",
                        "",
                        "\t\t/* MTU range: 256 - 2304 */",
                        "\t\tndev->min_mtu = 256;",
                        "\t\tndev->max_mtu = local->hw.max_mtu;",
                        "",
                        "\t\tret = register_netdevice(ndev);",
                        "\t\tif (ret) {",
                        "\t\t\tfree_netdev(ndev);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tmutex_lock(&local->iflist_mtx);",
                        "\tlist_add_tail_rcu(&sdata->list, &local->interfaces);",
                        "\tmutex_unlock(&local->iflist_mtx);",
                        "",
                        "\tif (new_wdev)",
                        "\t\t*new_wdev = &sdata->wdev;",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1840,
                    "highlight": 1887
                }
            ],
            "ins_idx": 25457,
            "addr": "0xffffffff81c2924a"
        },
        "52603": {
            "name": "+0x39",
            "parent_idx": 52563,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n213",
                    "code": [
                        "static inline struct hlist_head *dev_name_hash(struct net *net, const char *name)",
                        "{",
                        "\tunsigned int hash = full_name_hash(net, name, strnlen(name, IFNAMSIZ));",
                        "",
                        "\treturn &net->dev_name_head[hash_32(hash, NETDEV_HASHBITS)];",
                        "}"
                    ],
                    "start": 209,
                    "highlight": 213
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n269",
                    "code": [
                        "static void netdev_name_node_add(struct net *net,",
                        "\t\t\t\t struct netdev_name_node *name_node)",
                        "{",
                        "\thlist_add_head_rcu(&name_node->hlist,",
                        "\t\t\t   dev_name_hash(net, name_node->name));",
                        "}"
                    ],
                    "start": 266,
                    "highlight": 269
                }
            ],
            "ins_idx": 21372,
            "addr": "0xffffffff819f58d9"
        },
        "48014": {
            "name": "+0x310",
            "parent_idx": 47933,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n10513",
                    "code": [
                        "/**",
                        " * alloc_netdev_mqs - allocate network device",
                        " * @sizeof_priv: size of private data to allocate space for",
                        " * @name: device name format string",
                        " * @name_assign_type: origin of device name",
                        " * @setup: callback to initialize device",
                        " * @txqs: the number of TX subqueues to allocate",
                        " * @rxqs: the number of RX subqueues to allocate",
                        " *",
                        " * Allocates a struct net_device with private data area for driver use",
                        " * and performs basic initialization.  Also allocates subqueue structs",
                        " * for each queue on the device.",
                        " */",
                        "struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,",
                        "\t\tunsigned char name_assign_type,",
                        "\t\tvoid (*setup)(struct net_device *),",
                        "\t\tunsigned int txqs, unsigned int rxqs)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tunsigned int alloc_size;",
                        "\tstruct net_device *p;",
                        "",
                        "\tBUG_ON(strlen(name) >= sizeof(dev->name));",
                        "",
                        "\tif (txqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\tif (rxqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero RX queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\talloc_size = sizeof(struct net_device);",
                        "\tif (sizeof_priv) {",
                        "\t\t/* ensure 32-byte alignment of private area */",
                        "\t\talloc_size = ALIGN(alloc_size, NETDEV_ALIGN);",
                        "\t\talloc_size += sizeof_priv;",
                        "\t}",
                        "\t/* ensure 32-byte alignment of whole construct */",
                        "\talloc_size += NETDEV_ALIGN - 1;",
                        "",
                        "\tp = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);",
                        "\tif (!p)",
                        "\t\treturn NULL;",
                        "",
                        "\tdev = PTR_ALIGN(p, NETDEV_ALIGN);",
                        "\tdev->padded = (char *)dev - (char *)p;",
                        "",
                        "\tdev->pcpu_refcnt = alloc_percpu(int);",
                        "\tif (!dev->pcpu_refcnt)",
                        "\t\tgoto free_dev;",
                        "",
                        "\tif (dev_addr_init(dev))",
                        "\t\tgoto free_pcpu;",
                        "",
                        "\tdev_mc_init(dev);",
                        "\tdev_uc_init(dev);",
                        "",
                        "\tdev_net_set(dev, &init_net);",
                        "",
                        "\tdev->gso_max_size = GSO_MAX_SIZE;",
                        "\tdev->gso_max_segs = GSO_MAX_SEGS;",
                        "\tdev->upper_level = 1;",
                        "\tdev->lower_level = 1;",
                        "#ifdef CONFIG_LOCKDEP",
                        "\tdev->nested_level = 0;",
                        "\tINIT_LIST_HEAD(&dev->unlink_list);",
                        "#endif",
                        "",
                        "\tINIT_LIST_HEAD(&dev->napi_list);",
                        "\tINIT_LIST_HEAD(&dev->unreg_list);",
                        "\tINIT_LIST_HEAD(&dev->close_list);",
                        "\tINIT_LIST_HEAD(&dev->link_watch_list);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.upper);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.lower);",
                        "\tINIT_LIST_HEAD(&dev->ptype_all);",
                        "\tINIT_LIST_HEAD(&dev->ptype_specific);",
                        "\tINIT_LIST_HEAD(&dev->net_notifier_list);",
                        "#ifdef CONFIG_NET_SCHED",
                        "\thash_init(dev->qdisc_hash);",
                        "#endif",
                        "\tdev->priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;",
                        "\tsetup(dev);",
                        "",
                        "\tif (!dev->tx_queue_len) {",
                        "\t\tdev->priv_flags |= IFF_NO_QUEUE;",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t}",
                        "",
                        "\tdev->num_tx_queues = txqs;",
                        "\tdev->real_num_tx_queues = txqs;",
                        "\tif (netif_alloc_netdev_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tdev->num_rx_queues = rxqs;",
                        "\tdev->real_num_rx_queues = rxqs;",
                        "\tif (netif_alloc_rx_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tstrcpy(dev->name, name);",
                        "\tdev->name_assign_type = name_assign_type;",
                        "\tdev->group = INIT_NETDEV_GROUP;",
                        "\tif (!dev->ethtool_ops)",
                        "\t\tdev->ethtool_ops = &default_ethtool_ops;",
                        "",
                        "\tnf_hook_ingress_init(dev);",
                        "",
                        "\treturn dev;",
                        "",
                        "free_all:",
                        "\tfree_netdev(dev);",
                        "\treturn NULL;",
                        "",
                        "free_pcpu:",
                        "\tfree_percpu(dev->pcpu_refcnt);",
                        "free_dev:",
                        "\tnetdev_freemem(dev);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 10404,
                    "highlight": 10513
                }
            ],
            "ins_idx": 26290,
            "addr": "0xffffffff819f6f30"
        },
        "52602": {
            "name": "+0x36",
            "parent_idx": 52563,
            "source_line": [
                {
                    "file": "./include/linux/hash.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/hash.h?id=e28c0d7c92c89016c12a677616668957351e7542#n71",
                    "code": [
                        "#ifndef HAVE_ARCH_HASH_32",
                        "#define hash_32 hash_32_generic",
                        "#endif",
                        "static inline u32 hash_32_generic(u32 val, unsigned int bits)",
                        "{",
                        "\t/* High bits are more random, so use them. */",
                        "\treturn __hash_32(val) >> (32 - bits);",
                        "}"
                    ],
                    "start": 65,
                    "highlight": 71
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n213",
                    "code": [
                        "static inline struct hlist_head *dev_name_hash(struct net *net, const char *name)",
                        "{",
                        "\tunsigned int hash = full_name_hash(net, name, strnlen(name, IFNAMSIZ));",
                        "",
                        "\treturn &net->dev_name_head[hash_32(hash, NETDEV_HASHBITS)];",
                        "}"
                    ],
                    "start": 209,
                    "highlight": 213
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n269",
                    "code": [
                        "static void netdev_name_node_add(struct net *net,",
                        "\t\t\t\t struct netdev_name_node *name_node)",
                        "{",
                        "\thlist_add_head_rcu(&name_node->hlist,",
                        "\t\t\t   dev_name_hash(net, name_node->name));",
                        "}"
                    ],
                    "start": 266,
                    "highlight": 269
                }
            ],
            "ins_idx": 22448,
            "addr": "0xffffffff819f58d6"
        },
        "47943": {
            "name": "+0x6f",
            "parent_idx": 47933,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n10451",
                    "code": [
                        "/**",
                        " * alloc_netdev_mqs - allocate network device",
                        " * @sizeof_priv: size of private data to allocate space for",
                        " * @name: device name format string",
                        " * @name_assign_type: origin of device name",
                        " * @setup: callback to initialize device",
                        " * @txqs: the number of TX subqueues to allocate",
                        " * @rxqs: the number of RX subqueues to allocate",
                        " *",
                        " * Allocates a struct net_device with private data area for driver use",
                        " * and performs basic initialization.  Also allocates subqueue structs",
                        " * for each queue on the device.",
                        " */",
                        "struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,",
                        "\t\tunsigned char name_assign_type,",
                        "\t\tvoid (*setup)(struct net_device *),",
                        "\t\tunsigned int txqs, unsigned int rxqs)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tunsigned int alloc_size;",
                        "\tstruct net_device *p;",
                        "",
                        "\tBUG_ON(strlen(name) >= sizeof(dev->name));",
                        "",
                        "\tif (txqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\tif (rxqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero RX queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\talloc_size = sizeof(struct net_device);",
                        "\tif (sizeof_priv) {",
                        "\t\t/* ensure 32-byte alignment of private area */",
                        "\t\talloc_size = ALIGN(alloc_size, NETDEV_ALIGN);",
                        "\t\talloc_size += sizeof_priv;",
                        "\t}",
                        "\t/* ensure 32-byte alignment of whole construct */",
                        "\talloc_size += NETDEV_ALIGN - 1;",
                        "",
                        "\tp = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);",
                        "\tif (!p)",
                        "\t\treturn NULL;",
                        "",
                        "\tdev = PTR_ALIGN(p, NETDEV_ALIGN);",
                        "\tdev->padded = (char *)dev - (char *)p;",
                        "",
                        "\tdev->pcpu_refcnt = alloc_percpu(int);",
                        "\tif (!dev->pcpu_refcnt)",
                        "\t\tgoto free_dev;",
                        "",
                        "\tif (dev_addr_init(dev))",
                        "\t\tgoto free_pcpu;",
                        "",
                        "\tdev_mc_init(dev);",
                        "\tdev_uc_init(dev);",
                        "",
                        "\tdev_net_set(dev, &init_net);",
                        "",
                        "\tdev->gso_max_size = GSO_MAX_SIZE;",
                        "\tdev->gso_max_segs = GSO_MAX_SEGS;",
                        "\tdev->upper_level = 1;",
                        "\tdev->lower_level = 1;",
                        "#ifdef CONFIG_LOCKDEP",
                        "\tdev->nested_level = 0;",
                        "\tINIT_LIST_HEAD(&dev->unlink_list);",
                        "#endif",
                        "",
                        "\tINIT_LIST_HEAD(&dev->napi_list);",
                        "\tINIT_LIST_HEAD(&dev->unreg_list);",
                        "\tINIT_LIST_HEAD(&dev->close_list);",
                        "\tINIT_LIST_HEAD(&dev->link_watch_list);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.upper);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.lower);",
                        "\tINIT_LIST_HEAD(&dev->ptype_all);",
                        "\tINIT_LIST_HEAD(&dev->ptype_specific);",
                        "\tINIT_LIST_HEAD(&dev->net_notifier_list);",
                        "#ifdef CONFIG_NET_SCHED",
                        "\thash_init(dev->qdisc_hash);",
                        "#endif",
                        "\tdev->priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;",
                        "\tsetup(dev);",
                        "",
                        "\tif (!dev->tx_queue_len) {",
                        "\t\tdev->priv_flags |= IFF_NO_QUEUE;",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t}",
                        "",
                        "\tdev->num_tx_queues = txqs;",
                        "\tdev->real_num_tx_queues = txqs;",
                        "\tif (netif_alloc_netdev_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tdev->num_rx_queues = rxqs;",
                        "\tdev->real_num_rx_queues = rxqs;",
                        "\tif (netif_alloc_rx_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tstrcpy(dev->name, name);",
                        "\tdev->name_assign_type = name_assign_type;",
                        "\tdev->group = INIT_NETDEV_GROUP;",
                        "\tif (!dev->ethtool_ops)",
                        "\t\tdev->ethtool_ops = &default_ethtool_ops;",
                        "",
                        "\tnf_hook_ingress_init(dev);",
                        "",
                        "\treturn dev;",
                        "",
                        "free_all:",
                        "\tfree_netdev(dev);",
                        "\treturn NULL;",
                        "",
                        "free_pcpu:",
                        "\tfree_percpu(dev->pcpu_refcnt);",
                        "free_dev:",
                        "\tnetdev_freemem(dev);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 10404,
                    "highlight": 10451
                }
            ],
            "ins_idx": 20095,
            "addr": "0xffffffff819f6c8f"
        },
        "52601": {
            "name": "+0x30",
            "parent_idx": 52563,
            "source_line": [
                {
                    "file": "./include/linux/hash.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/hash.h?id=e28c0d7c92c89016c12a677616668957351e7542#n62",
                    "code": [
                        "/*",
                        " * The _generic versions exist only so lib/test_hash.c can compare",
                        " * the arch-optimized versions with the generic.",
                        " *",
                        " * Note that if you change these, any <asm/hash.h> that aren't updated",
                        " * to match need to have their HAVE_ARCH_* define values updated so the",
                        " * self-test will not false-positive.",
                        " */",
                        "#ifndef HAVE_ARCH__HASH_32",
                        "#define __hash_32 __hash_32_generic",
                        "#endif",
                        "static inline u32 __hash_32_generic(u32 val)",
                        "{",
                        "\treturn val * GOLDEN_RATIO_32;",
                        "}"
                    ],
                    "start": 49,
                    "highlight": 62
                },
                {
                    "file": "./include/linux/hash.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/hash.h?id=e28c0d7c92c89016c12a677616668957351e7542#n71",
                    "code": [
                        "#ifndef HAVE_ARCH_HASH_32",
                        "#define hash_32 hash_32_generic",
                        "#endif",
                        "static inline u32 hash_32_generic(u32 val, unsigned int bits)",
                        "{",
                        "\t/* High bits are more random, so use them. */",
                        "\treturn __hash_32(val) >> (32 - bits);",
                        "}"
                    ],
                    "start": 65,
                    "highlight": 71
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n213",
                    "code": [
                        "static inline struct hlist_head *dev_name_hash(struct net *net, const char *name)",
                        "{",
                        "\tunsigned int hash = full_name_hash(net, name, strnlen(name, IFNAMSIZ));",
                        "",
                        "\treturn &net->dev_name_head[hash_32(hash, NETDEV_HASHBITS)];",
                        "}"
                    ],
                    "start": 209,
                    "highlight": 213
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n269",
                    "code": [
                        "static void netdev_name_node_add(struct net *net,",
                        "\t\t\t\t struct netdev_name_node *name_node)",
                        "{",
                        "\thlist_add_head_rcu(&name_node->hlist,",
                        "\t\t\t   dev_name_hash(net, name_node->name));",
                        "}"
                    ],
                    "start": 266,
                    "highlight": 269
                }
            ],
            "ins_idx": 23518,
            "addr": "0xffffffff819f58d0"
        },
        "47942": {
            "name": "+0x61",
            "parent_idx": 47933,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n10451",
                    "code": [
                        "/**",
                        " * alloc_netdev_mqs - allocate network device",
                        " * @sizeof_priv: size of private data to allocate space for",
                        " * @name: device name format string",
                        " * @name_assign_type: origin of device name",
                        " * @setup: callback to initialize device",
                        " * @txqs: the number of TX subqueues to allocate",
                        " * @rxqs: the number of RX subqueues to allocate",
                        " *",
                        " * Allocates a struct net_device with private data area for driver use",
                        " * and performs basic initialization.  Also allocates subqueue structs",
                        " * for each queue on the device.",
                        " */",
                        "struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,",
                        "\t\tunsigned char name_assign_type,",
                        "\t\tvoid (*setup)(struct net_device *),",
                        "\t\tunsigned int txqs, unsigned int rxqs)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tunsigned int alloc_size;",
                        "\tstruct net_device *p;",
                        "",
                        "\tBUG_ON(strlen(name) >= sizeof(dev->name));",
                        "",
                        "\tif (txqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\tif (rxqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero RX queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\talloc_size = sizeof(struct net_device);",
                        "\tif (sizeof_priv) {",
                        "\t\t/* ensure 32-byte alignment of private area */",
                        "\t\talloc_size = ALIGN(alloc_size, NETDEV_ALIGN);",
                        "\t\talloc_size += sizeof_priv;",
                        "\t}",
                        "\t/* ensure 32-byte alignment of whole construct */",
                        "\talloc_size += NETDEV_ALIGN - 1;",
                        "",
                        "\tp = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);",
                        "\tif (!p)",
                        "\t\treturn NULL;",
                        "",
                        "\tdev = PTR_ALIGN(p, NETDEV_ALIGN);",
                        "\tdev->padded = (char *)dev - (char *)p;",
                        "",
                        "\tdev->pcpu_refcnt = alloc_percpu(int);",
                        "\tif (!dev->pcpu_refcnt)",
                        "\t\tgoto free_dev;",
                        "",
                        "\tif (dev_addr_init(dev))",
                        "\t\tgoto free_pcpu;",
                        "",
                        "\tdev_mc_init(dev);",
                        "\tdev_uc_init(dev);",
                        "",
                        "\tdev_net_set(dev, &init_net);",
                        "",
                        "\tdev->gso_max_size = GSO_MAX_SIZE;",
                        "\tdev->gso_max_segs = GSO_MAX_SEGS;",
                        "\tdev->upper_level = 1;",
                        "\tdev->lower_level = 1;",
                        "#ifdef CONFIG_LOCKDEP",
                        "\tdev->nested_level = 0;",
                        "\tINIT_LIST_HEAD(&dev->unlink_list);",
                        "#endif",
                        "",
                        "\tINIT_LIST_HEAD(&dev->napi_list);",
                        "\tINIT_LIST_HEAD(&dev->unreg_list);",
                        "\tINIT_LIST_HEAD(&dev->close_list);",
                        "\tINIT_LIST_HEAD(&dev->link_watch_list);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.upper);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.lower);",
                        "\tINIT_LIST_HEAD(&dev->ptype_all);",
                        "\tINIT_LIST_HEAD(&dev->ptype_specific);",
                        "\tINIT_LIST_HEAD(&dev->net_notifier_list);",
                        "#ifdef CONFIG_NET_SCHED",
                        "\thash_init(dev->qdisc_hash);",
                        "#endif",
                        "\tdev->priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;",
                        "\tsetup(dev);",
                        "",
                        "\tif (!dev->tx_queue_len) {",
                        "\t\tdev->priv_flags |= IFF_NO_QUEUE;",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t}",
                        "",
                        "\tdev->num_tx_queues = txqs;",
                        "\tdev->real_num_tx_queues = txqs;",
                        "\tif (netif_alloc_netdev_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tdev->num_rx_queues = rxqs;",
                        "\tdev->real_num_rx_queues = rxqs;",
                        "\tif (netif_alloc_rx_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tstrcpy(dev->name, name);",
                        "\tdev->name_assign_type = name_assign_type;",
                        "\tdev->group = INIT_NETDEV_GROUP;",
                        "\tif (!dev->ethtool_ops)",
                        "\t\tdev->ethtool_ops = &default_ethtool_ops;",
                        "",
                        "\tnf_hook_ingress_init(dev);",
                        "",
                        "\treturn dev;",
                        "",
                        "free_all:",
                        "\tfree_netdev(dev);",
                        "\treturn NULL;",
                        "",
                        "free_pcpu:",
                        "\tfree_percpu(dev->pcpu_refcnt);",
                        "free_dev:",
                        "\tnetdev_freemem(dev);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 10404,
                    "highlight": 10451
                }
            ],
            "ins_idx": 21269,
            "addr": "0xffffffff819f6c81"
        },
        "52598": {
            "name": "+0x74",
            "parent_idx": 52583,
            "source_line": [
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1993",
                    "code": [
                        "/*",
                        " * Return the hash of a string of known length.  This is carfully",
                        " * designed to match hash_name(), which is the more critical function.",
                        " * In particular, we must end by hashing a final word containing 0..7",
                        " * payload bytes, to match the way that hash_name() iterates until it",
                        " * finds the delimiter after the name.",
                        " */",
                        "unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)",
                        "{",
                        "\tunsigned long a, x = 0, y = (unsigned long)salt;",
                        "",
                        "\tfor (;;) {",
                        "\t\tif (!len)",
                        "\t\t\tgoto done;",
                        "\t\ta = load_unaligned_zeropad(name);",
                        "\t\tif (len < sizeof(unsigned long))",
                        "\t\t\tbreak;",
                        "\t\tHASH_MIX(x, y, a);",
                        "\t\tname += sizeof(unsigned long);",
                        "\t\tlen -= sizeof(unsigned long);",
                        "\t}",
                        "\tx ^= a & bytemask_from_count(len);",
                        "done:",
                        "\treturn fold_hash(x, y);",
                        "}"
                    ],
                    "start": 1969,
                    "highlight": 1993
                }
            ],
            "ins_idx": 24596,
            "addr": "0xffffffff81222b74"
        },
        "52583": {
            "name": "full_name_hash",
            "parent_idx": 52563,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n211",
                    "code": [
                        "static inline struct hlist_head *dev_name_hash(struct net *net, const char *name)",
                        "{",
                        "\tunsigned int hash = full_name_hash(net, name, strnlen(name, IFNAMSIZ));",
                        "",
                        "\treturn &net->dev_name_head[hash_32(hash, NETDEV_HASHBITS)];",
                        "}"
                    ],
                    "start": 209,
                    "highlight": 211
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n269",
                    "code": [
                        "static void netdev_name_node_add(struct net *net,",
                        "\t\t\t\t struct netdev_name_node *name_node)",
                        "{",
                        "\thlist_add_head_rcu(&name_node->hlist,",
                        "\t\t\t   dev_name_hash(net, name_node->name));",
                        "}"
                    ],
                    "start": 266,
                    "highlight": 269
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819f58c4"
        },
        "52597": {
            "name": "+0x70",
            "parent_idx": 52583,
            "source_line": [
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1940",
                    "code": [
                        "/*",
                        " * Fold two longs into one 32-bit hash value.  This must be fast, but",
                        " * latency isn't quite as critical, as there is a fair bit of additional",
                        " * work done before the hash value is used.",
                        " */",
                        "static inline unsigned int fold_hash(unsigned long x, unsigned long y)",
                        "{",
                        "\ty ^= x * GOLDEN_RATIO_64;",
                        "\ty *= GOLDEN_RATIO_64;",
                        "\treturn y >> 32;",
                        "}"
                    ],
                    "start": 1931,
                    "highlight": 1940
                },
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1992",
                    "code": [
                        "/*",
                        " * Return the hash of a string of known length.  This is carfully",
                        " * designed to match hash_name(), which is the more critical function.",
                        " * In particular, we must end by hashing a final word containing 0..7",
                        " * payload bytes, to match the way that hash_name() iterates until it",
                        " * finds the delimiter after the name.",
                        " */",
                        "unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)",
                        "{",
                        "\tunsigned long a, x = 0, y = (unsigned long)salt;",
                        "",
                        "\tfor (;;) {",
                        "\t\tif (!len)",
                        "\t\t\tgoto done;",
                        "\t\ta = load_unaligned_zeropad(name);",
                        "\t\tif (len < sizeof(unsigned long))",
                        "\t\t\tbreak;",
                        "\t\tHASH_MIX(x, y, a);",
                        "\t\tname += sizeof(unsigned long);",
                        "\t\tlen -= sizeof(unsigned long);",
                        "\t}",
                        "\tx ^= a & bytemask_from_count(len);",
                        "done:",
                        "\treturn fold_hash(x, y);",
                        "}"
                    ],
                    "start": 1969,
                    "highlight": 1992
                }
            ],
            "ins_idx": 25588,
            "addr": "0xffffffff81222b70"
        },
        "52596": {
            "name": "+0x6c",
            "parent_idx": 52583,
            "source_line": [
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1939",
                    "code": [
                        "/*",
                        " * Fold two longs into one 32-bit hash value.  This must be fast, but",
                        " * latency isn't quite as critical, as there is a fair bit of additional",
                        " * work done before the hash value is used.",
                        " */",
                        "static inline unsigned int fold_hash(unsigned long x, unsigned long y)",
                        "{",
                        "\ty ^= x * GOLDEN_RATIO_64;",
                        "\ty *= GOLDEN_RATIO_64;",
                        "\treturn y >> 32;",
                        "}"
                    ],
                    "start": 1931,
                    "highlight": 1939
                },
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1992",
                    "code": [
                        "/*",
                        " * Return the hash of a string of known length.  This is carfully",
                        " * designed to match hash_name(), which is the more critical function.",
                        " * In particular, we must end by hashing a final word containing 0..7",
                        " * payload bytes, to match the way that hash_name() iterates until it",
                        " * finds the delimiter after the name.",
                        " */",
                        "unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)",
                        "{",
                        "\tunsigned long a, x = 0, y = (unsigned long)salt;",
                        "",
                        "\tfor (;;) {",
                        "\t\tif (!len)",
                        "\t\t\tgoto done;",
                        "\t\ta = load_unaligned_zeropad(name);",
                        "\t\tif (len < sizeof(unsigned long))",
                        "\t\t\tbreak;",
                        "\t\tHASH_MIX(x, y, a);",
                        "\t\tname += sizeof(unsigned long);",
                        "\t\tlen -= sizeof(unsigned long);",
                        "\t}",
                        "\tx ^= a & bytemask_from_count(len);",
                        "done:",
                        "\treturn fold_hash(x, y);",
                        "}"
                    ],
                    "start": 1969,
                    "highlight": 1992
                }
            ],
            "ins_idx": 26427,
            "addr": "0xffffffff81222b6c"
        },
        "52594": {
            "name": "+0x5f",
            "parent_idx": 52583,
            "source_line": [
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1938",
                    "code": [
                        "/*",
                        " * Fold two longs into one 32-bit hash value.  This must be fast, but",
                        " * latency isn't quite as critical, as there is a fair bit of additional",
                        " * work done before the hash value is used.",
                        " */",
                        "static inline unsigned int fold_hash(unsigned long x, unsigned long y)",
                        "{",
                        "\ty ^= x * GOLDEN_RATIO_64;",
                        "\ty *= GOLDEN_RATIO_64;",
                        "\treturn y >> 32;",
                        "}"
                    ],
                    "start": 1931,
                    "highlight": 1938
                },
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1992",
                    "code": [
                        "/*",
                        " * Return the hash of a string of known length.  This is carfully",
                        " * designed to match hash_name(), which is the more critical function.",
                        " * In particular, we must end by hashing a final word containing 0..7",
                        " * payload bytes, to match the way that hash_name() iterates until it",
                        " * finds the delimiter after the name.",
                        " */",
                        "unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)",
                        "{",
                        "\tunsigned long a, x = 0, y = (unsigned long)salt;",
                        "",
                        "\tfor (;;) {",
                        "\t\tif (!len)",
                        "\t\t\tgoto done;",
                        "\t\ta = load_unaligned_zeropad(name);",
                        "\t\tif (len < sizeof(unsigned long))",
                        "\t\t\tbreak;",
                        "\t\tHASH_MIX(x, y, a);",
                        "\t\tname += sizeof(unsigned long);",
                        "\t\tlen -= sizeof(unsigned long);",
                        "\t}",
                        "\tx ^= a & bytemask_from_count(len);",
                        "done:",
                        "\treturn fold_hash(x, y);",
                        "}"
                    ],
                    "start": 1969,
                    "highlight": 1992
                }
            ],
            "ins_idx": 27155,
            "addr": "0xffffffff81222b5f"
        },
        "52593": {
            "name": "+0x5b",
            "parent_idx": 52583,
            "source_line": [
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1938",
                    "code": [
                        "/*",
                        " * Fold two longs into one 32-bit hash value.  This must be fast, but",
                        " * latency isn't quite as critical, as there is a fair bit of additional",
                        " * work done before the hash value is used.",
                        " */",
                        "static inline unsigned int fold_hash(unsigned long x, unsigned long y)",
                        "{",
                        "\ty ^= x * GOLDEN_RATIO_64;",
                        "\ty *= GOLDEN_RATIO_64;",
                        "\treturn y >> 32;",
                        "}"
                    ],
                    "start": 1931,
                    "highlight": 1938
                },
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1992",
                    "code": [
                        "/*",
                        " * Return the hash of a string of known length.  This is carfully",
                        " * designed to match hash_name(), which is the more critical function.",
                        " * In particular, we must end by hashing a final word containing 0..7",
                        " * payload bytes, to match the way that hash_name() iterates until it",
                        " * finds the delimiter after the name.",
                        " */",
                        "unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)",
                        "{",
                        "\tunsigned long a, x = 0, y = (unsigned long)salt;",
                        "",
                        "\tfor (;;) {",
                        "\t\tif (!len)",
                        "\t\t\tgoto done;",
                        "\t\ta = load_unaligned_zeropad(name);",
                        "\t\tif (len < sizeof(unsigned long))",
                        "\t\t\tbreak;",
                        "\t\tHASH_MIX(x, y, a);",
                        "\t\tname += sizeof(unsigned long);",
                        "\t\tlen -= sizeof(unsigned long);",
                        "\t}",
                        "\tx ^= a & bytemask_from_count(len);",
                        "done:",
                        "\treturn fold_hash(x, y);",
                        "}"
                    ],
                    "start": 1969,
                    "highlight": 1992
                }
            ],
            "ins_idx": 27920,
            "addr": "0xffffffff81222b5b"
        },
        "52591": {
            "name": "+0x4e",
            "parent_idx": 52583,
            "source_line": [
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1990",
                    "code": [
                        "/*",
                        " * Return the hash of a string of known length.  This is carfully",
                        " * designed to match hash_name(), which is the more critical function.",
                        " * In particular, we must end by hashing a final word containing 0..7",
                        " * payload bytes, to match the way that hash_name() iterates until it",
                        " * finds the delimiter after the name.",
                        " */",
                        "unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)",
                        "{",
                        "\tunsigned long a, x = 0, y = (unsigned long)salt;",
                        "",
                        "\tfor (;;) {",
                        "\t\tif (!len)",
                        "\t\t\tgoto done;",
                        "\t\ta = load_unaligned_zeropad(name);",
                        "\t\tif (len < sizeof(unsigned long))",
                        "\t\t\tbreak;",
                        "\t\tHASH_MIX(x, y, a);",
                        "\t\tname += sizeof(unsigned long);",
                        "\t\tlen -= sizeof(unsigned long);",
                        "\t}",
                        "\tx ^= a & bytemask_from_count(len);",
                        "done:",
                        "\treturn fold_hash(x, y);",
                        "}"
                    ],
                    "start": 1969,
                    "highlight": 1990
                }
            ],
            "ins_idx": 28705,
            "addr": "0xffffffff81222b4e"
        },
        "52590": {
            "name": "+0x4b",
            "parent_idx": 52583,
            "source_line": [
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1990",
                    "code": [
                        "/*",
                        " * Return the hash of a string of known length.  This is carfully",
                        " * designed to match hash_name(), which is the more critical function.",
                        " * In particular, we must end by hashing a final word containing 0..7",
                        " * payload bytes, to match the way that hash_name() iterates until it",
                        " * finds the delimiter after the name.",
                        " */",
                        "unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)",
                        "{",
                        "\tunsigned long a, x = 0, y = (unsigned long)salt;",
                        "",
                        "\tfor (;;) {",
                        "\t\tif (!len)",
                        "\t\t\tgoto done;",
                        "\t\ta = load_unaligned_zeropad(name);",
                        "\t\tif (len < sizeof(unsigned long))",
                        "\t\t\tbreak;",
                        "\t\tHASH_MIX(x, y, a);",
                        "\t\tname += sizeof(unsigned long);",
                        "\t\tlen -= sizeof(unsigned long);",
                        "\t}",
                        "\tx ^= a & bytemask_from_count(len);",
                        "done:",
                        "\treturn fold_hash(x, y);",
                        "}"
                    ],
                    "start": 1969,
                    "highlight": 1990
                }
            ],
            "ins_idx": 29471,
            "addr": "0xffffffff81222b4b"
        },
        "52585": {
            "name": "+0x2f",
            "parent_idx": 52583,
            "source_line": [
                {
                    "file": "./arch/x86/include/asm/word-at-a-time.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./arch/x86/include/asm/word-at-a-time.h?id=e28c0d7c92c89016c12a677616668957351e7542#n84",
                    "code": [
                        "/*",
                        " * Load an unaligned word from kernel space.",
                        " *",
                        " * In the (very unlikely) case of the word being a page-crosser",
                        " * and the next page not being mapped, take the exception and",
                        " * return zeroes in the non-existing part.",
                        " */",
                        "static inline unsigned long load_unaligned_zeropad(const void *addr)",
                        "{",
                        "\tunsigned long ret, dummy;",
                        "",
                        "\tasm(",
                        "\t\t\"1:\\tmov %2,%0\\n\"",
                        "\t\t\"2:\\n\"",
                        "\t\t\".section .fixup,\\\"ax\\\"\\n\"",
                        "\t\t\"3:\\t\"",
                        "\t\t\"lea %2,%1\\n\\t\"",
                        "\t\t\"and %3,%1\\n\\t\"",
                        "\t\t\"mov (%1),%0\\n\\t\"",
                        "\t\t\"leal %2,%%ecx\\n\\t\"",
                        "\t\t\"andl %4,%%ecx\\n\\t\"",
                        "\t\t\"shll $3,%%ecx\\n\\t\"",
                        "\t\t\"shr %%cl,%0\\n\\t\"",
                        "\t\t\"jmp 2b\\n\"",
                        "\t\t\".previous\\n\"",
                        "\t\t_ASM_EXTABLE(1b, 3b)",
                        "\t\t:\"=&r\" (ret),\"=&c\" (dummy)",
                        "\t\t:\"m\" (*(unsigned long *)addr),",
                        "\t\t \"i\" (-sizeof(unsigned long)),",
                        "\t\t \"i\" (sizeof(unsigned long)-1));",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 73,
                    "highlight": 84
                },
                {
                    "file": "fs/namei.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namei.c?id=e28c0d7c92c89016c12a677616668957351e7542#n1983",
                    "code": [
                        "/*",
                        " * Return the hash of a string of known length.  This is carfully",
                        " * designed to match hash_name(), which is the more critical function.",
                        " * In particular, we must end by hashing a final word containing 0..7",
                        " * payload bytes, to match the way that hash_name() iterates until it",
                        " * finds the delimiter after the name.",
                        " */",
                        "unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)",
                        "{",
                        "\tunsigned long a, x = 0, y = (unsigned long)salt;",
                        "",
                        "\tfor (;;) {",
                        "\t\tif (!len)",
                        "\t\t\tgoto done;",
                        "\t\ta = load_unaligned_zeropad(name);",
                        "\t\tif (len < sizeof(unsigned long))",
                        "\t\t\tbreak;",
                        "\t\tHASH_MIX(x, y, a);",
                        "\t\tname += sizeof(unsigned long);",
                        "\t\tlen -= sizeof(unsigned long);",
                        "\t}",
                        "\tx ^= a & bytemask_from_count(len);",
                        "done:",
                        "\treturn fold_hash(x, y);",
                        "}"
                    ],
                    "start": 1969,
                    "highlight": 1983
                }
            ],
            "ins_idx": 30246,
            "addr": "0xffffffff81222b2f"
        },
        "52580": {
            "name": "+0x1b",
            "parent_idx": 52563,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n211",
                    "code": [
                        "static inline struct hlist_head *dev_name_hash(struct net *net, const char *name)",
                        "{",
                        "\tunsigned int hash = full_name_hash(net, name, strnlen(name, IFNAMSIZ));",
                        "",
                        "\treturn &net->dev_name_head[hash_32(hash, NETDEV_HASHBITS)];",
                        "}"
                    ],
                    "start": 209,
                    "highlight": 211
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n269",
                    "code": [
                        "static void netdev_name_node_add(struct net *net,",
                        "\t\t\t\t struct netdev_name_node *name_node)",
                        "{",
                        "\thlist_add_head_rcu(&name_node->hlist,",
                        "\t\t\t   dev_name_hash(net, name_node->name));",
                        "}"
                    ],
                    "start": 266,
                    "highlight": 269
                }
            ],
            "ins_idx": 31052,
            "addr": "0xffffffff819f58bb"
        },
        "48013": {
            "name": "+0x9",
            "parent_idx": 47995,
            "source_line": [
                {
                    "file": "lib/string.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/string.c?id=e28c0d7c92c89016c12a677616668957351e7542#n93",
                    "code": [
                        "#ifndef __HAVE_ARCH_STRCPY",
                        "/**",
                        " * strcpy - Copy a %NUL terminated string",
                        " * @dest: Where to copy the string to",
                        " * @src: Where to copy the string from",
                        " */",
                        "#undef strcpy",
                        "char *strcpy(char *dest, const char *src)",
                        "{",
                        "\tchar *tmp = dest;",
                        "",
                        "\twhile ((*dest++ = *src++) != '\\0')",
                        "\t\t/* nothing */;",
                        "\treturn tmp;",
                        "}"
                    ],
                    "start": 82,
                    "highlight": 93
                }
            ],
            "ins_idx": 31053,
            "addr": "0xffffffff81462059"
        },
        "47995": {
            "name": "strcpy",
            "parent_idx": 47933,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n10505",
                    "code": [
                        "/**",
                        " * alloc_netdev_mqs - allocate network device",
                        " * @sizeof_priv: size of private data to allocate space for",
                        " * @name: device name format string",
                        " * @name_assign_type: origin of device name",
                        " * @setup: callback to initialize device",
                        " * @txqs: the number of TX subqueues to allocate",
                        " * @rxqs: the number of RX subqueues to allocate",
                        " *",
                        " * Allocates a struct net_device with private data area for driver use",
                        " * and performs basic initialization.  Also allocates subqueue structs",
                        " * for each queue on the device.",
                        " */",
                        "struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,",
                        "\t\tunsigned char name_assign_type,",
                        "\t\tvoid (*setup)(struct net_device *),",
                        "\t\tunsigned int txqs, unsigned int rxqs)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tunsigned int alloc_size;",
                        "\tstruct net_device *p;",
                        "",
                        "\tBUG_ON(strlen(name) >= sizeof(dev->name));",
                        "",
                        "\tif (txqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\tif (rxqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero RX queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\talloc_size = sizeof(struct net_device);",
                        "\tif (sizeof_priv) {",
                        "\t\t/* ensure 32-byte alignment of private area */",
                        "\t\talloc_size = ALIGN(alloc_size, NETDEV_ALIGN);",
                        "\t\talloc_size += sizeof_priv;",
                        "\t}",
                        "\t/* ensure 32-byte alignment of whole construct */",
                        "\talloc_size += NETDEV_ALIGN - 1;",
                        "",
                        "\tp = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);",
                        "\tif (!p)",
                        "\t\treturn NULL;",
                        "",
                        "\tdev = PTR_ALIGN(p, NETDEV_ALIGN);",
                        "\tdev->padded = (char *)dev - (char *)p;",
                        "",
                        "\tdev->pcpu_refcnt = alloc_percpu(int);",
                        "\tif (!dev->pcpu_refcnt)",
                        "\t\tgoto free_dev;",
                        "",
                        "\tif (dev_addr_init(dev))",
                        "\t\tgoto free_pcpu;",
                        "",
                        "\tdev_mc_init(dev);",
                        "\tdev_uc_init(dev);",
                        "",
                        "\tdev_net_set(dev, &init_net);",
                        "",
                        "\tdev->gso_max_size = GSO_MAX_SIZE;",
                        "\tdev->gso_max_segs = GSO_MAX_SEGS;",
                        "\tdev->upper_level = 1;",
                        "\tdev->lower_level = 1;",
                        "#ifdef CONFIG_LOCKDEP",
                        "\tdev->nested_level = 0;",
                        "\tINIT_LIST_HEAD(&dev->unlink_list);",
                        "#endif",
                        "",
                        "\tINIT_LIST_HEAD(&dev->napi_list);",
                        "\tINIT_LIST_HEAD(&dev->unreg_list);",
                        "\tINIT_LIST_HEAD(&dev->close_list);",
                        "\tINIT_LIST_HEAD(&dev->link_watch_list);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.upper);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.lower);",
                        "\tINIT_LIST_HEAD(&dev->ptype_all);",
                        "\tINIT_LIST_HEAD(&dev->ptype_specific);",
                        "\tINIT_LIST_HEAD(&dev->net_notifier_list);",
                        "#ifdef CONFIG_NET_SCHED",
                        "\thash_init(dev->qdisc_hash);",
                        "#endif",
                        "\tdev->priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;",
                        "\tsetup(dev);",
                        "",
                        "\tif (!dev->tx_queue_len) {",
                        "\t\tdev->priv_flags |= IFF_NO_QUEUE;",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t}",
                        "",
                        "\tdev->num_tx_queues = txqs;",
                        "\tdev->real_num_tx_queues = txqs;",
                        "\tif (netif_alloc_netdev_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tdev->num_rx_queues = rxqs;",
                        "\tdev->real_num_rx_queues = rxqs;",
                        "\tif (netif_alloc_rx_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tstrcpy(dev->name, name);",
                        "\tdev->name_assign_type = name_assign_type;",
                        "\tdev->group = INIT_NETDEV_GROUP;",
                        "\tif (!dev->ethtool_ops)",
                        "\t\tdev->ethtool_ops = &default_ethtool_ops;",
                        "",
                        "\tnf_hook_ingress_init(dev);",
                        "",
                        "\treturn dev;",
                        "",
                        "free_all:",
                        "\tfree_netdev(dev);",
                        "\treturn NULL;",
                        "",
                        "free_pcpu:",
                        "\tfree_percpu(dev->pcpu_refcnt);",
                        "free_dev:",
                        "\tnetdev_freemem(dev);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 10404,
                    "highlight": 10505
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff819f6efd"
        },
        "52569": {
            "name": "+0x7",
            "parent_idx": 52563,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n269",
                    "code": [
                        "static void netdev_name_node_add(struct net *net,",
                        "\t\t\t\t struct netdev_name_node *name_node)",
                        "{",
                        "\thlist_add_head_rcu(&name_node->hlist,",
                        "\t\t\t   dev_name_hash(net, name_node->name));",
                        "}"
                    ],
                    "start": 266,
                    "highlight": 269
                }
            ],
            "ins_idx": 31842,
            "addr": "0xffffffff819f58a7"
        },
        "47996": {
            "name": "+0x0",
            "parent_idx": 47995,
            "source_line": [
                {
                    "file": "lib/string.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/lib/string.c?id=e28c0d7c92c89016c12a677616668957351e7542#n90",
                    "code": [
                        "#ifndef __HAVE_ARCH_STRCPY",
                        "/**",
                        " * strcpy - Copy a %NUL terminated string",
                        " * @dest: Where to copy the string to",
                        " * @src: Where to copy the string from",
                        " */",
                        "#undef strcpy",
                        "char *strcpy(char *dest, const char *src)",
                        "{",
                        "\tchar *tmp = dest;",
                        "",
                        "\twhile ((*dest++ = *src++) != '\\0')",
                        "\t\t/* nothing */;",
                        "\treturn tmp;",
                        "}"
                    ],
                    "start": 82,
                    "highlight": 90
                }
            ],
            "ins_idx": 31844,
            "addr": "0xffffffff81462050"
        },
        "49405": {
            "name": "+0xe4",
            "parent_idx": 49373,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n245",
                    "code": [
                        "static struct netdev_name_node *netdev_name_node_alloc(struct net_device *dev,",
                        "\t\t\t\t\t\t       const char *name)",
                        "{",
                        "\tstruct netdev_name_node *name_node;",
                        "",
                        "\tname_node = kmalloc(sizeof(*name_node), GFP_KERNEL);",
                        "\tif (!name_node)",
                        "\t\treturn NULL;",
                        "\tINIT_HLIST_NODE(&name_node->hlist);",
                        "\tname_node->dev = dev;",
                        "\tname_node->name = name;",
                        "\treturn name_node;",
                        "}"
                    ],
                    "start": 235,
                    "highlight": 245
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n254",
                    "code": [
                        "static struct netdev_name_node *",
                        "netdev_name_node_head_alloc(struct net_device *dev)",
                        "{",
                        "\tstruct netdev_name_node *name_node;",
                        "",
                        "\tname_node = netdev_name_node_alloc(dev, dev->name);",
                        "\tif (!name_node)",
                        "\t\treturn NULL;",
                        "\tINIT_LIST_HEAD(&name_node->list);",
                        "\treturn name_node;",
                        "}"
                    ],
                    "start": 249,
                    "highlight": 254
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n9892",
                    "code": [
                        "int register_netdevice(struct net_device *dev)",
                        "{",
                        "\tint ret;",
                        "\tstruct net *net = dev_net(dev);",
                        "",
                        "\tBUILD_BUG_ON(sizeof(netdev_features_t) * BITS_PER_BYTE <",
                        "\t\t     NETDEV_FEATURE_COUNT);",
                        "\tBUG_ON(dev_boot_phase);",
                        "\tASSERT_RTNL();",
                        "",
                        "\tmight_sleep();",
                        "",
                        "\t/* When net_device's are persistent, this will be fatal. */",
                        "\tBUG_ON(dev->reg_state != NETREG_UNINITIALIZED);",
                        "\tBUG_ON(!net);",
                        "",
                        "\tret = ethtool_check_ops(dev->ethtool_ops);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\tspin_lock_init(&dev->addr_list_lock);",
                        "\tnetdev_set_addr_lockdep_class(dev);",
                        "",
                        "\tret = dev_get_valid_name(net, dev, dev->name);",
                        "\tif (ret < 0)",
                        "\t\tgoto out;",
                        "",
                        "\tret = -ENOMEM;",
                        "\tdev->name_node = netdev_name_node_head_alloc(dev);",
                        "\tif (!dev->name_node)",
                        "\t\tgoto out;",
                        "",
                        "\t/* Init, if this function is available */",
                        "\tif (dev->netdev_ops->ndo_init) {",
                        "\t\tret = dev->netdev_ops->ndo_init(dev);",
                        "\t\tif (ret) {",
                        "\t\t\tif (ret > 0)",
                        "\t\t\t\tret = -EIO;",
                        "\t\t\tgoto err_free_name;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (((dev->hw_features | dev->features) &",
                        "\t     NETIF_F_HW_VLAN_CTAG_FILTER) &&",
                        "\t    (!dev->netdev_ops->ndo_vlan_rx_add_vid ||",
                        "\t     !dev->netdev_ops->ndo_vlan_rx_kill_vid)) {",
                        "\t\tnetdev_WARN(dev, \"Buggy VLAN acceleration in driver!\\n\");",
                        "\t\tret = -EINVAL;",
                        "\t\tgoto err_uninit;",
                        "\t}",
                        "",
                        "\tret = -EBUSY;",
                        "\tif (!dev->ifindex)",
                        "\t\tdev->ifindex = dev_new_index(net);",
                        "\telse if (__dev_get_by_index(net, dev->ifindex))",
                        "\t\tgoto err_uninit;",
                        "",
                        "\t/* Transfer changeable features to wanted_features and enable",
                        "\t * software offloads (GSO and GRO).",
                        "\t */",
                        "\tdev->hw_features |= (NETIF_F_SOFT_FEATURES | NETIF_F_SOFT_FEATURES_OFF);",
                        "\tdev->features |= NETIF_F_SOFT_FEATURES;",
                        "",
                        "\tif (dev->netdev_ops->ndo_udp_tunnel_add) {",
                        "\t\tdev->features |= NETIF_F_RX_UDP_TUNNEL_PORT;",
                        "\t\tdev->hw_features |= NETIF_F_RX_UDP_TUNNEL_PORT;",
                        "\t}",
                        "",
                        "\tdev->wanted_features = dev->features & dev->hw_features;",
                        "",
                        "\tif (!(dev->flags & IFF_LOOPBACK))",
                        "\t\tdev->hw_features |= NETIF_F_NOCACHE_COPY;",
                        "",
                        "\t/* If IPv4 TCP segmentation offload is supported we should also",
                        "\t * allow the device to enable segmenting the frame with the option",
                        "\t * of ignoring a static IP ID value.  This doesn't enable the",
                        "\t * feature itself but allows the user to enable it later.",
                        "\t */",
                        "\tif (dev->hw_features & NETIF_F_TSO)",
                        "\t\tdev->hw_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->vlan_features & NETIF_F_TSO)",
                        "\t\tdev->vlan_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->mpls_features & NETIF_F_TSO)",
                        "\t\tdev->mpls_features |= NETIF_F_TSO_MANGLEID;",
                        "\tif (dev->hw_enc_features & NETIF_F_TSO)",
                        "\t\tdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;",
                        "",
                        "\t/* Make NETIF_F_HIGHDMA inheritable to VLAN devices.",
                        "\t */",
                        "\tdev->vlan_features |= NETIF_F_HIGHDMA;",
                        "",
                        "\t/* Make NETIF_F_SG inheritable to tunnel devices.",
                        "\t */",
                        "\tdev->hw_enc_features |= NETIF_F_SG | NETIF_F_GSO_PARTIAL;",
                        "",
                        "\t/* Make NETIF_F_SG inheritable to MPLS.",
                        "\t */",
                        "\tdev->mpls_features |= NETIF_F_SG;",
                        "",
                        "\tret = call_netdevice_notifiers(NETDEV_POST_INIT, dev);",
                        "\tret = notifier_to_errno(ret);",
                        "\tif (ret)",
                        "\t\tgoto err_uninit;",
                        "",
                        "\tret = netdev_register_kobject(dev);",
                        "\tif (ret) {",
                        "\t\tdev->reg_state = NETREG_UNREGISTERED;",
                        "\t\tgoto err_uninit;",
                        "\t}",
                        "\tdev->reg_state = NETREG_REGISTERED;",
                        "",
                        "\t__netdev_update_features(dev);",
                        "",
                        "\t/*",
                        "\t *\tDefault initial state at registry is that the",
                        "\t *\tdevice is present.",
                        "\t */",
                        "",
                        "\tset_bit(__LINK_STATE_PRESENT, &dev->state);",
                        "",
                        "\tlinkwatch_init_dev(dev);",
                        "",
                        "\tdev_init_scheduler(dev);",
                        "\tdev_hold(dev);",
                        "\tlist_netdevice(dev);",
                        "\tadd_device_randomness(dev->dev_addr, dev->addr_len);",
                        "",
                        "\t/* If the device has permanent device address, driver should",
                        "\t * set dev_addr and also addr_assign_type should be set to",
                        "\t * NET_ADDR_PERM (default value).",
                        "\t */",
                        "\tif (dev->addr_assign_type == NET_ADDR_PERM)",
                        "\t\tmemcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);",
                        "",
                        "\t/* Notify protocols, that a new device appeared. */",
                        "\tret = call_netdevice_notifiers(NETDEV_REGISTER, dev);",
                        "\tret = notifier_to_errno(ret);",
                        "\tif (ret) {",
                        "\t\trollback_registered(dev);",
                        "\t\trcu_barrier();",
                        "",
                        "\t\tdev->reg_state = NETREG_UNREGISTERED;",
                        "\t\t/* We should put the kobject that hold in",
                        "\t\t * netdev_unregister_kobject(), otherwise",
                        "\t\t * the net device cannot be freed when",
                        "\t\t * driver calls free_netdev(), because the",
                        "\t\t * kobject is being hold.",
                        "\t\t */",
                        "\t\tkobject_put(&dev->dev.kobj);",
                        "\t}",
                        "\t/*",
                        "\t *\tPrevent userspace races by waiting until the network",
                        "\t *\tdevice is fully setup before sending notifications.",
                        "\t */",
                        "\tif (!dev->rtnl_link_ops ||",
                        "\t    dev->rtnl_link_state == RTNL_LINK_INITIALIZED)",
                        "\t\trtmsg_ifinfo(RTM_NEWLINK, dev, ~0U, GFP_KERNEL);",
                        "",
                        "out:",
                        "\treturn ret;",
                        "",
                        "err_uninit:",
                        "\tif (dev->netdev_ops->ndo_uninit)",
                        "\t\tdev->netdev_ops->ndo_uninit(dev);",
                        "\tif (dev->priv_destructor)",
                        "\t\tdev->priv_destructor(dev);",
                        "err_free_name:",
                        "\tnetdev_name_node_free(dev->name_node);",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 9864,
                    "highlight": 9892
                }
            ],
            "ins_idx": 32624,
            "addr": "0xffffffff81a01ae4"
        },
        "47994": {
            "name": "+0x2da",
            "parent_idx": 47933,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=e28c0d7c92c89016c12a677616668957351e7542#n10505",
                    "code": [
                        "/**",
                        " * alloc_netdev_mqs - allocate network device",
                        " * @sizeof_priv: size of private data to allocate space for",
                        " * @name: device name format string",
                        " * @name_assign_type: origin of device name",
                        " * @setup: callback to initialize device",
                        " * @txqs: the number of TX subqueues to allocate",
                        " * @rxqs: the number of RX subqueues to allocate",
                        " *",
                        " * Allocates a struct net_device with private data area for driver use",
                        " * and performs basic initialization.  Also allocates subqueue structs",
                        " * for each queue on the device.",
                        " */",
                        "struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,",
                        "\t\tunsigned char name_assign_type,",
                        "\t\tvoid (*setup)(struct net_device *),",
                        "\t\tunsigned int txqs, unsigned int rxqs)",
                        "{",
                        "\tstruct net_device *dev;",
                        "\tunsigned int alloc_size;",
                        "\tstruct net_device *p;",
                        "",
                        "\tBUG_ON(strlen(name) >= sizeof(dev->name));",
                        "",
                        "\tif (txqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\tif (rxqs < 1) {",
                        "\t\tpr_err(\"alloc_netdev: Unable to allocate device with zero RX queues\\n\");",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\talloc_size = sizeof(struct net_device);",
                        "\tif (sizeof_priv) {",
                        "\t\t/* ensure 32-byte alignment of private area */",
                        "\t\talloc_size = ALIGN(alloc_size, NETDEV_ALIGN);",
                        "\t\talloc_size += sizeof_priv;",
                        "\t}",
                        "\t/* ensure 32-byte alignment of whole construct */",
                        "\talloc_size += NETDEV_ALIGN - 1;",
                        "",
                        "\tp = kvzalloc(alloc_size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);",
                        "\tif (!p)",
                        "\t\treturn NULL;",
                        "",
                        "\tdev = PTR_ALIGN(p, NETDEV_ALIGN);",
                        "\tdev->padded = (char *)dev - (char *)p;",
                        "",
                        "\tdev->pcpu_refcnt = alloc_percpu(int);",
                        "\tif (!dev->pcpu_refcnt)",
                        "\t\tgoto free_dev;",
                        "",
                        "\tif (dev_addr_init(dev))",
                        "\t\tgoto free_pcpu;",
                        "",
                        "\tdev_mc_init(dev);",
                        "\tdev_uc_init(dev);",
                        "",
                        "\tdev_net_set(dev, &init_net);",
                        "",
                        "\tdev->gso_max_size = GSO_MAX_SIZE;",
                        "\tdev->gso_max_segs = GSO_MAX_SEGS;",
                        "\tdev->upper_level = 1;",
                        "\tdev->lower_level = 1;",
                        "#ifdef CONFIG_LOCKDEP",
                        "\tdev->nested_level = 0;",
                        "\tINIT_LIST_HEAD(&dev->unlink_list);",
                        "#endif",
                        "",
                        "\tINIT_LIST_HEAD(&dev->napi_list);",
                        "\tINIT_LIST_HEAD(&dev->unreg_list);",
                        "\tINIT_LIST_HEAD(&dev->close_list);",
                        "\tINIT_LIST_HEAD(&dev->link_watch_list);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.upper);",
                        "\tINIT_LIST_HEAD(&dev->adj_list.lower);",
                        "\tINIT_LIST_HEAD(&dev->ptype_all);",
                        "\tINIT_LIST_HEAD(&dev->ptype_specific);",
                        "\tINIT_LIST_HEAD(&dev->net_notifier_list);",
                        "#ifdef CONFIG_NET_SCHED",
                        "\thash_init(dev->qdisc_hash);",
                        "#endif",
                        "\tdev->priv_flags = IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM;",
                        "\tsetup(dev);",
                        "",
                        "\tif (!dev->tx_queue_len) {",
                        "\t\tdev->priv_flags |= IFF_NO_QUEUE;",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t}",
                        "",
                        "\tdev->num_tx_queues = txqs;",
                        "\tdev->real_num_tx_queues = txqs;",
                        "\tif (netif_alloc_netdev_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tdev->num_rx_queues = rxqs;",
                        "\tdev->real_num_rx_queues = rxqs;",
                        "\tif (netif_alloc_rx_queues(dev))",
                        "\t\tgoto free_all;",
                        "",
                        "\tstrcpy(dev->name, name);",
                        "\tdev->name_assign_type = name_assign_type;",
                        "\tdev->group = INIT_NETDEV_GROUP;",
                        "\tif (!dev->ethtool_ops)",
                        "\t\tdev->ethtool_ops = &default_ethtool_ops;",
                        "",
                        "\tnf_hook_ingress_init(dev);",
                        "",
                        "\treturn dev;",
                        "",
                        "free_all:",
                        "\tfree_netdev(dev);",
                        "\treturn NULL;",
                        "",
                        "free_pcpu:",
                        "\tfree_percpu(dev->pcpu_refcnt);",
                        "free_dev:",
                        "\tnetdev_freemem(dev);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 10404,
                    "highlight": 10505
                }
            ],
            "ins_idx": 32626,
            "addr": "0xffffffff819f6efa"
        }
    },
    "ins": {
        "1385": {
            "name": "mov rax, qword ptr [rax]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x0",
            "call_idx": 74747,
            "inputs": [
                137420,
                137421
            ],
            "outputs": [
                137422
            ]
        },
        "2795": {
            "name": "mov rax, qword ptr [r12 + 0x1e0]",
            "desc": "Heap Use Before Initialization\nSource of base address MEMALLOC 0x0",
            "call_idx": 74746,
            "inputs": [
                137417,
                137418
            ],
            "outputs": [
                137419
            ]
        },
        "4350": {
            "name": "ret ",
            "desc": "Source of base address MEMALLOC 0x0",
            "call_idx": 47941,
            "inputs": [],
            "outputs": [
                87995
            ]
        },
        "4349": {
            "name": "pop r12",
            "desc": "",
            "call_idx": 74745,
            "inputs": [
                137414,
                137415
            ],
            "outputs": [
                137416
            ]
        },
        "6152": {
            "name": "push r12",
            "desc": "",
            "call_idx": 74743,
            "inputs": [
                137410,
                137411
            ],
            "outputs": [
                137412
            ]
        },
        "13114": {
            "name": "mov r12, rdi",
            "desc": "",
            "call_idx": 74735,
            "inputs": [
                137399
            ],
            "outputs": [
                137400
            ]
        },
        "14804": {
            "name": "mov rdi, rax",
            "desc": "",
            "call_idx": 74734,
            "inputs": [
                137397
            ],
            "outputs": [
                137398
            ]
        },
        "16369": {
            "name": "mov rax, qword ptr [rax + 0x20]",
            "desc": "",
            "call_idx": 74733,
            "inputs": [
                137394,
                137395
            ],
            "outputs": [
                137396
            ]
        },
        "17610": {
            "name": "mov qword ptr [rax + 0x20], rbp",
            "desc": "",
            "call_idx": 49404,
            "inputs": [
                90498,
                90499
            ],
            "outputs": [
                90500
            ]
        },
        "17609": {
            "name": "mov rax, r12",
            "desc": "",
            "call_idx": 74732,
            "inputs": [
                137392
            ],
            "outputs": [
                137393
            ]
        },
        "21374": {
            "name": "mov rbp, rdi",
            "desc": "",
            "call_idx": 49375,
            "inputs": [
                90458
            ],
            "outputs": [
                90459
            ]
        },
        "18983": {
            "name": "mov r12, qword ptr [rdx + rax*8]",
            "desc": "",
            "call_idx": 74731,
            "inputs": [
                137388,
                137389,
                137390
            ],
            "outputs": [
                137391
            ]
        },
        "22450": {
            "name": "mov rdi, r12",
            "desc": "",
            "call_idx": 49372,
            "inputs": [
                90453
            ],
            "outputs": [
                90454
            ]
        },
        "20199": {
            "name": "mov qword ptr [rax], rbx",
            "desc": "",
            "call_idx": 52604,
            "inputs": [
                96547,
                96548
            ],
            "outputs": [
                96549
            ]
        },
        "25457": {
            "name": "mov r12, rax",
            "desc": "",
            "call_idx": 48017,
            "inputs": [
                88159
            ],
            "outputs": [
                88160
            ]
        },
        "21372": {
            "name": "lea rax, qword ptr [rdx + rax*8]",
            "desc": "",
            "call_idx": 52603,
            "inputs": [
                96544,
                96545
            ],
            "outputs": [
                96546
            ]
        },
        "26290": {
            "name": "mov rax, rbp",
            "desc": "",
            "call_idx": 48014,
            "inputs": [
                88153
            ],
            "outputs": [
                88154
            ]
        },
        "22448": {
            "name": "shr eax, 0x18",
            "desc": "",
            "call_idx": 52602,
            "inputs": [
                96542
            ],
            "outputs": [
                96543
            ]
        },
        "20095": {
            "name": "and rbp, 0xffffffffffffffe0",
            "desc": "",
            "call_idx": 47943,
            "inputs": [
                87998
            ],
            "outputs": [
                87999
            ]
        },
        "23518": {
            "name": "imul eax, eax, 0x61c88647",
            "desc": "",
            "call_idx": 52601,
            "inputs": [
                96540
            ],
            "outputs": [
                96541
            ]
        },
        "21269": {
            "name": "lea rbp, qword ptr [rax + 0x1f]",
            "desc": "",
            "call_idx": 47942,
            "inputs": [
                87996
            ],
            "outputs": [
                87997
            ]
        },
        "24596": {
            "name": "mov eax, edi",
            "desc": "",
            "call_idx": 52598,
            "inputs": [
                96534
            ],
            "outputs": [
                96535
            ]
        },
        "25588": {
            "name": "shr rdi, 0x20",
            "desc": "",
            "call_idx": 52597,
            "inputs": [
                96532
            ],
            "outputs": [
                96533
            ]
        },
        "26427": {
            "name": "imul rdi, rax",
            "desc": "",
            "call_idx": 52596,
            "inputs": [
                96529,
                96530
            ],
            "outputs": [
                96531
            ]
        },
        "27155": {
            "name": "xor rdi, rax",
            "desc": "",
            "call_idx": 52594,
            "inputs": [
                96525,
                96526
            ],
            "outputs": [
                96527
            ]
        },
        "27920": {
            "name": "imul rax, r8",
            "desc": "",
            "call_idx": 52593,
            "inputs": [
                96522,
                96523
            ],
            "outputs": [
                96524
            ]
        },
        "28705": {
            "name": "xor rax, r8",
            "desc": "",
            "call_idx": 52591,
            "inputs": [
                96518,
                96519
            ],
            "outputs": [
                96520
            ]
        },
        "29471": {
            "name": "and rax, rdx",
            "desc": "",
            "call_idx": 52590,
            "inputs": [
                96515,
                96516
            ],
            "outputs": [
                96517
            ]
        },
        "30246": {
            "name": "mov rax, qword ptr [rsi]",
            "desc": "Heap Use Before Initialization\nSource of base address MEMALLOC 0x0",
            "call_idx": 52585,
            "inputs": [
                96504,
                96505
            ],
            "outputs": [
                96506
            ]
        },
        "31052": {
            "name": "mov rsi, r12",
            "desc": "",
            "call_idx": 52580,
            "inputs": [
                96495
            ],
            "outputs": [
                96496
            ]
        },
        "31053": {
            "name": "mov byte ptr [r8 + rax], dl",
            "desc": "",
            "call_idx": 48013,
            "inputs": [
                88149,
                88150,
                88151
            ],
            "outputs": [
                88152
            ]
        },
        "31842": {
            "name": "mov r12, qword ptr [rsi + 0x28]",
            "desc": "",
            "call_idx": 52569,
            "inputs": [
                96473,
                96474
            ],
            "outputs": [
                96475
            ]
        },
        "31844": {
            "name": "mov r8, rdi",
            "desc": "",
            "call_idx": 47996,
            "inputs": [
                88096
            ],
            "outputs": [
                88097
            ]
        },
        "32624": {
            "name": "mov qword ptr [rax + 0x28], rbp",
            "desc": "",
            "call_idx": 49405,
            "inputs": [
                90501,
                90502
            ],
            "outputs": [
                90503
            ]
        },
        "32626": {
            "name": "mov rdi, rbp",
            "desc": "",
            "call_idx": 47994,
            "inputs": [
                88094
            ],
            "outputs": [
                88095
            ]
        }
    },
    "data": {
        "137420": {
            "name": "RAX",
            "ins_idx": 1385,
            "value": "0x0",
            "sources": []
        },
        "137421": {
            "name": "[0x0]",
            "ins_idx": 1385,
            "value": "0x0",
            "sources": []
        },
        "137422": {
            "name": "RAX",
            "ins_idx": 1385,
            "value": "0x0",
            "sources": []
        },
        "137417": {
            "name": "R12",
            "ins_idx": 2795,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "137418": {
            "name": "[0xffff888102c741e0]",
            "ins_idx": 2795,
            "value": "0x0",
            "sources": []
        },
        "137419": {
            "name": "RAX",
            "ins_idx": 2795,
            "value": "0x0",
            "sources": [
                137420
            ]
        },
        "87995": {
            "name": "RAX",
            "ins_idx": 4350,
            "value": "0xffff888102c74000",
            "sources": [
                87996
            ]
        },
        "137414": {
            "name": "RSP",
            "ins_idx": 4349,
            "value": "0xffffc900002e7e00",
            "sources": []
        },
        "137415": {
            "name": "[0xffffc900002e7e00]",
            "ins_idx": 4349,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "137416": {
            "name": "R12",
            "ins_idx": 4349,
            "value": "0xffff888102c74000",
            "sources": [
                137417
            ]
        },
        "137410": {
            "name": "RSP",
            "ins_idx": 6152,
            "value": "0xffffc900002e7e08",
            "sources": []
        },
        "137411": {
            "name": "R12",
            "ins_idx": 6152,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "137412": {
            "name": "[0xffffc900002e7e00]",
            "ins_idx": 6152,
            "value": "0xffff888102c74000",
            "sources": [
                137415
            ]
        },
        "137399": {
            "name": "RDI",
            "ins_idx": 13114,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "137400": {
            "name": "R12",
            "ins_idx": 13114,
            "value": "0xffff888102c74000",
            "sources": [
                137411
            ]
        },
        "137397": {
            "name": "RAX",
            "ins_idx": 14804,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "137398": {
            "name": "RDI",
            "ins_idx": 14804,
            "value": "0xffff888102c74000",
            "sources": [
                137399
            ]
        },
        "137394": {
            "name": "RAX",
            "ins_idx": 16369,
            "value": "0xffff888102cefb40",
            "sources": []
        },
        "137395": {
            "name": "[0xffff888102cefb60]",
            "ins_idx": 16369,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "137396": {
            "name": "RAX",
            "ins_idx": 16369,
            "value": "0xffff888102c74000",
            "sources": [
                137397
            ]
        },
        "90498": {
            "name": "RAX",
            "ins_idx": 17610,
            "value": "0xffff888102cefb40",
            "sources": []
        },
        "90499": {
            "name": "RBP",
            "ins_idx": 17610,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "90500": {
            "name": "[0xffff888102cefb60]",
            "ins_idx": 17610,
            "value": "0xffff888102c74000",
            "sources": [
                137395
            ]
        },
        "137392": {
            "name": "R12",
            "ins_idx": 17609,
            "value": "0xffff888102cefb40",
            "sources": []
        },
        "137393": {
            "name": "RAX",
            "ins_idx": 17609,
            "value": "0xffff888102cefb40",
            "sources": [
                137394
            ]
        },
        "90458": {
            "name": "RDI",
            "ins_idx": 21374,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "90459": {
            "name": "RBP",
            "ins_idx": 21374,
            "value": "0xffff888102c74000",
            "sources": [
                90499,
                90502
            ]
        },
        "137388": {
            "name": "RAX",
            "ins_idx": 18983,
            "value": "0xcc",
            "sources": []
        },
        "137389": {
            "name": "RDX",
            "ins_idx": 18983,
            "value": "0xffff888102db0000",
            "sources": []
        },
        "137390": {
            "name": "[0xffff888102db0660]",
            "ins_idx": 18983,
            "value": "0xffff888102cefb40",
            "sources": []
        },
        "137391": {
            "name": "R12",
            "ins_idx": 18983,
            "value": "0xffff888102cefb40",
            "sources": [
                137392
            ]
        },
        "90453": {
            "name": "R12",
            "ins_idx": 22450,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "90454": {
            "name": "RDI",
            "ins_idx": 22450,
            "value": "0xffff888102c74000",
            "sources": [
                90458
            ]
        },
        "96547": {
            "name": "RBX",
            "ins_idx": 20199,
            "value": "0xffff888102cefb40",
            "sources": []
        },
        "96548": {
            "name": "RAX",
            "ins_idx": 20199,
            "value": "0xffff888102db0660",
            "sources": []
        },
        "96549": {
            "name": "[0xffff888102db0660]",
            "ins_idx": 20199,
            "value": "0xffff888102cefb40",
            "sources": [
                137390
            ]
        },
        "88159": {
            "name": "RAX",
            "ins_idx": 25457,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "88160": {
            "name": "R12",
            "ins_idx": 25457,
            "value": "0xffff888102c74000",
            "sources": [
                90453
            ]
        },
        "96544": {
            "name": "RAX",
            "ins_idx": 21372,
            "value": "0xcc",
            "sources": []
        },
        "96545": {
            "name": "RDX",
            "ins_idx": 21372,
            "value": "0xffff888102db0000",
            "sources": []
        },
        "96546": {
            "name": "RAX",
            "ins_idx": 21372,
            "value": "0xffff888102db0660",
            "sources": [
                96548
            ]
        },
        "88153": {
            "name": "RBP",
            "ins_idx": 26290,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "88154": {
            "name": "RAX",
            "ins_idx": 26290,
            "value": "0xffff888102c74000",
            "sources": [
                88159
            ]
        },
        "96542": {
            "name": "RAX",
            "ins_idx": 22448,
            "value": "0xcc37ea5e",
            "sources": []
        },
        "96543": {
            "name": "RAX",
            "ins_idx": 22448,
            "value": "0xcc",
            "sources": [
                96544
            ]
        },
        "87998": {
            "name": "RBP",
            "ins_idx": 20095,
            "value": "0xffff888102c7401f",
            "sources": []
        },
        "87999": {
            "name": "RBP",
            "ins_idx": 20095,
            "value": "0xffff888102c74000",
            "sources": [
                88153,
                88094
            ]
        },
        "96540": {
            "name": "RAX",
            "ins_idx": 23518,
            "value": "0xba0e8bb2",
            "sources": []
        },
        "96541": {
            "name": "RAX",
            "ins_idx": 23518,
            "value": "0xcc37ea5e",
            "sources": [
                96542
            ]
        },
        "87996": {
            "name": "RAX",
            "ins_idx": 21269,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "87997": {
            "name": "RBP",
            "ins_idx": 21269,
            "value": "0xffff888102c7401f",
            "sources": [
                87998
            ]
        },
        "96534": {
            "name": "RDI",
            "ins_idx": 24596,
            "value": "0xba0e8bb2",
            "sources": []
        },
        "96535": {
            "name": "RAX",
            "ins_idx": 24596,
            "value": "0xba0e8bb2",
            "sources": [
                96540
            ]
        },
        "96532": {
            "name": "RDI",
            "ins_idx": 25588,
            "value": "0xba0e8bb22f9cc0ff",
            "sources": []
        },
        "96533": {
            "name": "RDI",
            "ins_idx": 25588,
            "value": "0xba0e8bb2",
            "sources": [
                96534
            ]
        },
        "96529": {
            "name": "RAX",
            "ins_idx": 26427,
            "value": "0x61c8864680b583eb",
            "sources": []
        },
        "96530": {
            "name": "RDI",
            "ins_idx": 26427,
            "value": "0x2460a4025f2a763d",
            "sources": []
        },
        "96531": {
            "name": "RDI",
            "ins_idx": 26427,
            "value": "0xba0e8bb22f9cc0ff",
            "sources": [
                96532
            ]
        },
        "96525": {
            "name": "RDI",
            "ins_idx": 27155,
            "value": "0xffff888101380000",
            "sources": []
        },
        "96526": {
            "name": "RAX",
            "ins_idx": 27155,
            "value": "0xdb9f2c835e12763d",
            "sources": []
        },
        "96527": {
            "name": "RDI",
            "ins_idx": 27155,
            "value": "0x2460a4025f2a763d",
            "sources": [
                96530
            ]
        },
        "96522": {
            "name": "R8",
            "ins_idx": 27920,
            "value": "0x61c8864680b583eb",
            "sources": []
        },
        "96523": {
            "name": "RAX",
            "ins_idx": 27920,
            "value": "0x316e616c77",
            "sources": []
        },
        "96524": {
            "name": "RAX",
            "ins_idx": 27920,
            "value": "0xdb9f2c835e12763d",
            "sources": [
                96526
            ]
        },
        "96518": {
            "name": "RAX",
            "ins_idx": 28705,
            "value": "0x316e616c77",
            "sources": []
        },
        "96519": {
            "name": "R8",
            "ins_idx": 28705,
            "value": "0x0",
            "sources": []
        },
        "96520": {
            "name": "RAX",
            "ins_idx": 28705,
            "value": "0x316e616c77",
            "sources": [
                96523
            ]
        },
        "96515": {
            "name": "RAX",
            "ins_idx": 29471,
            "value": "0x316e616c77",
            "sources": []
        },
        "96516": {
            "name": "RDX",
            "ins_idx": 29471,
            "value": "0xffffffffff",
            "sources": []
        },
        "96517": {
            "name": "RAX",
            "ins_idx": 29471,
            "value": "0x316e616c77",
            "sources": [
                96518
            ]
        },
        "96504": {
            "name": "RSI",
            "ins_idx": 30246,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "96505": {
            "name": "[0xffff888102c74000]",
            "ins_idx": 30246,
            "value": "0x316e616c77",
            "sources": []
        },
        "96506": {
            "name": "RAX",
            "ins_idx": 30246,
            "value": "0x316e616c77",
            "sources": [
                96515
            ]
        },
        "96495": {
            "name": "R12",
            "ins_idx": 31052,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "96496": {
            "name": "RSI",
            "ins_idx": 31052,
            "value": "0xffff888102c74000",
            "sources": [
                96504
            ]
        },
        "88149": {
            "name": "RAX",
            "ins_idx": 31053,
            "value": "0x6",
            "sources": []
        },
        "88150": {
            "name": "R8",
            "ins_idx": 31053,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "88151": {
            "name": "RDX",
            "ins_idx": 31053,
            "value": "0x0",
            "sources": []
        },
        "88152": {
            "name": "[0xffff888102c74006]",
            "ins_idx": 31053,
            "value": "0x0",
            "sources": []
        },
        "96473": {
            "name": "RSI",
            "ins_idx": 31842,
            "value": "0xffff888102cefb40",
            "sources": []
        },
        "96474": {
            "name": "[0xffff888102cefb68]",
            "ins_idx": 31842,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "96475": {
            "name": "R12",
            "ins_idx": 31842,
            "value": "0xffff888102c74000",
            "sources": [
                96495
            ]
        },
        "88096": {
            "name": "RDI",
            "ins_idx": 31844,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "88097": {
            "name": "R8",
            "ins_idx": 31844,
            "value": "0xffff888102c74000",
            "sources": [
                88150
            ]
        },
        "90501": {
            "name": "RAX",
            "ins_idx": 32624,
            "value": "0xffff888102cefb40",
            "sources": []
        },
        "90502": {
            "name": "RBP",
            "ins_idx": 32624,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "90503": {
            "name": "[0xffff888102cefb68]",
            "ins_idx": 32624,
            "value": "0xffff888102c74000",
            "sources": [
                96474
            ]
        },
        "88094": {
            "name": "RBP",
            "ins_idx": 32626,
            "value": "0xffff888102c74000",
            "sources": []
        },
        "88095": {
            "name": "RDI",
            "ins_idx": 32626,
            "value": "0xffff888102c74000",
            "sources": [
                88096
            ]
        }
    },
    "chain": {
        "1385": [
            2795
        ],
        "2795": [
            4350,
            4349
        ],
        "4349": [
            6152
        ],
        "6152": [
            13114
        ],
        "13114": [
            14804
        ],
        "14804": [
            16369
        ],
        "16369": [
            17610,
            17609
        ],
        "17610": [
            21374
        ],
        "17609": [
            18983
        ],
        "21374": [
            22450
        ],
        "18983": [
            20199
        ],
        "22450": [
            25457
        ],
        "20199": [
            21372
        ],
        "25457": [
            26290
        ],
        "21372": [
            22448
        ],
        "26290": [
            20095
        ],
        "22448": [
            23518
        ],
        "20095": [
            21269
        ],
        "23518": [
            24596
        ],
        "21269": [
            4350
        ],
        "24596": [
            25588
        ],
        "25588": [
            26427
        ],
        "26427": [
            27155
        ],
        "27155": [
            27920
        ],
        "27920": [
            28705
        ],
        "28705": [
            29471
        ],
        "29471": [
            30246
        ],
        "30246": [
            31052,
            31053
        ],
        "31052": [
            31842
        ],
        "31053": [
            31844
        ],
        "31842": [
            32624
        ],
        "31844": [
            32626
        ],
        "32624": [
            21374
        ],
        "32626": [
            20095
        ]
    }
}