{
    "report": "https://syzkaller.appspot.com/bug?id=2e1c26930cc57edee80734ae71bf020493b32306",
    "title": "KASAN: slab-out-of-bounds Read in fl6_update_dst",
    "call": {
        "883": {
            "name": "+0x98",
            "parent_idx": 877,
            "source_line": [
                {
                    "file": "net/ipv6/exthdrs.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/exthdrs.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n1356",
                    "code": [
                        "/**",
                        " * fl6_update_dst - update flowi destination address with info given",
                        " *                  by srcrt option, if any.",
                        " *",
                        " * @fl6: flowi6 for which daddr is to be updated",
                        " * @opt: struct ipv6_txoptions in which to look for srcrt opt",
                        " * @orig: copy of original daddr address if modified",
                        " *",
                        " * Returns NULL if no txoptions or no srcrt, otherwise returns orig",
                        " * and initial value of fl6->daddr set in orig",
                        " */",
                        "struct in6_addr *fl6_update_dst(struct flowi6 *fl6,",
                        "\t\t\t\tconst struct ipv6_txoptions *opt,",
                        "\t\t\t\tstruct in6_addr *orig)",
                        "{",
                        "\tif (!opt || !opt->srcrt)",
                        "\t\treturn NULL;",
                        "",
                        "\t*orig = fl6->daddr;",
                        "",
                        "\tswitch (opt->srcrt->type) {",
                        "\tcase IPV6_SRCRT_TYPE_0:",
                        "\tcase IPV6_SRCRT_STRICT:",
                        "\tcase IPV6_SRCRT_TYPE_2:",
                        "\t\tfl6->daddr = *((struct rt0_hdr *)opt->srcrt)->addr;",
                        "\t\tbreak;",
                        "\tcase IPV6_SRCRT_TYPE_4:",
                        "\t{",
                        "\t\tstruct ipv6_sr_hdr *srh = (struct ipv6_sr_hdr *)opt->srcrt;",
                        "",
                        "\t\tfl6->daddr = srh->segments[srh->segments_left];",
                        "\t\tbreak;",
                        "\t}",
                        "\tdefault:",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\treturn orig;",
                        "}"
                    ],
                    "start": 1326,
                    "highlight": 1356
                }
            ],
            "ins_idx": 1,
            "addr": "0xffffffff820a78e8"
        },
        "877": {
            "name": "fl6_update_dst",
            "parent_idx": 869,
            "source_line": [
                {
                    "file": "net/sctp/ipv6.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/ipv6.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n276",
                    "code": [
                        "/* Returns the dst cache entry for the given source and destination ip",
                        " * addresses.",
                        " */",
                        "static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,",
                        "\t\t\t    struct flowi *fl, struct sock *sk)",
                        "{",
                        "\tstruct sctp_association *asoc = t->asoc;",
                        "\tstruct dst_entry *dst = NULL;",
                        "\tstruct flowi _fl;",
                        "\tstruct flowi6 *fl6 = &_fl.u.ip6;",
                        "\tstruct sctp_bind_addr *bp;",
                        "\tstruct ipv6_pinfo *np = inet6_sk(sk);",
                        "\tstruct sctp_sockaddr_entry *laddr;",
                        "\tunion sctp_addr *daddr = &t->ipaddr;",
                        "\tunion sctp_addr dst_saddr;",
                        "\tstruct in6_addr *final_p, final;",
                        "\tenum sctp_scope scope;",
                        "\t__u8 matchlen = 0;",
                        "",
                        "\tmemset(&_fl, 0, sizeof(_fl));",
                        "\tfl6->daddr = daddr->v6.sin6_addr;",
                        "\tfl6->fl6_dport = daddr->v6.sin6_port;",
                        "\tfl6->flowi6_proto = IPPROTO_SCTP;",
                        "\tif (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)",
                        "\t\tfl6->flowi6_oif = daddr->v6.sin6_scope_id;",
                        "\telse if (asoc)",
                        "\t\tfl6->flowi6_oif = asoc->base.sk->sk_bound_dev_if;",
                        "\tif (t->flowlabel & SCTP_FLOWLABEL_SET_MASK)",
                        "\t\tfl6->flowlabel = htonl(t->flowlabel & SCTP_FLOWLABEL_VAL_MASK);",
                        "",
                        "\tif (np->sndflow && (fl6->flowlabel & IPV6_FLOWLABEL_MASK)) {",
                        "\t\tstruct ip6_flowlabel *flowlabel;",
                        "",
                        "\t\tflowlabel = fl6_sock_lookup(sk, fl6->flowlabel);",
                        "\t\tif (IS_ERR(flowlabel))",
                        "\t\t\tgoto out;",
                        "\t\tfl6_sock_release(flowlabel);",
                        "\t}",
                        "",
                        "\tpr_debug(\"%s: dst=%pI6 \", __func__, &fl6->daddr);",
                        "",
                        "\tif (asoc)",
                        "\t\tfl6->fl6_sport = htons(asoc->base.bind_addr.port);",
                        "",
                        "\tif (saddr) {",
                        "\t\tfl6->saddr = saddr->v6.sin6_addr;",
                        "\t\tif (!fl6->fl6_sport)",
                        "\t\t\tfl6->fl6_sport = saddr->v6.sin6_port;",
                        "",
                        "\t\tpr_debug(\"src=%pI6 - \", &fl6->saddr);",
                        "\t}",
                        "",
                        "\trcu_read_lock();",
                        "\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);",
                        "\trcu_read_unlock();",
                        "",
                        "\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, fl6, final_p);",
                        "\tif (!asoc || saddr) {",
                        "\t\tt->dst = dst;",
                        "\t\tmemcpy(fl, &_fl, sizeof(_fl));",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tbp = &asoc->base.bind_addr;",
                        "\tscope = sctp_scope(daddr);",
                        "\t/* ip6_dst_lookup has filled in the fl6->saddr for us.  Check",
                        "\t * to see if we can use it.",
                        "\t */",
                        "\tif (!IS_ERR(dst)) {",
                        "\t\t/* Walk through the bind address list and look for a bind",
                        "\t\t * address that matches the source address of the returned dst.",
                        "\t\t */",
                        "\t\tsctp_v6_to_addr(&dst_saddr, &fl6->saddr, htons(bp->port));",
                        "\t\trcu_read_lock();",
                        "\t\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {",
                        "\t\t\tif (!laddr->valid || laddr->state == SCTP_ADDR_DEL ||",
                        "\t\t\t    (laddr->state != SCTP_ADDR_SRC &&",
                        "\t\t\t     !asoc->src_out_of_asoc_ok))",
                        "\t\t\t\tcontinue;",
                        "",
                        "\t\t\t/* Do not compare against v4 addrs */",
                        "\t\t\tif ((laddr->a.sa.sa_family == AF_INET6) &&",
                        "\t\t\t    (sctp_v6_cmp_addr(&dst_saddr, &laddr->a))) {",
                        "\t\t\t\trcu_read_unlock();",
                        "\t\t\t\tt->dst = dst;",
                        "\t\t\t\tmemcpy(fl, &_fl, sizeof(_fl));",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\trcu_read_unlock();",
                        "\t\t/* None of the bound addresses match the source address of the",
                        "\t\t * dst. So release it.",
                        "\t\t */",
                        "\t\tdst_release(dst);",
                        "\t\tdst = NULL;",
                        "\t}",
                        "",
                        "\t/* Walk through the bind address list and try to get the",
                        "\t * best source address for a given destination.",
                        "\t */",
                        "\trcu_read_lock();",
                        "\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {",
                        "\t\tstruct dst_entry *bdst;",
                        "\t\t__u8 bmatchlen;",
                        "",
                        "\t\tif (!laddr->valid ||",
                        "\t\t    laddr->state != SCTP_ADDR_SRC ||",
                        "\t\t    laddr->a.sa.sa_family != AF_INET6 ||",
                        "\t\t    scope > sctp_scope(&laddr->a))",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tfl6->saddr = laddr->a.v6.sin6_addr;",
                        "\t\tfl6->fl6_sport = laddr->a.v6.sin6_port;",
                        "\t\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);",
                        "\t\tbdst = ip6_dst_lookup_flow(sock_net(sk), sk, fl6, final_p);",
                        "",
                        "\t\tif (IS_ERR(bdst))",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tif (ipv6_chk_addr(dev_net(bdst->dev),",
                        "\t\t\t\t  &laddr->a.v6.sin6_addr, bdst->dev, 1)) {",
                        "\t\t\tif (!IS_ERR_OR_NULL(dst))",
                        "\t\t\t\tdst_release(dst);",
                        "\t\t\tdst = bdst;",
                        "\t\t\tt->dst = dst;",
                        "\t\t\tmemcpy(fl, &_fl, sizeof(_fl));",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\tbmatchlen = sctp_v6_addr_match_len(daddr, &laddr->a);",
                        "\t\tif (matchlen > bmatchlen) {",
                        "\t\t\tdst_release(bdst);",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "",
                        "\t\tif (!IS_ERR_OR_NULL(dst))",
                        "\t\t\tdst_release(dst);",
                        "\t\tdst = bdst;",
                        "\t\tmatchlen = bmatchlen;",
                        "\t\tt->dst = dst;",
                        "\t\tmemcpy(fl, &_fl, sizeof(_fl));",
                        "\t}",
                        "\trcu_read_unlock();",
                        "",
                        "out:",
                        "\tif (!IS_ERR_OR_NULL(dst)) {",
                        "\t\tstruct rt6_info *rt;",
                        "",
                        "\t\trt = (struct rt6_info *)dst;",
                        "\t\tt->dst_cookie = rt6_get_cookie(rt);",
                        "\t\tpr_debug(\"rt6_dst:%pI6/%d rt6_src:%pI6\\n\",",
                        "\t\t\t &rt->rt6i_dst.addr, rt->rt6i_dst.plen,",
                        "\t\t\t &fl->u.ip6.saddr);",
                        "\t} else {",
                        "\t\tt->dst = NULL;",
                        "\t\tpr_debug(\"no route\\n\");",
                        "\t}",
                        "}"
                    ],
                    "start": 223,
                    "highlight": 276
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8218d7df"
        },
        "869": {
            "name": "sctp_v6_get_dst(indirect)",
            "parent_idx": 866,
            "source_line": [
                {
                    "file": "net/sctp/transport.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/transport.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n297",
                    "code": [
                        "/* Caches the dst entry and source address for a transport's destination",
                        " * address.",
                        " */",
                        "void sctp_transport_route(struct sctp_transport *transport,",
                        "\t\t\t  union sctp_addr *saddr, struct sctp_sock *opt)",
                        "{",
                        "\tstruct sctp_association *asoc = transport->asoc;",
                        "\tstruct sctp_af *af = transport->af_specific;",
                        "",
                        "\tsctp_transport_dst_release(transport);",
                        "\taf->get_dst(transport, saddr, &transport->fl, sctp_opt2sk(opt));",
                        "",
                        "\tif (saddr)",
                        "\t\tmemcpy(&transport->saddr, saddr, sizeof(union sctp_addr));",
                        "\telse",
                        "\t\taf->get_saddr(opt, transport, &transport->fl);",
                        "",
                        "\tsctp_transport_pmtu(transport, sctp_opt2sk(opt));",
                        "",
                        "\t/* Initialize sk->sk_rcv_saddr, if the transport is the",
                        "\t * association's active path for getsockname().",
                        "\t */",
                        "\tif (transport->dst && asoc &&",
                        "\t    (!asoc->peer.primary_path || transport == asoc->peer.active_path))",
                        "\t\topt->pf->to_sk_saddr(&transport->saddr, asoc->base.sk);",
                        "}"
                    ],
                    "start": 287,
                    "highlight": 297
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8214dd26"
        },
        "866": {
            "name": "sctp_transport_route",
            "parent_idx": 859,
            "source_line": [
                {
                    "file": "net/sctp/associola.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/associola.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n659",
                    "code": [
                        "/* Add a transport address to an association.  */",
                        "struct sctp_transport *sctp_assoc_add_peer(struct sctp_association *asoc,",
                        "\t\t\t\t\t   const union sctp_addr *addr,",
                        "\t\t\t\t\t   const gfp_t gfp,",
                        "\t\t\t\t\t   const int peer_state)",
                        "{",
                        "\tstruct sctp_transport *peer;",
                        "\tstruct sctp_sock *sp;",
                        "\tunsigned short port;",
                        "",
                        "\tsp = sctp_sk(asoc->base.sk);",
                        "",
                        "\t/* AF_INET and AF_INET6 share common port field. */",
                        "\tport = ntohs(addr->v4.sin_port);",
                        "",
                        "\tpr_debug(\"%s: association:%p addr:%pISpc state:%d\\n\", __func__,",
                        "\t\t asoc, &addr->sa, peer_state);",
                        "",
                        "\t/* Set the port if it has not been set yet.  */",
                        "\tif (0 == asoc->peer.port)",
                        "\t\tasoc->peer.port = port;",
                        "",
                        "\t/* Check to see if this is a duplicate. */",
                        "\tpeer = sctp_assoc_lookup_paddr(asoc, addr);",
                        "\tif (peer) {",
                        "\t\t/* An UNKNOWN state is only set on transports added by",
                        "\t\t * user in sctp_connectx() call.  Such transports should be",
                        "\t\t * considered CONFIRMED per RFC 4960, Section 5.4.",
                        "\t\t */",
                        "\t\tif (peer->state == SCTP_UNKNOWN) {",
                        "\t\t\tpeer->state = SCTP_ACTIVE;",
                        "\t\t}",
                        "\t\treturn peer;",
                        "\t}",
                        "",
                        "\tpeer = sctp_transport_new(asoc->base.net, addr, gfp);",
                        "\tif (!peer)",
                        "\t\treturn NULL;",
                        "",
                        "\tsctp_transport_set_owner(peer, asoc);",
                        "",
                        "\t/* Initialize the peer's heartbeat interval based on the",
                        "\t * association configured value.",
                        "\t */",
                        "\tpeer->hbinterval = asoc->hbinterval;",
                        "",
                        "\t/* Set the path max_retrans.  */",
                        "\tpeer->pathmaxrxt = asoc->pathmaxrxt;",
                        "",
                        "\t/* And the partial failure retrans threshold */",
                        "\tpeer->pf_retrans = asoc->pf_retrans;",
                        "\t/* And the primary path switchover retrans threshold */",
                        "\tpeer->ps_retrans = asoc->ps_retrans;",
                        "",
                        "\t/* Initialize the peer's SACK delay timeout based on the",
                        "\t * association configured value.",
                        "\t */",
                        "\tpeer->sackdelay = asoc->sackdelay;",
                        "\tpeer->sackfreq = asoc->sackfreq;",
                        "",
                        "\tif (addr->sa.sa_family == AF_INET6) {",
                        "\t\t__be32 info = addr->v6.sin6_flowinfo;",
                        "",
                        "\t\tif (info) {",
                        "\t\t\tpeer->flowlabel = ntohl(info & IPV6_FLOWLABEL_MASK);",
                        "\t\t\tpeer->flowlabel |= SCTP_FLOWLABEL_SET_MASK;",
                        "\t\t} else {",
                        "\t\t\tpeer->flowlabel = asoc->flowlabel;",
                        "\t\t}",
                        "\t}",
                        "\tpeer->dscp = asoc->dscp;",
                        "",
                        "\t/* Enable/disable heartbeat, SACK delay, and path MTU discovery",
                        "\t * based on association setting.",
                        "\t */",
                        "\tpeer->param_flags = asoc->param_flags;",
                        "",
                        "\t/* Initialize the pmtu of the transport. */",
                        "\tsctp_transport_route(peer, NULL, sp);",
                        "",
                        "\t/* If this is the first transport addr on this association,",
                        "\t * initialize the association PMTU to the peer's PMTU.",
                        "\t * If not and the current association PMTU is higher than the new",
                        "\t * peer's PMTU, reset the association PMTU to the new peer's PMTU.",
                        "\t */",
                        "\tsctp_assoc_set_pmtu(asoc, asoc->pathmtu ?",
                        "\t\t\t\t  min_t(int, peer->pathmtu, asoc->pathmtu) :",
                        "\t\t\t\t  peer->pathmtu);",
                        "",
                        "\tpeer->pmtu_pending = 0;",
                        "",
                        "\t/* The asoc->peer.port might not be meaningful yet, but",
                        "\t * initialize the packet structure anyway.",
                        "\t */",
                        "\tsctp_packet_init(&peer->packet, peer, asoc->base.bind_addr.port,",
                        "\t\t\t asoc->peer.port);",
                        "",
                        "\t/* 7.2.1 Slow-Start",
                        "\t *",
                        "\t * o The initial cwnd before DATA transmission or after a sufficiently",
                        "\t *   long idle period MUST be set to",
                        "\t *      min(4*MTU, max(2*MTU, 4380 bytes))",
                        "\t *",
                        "\t * o The initial value of ssthresh MAY be arbitrarily high",
                        "\t *   (for example, implementations MAY use the size of the",
                        "\t *   receiver advertised window).",
                        "\t */",
                        "\tpeer->cwnd = min(4*asoc->pathmtu, max_t(__u32, 2*asoc->pathmtu, 4380));",
                        "",
                        "\t/* At this point, we may not have the receiver's advertised window,",
                        "\t * so initialize ssthresh to the default value and it will be set",
                        "\t * later when we process the INIT.",
                        "\t */",
                        "\tpeer->ssthresh = SCTP_DEFAULT_MAXWINDOW;",
                        "",
                        "\tpeer->partial_bytes_acked = 0;",
                        "\tpeer->flight_size = 0;",
                        "\tpeer->burst_limited = 0;",
                        "",
                        "\t/* Set the transport's RTO.initial value */",
                        "\tpeer->rto = asoc->rto_initial;",
                        "\tsctp_max_rto(asoc, peer);",
                        "",
                        "\t/* Set the peer's active state. */",
                        "\tpeer->state = peer_state;",
                        "",
                        "\t/* Add this peer into the transport hashtable */",
                        "\tif (sctp_hash_transport(peer)) {",
                        "\t\tsctp_transport_free(peer);",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\t/* Attach the remote transport to our asoc.  */",
                        "\tlist_add_tail_rcu(&peer->transports, &asoc->peer.transport_addr_list);",
                        "\tasoc->peer.transport_count++;",
                        "",
                        "\tsctp_ulpevent_nofity_peer_addr_change(peer, SCTP_ADDR_ADDED, 0);",
                        "",
                        "\t/* If we do not yet have a primary path, set one.  */",
                        "\tif (!asoc->peer.primary_path) {",
                        "\t\tsctp_assoc_set_primary(asoc, peer);",
                        "\t\tasoc->peer.retran_path = peer;",
                        "\t}",
                        "",
                        "\tif (asoc->peer.active_path == asoc->peer.retran_path &&",
                        "\t    peer->state != SCTP_UNCONFIRMED) {",
                        "\t\tasoc->peer.retran_path = peer;",
                        "\t}",
                        "",
                        "\treturn peer;",
                        "}"
                    ],
                    "start": 581,
                    "highlight": 659
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8214aab9"
        },
        "859": {
            "name": "sctp_assoc_add_peer",
            "parent_idx": 697,
            "source_line": [
                {
                    "file": "net/sctp/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n1092",
                    "code": [
                        "static int sctp_connect_new_asoc(struct sctp_endpoint *ep,",
                        "\t\t\t\t const union sctp_addr *daddr,",
                        "\t\t\t\t const struct sctp_initmsg *init,",
                        "\t\t\t\t struct sctp_transport **tp)",
                        "{",
                        "\tstruct sctp_association *asoc;",
                        "\tstruct sock *sk = ep->base.sk;",
                        "\tstruct net *net = sock_net(sk);",
                        "\tenum sctp_scope scope;",
                        "\tint err;",
                        "",
                        "\tif (sctp_endpoint_is_peeled_off(ep, daddr))",
                        "\t\treturn -EADDRNOTAVAIL;",
                        "",
                        "\tif (!ep->base.bind_addr.port) {",
                        "\t\tif (sctp_autobind(sk))",
                        "\t\t\treturn -EAGAIN;",
                        "\t} else {",
                        "\t\tif (inet_port_requires_bind_service(net, ep->base.bind_addr.port) &&",
                        "\t\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))",
                        "\t\t\treturn -EACCES;",
                        "\t}",
                        "",
                        "\tscope = sctp_scope(daddr);",
                        "\tasoc = sctp_association_new(ep, sk, scope, GFP_KERNEL);",
                        "\tif (!asoc)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\terr = sctp_assoc_set_bind_addr_from_ep(asoc, scope, GFP_KERNEL);",
                        "\tif (err < 0)",
                        "\t\tgoto free;",
                        "",
                        "\t*tp = sctp_assoc_add_peer(asoc, daddr, GFP_KERNEL, SCTP_UNKNOWN);",
                        "\tif (!*tp) {",
                        "\t\terr = -ENOMEM;",
                        "\t\tgoto free;",
                        "\t}",
                        "",
                        "\tif (!init)",
                        "\t\treturn 0;",
                        "",
                        "\tif (init->sinit_num_ostreams) {",
                        "\t\t__u16 outcnt = init->sinit_num_ostreams;",
                        "",
                        "\t\tasoc->c.sinit_num_ostreams = outcnt;",
                        "\t\t/* outcnt has been changed, need to re-init stream */",
                        "\t\terr = sctp_stream_init(&asoc->stream, outcnt, 0, GFP_KERNEL);",
                        "\t\tif (err)",
                        "\t\t\tgoto free;",
                        "\t}",
                        "",
                        "\tif (init->sinit_max_instreams)",
                        "\t\tasoc->c.sinit_max_instreams = init->sinit_max_instreams;",
                        "",
                        "\tif (init->sinit_max_attempts)",
                        "\t\tasoc->max_init_attempts = init->sinit_max_attempts;",
                        "",
                        "\tif (init->sinit_max_init_timeo)",
                        "\t\tasoc->max_init_timeo =",
                        "\t\t\tmsecs_to_jiffies(init->sinit_max_init_timeo);",
                        "",
                        "\treturn 0;",
                        "free:",
                        "\tsctp_association_free(asoc);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1060,
                    "highlight": 1092
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8216dfa1"
        },
        "697": {
            "name": "sctp_connect_new_asoc",
            "parent_idx": 645,
            "source_line": [
                {
                    "file": "net/sctp/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n1694",
                    "code": [
                        "static int sctp_sendmsg_new_asoc(struct sock *sk, __u16 sflags,",
                        "\t\t\t\t struct sctp_cmsgs *cmsgs,",
                        "\t\t\t\t union sctp_addr *daddr,",
                        "\t\t\t\t struct sctp_transport **tp)",
                        "{",
                        "\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;",
                        "\tstruct sctp_association *asoc;",
                        "\tstruct cmsghdr *cmsg;",
                        "\t__be32 flowinfo = 0;",
                        "\tstruct sctp_af *af;",
                        "\tint err;",
                        "",
                        "\t*tp = NULL;",
                        "",
                        "\tif (sflags & (SCTP_EOF | SCTP_ABORT))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (sctp_style(sk, TCP) && (sctp_sstate(sk, ESTABLISHED) ||",
                        "\t\t\t\t    sctp_sstate(sk, CLOSING)))",
                        "\t\treturn -EADDRNOTAVAIL;",
                        "",
                        "\t/* Label connection socket for first association 1-to-many",
                        "\t * style for client sequence socket()->sendmsg(). This",
                        "\t * needs to be done before sctp_assoc_add_peer() as that will",
                        "\t * set up the initial packet that needs to account for any",
                        "\t * security ip options (CIPSO/CALIPSO) added to the packet.",
                        "\t */",
                        "\taf = sctp_get_af_specific(daddr->sa.sa_family);",
                        "\tif (!af)",
                        "\t\treturn -EINVAL;",
                        "\terr = security_sctp_bind_connect(sk, SCTP_SENDMSG_CONNECT,",
                        "\t\t\t\t\t (struct sockaddr *)daddr,",
                        "\t\t\t\t\t af->sockaddr_len);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\terr = sctp_connect_new_asoc(ep, daddr, cmsgs->init, tp);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "\tasoc = (*tp)->asoc;",
                        "",
                        "\tif (!cmsgs->addrs_msg)",
                        "\t\treturn 0;",
                        "",
                        "\tif (daddr->sa.sa_family == AF_INET6)",
                        "\t\tflowinfo = daddr->v6.sin6_flowinfo;",
                        "",
                        "\t/* sendv addr list parse */",
                        "\tfor_each_cmsghdr(cmsg, cmsgs->addrs_msg) {",
                        "\t\tunion sctp_addr _daddr;",
                        "\t\tint dlen;",
                        "",
                        "\t\tif (cmsg->cmsg_level != IPPROTO_SCTP ||",
                        "\t\t    (cmsg->cmsg_type != SCTP_DSTADDRV4 &&",
                        "\t\t     cmsg->cmsg_type != SCTP_DSTADDRV6))",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tdaddr = &_daddr;",
                        "\t\tmemset(daddr, 0, sizeof(*daddr));",
                        "\t\tdlen = cmsg->cmsg_len - sizeof(struct cmsghdr);",
                        "\t\tif (cmsg->cmsg_type == SCTP_DSTADDRV4) {",
                        "\t\t\tif (dlen < sizeof(struct in_addr)) {",
                        "\t\t\t\terr = -EINVAL;",
                        "\t\t\t\tgoto free;",
                        "\t\t\t}",
                        "",
                        "\t\t\tdlen = sizeof(struct in_addr);",
                        "\t\t\tdaddr->v4.sin_family = AF_INET;",
                        "\t\t\tdaddr->v4.sin_port = htons(asoc->peer.port);",
                        "\t\t\tmemcpy(&daddr->v4.sin_addr, CMSG_DATA(cmsg), dlen);",
                        "\t\t} else {",
                        "\t\t\tif (dlen < sizeof(struct in6_addr)) {",
                        "\t\t\t\terr = -EINVAL;",
                        "\t\t\t\tgoto free;",
                        "\t\t\t}",
                        "",
                        "\t\t\tdlen = sizeof(struct in6_addr);",
                        "\t\t\tdaddr->v6.sin6_flowinfo = flowinfo;",
                        "\t\t\tdaddr->v6.sin6_family = AF_INET6;",
                        "\t\t\tdaddr->v6.sin6_port = htons(asoc->peer.port);",
                        "\t\t\tmemcpy(&daddr->v6.sin6_addr, CMSG_DATA(cmsg), dlen);",
                        "\t\t}",
                        "",
                        "\t\terr = sctp_connect_add_peer(asoc, daddr, sizeof(*daddr));",
                        "\t\tif (err)",
                        "\t\t\tgoto free;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "",
                        "free:",
                        "\tsctp_association_free(asoc);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1658,
                    "highlight": 1694
                },
                {
                    "file": "net/sctp/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2004",
                    "code": [
                        "static int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)",
                        "{",
                        "\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;",
                        "\tstruct sctp_transport *transport = NULL;",
                        "\tstruct sctp_sndrcvinfo _sinfo, *sinfo;",
                        "\tstruct sctp_association *asoc, *tmp;",
                        "\tstruct sctp_cmsgs cmsgs;",
                        "\tunion sctp_addr *daddr;",
                        "\tbool new = false;",
                        "\t__u16 sflags;",
                        "\tint err;",
                        "",
                        "\t/* Parse and get snd_info */",
                        "\terr = sctp_sendmsg_parse(sk, &cmsgs, &_sinfo, msg, msg_len);",
                        "\tif (err)",
                        "\t\tgoto out;",
                        "",
                        "\tsinfo  = &_sinfo;",
                        "\tsflags = sinfo->sinfo_flags;",
                        "",
                        "\t/* Get daddr from msg */",
                        "\tdaddr = sctp_sendmsg_get_daddr(sk, msg, &cmsgs);",
                        "\tif (IS_ERR(daddr)) {",
                        "\t\terr = PTR_ERR(daddr);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tlock_sock(sk);",
                        "",
                        "\t/* SCTP_SENDALL process */",
                        "\tif ((sflags & SCTP_SENDALL) && sctp_style(sk, UDP)) {",
                        "\t\tlist_for_each_entry_safe(asoc, tmp, &ep->asocs, asocs) {",
                        "\t\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg,",
                        "\t\t\t\t\t\t\tmsg_len);",
                        "\t\t\tif (err == 0)",
                        "\t\t\t\tcontinue;",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\tgoto out_unlock;",
                        "",
                        "\t\t\tsctp_sendmsg_update_sinfo(asoc, sinfo, &cmsgs);",
                        "",
                        "\t\t\terr = sctp_sendmsg_to_asoc(asoc, msg, msg_len,",
                        "\t\t\t\t\t\t   NULL, sinfo);",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\tgoto out_unlock;",
                        "",
                        "\t\t\tiov_iter_revert(&msg->msg_iter, err);",
                        "\t\t}",
                        "",
                        "\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\t/* Get and check or create asoc */",
                        "\tif (daddr) {",
                        "\t\tasoc = sctp_endpoint_lookup_assoc(ep, daddr, &transport);",
                        "\t\tif (asoc) {",
                        "\t\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg,",
                        "\t\t\t\t\t\t\tmsg_len);",
                        "\t\t\tif (err <= 0)",
                        "\t\t\t\tgoto out_unlock;",
                        "\t\t} else {",
                        "\t\t\terr = sctp_sendmsg_new_asoc(sk, sflags, &cmsgs, daddr,",
                        "\t\t\t\t\t\t    &transport);",
                        "\t\t\tif (err)",
                        "\t\t\t\tgoto out_unlock;",
                        "",
                        "\t\t\tasoc = transport->asoc;",
                        "\t\t\tnew = true;",
                        "\t\t}",
                        "",
                        "\t\tif (!sctp_style(sk, TCP) && !(sflags & SCTP_ADDR_OVER))",
                        "\t\t\ttransport = NULL;",
                        "\t} else {",
                        "\t\tasoc = sctp_id2assoc(sk, sinfo->sinfo_assoc_id);",
                        "\t\tif (!asoc) {",
                        "\t\t\terr = -EPIPE;",
                        "\t\t\tgoto out_unlock;",
                        "\t\t}",
                        "",
                        "\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg, msg_len);",
                        "\t\tif (err <= 0)",
                        "\t\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\t/* Update snd_info with the asoc */",
                        "\tsctp_sendmsg_update_sinfo(asoc, sinfo, &cmsgs);",
                        "",
                        "\t/* Send msg to the asoc */",
                        "\terr = sctp_sendmsg_to_asoc(asoc, msg, msg_len, transport, sinfo);",
                        "\tif (err < 0 && err != -ESRCH && new)",
                        "\t\tsctp_association_free(asoc);",
                        "",
                        "out_unlock:",
                        "\trelease_sock(sk);",
                        "out:",
                        "\treturn sctp_error(sk, msg->msg_flags, err);",
                        "}"
                    ],
                    "start": 1943,
                    "highlight": 2004
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff821728b7"
        },
        "645": {
            "name": "inet_sendmsg",
            "parent_idx": 637,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n652",
                    "code": [
                        "INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t   size_t));",
                        "INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t    size_t));",
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,",
                        "\t\t\t\t     inet_sendmsg, sock, msg,",
                        "\t\t\t\t     msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 646,
                    "highlight": 652
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n672",
                    "code": [
                        "/**",
                        " *\tsock_sendmsg - send a message through @sock",
                        " *\t@sock: socket",
                        " *\t@msg: message to send",
                        " *",
                        " *\tSends @msg through @sock, passing through LSM.",
                        " *\tReturns the number of bytes sent, or an error code.",
                        " */",
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 659,
                    "highlight": 672
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e38985"
        },
        "637": {
            "name": "sock_sendmsg",
            "parent_idx": 634,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2362",
                    "code": [
                        "static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,",
                        "\t\t\t   unsigned int flags, struct used_address *used_address,",
                        "\t\t\t   unsigned int allowed_msghdr_flags)",
                        "{",
                        "\tunsigned char ctl[sizeof(struct cmsghdr) + 20]",
                        "\t\t\t\t__aligned(sizeof(__kernel_size_t));",
                        "\t/* 20 is size of ipv6_pktinfo */",
                        "\tunsigned char *ctl_buf = ctl;",
                        "\tint ctl_len;",
                        "\tssize_t err;",
                        "",
                        "\terr = -ENOBUFS;",
                        "",
                        "\tif (msg_sys->msg_controllen > INT_MAX)",
                        "\t\tgoto out;",
                        "\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);",
                        "\tctl_len = msg_sys->msg_controllen;",
                        "\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
                        "\t\terr =",
                        "\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,",
                        "\t\t\t\t\t\t     sizeof(ctl));",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t\tctl_buf = msg_sys->msg_control;",
                        "\t\tctl_len = msg_sys->msg_controllen;",
                        "\t} else if (ctl_len) {",
                        "\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=",
                        "\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));",
                        "\t\tif (ctl_len > sizeof(ctl)) {",
                        "\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);",
                        "\t\t\tif (ctl_buf == NULL)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\terr = -EFAULT;",
                        "\t\t/*",
                        "\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.",
                        "\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted",
                        "\t\t * checking falls down on this.",
                        "\t\t */",
                        "\t\tif (copy_from_user(ctl_buf,",
                        "\t\t\t\t   (void __user __force *)msg_sys->msg_control,",
                        "\t\t\t\t   ctl_len))",
                        "\t\t\tgoto out_freectl;",
                        "\t\tmsg_sys->msg_control = ctl_buf;",
                        "\t}",
                        "\tmsg_sys->msg_flags = flags;",
                        "",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;",
                        "\t/*",
                        "\t * If this is sendmmsg() and current destination address is same as",
                        "\t * previously succeeded address, omit asking LSM's decision.",
                        "\t * used_address->name_len is initialized to UINT_MAX so that the first",
                        "\t * destination address never matches.",
                        "\t */",
                        "\tif (used_address && msg_sys->msg_name &&",
                        "\t    used_address->name_len == msg_sys->msg_namelen &&",
                        "\t    !memcmp(&used_address->name, msg_sys->msg_name,",
                        "\t\t    used_address->name_len)) {",
                        "\t\terr = sock_sendmsg_nosec(sock, msg_sys);",
                        "\t\tgoto out_freectl;",
                        "\t}",
                        "\terr = sock_sendmsg(sock, msg_sys);",
                        "\t/*",
                        "\t * If this is sendmmsg() and sending to current destination address was",
                        "\t * successful, remember it.",
                        "\t */",
                        "\tif (used_address && err >= 0) {",
                        "\t\tused_address->name_len = msg_sys->msg_namelen;",
                        "\t\tif (msg_sys->msg_name)",
                        "\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,",
                        "\t\t\t       used_address->name_len);",
                        "\t}",
                        "",
                        "out_freectl:",
                        "\tif (ctl_buf != ctl)",
                        "\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2300,
                    "highlight": 2362
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e38dea"
        },
        "634": {
            "name": "____sys_sendmsg",
            "parent_idx": 628,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2416",
                    "code": [
                        "\terr = ____sys_sendmsg(sock, msg_sys, flags, used_address,",
                        "\t\t\t\tallowed_msghdr_flags);",
                        "\tkfree(iov);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2416,
                    "highlight": 2416
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e3d1ee"
        },
        "628": {
            "name": "___sys_sendmsg",
            "parent_idx": 605,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2506",
                    "code": [
                        "int __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,",
                        "\t\t   unsigned int flags, bool forbid_cmsg_compat)",
                        "{",
                        "\tint fput_needed, err, datagrams;",
                        "\tstruct socket *sock;",
                        "\tstruct mmsghdr __user *entry;",
                        "\tstruct compat_mmsghdr __user *compat_entry;",
                        "\tstruct msghdr msg_sys;",
                        "\tstruct used_address used_address;",
                        "\tunsigned int oflags = flags;",
                        "",
                        "\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (vlen > UIO_MAXIOV)",
                        "\t\tvlen = UIO_MAXIOV;",
                        "",
                        "\tdatagrams = 0;",
                        "",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (!sock)",
                        "\t\treturn err;",
                        "",
                        "\tused_address.name_len = UINT_MAX;",
                        "\tentry = mmsg;",
                        "\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;",
                        "\terr = 0;",
                        "\tflags |= MSG_BATCH;",
                        "",
                        "\twhile (datagrams < vlen) {",
                        "\t\tif (datagrams == vlen - 1)",
                        "\t\t\tflags = oflags;",
                        "",
                        "\t\tif (MSG_CMSG_COMPAT & flags) {",
                        "\t\t\terr = ___sys_sendmsg(sock, (struct user_msghdr __user *)compat_entry,",
                        "\t\t\t\t\t     &msg_sys, flags, &used_address, MSG_EOR);",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\tbreak;",
                        "\t\t\terr = __put_user(err, &compat_entry->msg_len);",
                        "\t\t\t++compat_entry;",
                        "\t\t} else {",
                        "\t\t\terr = ___sys_sendmsg(sock,",
                        "\t\t\t\t\t     (struct user_msghdr __user *)entry,",
                        "\t\t\t\t\t     &msg_sys, flags, &used_address, MSG_EOR);",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\tbreak;",
                        "\t\t\terr = put_user(err, &entry->msg_len);",
                        "\t\t\t++entry;",
                        "\t\t}",
                        "",
                        "\t\tif (err)",
                        "\t\t\tbreak;",
                        "\t\t++datagrams;",
                        "\t\tif (msg_data_left(&msg_sys))",
                        "\t\t\tbreak;",
                        "\t\tcond_resched();",
                        "\t}",
                        "",
                        "\tfput_light(sock->file, fput_needed);",
                        "",
                        "\t/* We only return an error if no datagrams were able to be sent */",
                        "\tif (datagrams != 0)",
                        "\t\treturn datagrams;",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2465,
                    "highlight": 2506
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e3d5b9"
        },
        "605": {
            "name": "__sys_sendmmsg",
            "parent_idx": 602,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2535",
                    "code": [
                        "SYSCALL_DEFINE4(sendmmsg, int, fd, struct mmsghdr __user *, mmsg,",
                        "\t\tunsigned int, vlen, unsigned int, flags)",
                        "{",
                        "\treturn __sys_sendmmsg(fd, mmsg, vlen, flags, true);",
                        "}"
                    ],
                    "start": 2532,
                    "highlight": 2535
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2532",
                    "code": [
                        "int __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,",
                        "\t\t   unsigned int flags, bool forbid_cmsg_compat)",
                        "{",
                        "\tint fput_needed, err, datagrams;",
                        "\tstruct socket *sock;",
                        "\tstruct mmsghdr __user *entry;",
                        "\tstruct compat_mmsghdr __user *compat_entry;",
                        "\tstruct msghdr msg_sys;",
                        "\tstruct used_address used_address;",
                        "\tunsigned int oflags = flags;",
                        "",
                        "\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (vlen > UIO_MAXIOV)",
                        "\t\tvlen = UIO_MAXIOV;",
                        "",
                        "\tdatagrams = 0;",
                        "",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (!sock)",
                        "\t\treturn err;",
                        "",
                        "\tused_address.name_len = UINT_MAX;",
                        "\tentry = mmsg;",
                        "\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;",
                        "\terr = 0;",
                        "\tflags |= MSG_BATCH;",
                        "",
                        "\twhile (datagrams < vlen) {",
                        "\t\tif (datagrams == vlen - 1)",
                        "\t\t\tflags = oflags;",
                        "",
                        "\t\tif (MSG_CMSG_COMPAT & flags) {",
                        "\t\t\terr = ___sys_sendmsg(sock, (struct user_msghdr __user *)compat_entry,",
                        "\t\t\t\t\t     &msg_sys, flags, &used_address, MSG_EOR);",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\tbreak;",
                        "\t\t\terr = __put_user(err, &compat_entry->msg_len);",
                        "\t\t\t++compat_entry;",
                        "\t\t} else {",
                        "\t\t\terr = ___sys_sendmsg(sock,",
                        "\t\t\t\t\t     (struct user_msghdr __user *)entry,",
                        "\t\t\t\t\t     &msg_sys, flags, &used_address, MSG_EOR);",
                        "\t\t\tif (err < 0)",
                        "\t\t\t\tbreak;",
                        "\t\t\terr = put_user(err, &entry->msg_len);",
                        "\t\t\t++entry;",
                        "\t\t}",
                        "",
                        "\t\tif (err)",
                        "\t\t\tbreak;",
                        "\t\t++datagrams;",
                        "\t\tif (msg_data_left(&msg_sys))",
                        "\t\t\tbreak;",
                        "\t\tcond_resched();",
                        "\t}",
                        "",
                        "\tfput_light(sock->file, fput_needed);",
                        "",
                        "\t/* We only return an error if no datagrams were able to be sent */",
                        "\tif (datagrams != 0)",
                        "\t\treturn datagrams;",
                        "",
                        "\treturn err;",
                        "}",
                        "",
                        "SYSCALL_DEFINE4(sendmmsg, int, fd, struct mmsghdr __user *, mmsg,",
                        "\t\tunsigned int, vlen, unsigned int, flags)",
                        "{",
                        "\treturn __sys_sendmmsg(fd, mmsg, vlen, flags, true);",
                        "}"
                    ],
                    "start": 2465,
                    "highlight": 2532
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e3d79c"
        },
        "602": {
            "name": "__x64_sys_sendmmsg(indirect)",
            "parent_idx": 599,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n295",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 282,
                    "highlight": 295
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81003f95"
        },
        "599": {
            "name": "do_syscall_64",
            "parent_idx": 592,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_ON\t\t\t/* return enables interrupts */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "592": {
            "name": "89_syscall_6",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "882": {
            "name": "+0x86",
            "parent_idx": 877,
            "source_line": [
                {
                    "file": "net/ipv6/exthdrs.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/exthdrs.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n1356",
                    "code": [
                        "/**",
                        " * fl6_update_dst - update flowi destination address with info given",
                        " *                  by srcrt option, if any.",
                        " *",
                        " * @fl6: flowi6 for which daddr is to be updated",
                        " * @opt: struct ipv6_txoptions in which to look for srcrt opt",
                        " * @orig: copy of original daddr address if modified",
                        " *",
                        " * Returns NULL if no txoptions or no srcrt, otherwise returns orig",
                        " * and initial value of fl6->daddr set in orig",
                        " */",
                        "struct in6_addr *fl6_update_dst(struct flowi6 *fl6,",
                        "\t\t\t\tconst struct ipv6_txoptions *opt,",
                        "\t\t\t\tstruct in6_addr *orig)",
                        "{",
                        "\tif (!opt || !opt->srcrt)",
                        "\t\treturn NULL;",
                        "",
                        "\t*orig = fl6->daddr;",
                        "",
                        "\tswitch (opt->srcrt->type) {",
                        "\tcase IPV6_SRCRT_TYPE_0:",
                        "\tcase IPV6_SRCRT_STRICT:",
                        "\tcase IPV6_SRCRT_TYPE_2:",
                        "\t\tfl6->daddr = *((struct rt0_hdr *)opt->srcrt)->addr;",
                        "\t\tbreak;",
                        "\tcase IPV6_SRCRT_TYPE_4:",
                        "\t{",
                        "\t\tstruct ipv6_sr_hdr *srh = (struct ipv6_sr_hdr *)opt->srcrt;",
                        "",
                        "\t\tfl6->daddr = srh->segments[srh->segments_left];",
                        "\t\tbreak;",
                        "\t}",
                        "\tdefault:",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\treturn orig;",
                        "}"
                    ],
                    "start": 1326,
                    "highlight": 1356
                }
            ],
            "ins_idx": 3,
            "addr": "0xffffffff820a78d6"
        },
        "879": {
            "name": "+0x55",
            "parent_idx": 877,
            "source_line": [
                {
                    "file": "net/ipv6/exthdrs.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/exthdrs.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n1346",
                    "code": [
                        "/**",
                        " * fl6_update_dst - update flowi destination address with info given",
                        " *                  by srcrt option, if any.",
                        " *",
                        " * @fl6: flowi6 for which daddr is to be updated",
                        " * @opt: struct ipv6_txoptions in which to look for srcrt opt",
                        " * @orig: copy of original daddr address if modified",
                        " *",
                        " * Returns NULL if no txoptions or no srcrt, otherwise returns orig",
                        " * and initial value of fl6->daddr set in orig",
                        " */",
                        "struct in6_addr *fl6_update_dst(struct flowi6 *fl6,",
                        "\t\t\t\tconst struct ipv6_txoptions *opt,",
                        "\t\t\t\tstruct in6_addr *orig)",
                        "{",
                        "\tif (!opt || !opt->srcrt)",
                        "\t\treturn NULL;",
                        "",
                        "\t*orig = fl6->daddr;",
                        "",
                        "\tswitch (opt->srcrt->type) {",
                        "\tcase IPV6_SRCRT_TYPE_0:",
                        "\tcase IPV6_SRCRT_STRICT:",
                        "\tcase IPV6_SRCRT_TYPE_2:",
                        "\t\tfl6->daddr = *((struct rt0_hdr *)opt->srcrt)->addr;",
                        "\t\tbreak;",
                        "\tcase IPV6_SRCRT_TYPE_4:",
                        "\t{",
                        "\t\tstruct ipv6_sr_hdr *srh = (struct ipv6_sr_hdr *)opt->srcrt;",
                        "",
                        "\t\tfl6->daddr = srh->segments[srh->segments_left];",
                        "\t\tbreak;",
                        "\t}",
                        "\tdefault:",
                        "\t\treturn NULL;",
                        "\t}",
                        "",
                        "\treturn orig;",
                        "}"
                    ],
                    "start": 1326,
                    "highlight": 1346
                }
            ],
            "ins_idx": 5,
            "addr": "0xffffffff820a78a5"
        },
        "566": {
            "name": "+0x261",
            "parent_idx": 517,
            "source_line": [
                {
                    "file": "net/ipv6/exthdrs.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/exthdrs.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n1224",
                    "code": [
                        "static void ipv6_renew_option(int renewtype,",
                        "\t\t\t      struct ipv6_opt_hdr **dest,",
                        "\t\t\t      struct ipv6_opt_hdr *old,",
                        "\t\t\t      struct ipv6_opt_hdr *new,",
                        "\t\t\t      int newtype, char **p)",
                        "{",
                        "\tstruct ipv6_opt_hdr *src;",
                        "",
                        "\tsrc = (renewtype == newtype ? new : old);",
                        "\tif (!src)",
                        "\t\treturn;",
                        "",
                        "\tmemcpy(*p, src, ipv6_optlen(src));",
                        "\t*dest = (struct ipv6_opt_hdr *)*p;",
                        "\t*p += CMSG_ALIGN(ipv6_optlen(*dest));",
                        "}"
                    ],
                    "start": 1211,
                    "highlight": 1224
                },
                {
                    "file": "net/ipv6/exthdrs.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/exthdrs.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n1290",
                    "code": [
                        "/**",
                        " * ipv6_renew_options - replace a specific ext hdr with a new one.",
                        " *",
                        " * @sk: sock from which to allocate memory",
                        " * @opt: original options",
                        " * @newtype: option type to replace in @opt",
                        " * @newopt: new option of type @newtype to replace (user-mem)",
                        " * @newoptlen: length of @newopt",
                        " *",
                        " * Returns a new set of options which is a copy of @opt with the",
                        " * option type @newtype replaced with @newopt.",
                        " *",
                        " * @opt may be NULL, in which case a new set of options is returned",
                        " * containing just @newopt.",
                        " *",
                        " * @newopt may be NULL, in which case the specified option type is",
                        " * not copied into the new set of options.",
                        " *",
                        " * The new set of options is allocated from the socket option memory",
                        " * buffer of @sk.",
                        " */",
                        "struct ipv6_txoptions *",
                        "ipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,",
                        "\t\t   int newtype, struct ipv6_opt_hdr *newopt)",
                        "{",
                        "\tint tot_len = 0;",
                        "\tchar *p;",
                        "\tstruct ipv6_txoptions *opt2;",
                        "",
                        "\tif (opt) {",
                        "\t\tif (newtype != IPV6_HOPOPTS && opt->hopopt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->hopopt));",
                        "\t\tif (newtype != IPV6_RTHDRDSTOPTS && opt->dst0opt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst0opt));",
                        "\t\tif (newtype != IPV6_RTHDR && opt->srcrt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->srcrt));",
                        "\t\tif (newtype != IPV6_DSTOPTS && opt->dst1opt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst1opt));",
                        "\t}",
                        "",
                        "\tif (newopt)",
                        "\t\ttot_len += CMSG_ALIGN(ipv6_optlen(newopt));",
                        "",
                        "\tif (!tot_len)",
                        "\t\treturn NULL;",
                        "",
                        "\ttot_len += sizeof(*opt2);",
                        "\topt2 = sock_kmalloc(sk, tot_len, GFP_ATOMIC);",
                        "\tif (!opt2)",
                        "\t\treturn ERR_PTR(-ENOBUFS);",
                        "",
                        "\tmemset(opt2, 0, tot_len);",
                        "\trefcount_set(&opt2->refcnt, 1);",
                        "\topt2->tot_len = tot_len;",
                        "\tp = (char *)(opt2 + 1);",
                        "",
                        "\tipv6_renew_option(IPV6_HOPOPTS, &opt2->hopopt,",
                        "\t\t\t  (opt ? opt->hopopt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_RTHDRDSTOPTS, &opt2->dst0opt,",
                        "\t\t\t  (opt ? opt->dst0opt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_RTHDR,",
                        "\t\t\t  (struct ipv6_opt_hdr **)&opt2->srcrt,",
                        "\t\t\t  (opt ? (struct ipv6_opt_hdr *)opt->srcrt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_DSTOPTS, &opt2->dst1opt,",
                        "\t\t\t  (opt ? opt->dst1opt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "",
                        "\topt2->opt_nflen = (opt2->hopopt ? ipv6_optlen(opt2->hopopt) : 0) +",
                        "\t\t\t  (opt2->dst0opt ? ipv6_optlen(opt2->dst0opt) : 0) +",
                        "\t\t\t  (opt2->srcrt ? ipv6_optlen(opt2->srcrt) : 0);",
                        "\topt2->opt_flen = (opt2->dst1opt ? ipv6_optlen(opt2->dst1opt) : 0);",
                        "",
                        "\treturn opt2;",
                        "}"
                    ],
                    "start": 1228,
                    "highlight": 1290
                }
            ],
            "ins_idx": 9,
            "addr": "0xffffffff820aaaa1"
        },
        "517": {
            "name": "ipv6_renew_options",
            "parent_idx": 478,
            "source_line": [
                {
                    "file": "net/ipv6/ipv6_sockglue.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/ipv6_sockglue.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n435",
                    "code": [
                        "static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,",
                        "\t\t    char __user *optval, unsigned int optlen)",
                        "{",
                        "\tstruct ipv6_pinfo *np = inet6_sk(sk);",
                        "\tstruct net *net = sock_net(sk);",
                        "\tint val, valbool;",
                        "\tint retv = -ENOPROTOOPT;",
                        "\tbool needs_rtnl = setsockopt_needs_rtnl(optname);",
                        "",
                        "\tif (!optval)",
                        "\t\tval = 0;",
                        "\telse {",
                        "\t\tif (optlen >= sizeof(int)) {",
                        "\t\t\tif (get_user(val, (int __user *) optval))",
                        "\t\t\t\treturn -EFAULT;",
                        "\t\t} else",
                        "\t\t\tval = 0;",
                        "\t}",
                        "",
                        "\tvalbool = (val != 0);",
                        "",
                        "\tif (ip6_mroute_opt(optname))",
                        "\t\treturn ip6_mroute_setsockopt(sk, optname, optval, optlen);",
                        "",
                        "\tif (needs_rtnl)",
                        "\t\trtnl_lock();",
                        "\tlock_sock(sk);",
                        "",
                        "\tswitch (optname) {",
                        "",
                        "\tcase IPV6_ADDRFORM:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tif (val == PF_INET) {",
                        "\t\t\tstruct ipv6_txoptions *opt;",
                        "\t\t\tstruct sk_buff *pktopt;",
                        "",
                        "\t\t\tif (sk->sk_type == SOCK_RAW)",
                        "\t\t\t\tbreak;",
                        "",
                        "\t\t\tif (sk->sk_protocol == IPPROTO_UDP ||",
                        "\t\t\t    sk->sk_protocol == IPPROTO_UDPLITE) {",
                        "\t\t\t\tstruct udp_sock *up = udp_sk(sk);",
                        "\t\t\t\tif (up->pending == AF_INET6) {",
                        "\t\t\t\t\tretv = -EBUSY;",
                        "\t\t\t\t\tbreak;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&",
                        "\t\t\t    sk->sk_prot != &tcpv6_prot) {",
                        "\t\t\t\tretv = -EBUSY;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tif (sk->sk_protocol != IPPROTO_TCP)",
                        "\t\t\t\tbreak;",
                        "\t\t\tif (sk->sk_state != TCP_ESTABLISHED) {",
                        "\t\t\t\tretv = -ENOTCONN;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (ipv6_only_sock(sk) ||",
                        "\t\t\t    !ipv6_addr_v4mapped(&sk->sk_v6_daddr)) {",
                        "\t\t\t\tretv = -EADDRNOTAVAIL;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "",
                        "\t\t\tfl6_free_socklist(sk);",
                        "\t\t\t__ipv6_sock_mc_close(sk);",
                        "",
                        "\t\t\t/*",
                        "\t\t\t * Sock is moving from IPv6 to IPv4 (sk_prot), so",
                        "\t\t\t * remove it from the refcnt debug socks count in the",
                        "\t\t\t * original family...",
                        "\t\t\t */",
                        "\t\t\tsk_refcnt_debug_dec(sk);",
                        "",
                        "\t\t\tif (sk->sk_protocol == IPPROTO_TCP) {",
                        "\t\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);",
                        "\t\t\t\tlocal_bh_disable();",
                        "\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);",
                        "\t\t\t\tsock_prot_inuse_add(net, &tcp_prot, 1);",
                        "\t\t\t\tlocal_bh_enable();",
                        "\t\t\t\tsk->sk_prot = &tcp_prot;",
                        "\t\t\t\ticsk->icsk_af_ops = &ipv4_specific;",
                        "\t\t\t\tsk->sk_socket->ops = &inet_stream_ops;",
                        "\t\t\t\tsk->sk_family = PF_INET;",
                        "\t\t\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);",
                        "\t\t\t} else {",
                        "\t\t\t\tstruct proto *prot = &udp_prot;",
                        "",
                        "\t\t\t\tif (sk->sk_protocol == IPPROTO_UDPLITE)",
                        "\t\t\t\t\tprot = &udplite_prot;",
                        "\t\t\t\tlocal_bh_disable();",
                        "\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);",
                        "\t\t\t\tsock_prot_inuse_add(net, prot, 1);",
                        "\t\t\t\tlocal_bh_enable();",
                        "\t\t\t\tsk->sk_prot = prot;",
                        "\t\t\t\tsk->sk_socket->ops = &inet_dgram_ops;",
                        "\t\t\t\tsk->sk_family = PF_INET;",
                        "\t\t\t}",
                        "\t\t\topt = xchg((__force struct ipv6_txoptions **)&np->opt,",
                        "\t\t\t\t   NULL);",
                        "\t\t\tif (opt) {",
                        "\t\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);",
                        "\t\t\t\ttxopt_put(opt);",
                        "\t\t\t}",
                        "\t\t\tpktopt = xchg(&np->pktoptions, NULL);",
                        "\t\t\tkfree_skb(pktopt);",
                        "",
                        "\t\t\t/*",
                        "\t\t\t * ... and add it to the refcnt debug socks count",
                        "\t\t\t * in the new family. -acme",
                        "\t\t\t */",
                        "\t\t\tsk_refcnt_debug_inc(sk);",
                        "\t\t\tmodule_put(THIS_MODULE);",
                        "\t\t\tretv = 0;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tgoto e_inval;",
                        "",
                        "\tcase IPV6_V6ONLY:",
                        "\t\tif (optlen < sizeof(int) ||",
                        "\t\t    inet_sk(sk)->inet_num)",
                        "\t\t\tgoto e_inval;",
                        "\t\tsk->sk_ipv6only = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_RECVPKTINFO:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.rxinfo = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_2292PKTINFO:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.rxoinfo = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_RECVHOPLIMIT:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.rxhlim = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_2292HOPLIMIT:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.rxohlim = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_RECVRTHDR:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.srcrt = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_2292RTHDR:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.osrcrt = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_RECVHOPOPTS:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.hopopts = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_2292HOPOPTS:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.ohopopts = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_RECVDSTOPTS:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.dstopts = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_2292DSTOPTS:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.odstopts = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_TCLASS:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tif (val < -1 || val > 0xff)",
                        "\t\t\tgoto e_inval;",
                        "\t\t/* RFC 3542, 6.5: default traffic class of 0x0 */",
                        "\t\tif (val == -1)",
                        "\t\t\tval = 0;",
                        "\t\tnp->tclass = val;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_RECVTCLASS:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.rxtclass = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_FLOWINFO:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.rxflow = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_RECVPATHMTU:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.rxpmtu = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_TRANSPARENT:",
                        "\t\tif (valbool && !ns_capable(net->user_ns, CAP_NET_RAW) &&",
                        "\t\t    !ns_capable(net->user_ns, CAP_NET_ADMIN)) {",
                        "\t\t\tretv = -EPERM;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\t/* we don't have a separate transparent bit for IPV6 we use the one in the IPv4 socket */",
                        "\t\tinet_sk(sk)->transparent = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_FREEBIND:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\t/* we also don't have a separate freebind bit for IPV6 */",
                        "\t\tinet_sk(sk)->freebind = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_RECVORIGDSTADDR:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rxopt.bits.rxorigdstaddr = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_HOPOPTS:",
                        "\tcase IPV6_RTHDRDSTOPTS:",
                        "\tcase IPV6_RTHDR:",
                        "\tcase IPV6_DSTOPTS:",
                        "\t{",
                        "\t\tstruct ipv6_txoptions *opt;",
                        "\t\tstruct ipv6_opt_hdr *new = NULL;",
                        "",
                        "\t\t/* hop-by-hop / destination options are privileged option */",
                        "\t\tretv = -EPERM;",
                        "\t\tif (optname != IPV6_RTHDR && !ns_capable(net->user_ns, CAP_NET_RAW))",
                        "\t\t\tbreak;",
                        "",
                        "\t\t/* remove any sticky options header with a zero option",
                        "\t\t * length, per RFC3542.",
                        "\t\t */",
                        "\t\tif (optlen == 0)",
                        "\t\t\toptval = NULL;",
                        "\t\telse if (!optval)",
                        "\t\t\tgoto e_inval;",
                        "\t\telse if (optlen < sizeof(struct ipv6_opt_hdr) ||",
                        "\t\t\t optlen & 0x7 || optlen > 8 * 255)",
                        "\t\t\tgoto e_inval;",
                        "\t\telse {",
                        "\t\t\tnew = memdup_user(optval, optlen);",
                        "\t\t\tif (IS_ERR(new)) {",
                        "\t\t\t\tretv = PTR_ERR(new);",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tif (unlikely(ipv6_optlen(new) > optlen)) {",
                        "\t\t\t\tkfree(new);",
                        "\t\t\t\tgoto e_inval;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\topt = rcu_dereference_protected(np->opt,",
                        "\t\t\t\t\t\tlockdep_sock_is_held(sk));",
                        "\t\topt = ipv6_renew_options(sk, opt, optname, new);",
                        "\t\tkfree(new);",
                        "\t\tif (IS_ERR(opt)) {",
                        "\t\t\tretv = PTR_ERR(opt);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\t/* routing header option needs extra check */",
                        "\t\tretv = -EINVAL;",
                        "\t\tif (optname == IPV6_RTHDR && opt && opt->srcrt) {",
                        "\t\t\tstruct ipv6_rt_hdr *rthdr = opt->srcrt;",
                        "\t\t\tswitch (rthdr->type) {",
                        "#if IS_ENABLED(CONFIG_IPV6_MIP6)",
                        "\t\t\tcase IPV6_SRCRT_TYPE_2:",
                        "\t\t\t\tif (rthdr->hdrlen != 2 ||",
                        "\t\t\t\t    rthdr->segments_left != 1)",
                        "\t\t\t\t\tgoto sticky_done;",
                        "",
                        "\t\t\t\tbreak;",
                        "#endif",
                        "\t\t\tcase IPV6_SRCRT_TYPE_4:",
                        "\t\t\t{",
                        "\t\t\t\tstruct ipv6_sr_hdr *srh = (struct ipv6_sr_hdr *)",
                        "\t\t\t\t\t\t\t  opt->srcrt;",
                        "",
                        "\t\t\t\tif (!seg6_validate_srh(srh, optlen))",
                        "\t\t\t\t\tgoto sticky_done;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tdefault:",
                        "\t\t\t\tgoto sticky_done;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tretv = 0;",
                        "\t\topt = ipv6_update_options(sk, opt);",
                        "sticky_done:",
                        "\t\tif (opt) {",
                        "\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);",
                        "\t\t\ttxopt_put(opt);",
                        "\t\t}",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tcase IPV6_PKTINFO:",
                        "\t{",
                        "\t\tstruct in6_pktinfo pkt;",
                        "",
                        "\t\tif (optlen == 0)",
                        "\t\t\tgoto e_inval;",
                        "\t\telse if (optlen < sizeof(struct in6_pktinfo) || !optval)",
                        "\t\t\tgoto e_inval;",
                        "",
                        "\t\tif (copy_from_user(&pkt, optval, sizeof(struct in6_pktinfo))) {",
                        "\t\t\t\tretv = -EFAULT;",
                        "\t\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (!sk_dev_equal_l3scope(sk, pkt.ipi6_ifindex))",
                        "\t\t\tgoto e_inval;",
                        "",
                        "\t\tnp->sticky_pktinfo.ipi6_ifindex = pkt.ipi6_ifindex;",
                        "\t\tnp->sticky_pktinfo.ipi6_addr = pkt.ipi6_addr;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tcase IPV6_2292PKTOPTIONS:",
                        "\t{",
                        "\t\tstruct ipv6_txoptions *opt = NULL;",
                        "\t\tstruct msghdr msg;",
                        "\t\tstruct flowi6 fl6;",
                        "\t\tstruct ipcm6_cookie ipc6;",
                        "",
                        "\t\tmemset(&fl6, 0, sizeof(fl6));",
                        "\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;",
                        "\t\tfl6.flowi6_mark = sk->sk_mark;",
                        "",
                        "\t\tif (optlen == 0)",
                        "\t\t\tgoto update;",
                        "",
                        "\t\t/* 1K is probably excessive",
                        "\t\t * 1K is surely not enough, 2K per standard header is 16K.",
                        "\t\t */",
                        "\t\tretv = -EINVAL;",
                        "\t\tif (optlen > 64*1024)",
                        "\t\t\tbreak;",
                        "",
                        "\t\topt = sock_kmalloc(sk, sizeof(*opt) + optlen, GFP_KERNEL);",
                        "\t\tretv = -ENOBUFS;",
                        "\t\tif (!opt)",
                        "\t\t\tbreak;",
                        "",
                        "\t\tmemset(opt, 0, sizeof(*opt));",
                        "\t\trefcount_set(&opt->refcnt, 1);",
                        "\t\topt->tot_len = sizeof(*opt) + optlen;",
                        "\t\tretv = -EFAULT;",
                        "\t\tif (copy_from_user(opt+1, optval, optlen))",
                        "\t\t\tgoto done;",
                        "",
                        "\t\tmsg.msg_controllen = optlen;",
                        "\t\tmsg.msg_control = (void *)(opt+1);",
                        "\t\tipc6.opt = opt;",
                        "",
                        "\t\tretv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, &ipc6);",
                        "\t\tif (retv)",
                        "\t\t\tgoto done;",
                        "update:",
                        "\t\tretv = 0;",
                        "\t\topt = ipv6_update_options(sk, opt);",
                        "done:",
                        "\t\tif (opt) {",
                        "\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);",
                        "\t\t\ttxopt_put(opt);",
                        "\t\t}",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase IPV6_UNICAST_HOPS:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tif (val > 255 || val < -1)",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->hop_limit = val;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_MULTICAST_HOPS:",
                        "\t\tif (sk->sk_type == SOCK_STREAM)",
                        "\t\t\tbreak;",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tif (val > 255 || val < -1)",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->mcast_hops = (val == -1 ? IPV6_DEFAULT_MCASTHOPS : val);",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_MULTICAST_LOOP:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tif (val != valbool)",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->mc_loop = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_UNICAST_IF:",
                        "\t{",
                        "\t\tstruct net_device *dev = NULL;",
                        "\t\tint ifindex;",
                        "",
                        "\t\tif (optlen != sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "",
                        "\t\tifindex = (__force int)ntohl((__force __be32)val);",
                        "\t\tif (ifindex == 0) {",
                        "\t\t\tnp->ucast_oif = 0;",
                        "\t\t\tretv = 0;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\tdev = dev_get_by_index(net, ifindex);",
                        "\t\tretv = -EADDRNOTAVAIL;",
                        "\t\tif (!dev)",
                        "\t\t\tbreak;",
                        "\t\tdev_put(dev);",
                        "",
                        "\t\tretv = -EINVAL;",
                        "\t\tif (sk->sk_bound_dev_if)",
                        "\t\t\tbreak;",
                        "",
                        "\t\tnp->ucast_oif = ifindex;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tcase IPV6_MULTICAST_IF:",
                        "\t\tif (sk->sk_type == SOCK_STREAM)",
                        "\t\t\tbreak;",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "",
                        "\t\tif (val) {",
                        "\t\t\tstruct net_device *dev;",
                        "\t\t\tint midx;",
                        "",
                        "\t\t\trcu_read_lock();",
                        "",
                        "\t\t\tdev = dev_get_by_index_rcu(net, val);",
                        "\t\t\tif (!dev) {",
                        "\t\t\t\trcu_read_unlock();",
                        "\t\t\t\tretv = -ENODEV;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tmidx = l3mdev_master_ifindex_rcu(dev);",
                        "",
                        "\t\t\trcu_read_unlock();",
                        "",
                        "\t\t\tif (sk->sk_bound_dev_if &&",
                        "\t\t\t    sk->sk_bound_dev_if != val &&",
                        "\t\t\t    (!midx || midx != sk->sk_bound_dev_if))",
                        "\t\t\t\tgoto e_inval;",
                        "\t\t}",
                        "\t\tnp->mcast_oif = val;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\tcase IPV6_ADD_MEMBERSHIP:",
                        "\tcase IPV6_DROP_MEMBERSHIP:",
                        "\t{",
                        "\t\tstruct ipv6_mreq mreq;",
                        "",
                        "\t\tif (optlen < sizeof(struct ipv6_mreq))",
                        "\t\t\tgoto e_inval;",
                        "",
                        "\t\tretv = -EPROTO;",
                        "\t\tif (inet_sk(sk)->is_icsk)",
                        "\t\t\tbreak;",
                        "",
                        "\t\tretv = -EFAULT;",
                        "\t\tif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))",
                        "\t\t\tbreak;",
                        "",
                        "\t\tif (optname == IPV6_ADD_MEMBERSHIP)",
                        "\t\t\tretv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);",
                        "\t\telse",
                        "\t\t\tretv = ipv6_sock_mc_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase IPV6_JOIN_ANYCAST:",
                        "\tcase IPV6_LEAVE_ANYCAST:",
                        "\t{",
                        "\t\tstruct ipv6_mreq mreq;",
                        "",
                        "\t\tif (optlen < sizeof(struct ipv6_mreq))",
                        "\t\t\tgoto e_inval;",
                        "",
                        "\t\tretv = -EFAULT;",
                        "\t\tif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))",
                        "\t\t\tbreak;",
                        "",
                        "\t\tif (optname == IPV6_JOIN_ANYCAST)",
                        "\t\t\tretv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);",
                        "\t\telse",
                        "\t\t\tretv = ipv6_sock_ac_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase IPV6_MULTICAST_ALL:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->mc_all = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "",
                        "\tcase MCAST_JOIN_GROUP:",
                        "\tcase MCAST_LEAVE_GROUP:",
                        "\t{",
                        "\t\tstruct group_req greq;",
                        "\t\tstruct sockaddr_in6 *psin6;",
                        "",
                        "\t\tif (optlen < sizeof(struct group_req))",
                        "\t\t\tgoto e_inval;",
                        "",
                        "\t\tretv = -EFAULT;",
                        "\t\tif (copy_from_user(&greq, optval, sizeof(struct group_req)))",
                        "\t\t\tbreak;",
                        "\t\tif (greq.gr_group.ss_family != AF_INET6) {",
                        "\t\t\tretv = -EADDRNOTAVAIL;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tpsin6 = (struct sockaddr_in6 *)&greq.gr_group;",
                        "\t\tif (optname == MCAST_JOIN_GROUP)",
                        "\t\t\tretv = ipv6_sock_mc_join(sk, greq.gr_interface,",
                        "\t\t\t\t\t\t &psin6->sin6_addr);",
                        "\t\telse",
                        "\t\t\tretv = ipv6_sock_mc_drop(sk, greq.gr_interface,",
                        "\t\t\t\t\t\t &psin6->sin6_addr);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase MCAST_JOIN_SOURCE_GROUP:",
                        "\tcase MCAST_LEAVE_SOURCE_GROUP:",
                        "\tcase MCAST_BLOCK_SOURCE:",
                        "\tcase MCAST_UNBLOCK_SOURCE:",
                        "\t{",
                        "\t\tstruct group_source_req greqs;",
                        "\t\tint omode, add;",
                        "",
                        "\t\tif (optlen < sizeof(struct group_source_req))",
                        "\t\t\tgoto e_inval;",
                        "\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {",
                        "\t\t\tretv = -EFAULT;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (greqs.gsr_group.ss_family != AF_INET6 ||",
                        "\t\t    greqs.gsr_source.ss_family != AF_INET6) {",
                        "\t\t\tretv = -EADDRNOTAVAIL;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (optname == MCAST_BLOCK_SOURCE) {",
                        "\t\t\tomode = MCAST_EXCLUDE;",
                        "\t\t\tadd = 1;",
                        "\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {",
                        "\t\t\tomode = MCAST_EXCLUDE;",
                        "\t\t\tadd = 0;",
                        "\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {",
                        "\t\t\tstruct sockaddr_in6 *psin6;",
                        "",
                        "\t\t\tpsin6 = (struct sockaddr_in6 *)&greqs.gsr_group;",
                        "\t\t\tretv = ipv6_sock_mc_join_ssm(sk, greqs.gsr_interface,",
                        "\t\t\t\t\t\t     &psin6->sin6_addr,",
                        "\t\t\t\t\t\t     MCAST_INCLUDE);",
                        "\t\t\t/* prior join w/ different source is ok */",
                        "\t\t\tif (retv && retv != -EADDRINUSE)",
                        "\t\t\t\tbreak;",
                        "\t\t\tomode = MCAST_INCLUDE;",
                        "\t\t\tadd = 1;",
                        "\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {",
                        "\t\t\tomode = MCAST_INCLUDE;",
                        "\t\t\tadd = 0;",
                        "\t\t}",
                        "\t\tretv = ip6_mc_source(add, omode, sk, &greqs);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase MCAST_MSFILTER:",
                        "\t{",
                        "\t\tstruct group_filter *gsf;",
                        "",
                        "\t\tif (optlen < GROUP_FILTER_SIZE(0))",
                        "\t\t\tgoto e_inval;",
                        "\t\tif (optlen > sysctl_optmem_max) {",
                        "\t\t\tretv = -ENOBUFS;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tgsf = memdup_user(optval, optlen);",
                        "\t\tif (IS_ERR(gsf)) {",
                        "\t\t\tretv = PTR_ERR(gsf);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */",
                        "\t\tif (gsf->gf_numsrc >= 0x1ffffffU ||",
                        "\t\t    gsf->gf_numsrc > sysctl_mld_max_msf) {",
                        "\t\t\tkfree(gsf);",
                        "\t\t\tretv = -ENOBUFS;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {",
                        "\t\t\tkfree(gsf);",
                        "\t\t\tretv = -EINVAL;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tretv = ip6_mc_msfilter(sk, gsf);",
                        "\t\tkfree(gsf);",
                        "",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase IPV6_ROUTER_ALERT:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tretv = ip6_ra_control(sk, val);",
                        "\t\tbreak;",
                        "\tcase IPV6_ROUTER_ALERT_ISOLATE:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->rtalert_isolate = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\tcase IPV6_MTU_DISCOVER:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tif (val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT)",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->pmtudisc = val;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\tcase IPV6_MTU:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tif (val && val < IPV6_MIN_MTU)",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->frag_size = val;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\tcase IPV6_RECVERR:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->recverr = valbool;",
                        "\t\tif (!val)",
                        "\t\t\tskb_queue_purge(&sk->sk_error_queue);",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\tcase IPV6_FLOWINFO_SEND:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->sndflow = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\tcase IPV6_FLOWLABEL_MGR:",
                        "\t\tretv = ipv6_flowlabel_opt(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase IPV6_IPSEC_POLICY:",
                        "\tcase IPV6_XFRM_POLICY:",
                        "\t\tretv = -EPERM;",
                        "\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))",
                        "\t\t\tbreak;",
                        "\t\tretv = xfrm_user_policy(sk, optname, optval, optlen);",
                        "\t\tbreak;",
                        "",
                        "\tcase IPV6_ADDR_PREFERENCES:",
                        "\t    {",
                        "\t\tunsigned int pref = 0;",
                        "\t\tunsigned int prefmask = ~0;",
                        "",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "",
                        "\t\tretv = -EINVAL;",
                        "",
                        "\t\t/* check PUBLIC/TMP/PUBTMP_DEFAULT conflicts */",
                        "\t\tswitch (val & (IPV6_PREFER_SRC_PUBLIC|",
                        "\t\t\t       IPV6_PREFER_SRC_TMP|",
                        "\t\t\t       IPV6_PREFER_SRC_PUBTMP_DEFAULT)) {",
                        "\t\tcase IPV6_PREFER_SRC_PUBLIC:",
                        "\t\t\tpref |= IPV6_PREFER_SRC_PUBLIC;",
                        "\t\t\tbreak;",
                        "\t\tcase IPV6_PREFER_SRC_TMP:",
                        "\t\t\tpref |= IPV6_PREFER_SRC_TMP;",
                        "\t\t\tbreak;",
                        "\t\tcase IPV6_PREFER_SRC_PUBTMP_DEFAULT:",
                        "\t\t\tbreak;",
                        "\t\tcase 0:",
                        "\t\t\tgoto pref_skip_pubtmp;",
                        "\t\tdefault:",
                        "\t\t\tgoto e_inval;",
                        "\t\t}",
                        "",
                        "\t\tprefmask &= ~(IPV6_PREFER_SRC_PUBLIC|",
                        "\t\t\t      IPV6_PREFER_SRC_TMP);",
                        "pref_skip_pubtmp:",
                        "",
                        "\t\t/* check HOME/COA conflicts */",
                        "\t\tswitch (val & (IPV6_PREFER_SRC_HOME|IPV6_PREFER_SRC_COA)) {",
                        "\t\tcase IPV6_PREFER_SRC_HOME:",
                        "\t\t\tbreak;",
                        "\t\tcase IPV6_PREFER_SRC_COA:",
                        "\t\t\tpref |= IPV6_PREFER_SRC_COA;",
                        "\t\tcase 0:",
                        "\t\t\tgoto pref_skip_coa;",
                        "\t\tdefault:",
                        "\t\t\tgoto e_inval;",
                        "\t\t}",
                        "",
                        "\t\tprefmask &= ~IPV6_PREFER_SRC_COA;",
                        "pref_skip_coa:",
                        "",
                        "\t\t/* check CGA/NONCGA conflicts */",
                        "\t\tswitch (val & (IPV6_PREFER_SRC_CGA|IPV6_PREFER_SRC_NONCGA)) {",
                        "\t\tcase IPV6_PREFER_SRC_CGA:",
                        "\t\tcase IPV6_PREFER_SRC_NONCGA:",
                        "\t\tcase 0:",
                        "\t\t\tbreak;",
                        "\t\tdefault:",
                        "\t\t\tgoto e_inval;",
                        "\t\t}",
                        "",
                        "\t\tnp->srcprefs = (np->srcprefs & prefmask) | pref;",
                        "\t\tretv = 0;",
                        "",
                        "\t\tbreak;",
                        "\t    }",
                        "\tcase IPV6_MINHOPCOUNT:",
                        "\t\tif (optlen < sizeof(int))",
                        "\t\t\tgoto e_inval;",
                        "\t\tif (val < 0 || val > 255)",
                        "\t\t\tgoto e_inval;",
                        "\t\tnp->min_hopcount = val;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\tcase IPV6_DONTFRAG:",
                        "\t\tnp->dontfrag = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\tcase IPV6_AUTOFLOWLABEL:",
                        "\t\tnp->autoflowlabel = valbool;",
                        "\t\tnp->autoflowlabel_set = 1;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\tcase IPV6_RECVFRAGSIZE:",
                        "\t\tnp->rxopt.bits.recvfragsize = valbool;",
                        "\t\tretv = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\trelease_sock(sk);",
                        "\tif (needs_rtnl)",
                        "\t\trtnl_unlock();",
                        "",
                        "\treturn retv;",
                        "",
                        "e_inval:",
                        "\trelease_sock(sk);",
                        "\tif (needs_rtnl)",
                        "\t\trtnl_unlock();",
                        "\treturn -EINVAL;",
                        "}"
                    ],
                    "start": 139,
                    "highlight": 435
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82080363"
        },
        "478": {
            "name": "do_ipv6_setsockopt",
            "parent_idx": 474,
            "source_line": [
                {
                    "file": "net/ipv6/ipv6_sockglue.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/ipv6_sockglue.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n949",
                    "code": [
                        "\terr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);",
                        "#ifdef CONFIG_NETFILTER",
                        "\t/* we need to exclude all possible ENOPROTOOPTs except default case */",
                        "\tif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&",
                        "\t\t\toptname != IPV6_XFRM_POLICY)",
                        "\t\terr = nf_setsockopt(sk, PF_INET6, optname, optval, optlen);",
                        "#endif",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 949,
                    "highlight": 949
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82082886"
        },
        "474": {
            "name": "ipv6_setsockopt(indirect)",
            "parent_idx": 460,
            "source_line": [
                {
                    "file": "net/sctp/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sctp/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n4685",
                    "code": [
                        "/* API 6.2 setsockopt(), getsockopt()",
                        " *",
                        " * Applications use setsockopt() and getsockopt() to set or retrieve",
                        " * socket options.  Socket options are used to change the default",
                        " * behavior of sockets calls.  They are described in Section 7.",
                        " *",
                        " * The syntax is:",
                        " *",
                        " *   ret = getsockopt(int sd, int level, int optname, void __user *optval,",
                        " *                    int __user *optlen);",
                        " *   ret = setsockopt(int sd, int level, int optname, const void __user *optval,",
                        " *                    int optlen);",
                        " *",
                        " *   sd      - the socket descript.",
                        " *   level   - set to IPPROTO_SCTP for all SCTP options.",
                        " *   optname - the option name.",
                        " *   optval  - the buffer to store the value of the option.",
                        " *   optlen  - the size of the buffer.",
                        " */",
                        "static int sctp_setsockopt(struct sock *sk, int level, int optname,",
                        "\t\t\t   char __user *optval, unsigned int optlen)",
                        "{",
                        "\tint retval = 0;",
                        "",
                        "\tpr_debug(\"%s: sk:%p, optname:%d\\n\", __func__, sk, optname);",
                        "",
                        "\t/* I can hardly begin to describe how wrong this is.  This is",
                        "\t * so broken as to be worse than useless.  The API draft",
                        "\t * REALLY is NOT helpful here...  I am not convinced that the",
                        "\t * semantics of setsockopt() with a level OTHER THAN SOL_SCTP",
                        "\t * are at all well-founded.",
                        "\t */",
                        "\tif (level != SOL_SCTP) {",
                        "\t\tstruct sctp_af *af = sctp_sk(sk)->pf->af;",
                        "\t\tretval = af->setsockopt(sk, level, optname, optval, optlen);",
                        "\t\tgoto out_nounlock;",
                        "\t}",
                        "",
                        "\tlock_sock(sk);",
                        "",
                        "\tswitch (optname) {",
                        "\tcase SCTP_SOCKOPT_BINDX_ADD:",
                        "\t\t/* 'optlen' is the size of the addresses buffer. */",
                        "\t\tretval = sctp_setsockopt_bindx(sk, (struct sockaddr __user *)optval,",
                        "\t\t\t\t\t       optlen, SCTP_BINDX_ADD_ADDR);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_SOCKOPT_BINDX_REM:",
                        "\t\t/* 'optlen' is the size of the addresses buffer. */",
                        "\t\tretval = sctp_setsockopt_bindx(sk, (struct sockaddr __user *)optval,",
                        "\t\t\t\t\t       optlen, SCTP_BINDX_REM_ADDR);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_SOCKOPT_CONNECTX_OLD:",
                        "\t\t/* 'optlen' is the size of the addresses buffer. */",
                        "\t\tretval = sctp_setsockopt_connectx_old(sk,",
                        "\t\t\t\t\t    (struct sockaddr __user *)optval,",
                        "\t\t\t\t\t    optlen);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_SOCKOPT_CONNECTX:",
                        "\t\t/* 'optlen' is the size of the addresses buffer. */",
                        "\t\tretval = sctp_setsockopt_connectx(sk,",
                        "\t\t\t\t\t    (struct sockaddr __user *)optval,",
                        "\t\t\t\t\t    optlen);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DISABLE_FRAGMENTS:",
                        "\t\tretval = sctp_setsockopt_disable_fragments(sk, optval, optlen);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_EVENTS:",
                        "\t\tretval = sctp_setsockopt_events(sk, optval, optlen);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_AUTOCLOSE:",
                        "\t\tretval = sctp_setsockopt_autoclose(sk, optval, optlen);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_PEER_ADDR_PARAMS:",
                        "\t\tretval = sctp_setsockopt_peer_addr_params(sk, optval, optlen);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_DELAYED_SACK:",
                        "\t\tretval = sctp_setsockopt_delayed_ack(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_PARTIAL_DELIVERY_POINT:",
                        "\t\tretval = sctp_setsockopt_partial_delivery_point(sk, optval, optlen);",
                        "\t\tbreak;",
                        "",
                        "\tcase SCTP_INITMSG:",
                        "\t\tretval = sctp_setsockopt_initmsg(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_DEFAULT_SEND_PARAM:",
                        "\t\tretval = sctp_setsockopt_default_send_param(sk, optval,",
                        "\t\t\t\t\t\t\t    optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_DEFAULT_SNDINFO:",
                        "\t\tretval = sctp_setsockopt_default_sndinfo(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_PRIMARY_ADDR:",
                        "\t\tretval = sctp_setsockopt_primary_addr(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_SET_PEER_PRIMARY_ADDR:",
                        "\t\tretval = sctp_setsockopt_peer_primary_addr(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_NODELAY:",
                        "\t\tretval = sctp_setsockopt_nodelay(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_RTOINFO:",
                        "\t\tretval = sctp_setsockopt_rtoinfo(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_ASSOCINFO:",
                        "\t\tretval = sctp_setsockopt_associnfo(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_I_WANT_MAPPED_V4_ADDR:",
                        "\t\tretval = sctp_setsockopt_mappedv4(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_MAXSEG:",
                        "\t\tretval = sctp_setsockopt_maxseg(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_ADAPTATION_LAYER:",
                        "\t\tretval = sctp_setsockopt_adaptation_layer(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_CONTEXT:",
                        "\t\tretval = sctp_setsockopt_context(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_FRAGMENT_INTERLEAVE:",
                        "\t\tretval = sctp_setsockopt_fragment_interleave(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_MAX_BURST:",
                        "\t\tretval = sctp_setsockopt_maxburst(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_AUTH_CHUNK:",
                        "\t\tretval = sctp_setsockopt_auth_chunk(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_HMAC_IDENT:",
                        "\t\tretval = sctp_setsockopt_hmac_ident(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_AUTH_KEY:",
                        "\t\tretval = sctp_setsockopt_auth_key(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_AUTH_ACTIVE_KEY:",
                        "\t\tretval = sctp_setsockopt_active_key(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_AUTH_DELETE_KEY:",
                        "\t\tretval = sctp_setsockopt_del_key(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_AUTH_DEACTIVATE_KEY:",
                        "\t\tretval = sctp_setsockopt_deactivate_key(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_AUTO_ASCONF:",
                        "\t\tretval = sctp_setsockopt_auto_asconf(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_PEER_ADDR_THLDS:",
                        "\t\tretval = sctp_setsockopt_paddr_thresholds(sk, optval, optlen,",
                        "\t\t\t\t\t\t\t  false);",
                        "\t\tbreak;",
                        "\tcase SCTP_PEER_ADDR_THLDS_V2:",
                        "\t\tretval = sctp_setsockopt_paddr_thresholds(sk, optval, optlen,",
                        "\t\t\t\t\t\t\t  true);",
                        "\t\tbreak;",
                        "\tcase SCTP_RECVRCVINFO:",
                        "\t\tretval = sctp_setsockopt_recvrcvinfo(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_RECVNXTINFO:",
                        "\t\tretval = sctp_setsockopt_recvnxtinfo(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_PR_SUPPORTED:",
                        "\t\tretval = sctp_setsockopt_pr_supported(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_DEFAULT_PRINFO:",
                        "\t\tretval = sctp_setsockopt_default_prinfo(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_RECONFIG_SUPPORTED:",
                        "\t\tretval = sctp_setsockopt_reconfig_supported(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_ENABLE_STREAM_RESET:",
                        "\t\tretval = sctp_setsockopt_enable_strreset(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_RESET_STREAMS:",
                        "\t\tretval = sctp_setsockopt_reset_streams(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_RESET_ASSOC:",
                        "\t\tretval = sctp_setsockopt_reset_assoc(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_ADD_STREAMS:",
                        "\t\tretval = sctp_setsockopt_add_streams(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_STREAM_SCHEDULER:",
                        "\t\tretval = sctp_setsockopt_scheduler(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_STREAM_SCHEDULER_VALUE:",
                        "\t\tretval = sctp_setsockopt_scheduler_value(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_INTERLEAVING_SUPPORTED:",
                        "\t\tretval = sctp_setsockopt_interleaving_supported(sk, optval,",
                        "\t\t\t\t\t\t\t\toptlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_REUSE_PORT:",
                        "\t\tretval = sctp_setsockopt_reuse_port(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_EVENT:",
                        "\t\tretval = sctp_setsockopt_event(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_ASCONF_SUPPORTED:",
                        "\t\tretval = sctp_setsockopt_asconf_supported(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_AUTH_SUPPORTED:",
                        "\t\tretval = sctp_setsockopt_auth_supported(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_ECN_SUPPORTED:",
                        "\t\tretval = sctp_setsockopt_ecn_supported(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tcase SCTP_EXPOSE_POTENTIALLY_FAILED_STATE:",
                        "\t\tretval = sctp_setsockopt_pf_expose(sk, optval, optlen);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tretval = -ENOPROTOOPT;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\trelease_sock(sk);",
                        "",
                        "out_nounlock:",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 4651,
                    "highlight": 4685
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8216e99a"
        },
        "460": {
            "name": "sock_common_setsockopt(indirect)",
            "parent_idx": 410,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2132",
                    "code": [
                        "static int __sys_setsockopt(int fd, int level, int optname,",
                        "\t\t\t    char __user *optval, int optlen)",
                        "{",
                        "\tmm_segment_t oldfs = get_fs();",
                        "\tchar *kernel_optval = NULL;",
                        "\tint err, fput_needed;",
                        "\tstruct socket *sock;",
                        "",
                        "\tif (optlen < 0)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (sock != NULL) {",
                        "\t\terr = security_socket_setsockopt(sock, level, optname);",
                        "\t\tif (err)",
                        "\t\t\tgoto out_put;",
                        "",
                        "\t\terr = BPF_CGROUP_RUN_PROG_SETSOCKOPT(sock->sk, &level,",
                        "\t\t\t\t\t\t     &optname, optval, &optlen,",
                        "\t\t\t\t\t\t     &kernel_optval);",
                        "",
                        "\t\tif (err < 0) {",
                        "\t\t\tgoto out_put;",
                        "\t\t} else if (err > 0) {",
                        "\t\t\terr = 0;",
                        "\t\t\tgoto out_put;",
                        "\t\t}",
                        "",
                        "\t\tif (kernel_optval) {",
                        "\t\t\tset_fs(KERNEL_DS);",
                        "\t\t\toptval = (char __user __force *)kernel_optval;",
                        "\t\t}",
                        "",
                        "\t\tif (level == SOL_SOCKET)",
                        "\t\t\terr =",
                        "\t\t\t    sock_setsockopt(sock, level, optname, optval,",
                        "\t\t\t\t\t    optlen);",
                        "\t\telse",
                        "\t\t\terr =",
                        "\t\t\t    sock->ops->setsockopt(sock, level, optname, optval,",
                        "\t\t\t\t\t\t  optlen);",
                        "",
                        "\t\tif (kernel_optval) {",
                        "\t\t\tset_fs(oldfs);",
                        "\t\t\tkfree(kernel_optval);",
                        "\t\t}",
                        "out_put:",
                        "\t\tfput_light(sock->file, fput_needed);",
                        "\t}",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2093,
                    "highlight": 2132
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e36f46"
        },
        "410": {
            "name": "__sys_setsockopt",
            "parent_idx": 403,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2148",
                    "code": [
                        "SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,",
                        "\t\tchar __user *, optval, int, optlen)",
                        "{",
                        "\treturn __sys_setsockopt(fd, level, optname, optval, optlen);",
                        "}"
                    ],
                    "start": 2145,
                    "highlight": 2148
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2145",
                    "code": [
                        "static int __sys_setsockopt(int fd, int level, int optname,",
                        "\t\t\t    char __user *optval, int optlen)",
                        "{",
                        "\tmm_segment_t oldfs = get_fs();",
                        "\tchar *kernel_optval = NULL;",
                        "\tint err, fput_needed;",
                        "\tstruct socket *sock;",
                        "",
                        "\tif (optlen < 0)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (sock != NULL) {",
                        "\t\terr = security_socket_setsockopt(sock, level, optname);",
                        "\t\tif (err)",
                        "\t\t\tgoto out_put;",
                        "",
                        "\t\terr = BPF_CGROUP_RUN_PROG_SETSOCKOPT(sock->sk, &level,",
                        "\t\t\t\t\t\t     &optname, optval, &optlen,",
                        "\t\t\t\t\t\t     &kernel_optval);",
                        "",
                        "\t\tif (err < 0) {",
                        "\t\t\tgoto out_put;",
                        "\t\t} else if (err > 0) {",
                        "\t\t\terr = 0;",
                        "\t\t\tgoto out_put;",
                        "\t\t}",
                        "",
                        "\t\tif (kernel_optval) {",
                        "\t\t\tset_fs(KERNEL_DS);",
                        "\t\t\toptval = (char __user __force *)kernel_optval;",
                        "\t\t}",
                        "",
                        "\t\tif (level == SOL_SOCKET)",
                        "\t\t\terr =",
                        "\t\t\t    sock_setsockopt(sock, level, optname, optval,",
                        "\t\t\t\t\t    optlen);",
                        "\t\telse",
                        "\t\t\terr =",
                        "\t\t\t    sock->ops->setsockopt(sock, level, optname, optval,",
                        "\t\t\t\t\t\t  optlen);",
                        "",
                        "\t\tif (kernel_optval) {",
                        "\t\t\tset_fs(oldfs);",
                        "\t\t\tkfree(kernel_optval);",
                        "\t\t}",
                        "out_put:",
                        "\t\tfput_light(sock->file, fput_needed);",
                        "\t}",
                        "\treturn err;",
                        "}",
                        "",
                        "SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,",
                        "\t\tchar __user *, optval, int, optlen)",
                        "{",
                        "\treturn __sys_setsockopt(fd, level, optname, optval, optlen);",
                        "}"
                    ],
                    "start": 2093,
                    "highlight": 2145
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e37037"
        },
        "403": {
            "name": "__x64_sys_setsockopt(indirect)",
            "parent_idx": 400,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n295",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 282,
                    "highlight": 295
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81003f95"
        },
        "400": {
            "name": "do_syscall_64",
            "parent_idx": 387,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_ON\t\t\t/* return enables interrupts */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "387": {
            "name": "66_syscall_5",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "547": {
            "name": "+0x126",
            "parent_idx": 517,
            "source_line": [
                {
                    "file": "net/ipv6/exthdrs.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/exthdrs.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n1282",
                    "code": [
                        "/**",
                        " * ipv6_renew_options - replace a specific ext hdr with a new one.",
                        " *",
                        " * @sk: sock from which to allocate memory",
                        " * @opt: original options",
                        " * @newtype: option type to replace in @opt",
                        " * @newopt: new option of type @newtype to replace (user-mem)",
                        " * @newoptlen: length of @newopt",
                        " *",
                        " * Returns a new set of options which is a copy of @opt with the",
                        " * option type @newtype replaced with @newopt.",
                        " *",
                        " * @opt may be NULL, in which case a new set of options is returned",
                        " * containing just @newopt.",
                        " *",
                        " * @newopt may be NULL, in which case the specified option type is",
                        " * not copied into the new set of options.",
                        " *",
                        " * The new set of options is allocated from the socket option memory",
                        " * buffer of @sk.",
                        " */",
                        "struct ipv6_txoptions *",
                        "ipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,",
                        "\t\t   int newtype, struct ipv6_opt_hdr *newopt)",
                        "{",
                        "\tint tot_len = 0;",
                        "\tchar *p;",
                        "\tstruct ipv6_txoptions *opt2;",
                        "",
                        "\tif (opt) {",
                        "\t\tif (newtype != IPV6_HOPOPTS && opt->hopopt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->hopopt));",
                        "\t\tif (newtype != IPV6_RTHDRDSTOPTS && opt->dst0opt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst0opt));",
                        "\t\tif (newtype != IPV6_RTHDR && opt->srcrt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->srcrt));",
                        "\t\tif (newtype != IPV6_DSTOPTS && opt->dst1opt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst1opt));",
                        "\t}",
                        "",
                        "\tif (newopt)",
                        "\t\ttot_len += CMSG_ALIGN(ipv6_optlen(newopt));",
                        "",
                        "\tif (!tot_len)",
                        "\t\treturn NULL;",
                        "",
                        "\ttot_len += sizeof(*opt2);",
                        "\topt2 = sock_kmalloc(sk, tot_len, GFP_ATOMIC);",
                        "\tif (!opt2)",
                        "\t\treturn ERR_PTR(-ENOBUFS);",
                        "",
                        "\tmemset(opt2, 0, tot_len);",
                        "\trefcount_set(&opt2->refcnt, 1);",
                        "\topt2->tot_len = tot_len;",
                        "\tp = (char *)(opt2 + 1);",
                        "",
                        "\tipv6_renew_option(IPV6_HOPOPTS, &opt2->hopopt,",
                        "\t\t\t  (opt ? opt->hopopt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_RTHDRDSTOPTS, &opt2->dst0opt,",
                        "\t\t\t  (opt ? opt->dst0opt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_RTHDR,",
                        "\t\t\t  (struct ipv6_opt_hdr **)&opt2->srcrt,",
                        "\t\t\t  (opt ? (struct ipv6_opt_hdr *)opt->srcrt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_DSTOPTS, &opt2->dst1opt,",
                        "\t\t\t  (opt ? opt->dst1opt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "",
                        "\topt2->opt_nflen = (opt2->hopopt ? ipv6_optlen(opt2->hopopt) : 0) +",
                        "\t\t\t  (opt2->dst0opt ? ipv6_optlen(opt2->dst0opt) : 0) +",
                        "\t\t\t  (opt2->srcrt ? ipv6_optlen(opt2->srcrt) : 0);",
                        "\topt2->opt_flen = (opt2->dst1opt ? ipv6_optlen(opt2->dst1opt) : 0);",
                        "",
                        "\treturn opt2;",
                        "}"
                    ],
                    "start": 1228,
                    "highlight": 1282
                }
            ],
            "ins_idx": 35,
            "addr": "0xffffffff820aa966"
        },
        "537": {
            "name": "+0xe2",
            "parent_idx": 517,
            "source_line": [
                {
                    "file": "net/ipv6/exthdrs.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/exthdrs.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n1275",
                    "code": [
                        "/**",
                        " * ipv6_renew_options - replace a specific ext hdr with a new one.",
                        " *",
                        " * @sk: sock from which to allocate memory",
                        " * @opt: original options",
                        " * @newtype: option type to replace in @opt",
                        " * @newopt: new option of type @newtype to replace (user-mem)",
                        " * @newoptlen: length of @newopt",
                        " *",
                        " * Returns a new set of options which is a copy of @opt with the",
                        " * option type @newtype replaced with @newopt.",
                        " *",
                        " * @opt may be NULL, in which case a new set of options is returned",
                        " * containing just @newopt.",
                        " *",
                        " * @newopt may be NULL, in which case the specified option type is",
                        " * not copied into the new set of options.",
                        " *",
                        " * The new set of options is allocated from the socket option memory",
                        " * buffer of @sk.",
                        " */",
                        "struct ipv6_txoptions *",
                        "ipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,",
                        "\t\t   int newtype, struct ipv6_opt_hdr *newopt)",
                        "{",
                        "\tint tot_len = 0;",
                        "\tchar *p;",
                        "\tstruct ipv6_txoptions *opt2;",
                        "",
                        "\tif (opt) {",
                        "\t\tif (newtype != IPV6_HOPOPTS && opt->hopopt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->hopopt));",
                        "\t\tif (newtype != IPV6_RTHDRDSTOPTS && opt->dst0opt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst0opt));",
                        "\t\tif (newtype != IPV6_RTHDR && opt->srcrt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->srcrt));",
                        "\t\tif (newtype != IPV6_DSTOPTS && opt->dst1opt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst1opt));",
                        "\t}",
                        "",
                        "\tif (newopt)",
                        "\t\ttot_len += CMSG_ALIGN(ipv6_optlen(newopt));",
                        "",
                        "\tif (!tot_len)",
                        "\t\treturn NULL;",
                        "",
                        "\ttot_len += sizeof(*opt2);",
                        "\topt2 = sock_kmalloc(sk, tot_len, GFP_ATOMIC);",
                        "\tif (!opt2)",
                        "\t\treturn ERR_PTR(-ENOBUFS);",
                        "",
                        "\tmemset(opt2, 0, tot_len);",
                        "\trefcount_set(&opt2->refcnt, 1);",
                        "\topt2->tot_len = tot_len;",
                        "\tp = (char *)(opt2 + 1);",
                        "",
                        "\tipv6_renew_option(IPV6_HOPOPTS, &opt2->hopopt,",
                        "\t\t\t  (opt ? opt->hopopt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_RTHDRDSTOPTS, &opt2->dst0opt,",
                        "\t\t\t  (opt ? opt->dst0opt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_RTHDR,",
                        "\t\t\t  (struct ipv6_opt_hdr **)&opt2->srcrt,",
                        "\t\t\t  (opt ? (struct ipv6_opt_hdr *)opt->srcrt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_DSTOPTS, &opt2->dst1opt,",
                        "\t\t\t  (opt ? opt->dst1opt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "",
                        "\topt2->opt_nflen = (opt2->hopopt ? ipv6_optlen(opt2->hopopt) : 0) +",
                        "\t\t\t  (opt2->dst0opt ? ipv6_optlen(opt2->dst0opt) : 0) +",
                        "\t\t\t  (opt2->srcrt ? ipv6_optlen(opt2->srcrt) : 0);",
                        "\topt2->opt_flen = (opt2->dst1opt ? ipv6_optlen(opt2->dst1opt) : 0);",
                        "",
                        "\treturn opt2;",
                        "}"
                    ],
                    "start": 1228,
                    "highlight": 1275
                }
            ],
            "ins_idx": 59,
            "addr": "0xffffffff820aa922"
        },
        "534": {
            "name": "+0x83",
            "parent_idx": 527,
            "source_line": [
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2172",
                    "code": [
                        "/*",
                        " * Allocate a memory block from the socket's option memory buffer.",
                        " */",
                        "void *sock_kmalloc(struct sock *sk, int size, gfp_t priority)",
                        "{",
                        "\tif ((unsigned int)size <= sysctl_optmem_max &&",
                        "\t    atomic_read(&sk->sk_omem_alloc) + size < sysctl_optmem_max) {",
                        "\t\tvoid *mem;",
                        "\t\t/* First do the add, to avoid the race if kmalloc",
                        "\t\t * might sleep.",
                        "\t\t */",
                        "\t\tatomic_add(size, &sk->sk_omem_alloc);",
                        "\t\tmem = kmalloc(size, priority);",
                        "\t\tif (mem)",
                        "\t\t\treturn mem;",
                        "\t\tatomic_sub(size, &sk->sk_omem_alloc);",
                        "\t}",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 2154,
                    "highlight": 2172
                }
            ],
            "ins_idx": 72,
            "addr": "0xffffffff81e3f563"
        },
        "527": {
            "name": "sock_kmalloc",
            "parent_idx": 517,
            "source_line": [
                {
                    "file": "net/ipv6/exthdrs.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/exthdrs.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n1275",
                    "code": [
                        "/**",
                        " * ipv6_renew_options - replace a specific ext hdr with a new one.",
                        " *",
                        " * @sk: sock from which to allocate memory",
                        " * @opt: original options",
                        " * @newtype: option type to replace in @opt",
                        " * @newopt: new option of type @newtype to replace (user-mem)",
                        " * @newoptlen: length of @newopt",
                        " *",
                        " * Returns a new set of options which is a copy of @opt with the",
                        " * option type @newtype replaced with @newopt.",
                        " *",
                        " * @opt may be NULL, in which case a new set of options is returned",
                        " * containing just @newopt.",
                        " *",
                        " * @newopt may be NULL, in which case the specified option type is",
                        " * not copied into the new set of options.",
                        " *",
                        " * The new set of options is allocated from the socket option memory",
                        " * buffer of @sk.",
                        " */",
                        "struct ipv6_txoptions *",
                        "ipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,",
                        "\t\t   int newtype, struct ipv6_opt_hdr *newopt)",
                        "{",
                        "\tint tot_len = 0;",
                        "\tchar *p;",
                        "\tstruct ipv6_txoptions *opt2;",
                        "",
                        "\tif (opt) {",
                        "\t\tif (newtype != IPV6_HOPOPTS && opt->hopopt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->hopopt));",
                        "\t\tif (newtype != IPV6_RTHDRDSTOPTS && opt->dst0opt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst0opt));",
                        "\t\tif (newtype != IPV6_RTHDR && opt->srcrt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->srcrt));",
                        "\t\tif (newtype != IPV6_DSTOPTS && opt->dst1opt)",
                        "\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst1opt));",
                        "\t}",
                        "",
                        "\tif (newopt)",
                        "\t\ttot_len += CMSG_ALIGN(ipv6_optlen(newopt));",
                        "",
                        "\tif (!tot_len)",
                        "\t\treturn NULL;",
                        "",
                        "\ttot_len += sizeof(*opt2);",
                        "\topt2 = sock_kmalloc(sk, tot_len, GFP_ATOMIC);",
                        "\tif (!opt2)",
                        "\t\treturn ERR_PTR(-ENOBUFS);",
                        "",
                        "\tmemset(opt2, 0, tot_len);",
                        "\trefcount_set(&opt2->refcnt, 1);",
                        "\topt2->tot_len = tot_len;",
                        "\tp = (char *)(opt2 + 1);",
                        "",
                        "\tipv6_renew_option(IPV6_HOPOPTS, &opt2->hopopt,",
                        "\t\t\t  (opt ? opt->hopopt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_RTHDRDSTOPTS, &opt2->dst0opt,",
                        "\t\t\t  (opt ? opt->dst0opt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_RTHDR,",
                        "\t\t\t  (struct ipv6_opt_hdr **)&opt2->srcrt,",
                        "\t\t\t  (opt ? (struct ipv6_opt_hdr *)opt->srcrt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "\tipv6_renew_option(IPV6_DSTOPTS, &opt2->dst1opt,",
                        "\t\t\t  (opt ? opt->dst1opt : NULL),",
                        "\t\t\t  newopt, newtype, &p);",
                        "",
                        "\topt2->opt_nflen = (opt2->hopopt ? ipv6_optlen(opt2->hopopt) : 0) +",
                        "\t\t\t  (opt2->dst0opt ? ipv6_optlen(opt2->dst0opt) : 0) +",
                        "\t\t\t  (opt2->srcrt ? ipv6_optlen(opt2->srcrt) : 0);",
                        "\topt2->opt_flen = (opt2->dst1opt ? ipv6_optlen(opt2->dst1opt) : 0);",
                        "",
                        "\treturn opt2;",
                        "}"
                    ],
                    "start": 1228,
                    "highlight": 1275
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff820aa91d"
        },
        "533": {
            "name": "+0x61",
            "parent_idx": 527,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n560",
                    "code": [
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 555,
                    "highlight": 560
                },
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2166",
                    "code": [
                        "/*",
                        " * Allocate a memory block from the socket's option memory buffer.",
                        " */",
                        "void *sock_kmalloc(struct sock *sk, int size, gfp_t priority)",
                        "{",
                        "\tif ((unsigned int)size <= sysctl_optmem_max &&",
                        "\t    atomic_read(&sk->sk_omem_alloc) + size < sysctl_optmem_max) {",
                        "\t\tvoid *mem;",
                        "\t\t/* First do the add, to avoid the race if kmalloc",
                        "\t\t * might sleep.",
                        "\t\t */",
                        "\t\tatomic_add(size, &sk->sk_omem_alloc);",
                        "\t\tmem = kmalloc(size, priority);",
                        "\t\tif (mem)",
                        "\t\t\treturn mem;",
                        "\t\tatomic_sub(size, &sk->sk_omem_alloc);",
                        "\t}",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 2154,
                    "highlight": 2166
                },
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2157",
                    "code": [
                        "/*",
                        " * Allocate a memory block from the socket's option memory buffer.",
                        " */",
                        "void *sock_kmalloc(struct sock *sk, int size, gfp_t priority)",
                        "{",
                        "\tif ((unsigned int)size <= sysctl_optmem_max &&",
                        "\t    atomic_read(&sk->sk_omem_alloc) + size < sysctl_optmem_max) {",
                        "\t\tvoid *mem;",
                        "\t\t/* First do the add, to avoid the race if kmalloc",
                        "\t\t * might sleep.",
                        "\t\t */",
                        "\t\tatomic_add(size, &sk->sk_omem_alloc);",
                        "\t\tmem = kmalloc(size, priority);",
                        "\t\tif (mem)",
                        "\t\t\treturn mem;",
                        "\t\tatomic_sub(size, &sk->sk_omem_alloc);",
                        "\t}",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 2154,
                    "highlight": 2157
                }
            ],
            "ins_idx": 85,
            "addr": "0xffffffff81e3f541"
        },
        "532": {
            "name": "+0x3b",
            "parent_idx": 531,
            "source_line": [
                {
                    "file": "mm/kasan/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/kasan/common.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n52",
                    "code": [
                        "static inline depot_stack_handle_t save_stack(gfp_t flags)",
                        "{",
                        "\tunsigned long entries[KASAN_STACK_DEPTH];",
                        "\tunsigned int nr_entries;",
                        "",
                        "\tnr_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 0);",
                        "\tnr_entries = filter_irq_stacks(entries, nr_entries);",
                        "\treturn stack_depot_save(entries, nr_entries, flags);",
                        "}"
                    ],
                    "start": 44,
                    "highlight": 52
                }
            ],
            "ins_idx": 95,
            "addr": "0xffffffff8130490b"
        },
        "531": {
            "name": "__kmalloc",
            "parent_idx": 527,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n560",
                    "code": [
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 555,
                    "highlight": 560
                },
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2166",
                    "code": [
                        "/*",
                        " * Allocate a memory block from the socket's option memory buffer.",
                        " */",
                        "void *sock_kmalloc(struct sock *sk, int size, gfp_t priority)",
                        "{",
                        "\tif ((unsigned int)size <= sysctl_optmem_max &&",
                        "\t    atomic_read(&sk->sk_omem_alloc) + size < sysctl_optmem_max) {",
                        "\t\tvoid *mem;",
                        "\t\t/* First do the add, to avoid the race if kmalloc",
                        "\t\t * might sleep.",
                        "\t\t */",
                        "\t\tatomic_add(size, &sk->sk_omem_alloc);",
                        "\t\tmem = kmalloc(size, priority);",
                        "\t\tif (mem)",
                        "\t\t\treturn mem;",
                        "\t\tatomic_sub(size, &sk->sk_omem_alloc);",
                        "\t}",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 2154,
                    "highlight": 2166
                },
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=152036d1379ffd6985262743dcf6b0f9c75f83a4#n2157",
                    "code": [
                        "/*",
                        " * Allocate a memory block from the socket's option memory buffer.",
                        " */",
                        "void *sock_kmalloc(struct sock *sk, int size, gfp_t priority)",
                        "{",
                        "\tif ((unsigned int)size <= sysctl_optmem_max &&",
                        "\t    atomic_read(&sk->sk_omem_alloc) + size < sysctl_optmem_max) {",
                        "\t\tvoid *mem;",
                        "\t\t/* First do the add, to avoid the race if kmalloc",
                        "\t\t * might sleep.",
                        "\t\t */",
                        "\t\tatomic_add(size, &sk->sk_omem_alloc);",
                        "\t\tmem = kmalloc(size, priority);",
                        "\t\tif (mem)",
                        "\t\t\treturn mem;",
                        "\t\tatomic_sub(size, &sk->sk_omem_alloc);",
                        "\t}",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 2154,
                    "highlight": 2157
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e3f53c"
        }
    },
    "ins": {
        "1": {
            "name": "mov rax, qword ptr [r12 + 8]",
            "desc": "Invalid Memory Access\nOut of Bound Access.",
            "call_idx": 883,
            "inputs": [
                1588,
                1589
            ],
            "outputs": [
                1590
            ]
        },
        "3": {
            "name": "add r12, rax",
            "desc": "",
            "call_idx": 882,
            "inputs": [
                1585,
                1586
            ],
            "outputs": [
                1587
            ]
        },
        "5": {
            "name": "mov r12, qword ptr [r12 + 0x20]",
            "desc": "",
            "call_idx": 879,
            "inputs": [
                1577,
                1578
            ],
            "outputs": [
                1579
            ]
        },
        "9": {
            "name": "mov qword ptr [r12 + 0x20], rbp",
            "desc": "",
            "call_idx": 566,
            "inputs": [
                1050,
                1051
            ],
            "outputs": [
                1052
            ]
        },
        "35": {
            "name": "lea rbp, qword ptr [r12 + 0x40]",
            "desc": "",
            "call_idx": 547,
            "inputs": [
                1012
            ],
            "outputs": [
                1013
            ]
        },
        "59": {
            "name": "mov r12, rax",
            "desc": "",
            "call_idx": 537,
            "inputs": [
                994
            ],
            "outputs": [
                995
            ]
        },
        "72": {
            "name": "mov rax, r12",
            "desc": "",
            "call_idx": 534,
            "inputs": [
                988
            ],
            "outputs": [
                989
            ]
        },
        "85": {
            "name": "mov r12, rax",
            "desc": "",
            "call_idx": 533,
            "inputs": [
                986
            ],
            "outputs": [
                987
            ]
        },
        "95": {
            "name": "ret ",
            "desc": "",
            "call_idx": 532,
            "inputs": [],
            "outputs": [
                985
            ]
        }
    },
    "data": {
        "1588": {
            "name": "R12",
            "ins_idx": 1,
            "value": "0xffff8881e88f67d0",
            "sources": []
        },
        "1589": {
            "name": "[0xffff8881e88f67d8]",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "1590": {
            "name": "RAX",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "1585": {
            "name": "R12",
            "ins_idx": 3,
            "value": "0xffff8881e88f67c0",
            "sources": []
        },
        "1586": {
            "name": "RAX",
            "ins_idx": 3,
            "value": "0x10",
            "sources": []
        },
        "1587": {
            "name": "R12",
            "ins_idx": 3,
            "value": "0xffff8881e88f67d0",
            "sources": [
                1588
            ]
        },
        "1577": {
            "name": "R12",
            "ins_idx": 5,
            "value": "0xffff8881e88f6780",
            "sources": []
        },
        "1578": {
            "name": "[0xffff8881e88f67a0]",
            "ins_idx": 5,
            "value": "0xffff8881e88f67c0",
            "sources": []
        },
        "1579": {
            "name": "R12",
            "ins_idx": 5,
            "value": "0xffff8881e88f67c0",
            "sources": [
                1585
            ]
        },
        "1050": {
            "name": "R12",
            "ins_idx": 9,
            "value": "0xffff8881e88f6780",
            "sources": []
        },
        "1051": {
            "name": "RBP",
            "ins_idx": 9,
            "value": "0xffff8881e88f67c0",
            "sources": []
        },
        "1052": {
            "name": "[0xffff8881e88f67a0]",
            "ins_idx": 9,
            "value": "0xffff8881e88f67c0",
            "sources": [
                1578
            ]
        },
        "1012": {
            "name": "R12",
            "ins_idx": 35,
            "value": "0xffff8881e88f6780",
            "sources": []
        },
        "1013": {
            "name": "RBP",
            "ins_idx": 35,
            "value": "0xffff8881e88f67c0",
            "sources": [
                1051
            ]
        },
        "994": {
            "name": "RAX",
            "ins_idx": 59,
            "value": "0xffff8881e88f6780",
            "sources": []
        },
        "995": {
            "name": "R12",
            "ins_idx": 59,
            "value": "0xffff8881e88f6780",
            "sources": [
                1012
            ]
        },
        "988": {
            "name": "R12",
            "ins_idx": 72,
            "value": "0xffff8881e88f6780",
            "sources": []
        },
        "989": {
            "name": "RAX",
            "ins_idx": 72,
            "value": "0xffff8881e88f6780",
            "sources": [
                994
            ]
        },
        "986": {
            "name": "RAX",
            "ins_idx": 85,
            "value": "0xffff8881e88f6780",
            "sources": []
        },
        "987": {
            "name": "R12",
            "ins_idx": 85,
            "value": "0xffff8881e88f6780",
            "sources": [
                988
            ]
        },
        "985": {
            "name": "RAX",
            "ins_idx": 95,
            "value": "0xffff8881e88f6780",
            "sources": [
                986
            ]
        }
    },
    "chain": {
        "1": [
            3
        ],
        "3": [
            5
        ],
        "5": [
            9
        ],
        "9": [
            35
        ],
        "35": [
            59
        ],
        "59": [
            72
        ],
        "72": [
            85
        ],
        "85": [
            95
        ]
    }
}