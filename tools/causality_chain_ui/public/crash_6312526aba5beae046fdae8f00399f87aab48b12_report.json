{
    "report": "https://syzkaller.appspot.com/bug?id=6312526aba5beae046fdae8f00399f87aab48b12",
    "title": "KASAN: null-ptr-deref Read in filp_close (2)",
    "call": {
        "32771": {
            "name": "+0x24",
            "parent_idx": 32750,
            "source_line": [
                {
                    "file": "./arch/x86/include/asm/atomic64_64.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./arch/x86/include/asm/atomic64_64.h?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n22",
                    "code": [
                        "/**",
                        " * arch_atomic64_read - read atomic64 variable",
                        " * @v: pointer of type atomic64_t",
                        " *",
                        " * Atomically reads the value of @v.",
                        " * Doesn't imply a read memory barrier.",
                        " */",
                        "static inline s64 arch_atomic64_read(const atomic64_t *v)",
                        "{",
                        "\treturn __READ_ONCE((v)->counter);",
                        "}"
                    ],
                    "start": 13,
                    "highlight": 22
                },
                {
                    "file": "./include/asm-generic/atomic-instrumented.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/asm-generic/atomic-instrumented.h?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n606",
                    "code": [
                        "static __always_inline s64",
                        "atomic64_read(const atomic64_t *v)",
                        "{",
                        "\tinstrument_atomic_read(v, sizeof(*v));",
                        "\treturn arch_atomic64_read(v);",
                        "}"
                    ],
                    "start": 602,
                    "highlight": 606
                },
                {
                    "file": "./include/asm-generic/atomic-long.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/asm-generic/atomic-long.h?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n29",
                    "code": [
                        "static __always_inline long",
                        "atomic_long_read(const atomic_long_t *v)",
                        "{",
                        "\treturn atomic64_read(v);",
                        "}"
                    ],
                    "start": 26,
                    "highlight": 29
                },
                {
                    "file": "fs/open.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/open.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n1306",
                    "code": [
                        "/*",
                        " * \"id\" is the POSIX thread ID. We use the",
                        " * files pointer for this..",
                        " */",
                        "int filp_close(struct file *filp, fl_owner_t id)",
                        "{",
                        "\tint retval = 0;",
                        "",
                        "\tif (!file_count(filp)) {",
                        "\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\tif (filp->f_op->flush)",
                        "\t\tretval = filp->f_op->flush(filp, id);",
                        "",
                        "\tif (likely(!(filp->f_mode & FMODE_PATH))) {",
                        "\t\tdnotify_flush(filp, id);",
                        "\t\tlocks_remove_posix(filp, id);",
                        "\t}",
                        "\tfput(filp);",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 1298,
                    "highlight": 1306
                }
            ],
            "ins_idx": 341,
            "addr": "0xffffffff81328b14"
        },
        "32750": {
            "name": "close_fd",
            "parent_idx": 32747,
            "source_line": [
                {
                    "file": "fs/open.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/open.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n1331",
                    "code": [
                        "/*",
                        " * Careful here! We test whether the file pointer is NULL before",
                        " * releasing the fd. This ensures that one clone task can't release",
                        " * an fd while another clone is opening it.",
                        " */",
                        "SYSCALL_DEFINE1(close, unsigned int, fd)",
                        "{",
                        "\tint retval = close_fd(fd);",
                        "",
                        "\t/* can't restart close syscall because file table entry was cleared */",
                        "\tif (unlikely(retval == -ERESTARTSYS ||",
                        "\t\t     retval == -ERESTARTNOINTR ||",
                        "\t\t     retval == -ERESTARTNOHAND ||",
                        "\t\t     retval == -ERESTART_RESTARTBLOCK))",
                        "\t\tretval = -EINTR;",
                        "",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 1324,
                    "highlight": 1331
                },
                {
                    "file": "fs/open.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/open.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n1329",
                    "code": [
                        "/*",
                        " * \"id\" is the POSIX thread ID. We use the",
                        " * files pointer for this..",
                        " */",
                        "int filp_close(struct file *filp, fl_owner_t id)",
                        "{",
                        "\tint retval = 0;",
                        "",
                        "\tif (!file_count(filp)) {",
                        "\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\tif (filp->f_op->flush)",
                        "\t\tretval = filp->f_op->flush(filp, id);",
                        "",
                        "\tif (likely(!(filp->f_mode & FMODE_PATH))) {",
                        "\t\tdnotify_flush(filp, id);",
                        "\t\tlocks_remove_posix(filp, id);",
                        "\t}",
                        "\tfput(filp);",
                        "\treturn retval;",
                        "}",
                        "",
                        "EXPORT_SYMBOL(filp_close);",
                        "",
                        "/*",
                        " * Careful here! We test whether the file pointer is NULL before",
                        " * releasing the fd. This ensures that one clone task can't release",
                        " * an fd while another clone is opening it.",
                        " */",
                        "SYSCALL_DEFINE1(close, unsigned int, fd)",
                        "{",
                        "\tint retval = close_fd(fd);",
                        "",
                        "\t/* can't restart close syscall because file table entry was cleared */",
                        "\tif (unlikely(retval == -ERESTARTSYS ||",
                        "\t\t     retval == -ERESTARTNOINTR ||",
                        "\t\t     retval == -ERESTARTNOHAND ||",
                        "\t\t     retval == -ERESTART_RESTARTBLOCK))",
                        "\t\tretval = -EINTR;",
                        "",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 1298,
                    "highlight": 1329
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff813290a1"
        },
        "32747": {
            "name": "__x64_sys_close(indirect)",
            "parent_idx": 32744,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n50",
                    "code": [
                        "static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)",
                        "{",
                        "\t/*",
                        "\t * Convert negative numbers to very high and thus out of range",
                        "\t * numbers for comparisons.",
                        "\t */",
                        "\tunsigned int unr = nr;",
                        "",
                        "\tif (likely(unr < NR_syscalls)) {",
                        "\t\tunr = array_index_nospec(unr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[unr](regs);",
                        "\t\treturn true;",
                        "\t}",
                        "\treturn false;",
                        "}"
                    ],
                    "start": 40,
                    "highlight": 50
                },
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n80",
                    "code": [
                        "__visible noinstr void do_syscall_64(struct pt_regs *regs, int nr)",
                        "{",
                        "\tadd_random_kstack_offset();",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "",
                        "\tif (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {",
                        "\t\t/* Invalid system call, but still a system call. */",
                        "\t\tregs->ax = __x64_sys_ni_syscall(regs);",
                        "\t}",
                        "",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 73,
                    "highlight": 80
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff823840fe"
        },
        "32744": {
            "name": "do_syscall_64",
            "parent_idx": 32737,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n113",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rsp, %rdi",
                        "\t/* Sign extend the lower 32bit as syscall numbers are treated as int */",
                        "\tmovslq\t%eax, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t * In the Xen PV case we must use iret anyway.",
                        "\t */",
                        "",
                        "\tALTERNATIVE \"\", \"jmp\tswapgs_restore_regs_and_return_to_usermode\", \\",
                        "\t\tX86_FEATURE_XENPV",
                        "",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tswapgs",
                        "\tsysretq",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 87,
                    "highlight": 113
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "32737": {
            "name": "1336_syscall_52",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "32665": {
            "name": "+0xe5",
            "parent_idx": 32664,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n4336",
                    "code": [
                        "/*",
                        " * kmem_cache_shrink discards empty slabs and promotes the slabs filled",
                        " * up most to the head of the partial lists. New allocations will then",
                        " * fill those up and thus they can be removed from the partial lists.",
                        " *",
                        " * The slabs with the least items are placed last. This results in them",
                        " * being allocated from last increasing the chance that the last objects",
                        " * are freed in them.",
                        " */",
                        "int __kmem_cache_shrink(struct kmem_cache *s)",
                        "{",
                        "\tint node;",
                        "\tint i;",
                        "\tstruct kmem_cache_node *n;",
                        "\tstruct page *page;",
                        "\tstruct page *t;",
                        "\tstruct list_head discard;",
                        "\tstruct list_head promote[SHRINK_PROMOTE_MAX];",
                        "\tunsigned long flags;",
                        "\tint ret = 0;",
                        "",
                        "\tflush_all(s);",
                        "\tfor_each_kmem_cache_node(s, node, n) {",
                        "\t\tINIT_LIST_HEAD(&discard);",
                        "\t\tfor (i = 0; i < SHRINK_PROMOTE_MAX; i++)",
                        "\t\t\tINIT_LIST_HEAD(promote + i);",
                        "",
                        "\t\tspin_lock_irqsave(&n->list_lock, flags);",
                        "",
                        "\t\t/*",
                        "\t\t * Build lists of slabs to discard or promote.",
                        "\t\t *",
                        "\t\t * Note that concurrent frees may occur while we hold the",
                        "\t\t * list_lock. page->inuse here is the upper limit.",
                        "\t\t */",
                        "\t\tlist_for_each_entry_safe(page, t, &n->partial, slab_list) {",
                        "\t\t\tint free = page->objects - page->inuse;",
                        "",
                        "\t\t\t/* Do not reread page->inuse */",
                        "\t\t\tbarrier();",
                        "",
                        "\t\t\t/* We do not keep full slabs on the list */",
                        "\t\t\tBUG_ON(free <= 0);",
                        "",
                        "\t\t\tif (free == page->objects) {",
                        "\t\t\t\tlist_move(&page->slab_list, &discard);",
                        "\t\t\t\tn->nr_partial--;",
                        "\t\t\t} else if (free <= SHRINK_PROMOTE_MAX)",
                        "\t\t\t\tlist_move(&page->slab_list, promote + free - 1);",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * Promote the slabs filled up most to the head of the",
                        "\t\t * partial list.",
                        "\t\t */",
                        "\t\tfor (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)",
                        "\t\t\tlist_splice(promote + i, &n->partial);",
                        "",
                        "\t\tspin_unlock_irqrestore(&n->list_lock, flags);",
                        "",
                        "\t\t/* Release empty slabs */",
                        "\t\tlist_for_each_entry_safe(page, t, &discard, slab_list)",
                        "\t\t\tdiscard_slab(s, page);",
                        "",
                        "\t\tif (slabs_node(s, node))",
                        "\t\t\tret = 1;",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 4301,
                    "highlight": 4336
                }
            ],
            "ins_idx": 689,
            "addr": "0xffffffff8131d0a5"
        },
        "32664": {
            "name": "kfree",
            "parent_idx": 32635,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n454",
                    "code": [
                        "/**",
                        " * put_fs_context - Dispose of a superblock configuration context.",
                        " * @fc: The context to dispose of.",
                        " */",
                        "void put_fs_context(struct fs_context *fc)",
                        "{",
                        "\tstruct super_block *sb;",
                        "",
                        "\tif (fc->root) {",
                        "\t\tsb = fc->root->d_sb;",
                        "\t\tdput(fc->root);",
                        "\t\tfc->root = NULL;",
                        "\t\tdeactivate_super(sb);",
                        "\t}",
                        "",
                        "\tif (fc->need_free && fc->ops && fc->ops->free)",
                        "\t\tfc->ops->free(fc);",
                        "",
                        "\tsecurity_free_mnt_opts(&fc->security);",
                        "\tput_net(fc->net_ns);",
                        "\tput_user_ns(fc->user_ns);",
                        "\tput_cred(fc->cred);",
                        "\tput_fc_log(fc);",
                        "\tput_filesystem(fc->fs_type);",
                        "\tkfree(fc->source);",
                        "\tkfree(fc);",
                        "}"
                    ],
                    "start": 430,
                    "highlight": 454
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81394d5b"
        },
        "32635": {
            "name": "put_fs_context",
            "parent_idx": 32632,
            "source_line": [
                {
                    "file": "fs/fsopen.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fsopen.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n73",
                    "code": [
                        "static int fscontext_release(struct inode *inode, struct file *file)",
                        "{",
                        "\tstruct fs_context *fc = file->private_data;",
                        "",
                        "\tif (fc) {",
                        "\t\tfile->private_data = NULL;",
                        "\t\tput_fs_context(fc);",
                        "\t}",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 67,
                    "highlight": 73
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff813960d7"
        },
        "32632": {
            "name": "fscontext_release(indirect)",
            "parent_idx": 32616,
            "source_line": [
                {
                    "file": "fs/file_table.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/file_table.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n280",
                    "code": [
                        "/* the real guts of fput() - releasing the last reference to file",
                        " */",
                        "static void __fput(struct file *file)",
                        "{",
                        "\tstruct dentry *dentry = file->f_path.dentry;",
                        "\tstruct vfsmount *mnt = file->f_path.mnt;",
                        "\tstruct inode *inode = file->f_inode;",
                        "\tfmode_t mode = file->f_mode;",
                        "",
                        "\tif (unlikely(!(file->f_mode & FMODE_OPENED)))",
                        "\t\tgoto out;",
                        "",
                        "\tmight_sleep();",
                        "",
                        "\tfsnotify_close(file);",
                        "\t/*",
                        "\t * The function eventpoll_release() should be the first called",
                        "\t * in the file cleanup chain.",
                        "\t */",
                        "\teventpoll_release(file);",
                        "\tlocks_remove_file(file);",
                        "",
                        "\tima_file_free(file);",
                        "\tif (unlikely(file->f_flags & FASYNC)) {",
                        "\t\tif (file->f_op->fasync)",
                        "\t\t\tfile->f_op->fasync(-1, file, 0);",
                        "\t}",
                        "\tif (file->f_op->release)",
                        "\t\tfile->f_op->release(inode, file);",
                        "\tif (unlikely(S_ISCHR(inode->i_mode) && inode->i_cdev != NULL &&",
                        "\t\t     !(mode & FMODE_PATH))) {",
                        "\t\tcdev_put(inode->i_cdev);",
                        "\t}",
                        "\tfops_put(file->f_op);",
                        "\tput_pid(file->f_owner.pid);",
                        "\tif ((mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)",
                        "\t\ti_readcount_dec(inode);",
                        "\tif (mode & FMODE_WRITER) {",
                        "\t\tput_write_access(inode);",
                        "\t\t__mnt_drop_write(mnt);",
                        "\t}",
                        "\tdput(dentry);",
                        "\tif (unlikely(mode & FMODE_NEED_UNMOUNT))",
                        "\t\tdissolve_on_fput(mnt);",
                        "\tmntput(mnt);",
                        "out:",
                        "\tfile_free(file);",
                        "}"
                    ],
                    "start": 252,
                    "highlight": 280
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff813340ff"
        },
        "32616": {
            "name": "__fput(indirect)",
            "parent_idx": 32606,
            "source_line": [
                {
                    "file": "kernel/task_work.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/task_work.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n164",
                    "code": [
                        "/**",
                        " * task_work_run - execute the works added by task_work_add()",
                        " *",
                        " * Flush the pending works. Should be used by the core kernel code.",
                        " * Called before the task returns to the user-mode or stops, or when",
                        " * it exits. In the latter case task_work_add() can no longer add the",
                        " * new work after task_work_run() returns.",
                        " */",
                        "void task_work_run(void)",
                        "{",
                        "\tstruct task_struct *task = current;",
                        "\tstruct callback_head *work, *head, *next;",
                        "",
                        "\tfor (;;) {",
                        "\t\t/*",
                        "\t\t * work->func() can do task_work_add(), do not set",
                        "\t\t * work_exited unless the list is empty.",
                        "\t\t */",
                        "\t\tdo {",
                        "\t\t\thead = NULL;",
                        "\t\t\twork = READ_ONCE(task->task_works);",
                        "\t\t\tif (!work) {",
                        "\t\t\t\tif (task->flags & PF_EXITING)",
                        "\t\t\t\t\thead = &work_exited;",
                        "\t\t\t\telse",
                        "\t\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t} while (cmpxchg(&task->task_works, work, head) != work);",
                        "",
                        "\t\tif (!work)",
                        "\t\t\tbreak;",
                        "\t\t/*",
                        "\t\t * Synchronize with task_work_cancel(). It can not remove",
                        "\t\t * the first entry == work, cmpxchg(task_works) must fail.",
                        "\t\t * But it can remove another entry from the ->next list.",
                        "\t\t */",
                        "\t\traw_spin_lock_irq(&task->pi_lock);",
                        "\t\traw_spin_unlock_irq(&task->pi_lock);",
                        "",
                        "\t\tdo {",
                        "\t\t\tnext = work->next;",
                        "\t\t\twork->func(work);",
                        "\t\t\twork = next;",
                        "\t\t\tcond_resched();",
                        "\t\t} while (work);",
                        "\t}",
                        "}"
                    ],
                    "start": 123,
                    "highlight": 164
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff810de75a"
        },
        "32606": {
            "name": "task_work_run",
            "parent_idx": 32605,
            "source_line": [
                {
                    "file": "./include/linux/tracehook.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/tracehook.h?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n189",
                    "code": [
                        "/**",
                        " * tracehook_notify_resume - report when about to return to user mode",
                        " * @regs:\t\tuser-mode registers of @current task",
                        " *",
                        " * This is called when %TIF_NOTIFY_RESUME has been set.  Now we are",
                        " * about to return to user mode, and the user state in @regs can be",
                        " * inspected or adjusted.  The caller in arch code has cleared",
                        " * %TIF_NOTIFY_RESUME before the call.  If the flag gets set again",
                        " * asynchronously, this will be called again before we return to",
                        " * user mode.",
                        " *",
                        " * Called without locks.",
                        " */",
                        "static inline void tracehook_notify_resume(struct pt_regs *regs)",
                        "{",
                        "\tclear_thread_flag(TIF_NOTIFY_RESUME);",
                        "\t/*",
                        "\t * This barrier pairs with task_work_add()->set_notify_resume() after",
                        "\t * hlist_add_head(task->task_works);",
                        "\t */",
                        "\tsmp_mb__after_atomic();",
                        "\tif (unlikely(current->task_works))",
                        "\t\ttask_work_run();",
                        "",
                        "#ifdef CONFIG_KEYS_REQUEST_CACHE",
                        "\tif (unlikely(current->cached_requested_key)) {",
                        "\t\tkey_put(current->cached_requested_key);",
                        "\t\tcurrent->cached_requested_key = NULL;",
                        "\t}",
                        "#endif",
                        "",
                        "\tmem_cgroup_handle_over_high();",
                        "\tblkcg_maybe_throttle_current();",
                        "}"
                    ],
                    "start": 167,
                    "highlight": 189
                },
                {
                    "file": "kernel/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/entry/common.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n175",
                    "code": [
                        "static unsigned long exit_to_user_mode_loop(struct pt_regs *regs,",
                        "\t\t\t\t\t    unsigned long ti_work)",
                        "{",
                        "\t/*",
                        "\t * Before returning to user space ensure that all pending work",
                        "\t * items have been completed.",
                        "\t */",
                        "\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {",
                        "",
                        "\t\tlocal_irq_enable_exit_to_user(ti_work);",
                        "",
                        "\t\tif (ti_work & _TIF_NEED_RESCHED)",
                        "\t\t\tschedule();",
                        "",
                        "\t\tif (ti_work & _TIF_UPROBE)",
                        "\t\t\tuprobe_notify_resume(regs);",
                        "",
                        "\t\tif (ti_work & _TIF_PATCH_PENDING)",
                        "\t\t\tklp_update_patch_state(current);",
                        "",
                        "\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))",
                        "\t\t\thandle_signal_work(regs, ti_work);",
                        "",
                        "\t\tif (ti_work & _TIF_NOTIFY_RESUME) {",
                        "\t\t\ttracehook_notify_resume(regs);",
                        "\t\t\trseq_handle_notify_resume(NULL, regs);",
                        "\t\t}",
                        "",
                        "\t\t/* Architecture specific TIF work */",
                        "\t\tarch_exit_to_user_mode_work(regs, ti_work);",
                        "",
                        "\t\t/*",
                        "\t\t * Disable interrupts and reevaluate the work flags as they",
                        "\t\t * might have changed while interrupts and preemption was",
                        "\t\t * enabled above.",
                        "\t\t */",
                        "\t\tlocal_irq_disable_exit_to_user();",
                        "",
                        "\t\t/* Check if any of the above work has queued a deferred wakeup */",
                        "\t\ttick_nohz_user_enter_prepare();",
                        "",
                        "\t\tti_work = READ_ONCE(current_thread_info()->flags);",
                        "\t}",
                        "",
                        "\t/* Return the latest work state for arch_exit_to_user_mode() */",
                        "\treturn ti_work;",
                        "}"
                    ],
                    "start": 151,
                    "highlight": 175
                },
                {
                    "file": "kernel/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/entry/common.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n209",
                    "code": [
                        "static void exit_to_user_mode_prepare(struct pt_regs *regs)",
                        "{",
                        "\tunsigned long ti_work = READ_ONCE(current_thread_info()->flags);",
                        "",
                        "\tlockdep_assert_irqs_disabled();",
                        "",
                        "\t/* Flush pending rcuog wakeup before the last need_resched() check */",
                        "\ttick_nohz_user_enter_prepare();",
                        "",
                        "\tif (unlikely(ti_work & EXIT_TO_USER_MODE_WORK))",
                        "\t\tti_work = exit_to_user_mode_loop(regs, ti_work);",
                        "",
                        "\tarch_exit_to_user_mode_prepare(regs, ti_work);",
                        "",
                        "\t/* Ensure that the address limit is intact and no locks are held */",
                        "\taddr_limit_user_check();",
                        "\tkmap_assert_nomap();",
                        "\tlockdep_assert_irqs_disabled();",
                        "\tlockdep_sys_exit();",
                        "}"
                    ],
                    "start": 199,
                    "highlight": 209
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8116bb17"
        },
        "32605": {
            "name": "exit_to_user_mode_prepare",
            "parent_idx": 32604,
            "source_line": [
                {
                    "file": "kernel/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/entry/common.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n291",
                    "code": [
                        "static __always_inline void __syscall_exit_to_user_mode_work(struct pt_regs *regs)",
                        "{",
                        "\tsyscall_exit_to_user_mode_prepare(regs);",
                        "\tlocal_irq_disable_exit_to_user();",
                        "\texit_to_user_mode_prepare(regs);",
                        "}"
                    ],
                    "start": 287,
                    "highlight": 291
                },
                {
                    "file": "kernel/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/entry/common.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n302",
                    "code": [
                        "__visible noinstr void syscall_exit_to_user_mode(struct pt_regs *regs)",
                        "{",
                        "\tinstrumentation_begin();",
                        "\t__syscall_exit_to_user_mode_work(regs);",
                        "\tinstrumentation_end();",
                        "\t__exit_to_user_mode();",
                        "}"
                    ],
                    "start": 299,
                    "highlight": 302
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff823868c8"
        },
        "32604": {
            "name": "syscall_exit_to_user_mode",
            "parent_idx": 32552,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n86",
                    "code": [
                        "__visible noinstr void do_syscall_64(struct pt_regs *regs, int nr)",
                        "{",
                        "\tadd_random_kstack_offset();",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "",
                        "\tif (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {",
                        "\t\t/* Invalid system call, but still a system call. */",
                        "\t\tregs->ax = __x64_sys_ni_syscall(regs);",
                        "\t}",
                        "",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 73,
                    "highlight": 86
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8238410b"
        },
        "32552": {
            "name": "do_syscall_64",
            "parent_idx": 32545,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n113",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rsp, %rdi",
                        "\t/* Sign extend the lower 32bit as syscall numbers are treated as int */",
                        "\tmovslq\t%eax, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t * In the Xen PV case we must use iret anyway.",
                        "\t */",
                        "",
                        "\tALTERNATIVE \"\", \"jmp\tswapgs_restore_regs_and_return_to_usermode\", \\",
                        "\t\tX86_FEATURE_XENPV",
                        "",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tswapgs",
                        "\tsysretq",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 87,
                    "highlight": 113
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "32545": {
            "name": "1328_syscall_51",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "32770": {
            "name": "+0x11",
            "parent_idx": 32750,
            "source_line": [
                {
                    "file": "fs/open.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/open.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n1303",
                    "code": [
                        "/*",
                        " * \"id\" is the POSIX thread ID. We use the",
                        " * files pointer for this..",
                        " */",
                        "int filp_close(struct file *filp, fl_owner_t id)",
                        "{",
                        "\tint retval = 0;",
                        "",
                        "\tif (!file_count(filp)) {",
                        "\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\tif (filp->f_op->flush)",
                        "\t\tretval = filp->f_op->flush(filp, id);",
                        "",
                        "\tif (likely(!(filp->f_mode & FMODE_PATH))) {",
                        "\t\tdnotify_flush(filp, id);",
                        "\t\tlocks_remove_posix(filp, id);",
                        "\t}",
                        "\tfput(filp);",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 1298,
                    "highlight": 1303
                }
            ],
            "ins_idx": 688,
            "addr": "0xffffffff81328b01"
        },
        "32663": {
            "name": "+0x157",
            "parent_idx": 32635,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n454",
                    "code": [
                        "/**",
                        " * put_fs_context - Dispose of a superblock configuration context.",
                        " * @fc: The context to dispose of.",
                        " */",
                        "void put_fs_context(struct fs_context *fc)",
                        "{",
                        "\tstruct super_block *sb;",
                        "",
                        "\tif (fc->root) {",
                        "\t\tsb = fc->root->d_sb;",
                        "\t\tdput(fc->root);",
                        "\t\tfc->root = NULL;",
                        "\t\tdeactivate_super(sb);",
                        "\t}",
                        "",
                        "\tif (fc->need_free && fc->ops && fc->ops->free)",
                        "\t\tfc->ops->free(fc);",
                        "",
                        "\tsecurity_free_mnt_opts(&fc->security);",
                        "\tput_net(fc->net_ns);",
                        "\tput_user_ns(fc->user_ns);",
                        "\tput_cred(fc->cred);",
                        "\tput_fc_log(fc);",
                        "\tput_filesystem(fc->fs_type);",
                        "\tkfree(fc->source);",
                        "\tkfree(fc);",
                        "}"
                    ],
                    "start": 430,
                    "highlight": 454
                }
            ],
            "ins_idx": 1053,
            "addr": "0xffffffff81394d57"
        },
        "32769": {
            "name": "+0x99",
            "parent_idx": 32750,
            "source_line": [
                {
                    "file": "fs/file.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/file.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n628",
                    "code": [
                        "int close_fd(unsigned fd)",
                        "{",
                        "\tstruct files_struct *files = current->files;",
                        "\tstruct file *file;",
                        "",
                        "\tfile = pick_file(files, fd);",
                        "\tif (!file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\treturn filp_close(file, files);",
                        "}"
                    ],
                    "start": 619,
                    "highlight": 628
                }
            ],
            "ins_idx": 1052,
            "addr": "0xffffffff813667f9"
        },
        "32539": {
            "name": "+0x300",
            "parent_idx": 32517,
            "source_line": [
                {
                    "file": "kernel/cgroup/cgroup-v1.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/cgroup/cgroup-v1.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n917",
                    "code": [
                        "int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);",
                        "\tstruct cgroup_subsys *ss;",
                        "\tstruct fs_parse_result result;",
                        "\tint opt, i;",
                        "",
                        "\topt = fs_parse(fc, cgroup1_fs_parameters, param, &result);",
                        "\tif (opt == -ENOPARAM) {",
                        "\t\tif (strcmp(param->key, \"source\") == 0) {",
                        "\t\t\tif (fc->source)",
                        "\t\t\t\treturn invalf(fc, \"Multiple sources not supported\");",
                        "\t\t\tfc->source = param->string;",
                        "\t\t\tparam->string = NULL;",
                        "\t\t\treturn 0;",
                        "\t\t}",
                        "\t\tfor_each_subsys(ss, i) {",
                        "\t\t\tif (strcmp(param->key, ss->legacy_name))",
                        "\t\t\t\tcontinue;",
                        "\t\t\tif (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i))",
                        "\t\t\t\treturn invalfc(fc, \"Disabled controller '%s'\",",
                        "\t\t\t\t\t       param->key);",
                        "\t\t\tctx->subsys_mask |= (1 << i);",
                        "\t\t\treturn 0;",
                        "\t\t}",
                        "\t\treturn invalfc(fc, \"Unknown subsys name '%s'\", param->key);",
                        "\t}",
                        "\tif (opt < 0)",
                        "\t\treturn opt;",
                        "",
                        "\tswitch (opt) {",
                        "\tcase Opt_none:",
                        "\t\t/* Explicitly have no subsystems */",
                        "\t\tctx->none = true;",
                        "\t\tbreak;",
                        "\tcase Opt_all:",
                        "\t\tctx->all_ss = true;",
                        "\t\tbreak;",
                        "\tcase Opt_noprefix:",
                        "\t\tctx->flags |= CGRP_ROOT_NOPREFIX;",
                        "\t\tbreak;",
                        "\tcase Opt_clone_children:",
                        "\t\tctx->cpuset_clone_children = true;",
                        "\t\tbreak;",
                        "\tcase Opt_cpuset_v2_mode:",
                        "\t\tctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;",
                        "\t\tbreak;",
                        "\tcase Opt_xattr:",
                        "\t\tctx->flags |= CGRP_ROOT_XATTR;",
                        "\t\tbreak;",
                        "\tcase Opt_release_agent:",
                        "\t\t/* Specifying two release agents is forbidden */",
                        "\t\tif (ctx->release_agent)",
                        "\t\t\treturn invalfc(fc, \"release_agent respecified\");",
                        "\t\tctx->release_agent = param->string;",
                        "\t\tparam->string = NULL;",
                        "\t\tbreak;",
                        "\tcase Opt_name:",
                        "\t\t/* blocked by boot param? */",
                        "\t\tif (cgroup_no_v1_named)",
                        "\t\t\treturn -ENOENT;",
                        "\t\t/* Can't specify an empty name */",
                        "\t\tif (!param->size)",
                        "\t\t\treturn invalfc(fc, \"Empty name\");",
                        "\t\tif (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)",
                        "\t\t\treturn invalfc(fc, \"Name too long\");",
                        "\t\t/* Must match [\\w.-]+ */",
                        "\t\tfor (i = 0; i < param->size; i++) {",
                        "\t\t\tchar c = param->string[i];",
                        "\t\t\tif (isalnum(c))",
                        "\t\t\t\tcontinue;",
                        "\t\t\tif ((c == '.') || (c == '-') || (c == '_'))",
                        "\t\t\t\tcontinue;",
                        "\t\t\treturn invalfc(fc, \"Invalid name\");",
                        "\t\t}",
                        "\t\t/* Specifying two names is forbidden */",
                        "\t\tif (ctx->name)",
                        "\t\t\treturn invalfc(fc, \"name respecified\");",
                        "\t\tctx->name = param->string;",
                        "\t\tparam->string = NULL;",
                        "\t\tbreak;",
                        "\t}",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 905,
                    "highlight": 917
                }
            ],
            "ins_idx": 1488,
            "addr": "0xffffffff811beaa0"
        },
        "32517": {
            "name": "cgroup1_parse_param(indirect)",
            "parent_idx": 32484,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n117",
                    "code": [
                        "/**",
                        " * vfs_parse_fs_param - Add a single parameter to a superblock config",
                        " * @fc: The filesystem context to modify",
                        " * @param: The parameter",
                        " *",
                        " * A single mount option in string form is applied to the filesystem context",
                        " * being set up.  Certain standard options (for example \"ro\") are translated",
                        " * into flag bits without going to the filesystem.  The active security module",
                        " * is allowed to observe and poach options.  Any other options are passed over",
                        " * to the filesystem to parse.",
                        " *",
                        " * This may be called multiple times for a context.",
                        " *",
                        " * Returns 0 on success and a negative error code on failure.  In the event of",
                        " * failure, supplementary error information may have been set.",
                        " */",
                        "int vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tif (!param->key)",
                        "\t\treturn invalf(fc, \"Unnamed parameter\\n\");",
                        "",
                        "\tret = vfs_parse_sb_flag(fc, param->key);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\treturn ret;",
                        "",
                        "\tret = security_fs_context_parse_param(fc, param);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\t/* Param belongs to the LSM or is disallowed by the LSM; so",
                        "\t\t * don't pass to the FS.",
                        "\t\t */",
                        "\t\treturn ret;",
                        "",
                        "\tif (fc->ops->parse_param) {",
                        "\t\tret = fc->ops->parse_param(fc, param);",
                        "\t\tif (ret != -ENOPARAM)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "",
                        "\t/* If the filesystem doesn't take any arguments, give it the",
                        "\t * default handling of source.",
                        "\t */",
                        "\tif (strcmp(param->key, \"source\") == 0) {",
                        "\t\tif (param->type != fs_value_is_string)",
                        "\t\t\treturn invalf(fc, \"VFS: Non-string source\");",
                        "\t\tif (fc->source)",
                        "\t\t\treturn invalf(fc, \"VFS: Multiple sources\");",
                        "\t\tfc->source = param->string;",
                        "\t\tparam->string = NULL;",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\treturn invalf(fc, \"%s: Unknown parameter '%s'\",",
                        "\t\t      fc->fs_type->name, param->key);",
                        "}"
                    ],
                    "start": 82,
                    "highlight": 117
                },
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n98",
                    "code": [
                        "/**",
                        " * vfs_parse_fs_param - Add a single parameter to a superblock config",
                        " * @fc: The filesystem context to modify",
                        " * @param: The parameter",
                        " *",
                        " * A single mount option in string form is applied to the filesystem context",
                        " * being set up.  Certain standard options (for example \"ro\") are translated",
                        " * into flag bits without going to the filesystem.  The active security module",
                        " * is allowed to observe and poach options.  Any other options are passed over",
                        " * to the filesystem to parse.",
                        " *",
                        " * This may be called multiple times for a context.",
                        " *",
                        " * Returns 0 on success and a negative error code on failure.  In the event of",
                        " * failure, supplementary error information may have been set.",
                        " */",
                        "int vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tif (!param->key)",
                        "\t\treturn invalf(fc, \"Unnamed parameter\\n\");",
                        "",
                        "\tret = vfs_parse_sb_flag(fc, param->key);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\treturn ret;",
                        "",
                        "\tret = security_fs_context_parse_param(fc, param);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\t/* Param belongs to the LSM or is disallowed by the LSM; so",
                        "\t\t * don't pass to the FS.",
                        "\t\t */",
                        "\t\treturn ret;",
                        "",
                        "\tif (fc->ops->parse_param) {",
                        "\t\tret = fc->ops->parse_param(fc, param);",
                        "\t\tif (ret != -ENOPARAM)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "",
                        "\t/* If the filesystem doesn't take any arguments, give it the",
                        "\t * default handling of source.",
                        "\t */",
                        "\tif (strcmp(param->key, \"source\") == 0) {",
                        "\t\tif (param->type != fs_value_is_string)",
                        "\t\t\treturn invalf(fc, \"VFS: Non-string source\");",
                        "\t\tif (fc->source)",
                        "\t\t\treturn invalf(fc, \"VFS: Multiple sources\");",
                        "\t\tfc->source = param->string;",
                        "\t\tparam->string = NULL;",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\treturn invalf(fc, \"%s: Unknown parameter '%s'\",",
                        "\t\t      fc->fs_type->name, param->key);",
                        "}"
                    ],
                    "start": 82,
                    "highlight": 98
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff813947f6"
        },
        "32484": {
            "name": "vfs_parse_fs_param",
            "parent_idx": 32361,
            "source_line": [
                {
                    "file": "fs/fsopen.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fsopen.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n265",
                    "code": [
                        "/*",
                        " * Check the state and apply the configuration.  Note that this function is",
                        " * allowed to 'steal' the value by setting param->xxx to NULL before returning.",
                        " */",
                        "static int vfs_fsconfig_locked(struct fs_context *fc, int cmd,",
                        "\t\t\t       struct fs_parameter *param)",
                        "{",
                        "\tstruct super_block *sb;",
                        "\tint ret;",
                        "",
                        "\tret = finish_clean_context(fc);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tswitch (cmd) {",
                        "\tcase FSCONFIG_CMD_CREATE:",
                        "\t\tif (fc->phase != FS_CONTEXT_CREATE_PARAMS)",
                        "\t\t\treturn -EBUSY;",
                        "\t\tif (!mount_capable(fc))",
                        "\t\t\treturn -EPERM;",
                        "\t\tfc->phase = FS_CONTEXT_CREATING;",
                        "\t\tret = vfs_get_tree(fc);",
                        "\t\tif (ret)",
                        "\t\t\tbreak;",
                        "\t\tsb = fc->root->d_sb;",
                        "\t\tret = security_sb_kern_mount(sb);",
                        "\t\tif (unlikely(ret)) {",
                        "\t\t\tfc_drop_locked(fc);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tup_write(&sb->s_umount);",
                        "\t\tfc->phase = FS_CONTEXT_AWAITING_MOUNT;",
                        "\t\treturn 0;",
                        "\tcase FSCONFIG_CMD_RECONFIGURE:",
                        "\t\tif (fc->phase != FS_CONTEXT_RECONF_PARAMS)",
                        "\t\t\treturn -EBUSY;",
                        "\t\tfc->phase = FS_CONTEXT_RECONFIGURING;",
                        "\t\tsb = fc->root->d_sb;",
                        "\t\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN)) {",
                        "\t\t\tret = -EPERM;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tdown_write(&sb->s_umount);",
                        "\t\tret = reconfigure_super(fc);",
                        "\t\tup_write(&sb->s_umount);",
                        "\t\tif (ret)",
                        "\t\t\tbreak;",
                        "\t\tvfs_clean_context(fc);",
                        "\t\treturn 0;",
                        "\tdefault:",
                        "\t\tif (fc->phase != FS_CONTEXT_CREATE_PARAMS &&",
                        "\t\t    fc->phase != FS_CONTEXT_RECONF_PARAMS)",
                        "\t\t\treturn -EBUSY;",
                        "",
                        "\t\treturn vfs_parse_fs_param(fc, param);",
                        "\t}",
                        "\tfc->phase = FS_CONTEXT_FAILED;",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 212,
                    "highlight": 265
                },
                {
                    "file": "fs/fsopen.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fsopen.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n439",
                    "code": [
                        "/**",
                        " * sys_fsconfig - Set parameters and trigger actions on a context",
                        " * @fd: The filesystem context to act upon",
                        " * @cmd: The action to take",
                        " * @_key: Where appropriate, the parameter key to set",
                        " * @_value: Where appropriate, the parameter value to set",
                        " * @aux: Additional information for the value",
                        " *",
                        " * This system call is used to set parameters on a context, including",
                        " * superblock settings, data source and security labelling.",
                        " *",
                        " * Actions include triggering the creation of a superblock and the",
                        " * reconfiguration of the superblock attached to the specified context.",
                        " *",
                        " * When setting a parameter, @cmd indicates the type of value being proposed",
                        " * and @_key indicates the parameter to be altered.",
                        " *",
                        " * @_value and @aux are used to specify the value, should a value be required:",
                        " *",
                        " * (*) fsconfig_set_flag: No value is specified.  The parameter must be boolean",
                        " *     in nature.  The key may be prefixed with \"no\" to invert the",
                        " *     setting. @_value must be NULL and @aux must be 0.",
                        " *",
                        " * (*) fsconfig_set_string: A string value is specified.  The parameter can be",
                        " *     expecting boolean, integer, string or take a path.  A conversion to an",
                        " *     appropriate type will be attempted (which may include looking up as a",
                        " *     path).  @_value points to a NUL-terminated string and @aux must be 0.",
                        " *",
                        " * (*) fsconfig_set_binary: A binary blob is specified.  @_value points to the",
                        " *     blob and @aux indicates its size.  The parameter must be expecting a",
                        " *     blob.",
                        " *",
                        " * (*) fsconfig_set_path: A non-empty path is specified.  The parameter must be",
                        " *     expecting a path object.  @_value points to a NUL-terminated string that",
                        " *     is the path and @aux is a file descriptor at which to start a relative",
                        " *     lookup or AT_FDCWD.",
                        " *",
                        " * (*) fsconfig_set_path_empty: As fsconfig_set_path, but with AT_EMPTY_PATH",
                        " *     implied.",
                        " *",
                        " * (*) fsconfig_set_fd: An open file descriptor is specified.  @_value must be",
                        " *     NULL and @aux indicates the file descriptor.",
                        " */",
                        "SYSCALL_DEFINE5(fsconfig,",
                        "\t\tint, fd,",
                        "\t\tunsigned int, cmd,",
                        "\t\tconst char __user *, _key,",
                        "\t\tconst void __user *, _value,",
                        "\t\tint, aux)",
                        "{",
                        "\tstruct fs_context *fc;",
                        "\tstruct fd f;",
                        "\tint ret;",
                        "\tint lookup_flags = 0;",
                        "",
                        "\tstruct fs_parameter param = {",
                        "\t\t.type\t= fs_value_is_undefined,",
                        "\t};",
                        "",
                        "\tif (fd < 0)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FSCONFIG_SET_FLAG:",
                        "\t\tif (!_key || _value || aux)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_STRING:",
                        "\t\tif (!_key || !_value || aux)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_BINARY:",
                        "\t\tif (!_key || !_value || aux <= 0 || aux > 1024 * 1024)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_PATH:",
                        "\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tif (!_key || !_value || (aux != AT_FDCWD && aux < 0))",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_FD:",
                        "\t\tif (!_key || _value || aux < 0)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_CMD_CREATE:",
                        "\tcase FSCONFIG_CMD_RECONFIGURE:",
                        "\t\tif (_key || _value || aux)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\treturn -EOPNOTSUPP;",
                        "\t}",
                        "",
                        "\tf = fdget(fd);",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "\tret = -EINVAL;",
                        "\tif (f.file->f_op != &fscontext_fops)",
                        "\t\tgoto out_f;",
                        "",
                        "\tfc = f.file->private_data;",
                        "\tif (fc->ops == &legacy_fs_context_ops) {",
                        "\t\tswitch (cmd) {",
                        "\t\tcase FSCONFIG_SET_BINARY:",
                        "\t\tcase FSCONFIG_SET_PATH:",
                        "\t\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tcase FSCONFIG_SET_FD:",
                        "\t\t\tret = -EOPNOTSUPP;",
                        "\t\t\tgoto out_f;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (_key) {",
                        "\t\tparam.key = strndup_user(_key, 256);",
                        "\t\tif (IS_ERR(param.key)) {",
                        "\t\t\tret = PTR_ERR(param.key);",
                        "\t\t\tgoto out_f;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FSCONFIG_SET_FLAG:",
                        "\t\tparam.type = fs_value_is_flag;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_STRING:",
                        "\t\tparam.type = fs_value_is_string;",
                        "\t\tparam.string = strndup_user(_value, 256);",
                        "\t\tif (IS_ERR(param.string)) {",
                        "\t\t\tret = PTR_ERR(param.string);",
                        "\t\t\tgoto out_key;",
                        "\t\t}",
                        "\t\tparam.size = strlen(param.string);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_BINARY:",
                        "\t\tparam.type = fs_value_is_blob;",
                        "\t\tparam.size = aux;",
                        "\t\tparam.blob = memdup_user_nul(_value, aux);",
                        "\t\tif (IS_ERR(param.blob)) {",
                        "\t\t\tret = PTR_ERR(param.blob);",
                        "\t\t\tgoto out_key;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tlookup_flags = LOOKUP_EMPTY;",
                        "\t\tfallthrough;",
                        "\tcase FSCONFIG_SET_PATH:",
                        "\t\tparam.type = fs_value_is_filename;",
                        "\t\tparam.name = getname_flags(_value, lookup_flags, NULL);",
                        "\t\tif (IS_ERR(param.name)) {",
                        "\t\t\tret = PTR_ERR(param.name);",
                        "\t\t\tgoto out_key;",
                        "\t\t}",
                        "\t\tparam.dirfd = aux;",
                        "\t\tparam.size = strlen(param.name->name);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_FD:",
                        "\t\tparam.type = fs_value_is_file;",
                        "\t\tret = -EBADF;",
                        "\t\tparam.file = fget(aux);",
                        "\t\tif (!param.file)",
                        "\t\t\tgoto out_key;",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tret = mutex_lock_interruptible(&fc->uapi_mutex);",
                        "\tif (ret == 0) {",
                        "\t\tret = vfs_fsconfig_locked(fc, cmd, &param);",
                        "\t\tmutex_unlock(&fc->uapi_mutex);",
                        "\t}",
                        "",
                        "\t/* Clean up the our record of any value that we obtained from",
                        "\t * userspace.  Note that the value may have been stolen by the LSM or",
                        "\t * filesystem, in which case the value pointer will have been cleared.",
                        "\t */",
                        "\tswitch (cmd) {",
                        "\tcase FSCONFIG_SET_STRING:",
                        "\tcase FSCONFIG_SET_BINARY:",
                        "\t\tkfree(param.string);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_PATH:",
                        "\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tif (param.name)",
                        "\t\t\tputname(param.name);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_FD:",
                        "\t\tif (param.file)",
                        "\t\t\tfput(param.file);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tbreak;",
                        "\t}",
                        "out_key:",
                        "\tkfree(param.key);",
                        "out_f:",
                        "\tfdput(f);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 271,
                    "highlight": 439
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8139663b"
        },
        "32361": {
            "name": "__x64_sys_fsconfig(indirect)",
            "parent_idx": 32358,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n50",
                    "code": [
                        "static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)",
                        "{",
                        "\t/*",
                        "\t * Convert negative numbers to very high and thus out of range",
                        "\t * numbers for comparisons.",
                        "\t */",
                        "\tunsigned int unr = nr;",
                        "",
                        "\tif (likely(unr < NR_syscalls)) {",
                        "\t\tunr = array_index_nospec(unr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[unr](regs);",
                        "\t\treturn true;",
                        "\t}",
                        "\treturn false;",
                        "}"
                    ],
                    "start": 40,
                    "highlight": 50
                },
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n80",
                    "code": [
                        "__visible noinstr void do_syscall_64(struct pt_regs *regs, int nr)",
                        "{",
                        "\tadd_random_kstack_offset();",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "",
                        "\tif (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {",
                        "\t\t/* Invalid system call, but still a system call. */",
                        "\t\tregs->ax = __x64_sys_ni_syscall(regs);",
                        "\t}",
                        "",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 73,
                    "highlight": 80
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff823840fe"
        },
        "32358": {
            "name": "do_syscall_64",
            "parent_idx": 32345,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n113",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rsp, %rdi",
                        "\t/* Sign extend the lower 32bit as syscall numbers are treated as int */",
                        "\tmovslq\t%eax, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t * In the Xen PV case we must use iret anyway.",
                        "\t */",
                        "",
                        "\tALTERNATIVE \"\", \"jmp\tswapgs_restore_regs_and_return_to_usermode\", \\",
                        "\t\tX86_FEATURE_XENPV",
                        "",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tswapgs",
                        "\tsysretq",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 87,
                    "highlight": 113
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "32345": {
            "name": "1327_syscall_50",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "32763": {
            "name": "+0x6c",
            "parent_idx": 32750,
            "source_line": [
                {
                    "file": "fs/file.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/file.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n608",
                    "code": [
                        "static struct file *pick_file(struct files_struct *files, unsigned fd)",
                        "{",
                        "\tstruct file *file = NULL;",
                        "\tstruct fdtable *fdt;",
                        "",
                        "\tspin_lock(&files->file_lock);",
                        "\tfdt = files_fdtable(files);",
                        "\tif (fd >= fdt->max_fds)",
                        "\t\tgoto out_unlock;",
                        "\tfile = fdt->fd[fd];",
                        "\tif (!file)",
                        "\t\tgoto out_unlock;",
                        "\trcu_assign_pointer(fdt->fd[fd], NULL);",
                        "\t__put_unused_fd(files, fd);",
                        "",
                        "out_unlock:",
                        "\tspin_unlock(&files->file_lock);",
                        "\treturn file;",
                        "}"
                    ],
                    "start": 599,
                    "highlight": 608
                },
                {
                    "file": "fs/file.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/file.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n624",
                    "code": [
                        "int close_fd(unsigned fd)",
                        "{",
                        "\tstruct files_struct *files = current->files;",
                        "\tstruct file *file;",
                        "",
                        "\tfile = pick_file(files, fd);",
                        "\tif (!file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\treturn filp_close(file, files);",
                        "}"
                    ],
                    "start": 619,
                    "highlight": 624
                }
            ],
            "ins_idx": 2431,
            "addr": "0xffffffff813667cc"
        },
        "32538": {
            "name": "+0x2f9",
            "parent_idx": 32517,
            "source_line": [
                {
                    "file": "kernel/cgroup/cgroup-v1.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/cgroup/cgroup-v1.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n917",
                    "code": [
                        "int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);",
                        "\tstruct cgroup_subsys *ss;",
                        "\tstruct fs_parse_result result;",
                        "\tint opt, i;",
                        "",
                        "\topt = fs_parse(fc, cgroup1_fs_parameters, param, &result);",
                        "\tif (opt == -ENOPARAM) {",
                        "\t\tif (strcmp(param->key, \"source\") == 0) {",
                        "\t\t\tif (fc->source)",
                        "\t\t\t\treturn invalf(fc, \"Multiple sources not supported\");",
                        "\t\t\tfc->source = param->string;",
                        "\t\t\tparam->string = NULL;",
                        "\t\t\treturn 0;",
                        "\t\t}",
                        "\t\tfor_each_subsys(ss, i) {",
                        "\t\t\tif (strcmp(param->key, ss->legacy_name))",
                        "\t\t\t\tcontinue;",
                        "\t\t\tif (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i))",
                        "\t\t\t\treturn invalfc(fc, \"Disabled controller '%s'\",",
                        "\t\t\t\t\t       param->key);",
                        "\t\t\tctx->subsys_mask |= (1 << i);",
                        "\t\t\treturn 0;",
                        "\t\t}",
                        "\t\treturn invalfc(fc, \"Unknown subsys name '%s'\", param->key);",
                        "\t}",
                        "\tif (opt < 0)",
                        "\t\treturn opt;",
                        "",
                        "\tswitch (opt) {",
                        "\tcase Opt_none:",
                        "\t\t/* Explicitly have no subsystems */",
                        "\t\tctx->none = true;",
                        "\t\tbreak;",
                        "\tcase Opt_all:",
                        "\t\tctx->all_ss = true;",
                        "\t\tbreak;",
                        "\tcase Opt_noprefix:",
                        "\t\tctx->flags |= CGRP_ROOT_NOPREFIX;",
                        "\t\tbreak;",
                        "\tcase Opt_clone_children:",
                        "\t\tctx->cpuset_clone_children = true;",
                        "\t\tbreak;",
                        "\tcase Opt_cpuset_v2_mode:",
                        "\t\tctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;",
                        "\t\tbreak;",
                        "\tcase Opt_xattr:",
                        "\t\tctx->flags |= CGRP_ROOT_XATTR;",
                        "\t\tbreak;",
                        "\tcase Opt_release_agent:",
                        "\t\t/* Specifying two release agents is forbidden */",
                        "\t\tif (ctx->release_agent)",
                        "\t\t\treturn invalfc(fc, \"release_agent respecified\");",
                        "\t\tctx->release_agent = param->string;",
                        "\t\tparam->string = NULL;",
                        "\t\tbreak;",
                        "\tcase Opt_name:",
                        "\t\t/* blocked by boot param? */",
                        "\t\tif (cgroup_no_v1_named)",
                        "\t\t\treturn -ENOENT;",
                        "\t\t/* Can't specify an empty name */",
                        "\t\tif (!param->size)",
                        "\t\t\treturn invalfc(fc, \"Empty name\");",
                        "\t\tif (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)",
                        "\t\t\treturn invalfc(fc, \"Name too long\");",
                        "\t\t/* Must match [\\w.-]+ */",
                        "\t\tfor (i = 0; i < param->size; i++) {",
                        "\t\t\tchar c = param->string[i];",
                        "\t\t\tif (isalnum(c))",
                        "\t\t\t\tcontinue;",
                        "\t\t\tif ((c == '.') || (c == '-') || (c == '_'))",
                        "\t\t\t\tcontinue;",
                        "\t\t\treturn invalfc(fc, \"Invalid name\");",
                        "\t\t}",
                        "\t\t/* Specifying two names is forbidden */",
                        "\t\tif (ctx->name)",
                        "\t\t\treturn invalfc(fc, \"name respecified\");",
                        "\t\tctx->name = param->string;",
                        "\t\tparam->string = NULL;",
                        "\t\tbreak;",
                        "\t}",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 905,
                    "highlight": 917
                }
            ],
            "ins_idx": 1938,
            "addr": "0xffffffff811bea99"
        },
        "32276": {
            "name": "+0x89",
            "parent_idx": 32266,
            "source_line": [
                {
                    "file": "fs/file.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/file.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n593",
                    "code": [
                        "void fd_install(unsigned int fd, struct file *file)",
                        "{",
                        "\tstruct files_struct *files = current->files;",
                        "\tstruct fdtable *fdt;",
                        "",
                        "\trcu_read_lock_sched();",
                        "",
                        "\tif (unlikely(files->resize_in_progress)) {",
                        "\t\trcu_read_unlock_sched();",
                        "\t\tspin_lock(&files->file_lock);",
                        "\t\tfdt = files_fdtable(files);",
                        "\t\tBUG_ON(fdt->fd[fd] != NULL);",
                        "\t\trcu_assign_pointer(fdt->fd[fd], file);",
                        "\t\tspin_unlock(&files->file_lock);",
                        "\t\treturn;",
                        "\t}",
                        "\t/* coupled with smp_wmb() in expand_fdtable() */",
                        "\tsmp_rmb();",
                        "\tfdt = rcu_dereference_sched(files->fdt);",
                        "\tBUG_ON(fdt->fd[fd] != NULL);",
                        "\trcu_assign_pointer(fdt->fd[fd], file);",
                        "\trcu_read_unlock_sched();",
                        "}"
                    ],
                    "start": 573,
                    "highlight": 593
                }
            ],
            "ins_idx": 3065,
            "addr": "0xffffffff81366109"
        },
        "32266": {
            "name": "fd_install",
            "parent_idx": 32036,
            "source_line": [
                {
                    "file": "fs/open.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/open.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n1210",
                    "code": [
                        "static long do_sys_openat2(int dfd, const char __user *filename,",
                        "\t\t\t   struct open_how *how)",
                        "{",
                        "\tstruct open_flags op;",
                        "\tint fd = build_open_flags(how, &op);",
                        "\tstruct filename *tmp;",
                        "",
                        "\tif (fd)",
                        "\t\treturn fd;",
                        "",
                        "\ttmp = getname(filename);",
                        "\tif (IS_ERR(tmp))",
                        "\t\treturn PTR_ERR(tmp);",
                        "",
                        "\tfd = get_unused_fd_flags(how->flags);",
                        "\tif (fd >= 0) {",
                        "\t\tstruct file *f = do_filp_open(dfd, tmp, &op);",
                        "\t\tif (IS_ERR(f)) {",
                        "\t\t\tput_unused_fd(fd);",
                        "\t\t\tfd = PTR_ERR(f);",
                        "\t\t} else {",
                        "\t\t\tfsnotify_open(f);",
                        "\t\t\tfd_install(fd, f);",
                        "\t\t}",
                        "\t}",
                        "\tputname(tmp);",
                        "\treturn fd;",
                        "}"
                    ],
                    "start": 1188,
                    "highlight": 1210
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8132c07a"
        },
        "32036": {
            "name": "do_sys_openat2",
            "parent_idx": 32035,
            "source_line": [
                {
                    "file": "fs/open.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/open.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n1220",
                    "code": [
                        "long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)",
                        "{",
                        "\tstruct open_how how = build_open_how(flags, mode);",
                        "\treturn do_sys_openat2(dfd, filename, &how);",
                        "}"
                    ],
                    "start": 1217,
                    "highlight": 1220
                },
                {
                    "file": "fs/open.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/open.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n1294",
                    "code": [
                        "/*",
                        " * For backward compatibility?  Maybe this should be moved",
                        " * into arch/i386 instead?",
                        " */",
                        "SYSCALL_DEFINE2(creat, const char __user *, pathname, umode_t, mode)",
                        "{",
                        "\tint flags = O_CREAT | O_WRONLY | O_TRUNC;",
                        "",
                        "\tif (force_o_largefile())",
                        "\t\tflags |= O_LARGEFILE;",
                        "\treturn do_sys_open(AT_FDCWD, pathname, flags, mode);",
                        "}"
                    ],
                    "start": 1284,
                    "highlight": 1294
                },
                {
                    "file": "fs/open.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/open.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n1288",
                    "code": [
                        "/*",
                        " * Exactly like sys_openat(), except that it doesn't set the",
                        " * O_LARGEFILE flag.",
                        " */",
                        "COMPAT_SYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode)",
                        "{",
                        "\treturn do_sys_open(dfd, filename, flags, mode);",
                        "}",
                        "#endif",
                        "",
                        "#ifndef __alpha__",
                        "",
                        "/*",
                        " * For backward compatibility?  Maybe this should be moved",
                        " * into arch/i386 instead?",
                        " */",
                        "SYSCALL_DEFINE2(creat, const char __user *, pathname, umode_t, mode)",
                        "{",
                        "\tint flags = O_CREAT | O_WRONLY | O_TRUNC;",
                        "",
                        "\tif (force_o_largefile())",
                        "\t\tflags |= O_LARGEFILE;",
                        "\treturn do_sys_open(AT_FDCWD, pathname, flags, mode);",
                        "}"
                    ],
                    "start": 1272,
                    "highlight": 1288
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8132c42f"
        },
        "32035": {
            "name": "__x64_sys_creat(indirect)",
            "parent_idx": 32034,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n50",
                    "code": [
                        "static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)",
                        "{",
                        "\t/*",
                        "\t * Convert negative numbers to very high and thus out of range",
                        "\t * numbers for comparisons.",
                        "\t */",
                        "\tunsigned int unr = nr;",
                        "",
                        "\tif (likely(unr < NR_syscalls)) {",
                        "\t\tunr = array_index_nospec(unr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[unr](regs);",
                        "\t\treturn true;",
                        "\t}",
                        "\treturn false;",
                        "}"
                    ],
                    "start": 40,
                    "highlight": 50
                },
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n80",
                    "code": [
                        "__visible noinstr void do_syscall_64(struct pt_regs *regs, int nr)",
                        "{",
                        "\tadd_random_kstack_offset();",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "",
                        "\tif (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {",
                        "\t\t/* Invalid system call, but still a system call. */",
                        "\t\tregs->ax = __x64_sys_ni_syscall(regs);",
                        "\t}",
                        "",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 73,
                    "highlight": 80
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff823840fe"
        },
        "32034": {
            "name": "do_syscall_64",
            "parent_idx": 32032,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n113",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rsp, %rdi",
                        "\t/* Sign extend the lower 32bit as syscall numbers are treated as int */",
                        "\tmovslq\t%eax, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t * In the Xen PV case we must use iret anyway.",
                        "\t */",
                        "",
                        "\tALTERNATIVE \"\", \"jmp\tswapgs_restore_regs_and_return_to_usermode\", \\",
                        "\t\tX86_FEATURE_XENPV",
                        "",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tswapgs",
                        "\tsysretq",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 87,
                    "highlight": 113
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "32032": {
            "name": "1325_syscall_49",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "32480": {
            "name": "+0x2bb",
            "parent_idx": 32361,
            "source_line": [
                {
                    "file": "fs/fsopen.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fsopen.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n429",
                    "code": [
                        "/**",
                        " * sys_fsconfig - Set parameters and trigger actions on a context",
                        " * @fd: The filesystem context to act upon",
                        " * @cmd: The action to take",
                        " * @_key: Where appropriate, the parameter key to set",
                        " * @_value: Where appropriate, the parameter value to set",
                        " * @aux: Additional information for the value",
                        " *",
                        " * This system call is used to set parameters on a context, including",
                        " * superblock settings, data source and security labelling.",
                        " *",
                        " * Actions include triggering the creation of a superblock and the",
                        " * reconfiguration of the superblock attached to the specified context.",
                        " *",
                        " * When setting a parameter, @cmd indicates the type of value being proposed",
                        " * and @_key indicates the parameter to be altered.",
                        " *",
                        " * @_value and @aux are used to specify the value, should a value be required:",
                        " *",
                        " * (*) fsconfig_set_flag: No value is specified.  The parameter must be boolean",
                        " *     in nature.  The key may be prefixed with \"no\" to invert the",
                        " *     setting. @_value must be NULL and @aux must be 0.",
                        " *",
                        " * (*) fsconfig_set_string: A string value is specified.  The parameter can be",
                        " *     expecting boolean, integer, string or take a path.  A conversion to an",
                        " *     appropriate type will be attempted (which may include looking up as a",
                        " *     path).  @_value points to a NUL-terminated string and @aux must be 0.",
                        " *",
                        " * (*) fsconfig_set_binary: A binary blob is specified.  @_value points to the",
                        " *     blob and @aux indicates its size.  The parameter must be expecting a",
                        " *     blob.",
                        " *",
                        " * (*) fsconfig_set_path: A non-empty path is specified.  The parameter must be",
                        " *     expecting a path object.  @_value points to a NUL-terminated string that",
                        " *     is the path and @aux is a file descriptor at which to start a relative",
                        " *     lookup or AT_FDCWD.",
                        " *",
                        " * (*) fsconfig_set_path_empty: As fsconfig_set_path, but with AT_EMPTY_PATH",
                        " *     implied.",
                        " *",
                        " * (*) fsconfig_set_fd: An open file descriptor is specified.  @_value must be",
                        " *     NULL and @aux indicates the file descriptor.",
                        " */",
                        "SYSCALL_DEFINE5(fsconfig,",
                        "\t\tint, fd,",
                        "\t\tunsigned int, cmd,",
                        "\t\tconst char __user *, _key,",
                        "\t\tconst void __user *, _value,",
                        "\t\tint, aux)",
                        "{",
                        "\tstruct fs_context *fc;",
                        "\tstruct fd f;",
                        "\tint ret;",
                        "\tint lookup_flags = 0;",
                        "",
                        "\tstruct fs_parameter param = {",
                        "\t\t.type\t= fs_value_is_undefined,",
                        "\t};",
                        "",
                        "\tif (fd < 0)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FSCONFIG_SET_FLAG:",
                        "\t\tif (!_key || _value || aux)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_STRING:",
                        "\t\tif (!_key || !_value || aux)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_BINARY:",
                        "\t\tif (!_key || !_value || aux <= 0 || aux > 1024 * 1024)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_PATH:",
                        "\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tif (!_key || !_value || (aux != AT_FDCWD && aux < 0))",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_FD:",
                        "\t\tif (!_key || _value || aux < 0)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_CMD_CREATE:",
                        "\tcase FSCONFIG_CMD_RECONFIGURE:",
                        "\t\tif (_key || _value || aux)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\treturn -EOPNOTSUPP;",
                        "\t}",
                        "",
                        "\tf = fdget(fd);",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "\tret = -EINVAL;",
                        "\tif (f.file->f_op != &fscontext_fops)",
                        "\t\tgoto out_f;",
                        "",
                        "\tfc = f.file->private_data;",
                        "\tif (fc->ops == &legacy_fs_context_ops) {",
                        "\t\tswitch (cmd) {",
                        "\t\tcase FSCONFIG_SET_BINARY:",
                        "\t\tcase FSCONFIG_SET_PATH:",
                        "\t\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tcase FSCONFIG_SET_FD:",
                        "\t\t\tret = -EOPNOTSUPP;",
                        "\t\t\tgoto out_f;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (_key) {",
                        "\t\tparam.key = strndup_user(_key, 256);",
                        "\t\tif (IS_ERR(param.key)) {",
                        "\t\t\tret = PTR_ERR(param.key);",
                        "\t\t\tgoto out_f;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FSCONFIG_SET_FLAG:",
                        "\t\tparam.type = fs_value_is_flag;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_STRING:",
                        "\t\tparam.type = fs_value_is_string;",
                        "\t\tparam.string = strndup_user(_value, 256);",
                        "\t\tif (IS_ERR(param.string)) {",
                        "\t\t\tret = PTR_ERR(param.string);",
                        "\t\t\tgoto out_key;",
                        "\t\t}",
                        "\t\tparam.size = strlen(param.string);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_BINARY:",
                        "\t\tparam.type = fs_value_is_blob;",
                        "\t\tparam.size = aux;",
                        "\t\tparam.blob = memdup_user_nul(_value, aux);",
                        "\t\tif (IS_ERR(param.blob)) {",
                        "\t\t\tret = PTR_ERR(param.blob);",
                        "\t\t\tgoto out_key;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tlookup_flags = LOOKUP_EMPTY;",
                        "\t\tfallthrough;",
                        "\tcase FSCONFIG_SET_PATH:",
                        "\t\tparam.type = fs_value_is_filename;",
                        "\t\tparam.name = getname_flags(_value, lookup_flags, NULL);",
                        "\t\tif (IS_ERR(param.name)) {",
                        "\t\t\tret = PTR_ERR(param.name);",
                        "\t\t\tgoto out_key;",
                        "\t\t}",
                        "\t\tparam.dirfd = aux;",
                        "\t\tparam.size = strlen(param.name->name);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_FD:",
                        "\t\tparam.type = fs_value_is_file;",
                        "\t\tret = -EBADF;",
                        "\t\tparam.file = fget(aux);",
                        "\t\tif (!param.file)",
                        "\t\t\tgoto out_key;",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tret = mutex_lock_interruptible(&fc->uapi_mutex);",
                        "\tif (ret == 0) {",
                        "\t\tret = vfs_fsconfig_locked(fc, cmd, &param);",
                        "\t\tmutex_unlock(&fc->uapi_mutex);",
                        "\t}",
                        "",
                        "\t/* Clean up the our record of any value that we obtained from",
                        "\t * userspace.  Note that the value may have been stolen by the LSM or",
                        "\t * filesystem, in which case the value pointer will have been cleared.",
                        "\t */",
                        "\tswitch (cmd) {",
                        "\tcase FSCONFIG_SET_STRING:",
                        "\tcase FSCONFIG_SET_BINARY:",
                        "\t\tkfree(param.string);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_PATH:",
                        "\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tif (param.name)",
                        "\t\t\tputname(param.name);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_FD:",
                        "\t\tif (param.file)",
                        "\t\t\tfput(param.file);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tbreak;",
                        "\t}",
                        "out_key:",
                        "\tkfree(param.key);",
                        "out_f:",
                        "\tfdput(f);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 271,
                    "highlight": 429
                }
            ],
            "ins_idx": 2435,
            "addr": "0xffffffff8139650b"
        },
        "32478": {
            "name": "+0xba",
            "parent_idx": 32460,
            "source_line": [
                {
                    "file": "fs/file.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/file.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n849",
                    "code": [
                        "static struct file *__fget_files(struct files_struct *files, unsigned int fd,",
                        "\t\t\t\t fmode_t mask, unsigned int refs)",
                        "{",
                        "\tstruct file *file;",
                        "",
                        "\trcu_read_lock();",
                        "loop:",
                        "\tfile = files_lookup_fd_rcu(files, fd);",
                        "\tif (file) {",
                        "\t\t/* File object ref couldn't be taken.",
                        "\t\t * dup2() atomicity guarantee is the reason",
                        "\t\t * we loop to catch the new file (or NULL pointer)",
                        "\t\t */",
                        "\t\tif (file->f_mode & mask)",
                        "\t\t\tfile = NULL;",
                        "\t\telse if (!get_file_rcu_many(file, refs))",
                        "\t\t\tgoto loop;",
                        "\t}",
                        "\trcu_read_unlock();",
                        "",
                        "\treturn file;",
                        "}"
                    ],
                    "start": 828,
                    "highlight": 849
                }
            ],
            "ins_idx": 3071,
            "addr": "0xffffffff8136666a"
        },
        "32460": {
            "name": "fget",
            "parent_idx": 32361,
            "source_line": [
                {
                    "file": "fs/fsopen.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fsopen.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n429",
                    "code": [
                        "/**",
                        " * sys_fsconfig - Set parameters and trigger actions on a context",
                        " * @fd: The filesystem context to act upon",
                        " * @cmd: The action to take",
                        " * @_key: Where appropriate, the parameter key to set",
                        " * @_value: Where appropriate, the parameter value to set",
                        " * @aux: Additional information for the value",
                        " *",
                        " * This system call is used to set parameters on a context, including",
                        " * superblock settings, data source and security labelling.",
                        " *",
                        " * Actions include triggering the creation of a superblock and the",
                        " * reconfiguration of the superblock attached to the specified context.",
                        " *",
                        " * When setting a parameter, @cmd indicates the type of value being proposed",
                        " * and @_key indicates the parameter to be altered.",
                        " *",
                        " * @_value and @aux are used to specify the value, should a value be required:",
                        " *",
                        " * (*) fsconfig_set_flag: No value is specified.  The parameter must be boolean",
                        " *     in nature.  The key may be prefixed with \"no\" to invert the",
                        " *     setting. @_value must be NULL and @aux must be 0.",
                        " *",
                        " * (*) fsconfig_set_string: A string value is specified.  The parameter can be",
                        " *     expecting boolean, integer, string or take a path.  A conversion to an",
                        " *     appropriate type will be attempted (which may include looking up as a",
                        " *     path).  @_value points to a NUL-terminated string and @aux must be 0.",
                        " *",
                        " * (*) fsconfig_set_binary: A binary blob is specified.  @_value points to the",
                        " *     blob and @aux indicates its size.  The parameter must be expecting a",
                        " *     blob.",
                        " *",
                        " * (*) fsconfig_set_path: A non-empty path is specified.  The parameter must be",
                        " *     expecting a path object.  @_value points to a NUL-terminated string that",
                        " *     is the path and @aux is a file descriptor at which to start a relative",
                        " *     lookup or AT_FDCWD.",
                        " *",
                        " * (*) fsconfig_set_path_empty: As fsconfig_set_path, but with AT_EMPTY_PATH",
                        " *     implied.",
                        " *",
                        " * (*) fsconfig_set_fd: An open file descriptor is specified.  @_value must be",
                        " *     NULL and @aux indicates the file descriptor.",
                        " */",
                        "SYSCALL_DEFINE5(fsconfig,",
                        "\t\tint, fd,",
                        "\t\tunsigned int, cmd,",
                        "\t\tconst char __user *, _key,",
                        "\t\tconst void __user *, _value,",
                        "\t\tint, aux)",
                        "{",
                        "\tstruct fs_context *fc;",
                        "\tstruct fd f;",
                        "\tint ret;",
                        "\tint lookup_flags = 0;",
                        "",
                        "\tstruct fs_parameter param = {",
                        "\t\t.type\t= fs_value_is_undefined,",
                        "\t};",
                        "",
                        "\tif (fd < 0)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FSCONFIG_SET_FLAG:",
                        "\t\tif (!_key || _value || aux)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_STRING:",
                        "\t\tif (!_key || !_value || aux)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_BINARY:",
                        "\t\tif (!_key || !_value || aux <= 0 || aux > 1024 * 1024)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_PATH:",
                        "\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tif (!_key || !_value || (aux != AT_FDCWD && aux < 0))",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_FD:",
                        "\t\tif (!_key || _value || aux < 0)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_CMD_CREATE:",
                        "\tcase FSCONFIG_CMD_RECONFIGURE:",
                        "\t\tif (_key || _value || aux)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\treturn -EOPNOTSUPP;",
                        "\t}",
                        "",
                        "\tf = fdget(fd);",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "\tret = -EINVAL;",
                        "\tif (f.file->f_op != &fscontext_fops)",
                        "\t\tgoto out_f;",
                        "",
                        "\tfc = f.file->private_data;",
                        "\tif (fc->ops == &legacy_fs_context_ops) {",
                        "\t\tswitch (cmd) {",
                        "\t\tcase FSCONFIG_SET_BINARY:",
                        "\t\tcase FSCONFIG_SET_PATH:",
                        "\t\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tcase FSCONFIG_SET_FD:",
                        "\t\t\tret = -EOPNOTSUPP;",
                        "\t\t\tgoto out_f;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (_key) {",
                        "\t\tparam.key = strndup_user(_key, 256);",
                        "\t\tif (IS_ERR(param.key)) {",
                        "\t\t\tret = PTR_ERR(param.key);",
                        "\t\t\tgoto out_f;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FSCONFIG_SET_FLAG:",
                        "\t\tparam.type = fs_value_is_flag;",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_STRING:",
                        "\t\tparam.type = fs_value_is_string;",
                        "\t\tparam.string = strndup_user(_value, 256);",
                        "\t\tif (IS_ERR(param.string)) {",
                        "\t\t\tret = PTR_ERR(param.string);",
                        "\t\t\tgoto out_key;",
                        "\t\t}",
                        "\t\tparam.size = strlen(param.string);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_BINARY:",
                        "\t\tparam.type = fs_value_is_blob;",
                        "\t\tparam.size = aux;",
                        "\t\tparam.blob = memdup_user_nul(_value, aux);",
                        "\t\tif (IS_ERR(param.blob)) {",
                        "\t\t\tret = PTR_ERR(param.blob);",
                        "\t\t\tgoto out_key;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tlookup_flags = LOOKUP_EMPTY;",
                        "\t\tfallthrough;",
                        "\tcase FSCONFIG_SET_PATH:",
                        "\t\tparam.type = fs_value_is_filename;",
                        "\t\tparam.name = getname_flags(_value, lookup_flags, NULL);",
                        "\t\tif (IS_ERR(param.name)) {",
                        "\t\t\tret = PTR_ERR(param.name);",
                        "\t\t\tgoto out_key;",
                        "\t\t}",
                        "\t\tparam.dirfd = aux;",
                        "\t\tparam.size = strlen(param.name->name);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_FD:",
                        "\t\tparam.type = fs_value_is_file;",
                        "\t\tret = -EBADF;",
                        "\t\tparam.file = fget(aux);",
                        "\t\tif (!param.file)",
                        "\t\t\tgoto out_key;",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tret = mutex_lock_interruptible(&fc->uapi_mutex);",
                        "\tif (ret == 0) {",
                        "\t\tret = vfs_fsconfig_locked(fc, cmd, &param);",
                        "\t\tmutex_unlock(&fc->uapi_mutex);",
                        "\t}",
                        "",
                        "\t/* Clean up the our record of any value that we obtained from",
                        "\t * userspace.  Note that the value may have been stolen by the LSM or",
                        "\t * filesystem, in which case the value pointer will have been cleared.",
                        "\t */",
                        "\tswitch (cmd) {",
                        "\tcase FSCONFIG_SET_STRING:",
                        "\tcase FSCONFIG_SET_BINARY:",
                        "\t\tkfree(param.string);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_PATH:",
                        "\tcase FSCONFIG_SET_PATH_EMPTY:",
                        "\t\tif (param.name)",
                        "\t\t\tputname(param.name);",
                        "\t\tbreak;",
                        "\tcase FSCONFIG_SET_FD:",
                        "\t\tif (param.file)",
                        "\t\t\tfput(param.file);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tbreak;",
                        "\t}",
                        "out_key:",
                        "\tkfree(param.key);",
                        "out_f:",
                        "\tfdput(f);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 271,
                    "highlight": 429
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81396506"
        },
        "32477": {
            "name": "+0x6e",
            "parent_idx": 32460,
            "source_line": [
                {
                    "file": "./include/linux/fdtable.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/fdtable.h?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n89",
                    "code": [
                        "/*",
                        " * The caller must ensure that fd table isn't shared or hold rcu or file lock",
                        " */",
                        "static inline struct file *files_lookup_fd_raw(struct files_struct *files, unsigned int fd)",
                        "{",
                        "\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);",
                        "",
                        "\tif (fd < fdt->max_fds) {",
                        "\t\tfd = array_index_nospec(fd, fdt->max_fds);",
                        "\t\treturn rcu_dereference_raw(fdt->fd[fd]);",
                        "\t}",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 80,
                    "highlight": 89
                },
                {
                    "file": "./include/linux/fdtable.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/fdtable.h?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n105",
                    "code": [
                        "static inline struct file *files_lookup_fd_rcu(struct files_struct *files, unsigned int fd)",
                        "{",
                        "\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),",
                        "\t\t\t   \"suspicious rcu_dereference_check() usage\");",
                        "\treturn files_lookup_fd_raw(files, fd);",
                        "}"
                    ],
                    "start": 101,
                    "highlight": 105
                },
                {
                    "file": "fs/file.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/file.c?id=7fef2edf7cc753b51f7ccc74993971b0a9c81eca#n835",
                    "code": [
                        "static struct file *__fget_files(struct files_struct *files, unsigned int fd,",
                        "\t\t\t\t fmode_t mask, unsigned int refs)",
                        "{",
                        "\tstruct file *file;",
                        "",
                        "\trcu_read_lock();",
                        "loop:",
                        "\tfile = files_lookup_fd_rcu(files, fd);",
                        "\tif (file) {",
                        "\t\t/* File object ref couldn't be taken.",
                        "\t\t * dup2() atomicity guarantee is the reason",
                        "\t\t * we loop to catch the new file (or NULL pointer)",
                        "\t\t */",
                        "\t\tif (file->f_mode & mask)",
                        "\t\t\tfile = NULL;",
                        "\t\telse if (!get_file_rcu_many(file, refs))",
                        "\t\t\tgoto loop;",
                        "\t}",
                        "\trcu_read_unlock();",
                        "",
                        "\treturn file;",
                        "}"
                    ],
                    "start": 828,
                    "highlight": 835
                }
            ],
            "ins_idx": 3681,
            "addr": "0xffffffff8136661e"
        }
    },
    "ins": {
        "341": {
            "name": "mov rax, qword ptr [rbp + 0x38]",
            "desc": "Invalid Memory Access\nUse-After-Free.",
            "call_idx": 32771,
            "inputs": [
                60958,
                60959
            ],
            "outputs": [
                60960
            ]
        },
        "689": {
            "name": "ret ",
            "desc": "pointer free",
            "call_idx": 32665,
            "inputs": [
                60771,
                60772
            ],
            "outputs": [
                60773
            ]
        },
        "688": {
            "name": "mov rbp, rdi",
            "desc": "",
            "call_idx": 32770,
            "inputs": [
                60956
            ],
            "outputs": [
                60957
            ]
        },
        "1053": {
            "name": "mov rdi, qword ptr [rbp + 0x70]",
            "desc": "",
            "call_idx": 32663,
            "inputs": [
                60768,
                60769
            ],
            "outputs": [
                60770
            ]
        },
        "1052": {
            "name": "mov rdi, r14",
            "desc": "",
            "call_idx": 32769,
            "inputs": [
                60954
            ],
            "outputs": [
                60955
            ]
        },
        "1488": {
            "name": "mov qword ptr [rbx + 0x70], rdx",
            "desc": "",
            "call_idx": 32539,
            "inputs": [
                60548,
                60549
            ],
            "outputs": [
                60550
            ]
        },
        "2431": {
            "name": "mov r14, qword ptr [rbx]",
            "desc": "dangling ptr occurs.",
            "call_idx": 32763,
            "inputs": [
                60943,
                60944
            ],
            "outputs": [
                60945
            ]
        },
        "1938": {
            "name": "mov rdx, qword ptr [rbp + 0x10]",
            "desc": "",
            "call_idx": 32538,
            "inputs": [
                60545,
                60546
            ],
            "outputs": [
                60547
            ]
        },
        "3065": {
            "name": "mov qword ptr [rbx], r12",
            "desc": "dangling ptr occurs.",
            "call_idx": 32276,
            "inputs": [
                60050,
                60051
            ],
            "outputs": [
                60052
            ]
        },
        "2435": {
            "name": "mov qword ptr [rsp + 0x58], rax",
            "desc": "",
            "call_idx": 32480,
            "inputs": [
                60444,
                60445
            ],
            "outputs": [
                60446
            ]
        },
        "3071": {
            "name": "mov rax, r13",
            "desc": "",
            "call_idx": 32478,
            "inputs": [
                60441
            ],
            "outputs": [
                60442
            ]
        },
        "3681": {
            "name": "mov r13, qword ptr [r13]",
            "desc": "",
            "call_idx": 32477,
            "inputs": [
                60438,
                60439
            ],
            "outputs": [
                60440
            ]
        }
    },
    "data": {
        "60958": {
            "name": "RBP",
            "ins_idx": 341,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60959": {
            "name": "[0xffff88810e685df8]",
            "ins_idx": 341,
            "value": "0x0",
            "sources": []
        },
        "60960": {
            "name": "RAX",
            "ins_idx": 341,
            "value": "0x0",
            "sources": []
        },
        "60771": {
            "name": "RDI",
            "ins_idx": 689,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60772": {
            "name": "[0xffff88810e685dc0]",
            "ins_idx": 689,
            "value": "0x0",
            "sources": []
        },
        "60773": {
            "name": "[0xffff88810e685dc0]",
            "ins_idx": 689,
            "value": "0x0",
            "sources": []
        },
        "60956": {
            "name": "RDI",
            "ins_idx": 688,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60957": {
            "name": "RBP",
            "ins_idx": 688,
            "value": "0xffff88810e685dc0",
            "sources": [
                60958
            ]
        },
        "60768": {
            "name": "RBP",
            "ins_idx": 1053,
            "value": "0xffff88810e4acc00",
            "sources": []
        },
        "60769": {
            "name": "[0xffff88810e4acc70]",
            "ins_idx": 1053,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60770": {
            "name": "RDI",
            "ins_idx": 1053,
            "value": "0xffff88810e685dc0",
            "sources": [
                60771
            ]
        },
        "60954": {
            "name": "R14",
            "ins_idx": 1052,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60955": {
            "name": "RDI",
            "ins_idx": 1052,
            "value": "0xffff88810e685dc0",
            "sources": [
                60956
            ]
        },
        "60548": {
            "name": "RBX",
            "ins_idx": 1488,
            "value": "0xffff88810e4acc00",
            "sources": []
        },
        "60549": {
            "name": "RDX",
            "ins_idx": 1488,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60550": {
            "name": "[0xffff88810e4acc70]",
            "ins_idx": 1488,
            "value": "0xffff88810e685dc0",
            "sources": [
                60769
            ]
        },
        "60943": {
            "name": "RBX",
            "ins_idx": 2431,
            "value": "0xffff8881026c67c0",
            "sources": []
        },
        "60944": {
            "name": "[0xffff8881026c67c0]",
            "ins_idx": 2431,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60945": {
            "name": "R14",
            "ins_idx": 2431,
            "value": "0xffff88810e685dc0",
            "sources": [
                60954
            ]
        },
        "60545": {
            "name": "RBP",
            "ins_idx": 1938,
            "value": "0xffff88810f5c7e98",
            "sources": []
        },
        "60546": {
            "name": "[0xffff88810f5c7ea8]",
            "ins_idx": 1938,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60547": {
            "name": "RDX",
            "ins_idx": 1938,
            "value": "0xffff88810e685dc0",
            "sources": [
                60549
            ]
        },
        "60050": {
            "name": "R12",
            "ins_idx": 3065,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60051": {
            "name": "RBX",
            "ins_idx": 3065,
            "value": "0xffff8881026c67c0",
            "sources": []
        },
        "60052": {
            "name": "[0xffff8881026c67c0]",
            "ins_idx": 3065,
            "value": "0xffff88810e685dc0",
            "sources": [
                60944,
                60439
            ]
        },
        "60444": {
            "name": "RSP",
            "ins_idx": 2435,
            "value": "0xffff88810f5c7e50",
            "sources": []
        },
        "60445": {
            "name": "RAX",
            "ins_idx": 2435,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60446": {
            "name": "[0xffff88810f5c7ea8]",
            "ins_idx": 2435,
            "value": "0xffff88810e685dc0",
            "sources": [
                60546
            ]
        },
        "60441": {
            "name": "R13",
            "ins_idx": 3071,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60442": {
            "name": "RAX",
            "ins_idx": 3071,
            "value": "0xffff88810e685dc0",
            "sources": [
                60445
            ]
        },
        "60438": {
            "name": "R13",
            "ins_idx": 3681,
            "value": "0xffff8881026c67c0",
            "sources": []
        },
        "60439": {
            "name": "[0xffff8881026c67c0]",
            "ins_idx": 3681,
            "value": "0xffff88810e685dc0",
            "sources": []
        },
        "60440": {
            "name": "R13",
            "ins_idx": 3681,
            "value": "0xffff88810e685dc0",
            "sources": [
                60441
            ]
        }
    },
    "chain": {
        "341": [
            688
        ],
        "689": [
            1053
        ],
        "688": [
            1052
        ],
        "1053": [
            1488
        ],
        "1052": [
            2431
        ],
        "1488": [
            1938
        ],
        "2431": [
            3065
        ],
        "1938": [
            2435
        ],
        "2435": [
            3071
        ],
        "3071": [
            3681
        ],
        "3681": [
            3065
        ]
    }
}