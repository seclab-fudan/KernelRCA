{
    "report": "https://syzkaller.appspot.com/bug?id=691c051dfc6e52aefdb026b7c502b2aa6505a854",
    "title": "BUG: unable to handle kernel paging request in diFree",
    "call": {
        "1044": {
            "name": "+0x45",
            "parent_idx": 1040,
            "source_line": [
                {
                    "file": "fs/jfs/jfs_imap.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jfs/jfs_imap.c?id=805c6d3c#n853",
                    "code": [
                        "/*",
                        " * NAME:\tdiFree(ip)",
                        " *",
                        " * FUNCTION:\tfree a specified inode from the inode working map",
                        " *\t\tfor a fileset or aggregate.",
                        " *",
                        " *\t\tif the inode to be freed represents the first (only)",
                        " *\t\tfree inode within the iag, the iag will be placed on",
                        " *\t\tthe ag free inode list.",
                        " *",
                        " *\t\tfreeing the inode will cause the inode extent to be",
                        " *\t\tfreed if the inode is the only allocated inode within",
                        " *\t\tthe extent.  in this case all the disk resource backing",
                        " *\t\tup the inode extent will be freed. in addition, the iag",
                        " *\t\twill be placed on the ag extent free list if the extent",
                        " *\t\tis the first free extent in the iag.  if freeing the",
                        " *\t\textent also means that no free inodes will exist for",
                        " *\t\tthe iag, the iag will also be removed from the ag free",
                        " *\t\tinode list.",
                        " *",
                        " *\t\tthe iag describing the inode will be freed if the extent",
                        " *\t\tis to be freed and it is the only backed extent within",
                        " *\t\tthe iag.  in this case, the iag will be removed from the",
                        " *\t\tag free extent list and ag free inode list and placed on",
                        " *\t\tthe inode map's free iag list.",
                        " *",
                        " *\t\ta careful update approach is used to provide consistency",
                        " *\t\tin the face of updates to multiple buffers.  under this",
                        " *\t\tapproach, all required buffers are obtained before making",
                        " *\t\tany updates and are held until all updates are complete.",
                        " *",
                        " * PARAMETERS:",
                        " *\tip\t- inode to be freed.",
                        " *",
                        " * RETURN VALUES:",
                        " *\t0\t- success",
                        " *\t-EIO\t- i/o error.",
                        " */",
                        "int diFree(struct inode *ip)",
                        "{",
                        "\tint rc;",
                        "\tino_t inum = ip->i_ino;",
                        "\tstruct iag *iagp, *aiagp, *biagp, *ciagp, *diagp;",
                        "\tstruct metapage *mp, *amp, *bmp, *cmp, *dmp;",
                        "\tint iagno, ino, extno, bitno, sword, agno;",
                        "\tint back, fwd;",
                        "\tu32 bitmap, mask;",
                        "\tstruct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap;",
                        "\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;",
                        "\tpxd_t freepxd;",
                        "\ttid_t tid;",
                        "\tstruct inode *iplist[3];",
                        "\tstruct tlock *tlck;",
                        "\tstruct pxd_lock *pxdlock;",
                        "",
                        "\t/*",
                        "\t * This is just to suppress compiler warnings.  The same logic that",
                        "\t * references these variables is used to initialize them.",
                        "\t */",
                        "\taiagp = biagp = ciagp = diagp = NULL;",
                        "",
                        "\t/* get the iag number containing the inode.",
                        "\t */",
                        "\tiagno = INOTOIAG(inum);",
                        "",
                        "\t/* make sure that the iag is contained within",
                        "\t * the map.",
                        "\t */",
                        "\tif (iagno >= imap->im_nextiag) {",
                        "\t\tprint_hex_dump(KERN_ERR, \"imap: \", DUMP_PREFIX_ADDRESS, 16, 4,",
                        "\t\t\t       imap, 32, 0);",
                        "\t\tjfs_error(ip->i_sb, \"inum = %d, iagno = %d, nextiag = %d\\n\",",
                        "\t\t\t  (uint) inum, iagno, imap->im_nextiag);",
                        "\t\treturn -EIO;",
                        "\t}",
                        "",
                        "\t/* get the allocation group for this ino.",
                        "\t */",
                        "\tagno = BLKTOAG(JFS_IP(ip)->agstart, JFS_SBI(ip->i_sb));",
                        "",
                        "\t/* Lock the AG specific inode map information",
                        "\t */",
                        "\tAG_LOCK(imap, agno);",
                        "",
                        "\t/* Obtain read lock in imap inode.  Don't release it until we have",
                        "\t * read all of the IAG's that we are going to.",
                        "\t */",
                        "\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);",
                        "",
                        "\t/* read the iag.",
                        "\t */",
                        "\tif ((rc = diIAGRead(imap, iagno, &mp))) {",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "\t\treturn (rc);",
                        "\t}",
                        "\tiagp = (struct iag *) mp->data;",
                        "",
                        "\t/* get the inode number and extent number of the inode within",
                        "\t * the iag and the inode number within the extent.",
                        "\t */",
                        "\tino = inum & (INOSPERIAG - 1);",
                        "\textno = ino >> L2INOSPEREXT;",
                        "\tbitno = ino & (INOSPEREXT - 1);",
                        "\tmask = HIGHORDER >> bitno;",
                        "",
                        "\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {",
                        "\t\tjfs_error(ip->i_sb, \"wmap shows inode already free\\n\");",
                        "\t}",
                        "",
                        "\tif (!addressPXD(&iagp->inoext[extno])) {",
                        "\t\trelease_metapage(mp);",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "\t\tjfs_error(ip->i_sb, \"invalid inoext\\n\");",
                        "\t\treturn -EIO;",
                        "\t}",
                        "",
                        "\t/* compute the bitmap for the extent reflecting the freed inode.",
                        "\t */",
                        "\tbitmap = le32_to_cpu(iagp->wmap[extno]) & ~mask;",
                        "",
                        "\tif (imap->im_agctl[agno].numfree > imap->im_agctl[agno].numinos) {",
                        "\t\trelease_metapage(mp);",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");",
                        "\t\treturn -EIO;",
                        "\t}",
                        "\t/*",
                        "\t *\tinode extent still has some inodes or below low water mark:",
                        "\t *\tkeep the inode extent;",
                        "\t */",
                        "\tif (bitmap ||",
                        "\t    imap->im_agctl[agno].numfree < 96 ||",
                        "\t    (imap->im_agctl[agno].numfree < 288 &&",
                        "\t     (((imap->im_agctl[agno].numfree * 100) /",
                        "\t       imap->im_agctl[agno].numinos) <= 25))) {",
                        "\t\t/* if the iag currently has no free inodes (i.e.,",
                        "\t\t * the inode being freed is the first free inode of iag),",
                        "\t\t * insert the iag at head of the inode free list for the ag.",
                        "\t\t */",
                        "\t\tif (iagp->nfreeinos == 0) {",
                        "\t\t\t/* check if there are any iags on the ag inode",
                        "\t\t\t * free list.  if so, read the first one so that",
                        "\t\t\t * we can link the current iag onto the list at",
                        "\t\t\t * the head.",
                        "\t\t\t */",
                        "\t\t\tif ((fwd = imap->im_agctl[agno].inofree) >= 0) {",
                        "\t\t\t\t/* read the iag that currently is the head",
                        "\t\t\t\t * of the list.",
                        "\t\t\t\t */",
                        "\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp))) {",
                        "\t\t\t\t\tIREAD_UNLOCK(ipimap);",
                        "\t\t\t\t\tAG_UNLOCK(imap, agno);",
                        "\t\t\t\t\trelease_metapage(mp);",
                        "\t\t\t\t\treturn (rc);",
                        "\t\t\t\t}",
                        "\t\t\t\taiagp = (struct iag *) amp->data;",
                        "",
                        "\t\t\t\t/* make current head point back to the iag.",
                        "\t\t\t\t */",
                        "\t\t\t\taiagp->inofreeback = cpu_to_le32(iagno);",
                        "",
                        "\t\t\t\twrite_metapage(amp);",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* iag points forward to current head and iag",
                        "\t\t\t * becomes the new head of the list.",
                        "\t\t\t */",
                        "\t\t\tiagp->inofreefwd =",
                        "\t\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);",
                        "\t\t\tiagp->inofreeback = cpu_to_le32(-1);",
                        "\t\t\timap->im_agctl[agno].inofree = iagno;",
                        "\t\t}",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "",
                        "\t\t/* update the free inode summary map for the extent if",
                        "\t\t * freeing the inode means the extent will now have free",
                        "\t\t * inodes (i.e., the inode being freed is the first free",
                        "\t\t * inode of extent),",
                        "\t\t */",
                        "\t\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {",
                        "\t\t\tsword = extno >> L2EXTSPERSUM;",
                        "\t\t\tbitno = extno & (EXTSPERSUM - 1);",
                        "\t\t\tiagp->inosmap[sword] &=",
                        "\t\t\t    cpu_to_le32(~(HIGHORDER >> bitno));",
                        "\t\t}",
                        "",
                        "\t\t/* update the bitmap.",
                        "\t\t */",
                        "\t\tiagp->wmap[extno] = cpu_to_le32(bitmap);",
                        "",
                        "\t\t/* update the free inode counts at the iag, ag and",
                        "\t\t * map level.",
                        "\t\t */",
                        "\t\tle32_add_cpu(&iagp->nfreeinos, 1);",
                        "\t\timap->im_agctl[agno].numfree += 1;",
                        "\t\tatomic_inc(&imap->im_numfree);",
                        "",
                        "\t\t/* release the AG inode map lock",
                        "\t\t */",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "",
                        "\t\t/* write the iag */",
                        "\t\twrite_metapage(mp);",
                        "",
                        "\t\treturn (0);",
                        "\t}",
                        "",
                        "",
                        "\t/*",
                        "\t *\tinode extent has become free and above low water mark:",
                        "\t *\tfree the inode extent;",
                        "\t */",
                        "",
                        "\t/*",
                        "\t *\tprepare to update iag list(s) (careful update step 1)",
                        "\t */",
                        "\tamp = bmp = cmp = dmp = NULL;",
                        "\tfwd = back = -1;",
                        "",
                        "\t/* check if the iag currently has no free extents.  if so,",
                        "\t * it will be placed on the head of the ag extent free list.",
                        "\t */",
                        "\tif (iagp->nfreeexts == 0) {",
                        "\t\t/* check if the ag extent free list has any iags.",
                        "\t\t * if so, read the iag at the head of the list now.",
                        "\t\t * this (head) iag will be updated later to reflect",
                        "\t\t * the addition of the current iag at the head of",
                        "\t\t * the list.",
                        "\t\t */",
                        "\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {",
                        "\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))",
                        "\t\t\t\tgoto error_out;",
                        "\t\t\taiagp = (struct iag *) amp->data;",
                        "\t\t}",
                        "\t} else {",
                        "\t\t/* iag has free extents. check if the addition of a free",
                        "\t\t * extent will cause all extents to be free within this",
                        "\t\t * iag.  if so, the iag will be removed from the ag extent",
                        "\t\t * free list and placed on the inode map's free iag list.",
                        "\t\t */",
                        "\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {",
                        "\t\t\t/* in preparation for removing the iag from the",
                        "\t\t\t * ag extent free list, read the iags preceding",
                        "\t\t\t * and following the iag on the ag extent free",
                        "\t\t\t * list.",
                        "\t\t\t */",
                        "\t\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {",
                        "\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\taiagp = (struct iag *) amp->data;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {",
                        "\t\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\tbiagp = (struct iag *) bmp->data;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* remove the iag from the ag inode free list if freeing",
                        "\t * this extent cause the iag to have no free inodes.",
                        "\t */",
                        "\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {",
                        "\t\tint inofreeback = le32_to_cpu(iagp->inofreeback);",
                        "\t\tint inofreefwd = le32_to_cpu(iagp->inofreefwd);",
                        "",
                        "\t\t/* in preparation for removing the iag from the",
                        "\t\t * ag inode free list, read the iags preceding",
                        "\t\t * and following the iag on the ag inode free",
                        "\t\t * list.  before reading these iags, we must make",
                        "\t\t * sure that we already don't have them in hand",
                        "\t\t * from up above, since re-reading an iag (buffer)",
                        "\t\t * we are currently holding would cause a deadlock.",
                        "\t\t */",
                        "\t\tif (inofreefwd >= 0) {",
                        "",
                        "\t\t\tif (inofreefwd == fwd)",
                        "\t\t\t\tciagp = (struct iag *) amp->data;",
                        "\t\t\telse if (inofreefwd == back)",
                        "\t\t\t\tciagp = (struct iag *) bmp->data;",
                        "\t\t\telse {",
                        "\t\t\t\tif ((rc =",
                        "\t\t\t\t     diIAGRead(imap, inofreefwd, &cmp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\tciagp = (struct iag *) cmp->data;",
                        "\t\t\t}",
                        "\t\t\tassert(ciagp != NULL);",
                        "\t\t}",
                        "",
                        "\t\tif (inofreeback >= 0) {",
                        "\t\t\tif (inofreeback == fwd)",
                        "\t\t\t\tdiagp = (struct iag *) amp->data;",
                        "\t\t\telse if (inofreeback == back)",
                        "\t\t\t\tdiagp = (struct iag *) bmp->data;",
                        "\t\t\telse {",
                        "\t\t\t\tif ((rc =",
                        "\t\t\t\t     diIAGRead(imap, inofreeback, &dmp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\tdiagp = (struct iag *) dmp->data;",
                        "\t\t\t}",
                        "\t\t\tassert(diagp != NULL);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tIREAD_UNLOCK(ipimap);",
                        "",
                        "\t/*",
                        "\t * invalidate any page of the inode extent freed from buffer cache;",
                        "\t */",
                        "\tfreepxd = iagp->inoext[extno];",
                        "\tinvalidate_pxd_metapages(ip, freepxd);",
                        "",
                        "\t/*",
                        "\t *\tupdate iag list(s) (careful update step 2)",
                        "\t */",
                        "\t/* add the iag to the ag extent free list if this is the",
                        "\t * first free extent for the iag.",
                        "\t */",
                        "\tif (iagp->nfreeexts == 0) {",
                        "\t\tif (fwd >= 0)",
                        "\t\t\taiagp->extfreeback = cpu_to_le32(iagno);",
                        "",
                        "\t\tiagp->extfreefwd =",
                        "\t\t    cpu_to_le32(imap->im_agctl[agno].extfree);",
                        "\t\tiagp->extfreeback = cpu_to_le32(-1);",
                        "\t\timap->im_agctl[agno].extfree = iagno;",
                        "\t} else {",
                        "\t\t/* remove the iag from the ag extent list if all extents",
                        "\t\t * are now free and place it on the inode map iag free list.",
                        "\t\t */",
                        "\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {",
                        "\t\t\tif (fwd >= 0)",
                        "\t\t\t\taiagp->extfreeback = iagp->extfreeback;",
                        "",
                        "\t\t\tif (back >= 0)",
                        "\t\t\t\tbiagp->extfreefwd = iagp->extfreefwd;",
                        "\t\t\telse",
                        "\t\t\t\timap->im_agctl[agno].extfree =",
                        "\t\t\t\t    le32_to_cpu(iagp->extfreefwd);",
                        "",
                        "\t\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);",
                        "",
                        "\t\t\tIAGFREE_LOCK(imap);",
                        "\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);",
                        "\t\t\timap->im_freeiag = iagno;",
                        "\t\t\tIAGFREE_UNLOCK(imap);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* remove the iag from the ag inode free list if freeing",
                        "\t * this extent causes the iag to have no free inodes.",
                        "\t */",
                        "\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {",
                        "\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0)",
                        "\t\t\tciagp->inofreeback = iagp->inofreeback;",
                        "",
                        "\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0)",
                        "\t\t\tdiagp->inofreefwd = iagp->inofreefwd;",
                        "\t\telse",
                        "\t\t\timap->im_agctl[agno].inofree =",
                        "\t\t\t    le32_to_cpu(iagp->inofreefwd);",
                        "",
                        "\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);",
                        "\t}",
                        "",
                        "\t/* update the inode extent address and working map",
                        "\t * to reflect the free extent.",
                        "\t * the permanent map should have been updated already",
                        "\t * for the inode being freed.",
                        "\t */",
                        "\tif (iagp->pmap[extno] != 0) {",
                        "\t\tjfs_error(ip->i_sb, \"the pmap does not show inode free\\n\");",
                        "\t}",
                        "\tiagp->wmap[extno] = 0;",
                        "\tPXDlength(&iagp->inoext[extno], 0);",
                        "\tPXDaddress(&iagp->inoext[extno], 0);",
                        "",
                        "\t/* update the free extent and free inode summary maps",
                        "\t * to reflect the freed extent.",
                        "\t * the inode summary map is marked to indicate no inodes",
                        "\t * available for the freed extent.",
                        "\t */",
                        "\tsword = extno >> L2EXTSPERSUM;",
                        "\tbitno = extno & (EXTSPERSUM - 1);",
                        "\tmask = HIGHORDER >> bitno;",
                        "\tiagp->inosmap[sword] |= cpu_to_le32(mask);",
                        "\tiagp->extsmap[sword] &= cpu_to_le32(~mask);",
                        "",
                        "\t/* update the number of free inodes and number of free extents",
                        "\t * for the iag.",
                        "\t */",
                        "\tle32_add_cpu(&iagp->nfreeinos, -(INOSPEREXT - 1));",
                        "\tle32_add_cpu(&iagp->nfreeexts, 1);",
                        "",
                        "\t/* update the number of free inodes and backed inodes",
                        "\t * at the ag and inode map level.",
                        "\t */",
                        "\timap->im_agctl[agno].numfree -= (INOSPEREXT - 1);",
                        "\timap->im_agctl[agno].numinos -= INOSPEREXT;",
                        "\tatomic_sub(INOSPEREXT - 1, &imap->im_numfree);",
                        "\tatomic_sub(INOSPEREXT, &imap->im_numinos);",
                        "",
                        "\tif (amp)",
                        "\t\twrite_metapage(amp);",
                        "\tif (bmp)",
                        "\t\twrite_metapage(bmp);",
                        "\tif (cmp)",
                        "\t\twrite_metapage(cmp);",
                        "\tif (dmp)",
                        "\t\twrite_metapage(dmp);",
                        "",
                        "\t/*",
                        "\t * start transaction to update block allocation map",
                        "\t * for the inode extent freed;",
                        "\t *",
                        "\t * N.B. AG_LOCK is released and iag will be released below, and",
                        "\t * other thread may allocate inode from/reusing the ixad freed",
                        "\t * BUT with new/different backing inode extent from the extent",
                        "\t * to be freed by the transaction;",
                        "\t */",
                        "\ttid = txBegin(ipimap->i_sb, COMMIT_FORCE);",
                        "\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);",
                        "",
                        "\t/* acquire tlock of the iag page of the freed ixad",
                        "\t * to force the page NOHOMEOK (even though no data is",
                        "\t * logged from the iag page) until NOREDOPAGE|FREEXTENT log",
                        "\t * for the free of the extent is committed;",
                        "\t * write FREEXTENT|NOREDOPAGE log record",
                        "\t * N.B. linelock is overlaid as freed extent descriptor;",
                        "\t */",
                        "\ttlck = txLock(tid, ipimap, mp, tlckINODE | tlckFREE);",
                        "\tpxdlock = (struct pxd_lock *) & tlck->lock;",
                        "\tpxdlock->flag = mlckFREEPXD;",
                        "\tpxdlock->pxd = freepxd;",
                        "\tpxdlock->index = 1;",
                        "",
                        "\twrite_metapage(mp);",
                        "",
                        "\tiplist[0] = ipimap;",
                        "",
                        "\t/*",
                        "\t * logredo needs the IAG number and IAG extent index in order",
                        "\t * to ensure that the IMap is consistent.  The least disruptive",
                        "\t * way to pass these values through  to the transaction manager",
                        "\t * is in the iplist array.",
                        "\t *",
                        "\t * It's not pretty, but it works.",
                        "\t */",
                        "\tiplist[1] = (struct inode *) (size_t)iagno;",
                        "\tiplist[2] = (struct inode *) (size_t)extno;",
                        "",
                        "\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);",
                        "",
                        "\ttxEnd(tid);",
                        "\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);",
                        "",
                        "\t/* unlock the AG inode map information */",
                        "\tAG_UNLOCK(imap, agno);",
                        "",
                        "\treturn (0);",
                        "",
                        "      error_out:",
                        "\tIREAD_UNLOCK(ipimap);",
                        "",
                        "\tif (amp)",
                        "\t\trelease_metapage(amp);",
                        "\tif (bmp)",
                        "\t\trelease_metapage(bmp);",
                        "\tif (cmp)",
                        "\t\trelease_metapage(cmp);",
                        "\tif (dmp)",
                        "\t\trelease_metapage(dmp);",
                        "",
                        "\tAG_UNLOCK(imap, agno);",
                        "",
                        "\trelease_metapage(mp);",
                        "",
                        "\treturn (rc);",
                        "}"
                    ],
                    "start": 805,
                    "highlight": 853
                }
            ],
            "ins_idx": 16,
            "addr": "0xffffffff8136ac75"
        },
        "1040": {
            "name": "diFree",
            "parent_idx": 1027,
            "source_line": [
                {
                    "file": "fs/jfs/inode.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jfs/inode.c?id=805c6d3c#n154",
                    "code": [
                        "void jfs_evict_inode(struct inode *inode)",
                        "{",
                        "\tstruct jfs_inode_info *ji = JFS_IP(inode);",
                        "",
                        "\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);",
                        "",
                        "\tif (!inode->i_nlink && !is_bad_inode(inode)) {",
                        "\t\tdquot_initialize(inode);",
                        "",
                        "\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {",
                        "\t\t\ttruncate_inode_pages_final(&inode->i_data);",
                        "",
                        "\t\t\tif (test_cflag(COMMIT_Freewmap, inode))",
                        "\t\t\t\tjfs_free_zero_link(inode);",
                        "",
                        "\t\t\tdiFree(inode);",
                        "",
                        "\t\t\t/*",
                        "\t\t\t * Free the inode from the quota allocation.",
                        "\t\t\t */",
                        "\t\t\tdquot_free_inode(inode);",
                        "\t\t}",
                        "\t} else {",
                        "\t\ttruncate_inode_pages_final(&inode->i_data);",
                        "\t}",
                        "\tclear_inode(inode);",
                        "\tdquot_drop(inode);",
                        "",
                        "\tBUG_ON(!list_empty(&ji->anon_inode_list));",
                        "",
                        "\tspin_lock_irq(&ji->ag_lock);",
                        "\tif (ji->active_ag != -1) {",
                        "\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;",
                        "\t\tatomic_dec(&bmap->db_active[ji->active_ag]);",
                        "\t\tji->active_ag = -1;",
                        "\t}",
                        "\tspin_unlock_irq(&ji->ag_lock);",
                        "}"
                    ],
                    "start": 139,
                    "highlight": 154
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81360cb5"
        },
        "1027": {
            "name": "jfs_evict_inode(indirect)",
            "parent_idx": 998,
            "source_line": [
                {
                    "file": "fs/inode.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/inode.c?id=805c6d3c#n576",
                    "code": [
                        "/*",
                        " * Free the inode passed in, removing it from the lists it is still connected",
                        " * to. We remove any pages still attached to the inode and wait for any IO that",
                        " * is still in progress before finally destroying the inode.",
                        " *",
                        " * An inode must already be marked I_FREEING so that we avoid the inode being",
                        " * moved back onto lists if we race with other code that manipulates the lists",
                        " * (e.g. writeback_single_inode). The caller is responsible for setting this.",
                        " *",
                        " * An inode must already be removed from the LRU list before being evicted from",
                        " * the cache. This should occur atomically with setting the I_FREEING state",
                        " * flag, so no inodes here should ever be on the LRU when being evicted.",
                        " */",
                        "static void evict(struct inode *inode)",
                        "{",
                        "\tconst struct super_operations *op = inode->i_sb->s_op;",
                        "",
                        "\tBUG_ON(!(inode->i_state & I_FREEING));",
                        "\tBUG_ON(!list_empty(&inode->i_lru));",
                        "",
                        "\tif (!list_empty(&inode->i_io_list))",
                        "\t\tinode_io_list_del(inode);",
                        "",
                        "\tinode_sb_list_del(inode);",
                        "",
                        "\t/*",
                        "\t * Wait for flusher thread to be done with the inode so that filesystem",
                        "\t * does not start destroying it while writeback is still running. Since",
                        "\t * the inode has I_FREEING set, flusher thread won't start new work on",
                        "\t * the inode.  We just have to wait for running writeback to finish.",
                        "\t */",
                        "\tinode_wait_for_writeback(inode);",
                        "",
                        "\tif (op->evict_inode) {",
                        "\t\top->evict_inode(inode);",
                        "\t} else {",
                        "\t\ttruncate_inode_pages_final(&inode->i_data);",
                        "\t\tclear_inode(inode);",
                        "\t}",
                        "\tif (S_ISBLK(inode->i_mode) && inode->i_bdev)",
                        "\t\tbd_forget(inode);",
                        "\tif (S_ISCHR(inode->i_mode) && inode->i_cdev)",
                        "\t\tcd_forget(inode);",
                        "",
                        "\tremove_inode_hash(inode);",
                        "",
                        "\tspin_lock(&inode->i_lock);",
                        "\twake_up_bit(&inode->i_state, __I_NEW);",
                        "\tBUG_ON(inode->i_state != (I_FREEING | I_CLEAR));",
                        "\tspin_unlock(&inode->i_lock);",
                        "",
                        "\tdestroy_inode(inode);",
                        "}"
                    ],
                    "start": 542,
                    "highlight": 576
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81206f95"
        },
        "998": {
            "name": "diFreeSpecial",
            "parent_idx": 912,
            "source_line": [
                {
                    "file": "fs/jfs/jfs_mount.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jfs/jfs_mount.c?id=805c6d3c#n210",
                    "code": [
                        "/*",
                        " * NAME:\tjfs_mount(sb)",
                        " *",
                        " * FUNCTION:\tvfs_mount()",
                        " *",
                        " * PARAMETER:\tsb\t- super block",
                        " *",
                        " * RETURN:\t-EBUSY\t- device already mounted or open for write",
                        " *\t\t-EBUSY\t- cvrdvp already mounted;",
                        " *\t\t-EBUSY\t- mount table full",
                        " *\t\t-ENOTDIR- cvrdvp not directory on a device mount",
                        " *\t\t-ENXIO\t- device open failure",
                        " */",
                        "int jfs_mount(struct super_block *sb)",
                        "{",
                        "\tint rc = 0;\t\t/* Return code */",
                        "\tstruct jfs_sb_info *sbi = JFS_SBI(sb);",
                        "\tstruct inode *ipaimap = NULL;",
                        "\tstruct inode *ipaimap2 = NULL;",
                        "\tstruct inode *ipimap = NULL;",
                        "\tstruct inode *ipbmap = NULL;",
                        "",
                        "\t/*",
                        "\t * read/validate superblock",
                        "\t * (initialize mount inode from the superblock)",
                        "\t */",
                        "\tif ((rc = chkSuper(sb))) {",
                        "\t\tgoto errout20;",
                        "\t}",
                        "",
                        "\tipaimap = diReadSpecial(sb, AGGREGATE_I, 0);",
                        "\tif (ipaimap == NULL) {",
                        "\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");",
                        "\t\trc = -EIO;",
                        "\t\tgoto errout20;",
                        "\t}",
                        "\tsbi->ipaimap = ipaimap;",
                        "",
                        "\tjfs_info(\"jfs_mount: ipaimap:0x%p\", ipaimap);",
                        "",
                        "\t/*",
                        "\t * initialize aggregate inode allocation map",
                        "\t */",
                        "\tif ((rc = diMount(ipaimap))) {",
                        "\t\tjfs_err(\"jfs_mount: diMount(ipaimap) failed w/rc = %d\", rc);",
                        "\t\tgoto errout21;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * open aggregate block allocation map",
                        "\t */",
                        "\tipbmap = diReadSpecial(sb, BMAP_I, 0);",
                        "\tif (ipbmap == NULL) {",
                        "\t\trc = -EIO;",
                        "\t\tgoto errout22;",
                        "\t}",
                        "",
                        "\tjfs_info(\"jfs_mount: ipbmap:0x%p\", ipbmap);",
                        "",
                        "\tsbi->ipbmap = ipbmap;",
                        "",
                        "\t/*",
                        "\t * initialize aggregate block allocation map",
                        "\t */",
                        "\tif ((rc = dbMount(ipbmap))) {",
                        "\t\tjfs_err(\"jfs_mount: dbMount failed w/rc = %d\", rc);",
                        "\t\tgoto errout22;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * open the secondary aggregate inode allocation map",
                        "\t *",
                        "\t * This is a duplicate of the aggregate inode allocation map.",
                        "\t *",
                        "\t * hand craft a vfs in the same fashion as we did to read ipaimap.",
                        "\t * By adding INOSPEREXT (32) to the inode number, we are telling",
                        "\t * diReadSpecial that we are reading from the secondary aggregate",
                        "\t * inode table.  This also creates a unique entry in the inode hash",
                        "\t * table.",
                        "\t */",
                        "\tif ((sbi->mntflag & JFS_BAD_SAIT) == 0) {",
                        "\t\tipaimap2 = diReadSpecial(sb, AGGREGATE_I, 1);",
                        "\t\tif (!ipaimap2) {",
                        "\t\t\tjfs_err(\"jfs_mount: Failed to read AGGREGATE_I\");",
                        "\t\t\trc = -EIO;",
                        "\t\t\tgoto errout35;",
                        "\t\t}",
                        "\t\tsbi->ipaimap2 = ipaimap2;",
                        "",
                        "\t\tjfs_info(\"jfs_mount: ipaimap2:0x%p\", ipaimap2);",
                        "",
                        "\t\t/*",
                        "\t\t * initialize secondary aggregate inode allocation map",
                        "\t\t */",
                        "\t\tif ((rc = diMount(ipaimap2))) {",
                        "\t\t\tjfs_err(\"jfs_mount: diMount(ipaimap2) failed, rc = %d\",",
                        "\t\t\t\trc);",
                        "\t\t\tgoto errout35;",
                        "\t\t}",
                        "\t} else",
                        "\t\t/* Secondary aggregate inode table is not valid */",
                        "\t\tsbi->ipaimap2 = NULL;",
                        "",
                        "\t/*",
                        "\t *\tmount (the only/single) fileset",
                        "\t */",
                        "\t/*",
                        "\t * open fileset inode allocation map (aka fileset inode)",
                        "\t */",
                        "\tipimap = diReadSpecial(sb, FILESYSTEM_I, 0);",
                        "\tif (ipimap == NULL) {",
                        "\t\tjfs_err(\"jfs_mount: Failed to read FILESYSTEM_I\");",
                        "\t\t/* open fileset secondary inode allocation map */",
                        "\t\trc = -EIO;",
                        "\t\tgoto errout40;",
                        "\t}",
                        "\tjfs_info(\"jfs_mount: ipimap:0x%p\", ipimap);",
                        "",
                        "\t/* map further access of per fileset inodes by the fileset inode */",
                        "\tsbi->ipimap = ipimap;",
                        "",
                        "\t/* initialize fileset inode allocation map */",
                        "\tif ((rc = diMount(ipimap))) {",
                        "\t\tjfs_err(\"jfs_mount: diMount failed w/rc = %d\", rc);",
                        "\t\tgoto errout41;",
                        "\t}",
                        "",
                        "\tgoto out;",
                        "",
                        "\t/*",
                        "\t *\tunwind on error",
                        "\t */",
                        "      errout41:\t\t/* close fileset inode allocation map inode */",
                        "\tdiFreeSpecial(ipimap);",
                        "",
                        "      errout40:\t\t/* fileset closed */",
                        "",
                        "\t/* close secondary aggregate inode allocation map */",
                        "\tif (ipaimap2) {",
                        "\t\tdiUnmount(ipaimap2, 1);",
                        "\t\tdiFreeSpecial(ipaimap2);",
                        "\t}",
                        "",
                        "      errout35:",
                        "",
                        "\t/* close aggregate block allocation map */",
                        "\tdbUnmount(ipbmap, 1);",
                        "\tdiFreeSpecial(ipbmap);",
                        "",
                        "      errout22:\t\t/* close aggregate inode allocation map */",
                        "",
                        "\tdiUnmount(ipaimap, 1);",
                        "",
                        "      errout21:\t\t/* close aggregate inodes */",
                        "\tdiFreeSpecial(ipaimap);",
                        "      errout20:\t\t/* aggregate closed */",
                        "",
                        "      out:",
                        "",
                        "\tif (rc)",
                        "\t\tjfs_err(\"Mount JFS Failure: %d\", rc);",
                        "",
                        "\treturn rc;",
                        "}"
                    ],
                    "start": 56,
                    "highlight": 210
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8136397d"
        },
        "912": {
            "name": "jfs_mount",
            "parent_idx": 889,
            "source_line": [
                {
                    "file": "fs/jfs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jfs/super.c?id=805c6d3c#n562",
                    "code": [
                        "static int jfs_fill_super(struct super_block *sb, void *data, int silent)",
                        "{",
                        "\tstruct jfs_sb_info *sbi;",
                        "\tstruct inode *inode;",
                        "\tint rc;",
                        "\ts64 newLVSize = 0;",
                        "\tint flag, ret = -EINVAL;",
                        "",
                        "\tjfs_info(\"In jfs_read_super: s_flags=0x%lx\", sb->s_flags);",
                        "",
                        "\tsbi = kzalloc(sizeof(struct jfs_sb_info), GFP_KERNEL);",
                        "\tif (!sbi)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tsb->s_fs_info = sbi;",
                        "\tsb->s_max_links = JFS_LINK_MAX;",
                        "\tsb->s_time_min = 0;",
                        "\tsb->s_time_max = U32_MAX;",
                        "\tsbi->sb = sb;",
                        "\tsbi->uid = INVALID_UID;",
                        "\tsbi->gid = INVALID_GID;",
                        "\tsbi->umask = -1;",
                        "",
                        "\t/* initialize the mount flag and determine the default error handler */",
                        "\tflag = JFS_ERR_REMOUNT_RO;",
                        "",
                        "\tif (!parse_options((char *) data, sb, &newLVSize, &flag))",
                        "\t\tgoto out_kfree;",
                        "\tsbi->flag = flag;",
                        "",
                        "#ifdef CONFIG_JFS_POSIX_ACL",
                        "\tsb->s_flags |= SB_POSIXACL;",
                        "#endif",
                        "",
                        "\tif (newLVSize) {",
                        "\t\tpr_err(\"resize option for remount only\\n\");",
                        "\t\tgoto out_kfree;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Initialize blocksize to 4K.",
                        "\t */",
                        "\tsb_set_blocksize(sb, PSIZE);",
                        "",
                        "\t/*",
                        "\t * Set method vectors.",
                        "\t */",
                        "\tsb->s_op = &jfs_super_operations;",
                        "\tsb->s_export_op = &jfs_export_operations;",
                        "\tsb->s_xattr = jfs_xattr_handlers;",
                        "#ifdef CONFIG_QUOTA",
                        "\tsb->dq_op = &dquot_operations;",
                        "\tsb->s_qcop = &jfs_quotactl_ops;",
                        "\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;",
                        "#endif",
                        "",
                        "\t/*",
                        "\t * Initialize direct-mapping inode/address-space",
                        "\t */",
                        "\tinode = new_inode(sb);",
                        "\tif (inode == NULL) {",
                        "\t\tret = -ENOMEM;",
                        "\t\tgoto out_unload;",
                        "\t}",
                        "\tinode->i_ino = 0;",
                        "\tinode->i_size = i_size_read(sb->s_bdev->bd_inode);",
                        "\tinode->i_mapping->a_ops = &jfs_metapage_aops;",
                        "\tinode_fake_hash(inode);",
                        "\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);",
                        "",
                        "\tsbi->direct_inode = inode;",
                        "",
                        "\trc = jfs_mount(sb);",
                        "\tif (rc) {",
                        "\t\tif (!silent)",
                        "\t\t\tjfs_err(\"jfs_mount failed w/return code = %d\", rc);",
                        "\t\tgoto out_mount_failed;",
                        "\t}",
                        "\tif (sb_rdonly(sb))",
                        "\t\tsbi->log = NULL;",
                        "\telse {",
                        "\t\trc = jfs_mount_rw(sb, 0);",
                        "\t\tif (rc) {",
                        "\t\t\tif (!silent) {",
                        "\t\t\t\tjfs_err(\"jfs_mount_rw failed, return code = %d\",",
                        "\t\t\t\t\trc);",
                        "\t\t\t}",
                        "\t\t\tgoto out_no_rw;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tsb->s_magic = JFS_SUPER_MAGIC;",
                        "",
                        "\tif (sbi->mntflag & JFS_OS2)",
                        "\t\tsb->s_d_op = &jfs_ci_dentry_operations;",
                        "",
                        "\tinode = jfs_iget(sb, ROOT_I);",
                        "\tif (IS_ERR(inode)) {",
                        "\t\tret = PTR_ERR(inode);",
                        "\t\tgoto out_no_rw;",
                        "\t}",
                        "\tsb->s_root = d_make_root(inode);",
                        "\tif (!sb->s_root)",
                        "\t\tgoto out_no_root;",
                        "",
                        "\t/* logical blocks are represented by 40 bits in pxd_t, etc.",
                        "\t * and page cache is indexed by long",
                        "\t */",
                        "\tsb->s_maxbytes = min(((loff_t)sb->s_blocksize) << 40, MAX_LFS_FILESIZE);",
                        "\tsb->s_time_gran = 1;",
                        "\treturn 0;",
                        "",
                        "out_no_root:",
                        "\tjfs_err(\"jfs_read_super: get root dentry failed\");",
                        "",
                        "out_no_rw:",
                        "\trc = jfs_umount(sb);",
                        "\tif (rc)",
                        "\t\tjfs_err(\"jfs_umount failed with return code %d\", rc);",
                        "out_mount_failed:",
                        "\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);",
                        "\ttruncate_inode_pages(sbi->direct_inode->i_mapping, 0);",
                        "\tmake_bad_inode(sbi->direct_inode);",
                        "\tiput(sbi->direct_inode);",
                        "\tsbi->direct_inode = NULL;",
                        "out_unload:",
                        "\tunload_nls(sbi->nls_tab);",
                        "out_kfree:",
                        "\tkfree(sbi);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 490,
                    "highlight": 562
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8135ff42"
        },
        "889": {
            "name": "jfs_fill_super(indirect)",
            "parent_idx": 840,
            "source_line": [
                {
                    "file": "fs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/super.c?id=805c6d3c#n1417",
                    "code": [
                        "struct dentry *mount_bdev(struct file_system_type *fs_type,",
                        "\tint flags, const char *dev_name, void *data,",
                        "\tint (*fill_super)(struct super_block *, void *, int))",
                        "{",
                        "\tstruct block_device *bdev;",
                        "\tstruct super_block *s;",
                        "\tfmode_t mode = FMODE_READ | FMODE_EXCL;",
                        "\tint error = 0;",
                        "",
                        "\tif (!(flags & SB_RDONLY))",
                        "\t\tmode |= FMODE_WRITE;",
                        "",
                        "\tbdev = blkdev_get_by_path(dev_name, mode, fs_type);",
                        "\tif (IS_ERR(bdev))",
                        "\t\treturn ERR_CAST(bdev);",
                        "",
                        "\t/*",
                        "\t * once the super is inserted into the list by sget, s_umount",
                        "\t * will protect the lockfs code from trying to start a snapshot",
                        "\t * while we are mounting",
                        "\t */",
                        "\tmutex_lock(&bdev->bd_fsfreeze_mutex);",
                        "\tif (bdev->bd_fsfreeze_count > 0) {",
                        "\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);",
                        "\t\terror = -EBUSY;",
                        "\t\tgoto error_bdev;",
                        "\t}",
                        "\ts = sget(fs_type, test_bdev_super, set_bdev_super, flags | SB_NOSEC,",
                        "\t\t bdev);",
                        "\tmutex_unlock(&bdev->bd_fsfreeze_mutex);",
                        "\tif (IS_ERR(s))",
                        "\t\tgoto error_s;",
                        "",
                        "\tif (s->s_root) {",
                        "\t\tif ((flags ^ s->s_flags) & SB_RDONLY) {",
                        "\t\t\tdeactivate_locked_super(s);",
                        "\t\t\terror = -EBUSY;",
                        "\t\t\tgoto error_bdev;",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * s_umount nests inside bd_mutex during",
                        "\t\t * __invalidate_device().  blkdev_put() acquires",
                        "\t\t * bd_mutex and can't be called under s_umount.  Drop",
                        "\t\t * s_umount temporarily.  This is safe as we're",
                        "\t\t * holding an active reference.",
                        "\t\t */",
                        "\t\tup_write(&s->s_umount);",
                        "\t\tblkdev_put(bdev, mode);",
                        "\t\tdown_write(&s->s_umount);",
                        "\t} else {",
                        "\t\ts->s_mode = mode;",
                        "\t\tsnprintf(s->s_id, sizeof(s->s_id), \"%pg\", bdev);",
                        "\t\tsb_set_blocksize(s, block_size(bdev));",
                        "\t\terror = fill_super(s, data, flags & SB_SILENT ? 1 : 0);",
                        "\t\tif (error) {",
                        "\t\t\tdeactivate_locked_super(s);",
                        "\t\t\tgoto error;",
                        "\t\t}",
                        "",
                        "\t\ts->s_flags |= SB_ACTIVE;",
                        "\t\tbdev->bd_super = s;",
                        "\t}",
                        "",
                        "\treturn dget(s->s_root);",
                        "",
                        "error_s:",
                        "\terror = PTR_ERR(s);",
                        "error_bdev:",
                        "\tblkdev_put(bdev, mode);",
                        "error:",
                        "\treturn ERR_PTR(error);",
                        "}"
                    ],
                    "start": 1363,
                    "highlight": 1417
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811ec4db"
        },
        "840": {
            "name": "mount_bdev(indirect)",
            "parent_idx": 839,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=805c6d3c#n592",
                    "code": [
                        "/*",
                        " * Get a mountable root with the legacy mount command.",
                        " */",
                        "static int legacy_get_tree(struct fs_context *fc)",
                        "{",
                        "\tstruct legacy_fs_context *ctx = fc->fs_private;",
                        "\tstruct super_block *sb;",
                        "\tstruct dentry *root;",
                        "",
                        "\troot = fc->fs_type->mount(fc->fs_type, fc->sb_flags,",
                        "\t\t\t\t      fc->source, ctx->legacy_data);",
                        "\tif (IS_ERR(root))",
                        "\t\treturn PTR_ERR(root);",
                        "",
                        "\tsb = root->d_sb;",
                        "\tBUG_ON(!sb);",
                        "",
                        "\tfc->root = root;",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 583,
                    "highlight": 592
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8122369d"
        },
        "839": {
            "name": "legacy_get_tree(indirect)",
            "parent_idx": 838,
            "source_line": [
                {
                    "file": "fs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/super.c?id=805c6d3c#n1547",
                    "code": [
                        "/**",
                        " * vfs_get_tree - Get the mountable root",
                        " * @fc: The superblock configuration context.",
                        " *",
                        " * The filesystem is invoked to get or create a superblock which can then later",
                        " * be used for mounting.  The filesystem places a pointer to the root to be",
                        " * used for mounting in @fc->root.",
                        " */",
                        "int vfs_get_tree(struct fs_context *fc)",
                        "{",
                        "\tstruct super_block *sb;",
                        "\tint error;",
                        "",
                        "\tif (fc->root)",
                        "\t\treturn -EBUSY;",
                        "",
                        "\t/* Get the mountable root in fc->root, with a ref on the root and a ref",
                        "\t * on the superblock.",
                        "\t */",
                        "\terror = fc->ops->get_tree(fc);",
                        "\tif (error < 0)",
                        "\t\treturn error;",
                        "",
                        "\tif (!fc->root) {",
                        "\t\tpr_err(\"Filesystem %s get_tree() didn't set fc->root\\n\",",
                        "\t\t       fc->fs_type->name);",
                        "\t\t/* We don't know what the locking state of the superblock is -",
                        "\t\t * if there is a superblock.",
                        "\t\t */",
                        "\t\tBUG();",
                        "\t}",
                        "",
                        "\tsb = fc->root->d_sb;",
                        "\tWARN_ON(!sb->s_bdi);",
                        "",
                        "\t/*",
                        "\t * Write barrier is for super_cache_count(). We place it before setting",
                        "\t * SB_BORN as the data dependency between the two functions is the",
                        "\t * superblock structure contents that we just set up, not the SB_BORN",
                        "\t * flag.",
                        "\t */",
                        "\tsmp_wmb();",
                        "\tsb->s_flags |= SB_BORN;",
                        "",
                        "\terror = security_sb_set_mnt_opts(sb, fc->security, 0, NULL);",
                        "\tif (unlikely(error)) {",
                        "\t\tfc_drop_locked(fc);",
                        "\t\treturn error;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * filesystems should never set s_maxbytes larger than MAX_LFS_FILESIZE",
                        "\t * but s_maxbytes was an unsigned long long for many releases. Throw",
                        "\t * this warning for a little while to try and catch filesystems that",
                        "\t * violate this rule.",
                        "\t */",
                        "\tWARN((sb->s_maxbytes < 0), \"%s set sb->s_maxbytes to \"",
                        "\t\t\"negative value (%lld)\\n\", fc->fs_type->name, sb->s_maxbytes);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1528,
                    "highlight": 1547
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811ead5b"
        },
        "838": {
            "name": "vfs_get_tree",
            "parent_idx": 837,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=805c6d3c#n2875",
                    "code": [
                        "/*",
                        " * create a new mount for userspace and request it to be added into the",
                        " * namespace's tree",
                        " */",
                        "static int do_new_mount(struct path *path, const char *fstype, int sb_flags,",
                        "\t\t\tint mnt_flags, const char *name, void *data)",
                        "{",
                        "\tstruct file_system_type *type;",
                        "\tstruct fs_context *fc;",
                        "\tconst char *subtype = NULL;",
                        "\tint err = 0;",
                        "",
                        "\tif (!fstype)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\ttype = get_fs_type(fstype);",
                        "\tif (!type)",
                        "\t\treturn -ENODEV;",
                        "",
                        "\tif (type->fs_flags & FS_HAS_SUBTYPE) {",
                        "\t\tsubtype = strchr(fstype, '.');",
                        "\t\tif (subtype) {",
                        "\t\t\tsubtype++;",
                        "\t\t\tif (!*subtype) {",
                        "\t\t\t\tput_filesystem(type);",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tfc = fs_context_for_mount(type, sb_flags);",
                        "\tput_filesystem(type);",
                        "\tif (IS_ERR(fc))",
                        "\t\treturn PTR_ERR(fc);",
                        "",
                        "\tif (subtype)",
                        "\t\terr = vfs_parse_fs_string(fc, \"subtype\",",
                        "\t\t\t\t\t  subtype, strlen(subtype));",
                        "\tif (!err && name)",
                        "\t\terr = vfs_parse_fs_string(fc, \"source\", name, strlen(name));",
                        "\tif (!err)",
                        "\t\terr = parse_monolithic_mount_data(fc, data);",
                        "\tif (!err && !mount_capable(fc))",
                        "\t\terr = -EPERM;",
                        "\tif (!err)",
                        "\t\terr = vfs_get_tree(fc);",
                        "\tif (!err)",
                        "\t\terr = do_new_mount_fc(fc, path, mnt_flags);",
                        "",
                        "\tput_fs_context(fc);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2830,
                    "highlight": 2875
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=805c6d3c#n3192",
                    "code": [
                        "/*",
                        " * Flags is a 32-bit value that allows up to 31 non-fs dependent flags to",
                        " * be given to the mount() call (ie: read-only, no-dev, no-suid etc).",
                        " *",
                        " * data is a (void *) that can point to any structure up to",
                        " * PAGE_SIZE-1 bytes, which can contain arbitrary fs-dependent",
                        " * information (or be NULL).",
                        " *",
                        " * Pre-0.97 versions of mount() didn't have a flags word.",
                        " * When the flags word was introduced its top half was required",
                        " * to have the magic value 0xC0ED, and this remained so until 2.4.0-test9.",
                        " * Therefore, if this magic number is present, it carries no information",
                        " * and must be discarded.",
                        " */",
                        "int path_mount(const char *dev_name, struct path *path,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tunsigned int mnt_flags = 0, sb_flags;",
                        "\tint ret;",
                        "",
                        "\t/* Discard magic */",
                        "\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)",
                        "\t\tflags &= ~MS_MGC_MSK;",
                        "",
                        "\t/* Basic sanity checks */",
                        "\tif (data_page)",
                        "\t\t((char *)data_page)[PAGE_SIZE - 1] = 0;",
                        "",
                        "\tif (flags & MS_NOUSER)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tret = security_sb_mount(dev_name, path, type_page, flags, data_page);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tif (!may_mount())",
                        "\t\treturn -EPERM;",
                        "\tif ((flags & SB_MANDLOCK) && !may_mandlock())",
                        "\t\treturn -EPERM;",
                        "",
                        "\t/* Default to relatime unless overriden */",
                        "\tif (!(flags & MS_NOATIME))",
                        "\t\tmnt_flags |= MNT_RELATIME;",
                        "",
                        "\t/* Separate the per-mountpoint flags */",
                        "\tif (flags & MS_NOSUID)",
                        "\t\tmnt_flags |= MNT_NOSUID;",
                        "\tif (flags & MS_NODEV)",
                        "\t\tmnt_flags |= MNT_NODEV;",
                        "\tif (flags & MS_NOEXEC)",
                        "\t\tmnt_flags |= MNT_NOEXEC;",
                        "\tif (flags & MS_NOATIME)",
                        "\t\tmnt_flags |= MNT_NOATIME;",
                        "\tif (flags & MS_NODIRATIME)",
                        "\t\tmnt_flags |= MNT_NODIRATIME;",
                        "\tif (flags & MS_STRICTATIME)",
                        "\t\tmnt_flags &= ~(MNT_RELATIME | MNT_NOATIME);",
                        "\tif (flags & MS_RDONLY)",
                        "\t\tmnt_flags |= MNT_READONLY;",
                        "",
                        "\t/* The default atime for remount is preservation */",
                        "\tif ((flags & MS_REMOUNT) &&",
                        "\t    ((flags & (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |",
                        "\t\t       MS_STRICTATIME)) == 0)) {",
                        "\t\tmnt_flags &= ~MNT_ATIME_MASK;",
                        "\t\tmnt_flags |= path->mnt->mnt_flags & MNT_ATIME_MASK;",
                        "\t}",
                        "",
                        "\tsb_flags = flags & (SB_RDONLY |",
                        "\t\t\t    SB_SYNCHRONOUS |",
                        "\t\t\t    SB_MANDLOCK |",
                        "\t\t\t    SB_DIRSYNC |",
                        "\t\t\t    SB_SILENT |",
                        "\t\t\t    SB_POSIXACL |",
                        "\t\t\t    SB_LAZYTIME |",
                        "\t\t\t    SB_I_VERSION);",
                        "",
                        "\tif ((flags & (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND))",
                        "\t\treturn do_reconfigure_mnt(path, mnt_flags);",
                        "\tif (flags & MS_REMOUNT)",
                        "\t\treturn do_remount(path, flags, sb_flags, mnt_flags, data_page);",
                        "\tif (flags & MS_BIND)",
                        "\t\treturn do_loopback(path, dev_name, flags & MS_REC);",
                        "\tif (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))",
                        "\t\treturn do_change_type(path, flags);",
                        "\tif (flags & MS_MOVE)",
                        "\t\treturn do_move_mount_old(path, dev_name);",
                        "",
                        "\treturn do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,",
                        "\t\t\t    data_page);",
                        "}"
                    ],
                    "start": 3105,
                    "highlight": 3192
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8121014f"
        },
        "837": {
            "name": "path_mount",
            "parent_idx": 818,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=805c6d3c#n3205",
                    "code": [
                        "long do_mount(const char *dev_name, const char __user *dir_name,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tstruct path path;",
                        "\tint ret;",
                        "",
                        "\tret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &path);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tret = path_mount(dev_name, &path, type_page, flags, data_page);",
                        "\tpath_put(&path);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3196,
                    "highlight": 3205
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=805c6d3c#n3413",
                    "code": [
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3390,
                    "highlight": 3413
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=805c6d3c#n3390",
                    "code": [
                        "struct dentry *mount_subtree(struct vfsmount *m, const char *name)",
                        "{",
                        "\tstruct mount *mnt = real_mount(m);",
                        "\tstruct mnt_namespace *ns;",
                        "\tstruct super_block *s;",
                        "\tstruct path path;",
                        "\tint err;",
                        "",
                        "\tns = alloc_mnt_ns(&init_user_ns, true);",
                        "\tif (IS_ERR(ns)) {",
                        "\t\tmntput(m);",
                        "\t\treturn ERR_CAST(ns);",
                        "\t}",
                        "\tmnt->mnt_ns = ns;",
                        "\tns->root = mnt;",
                        "\tns->mounts++;",
                        "\tlist_add(&mnt->mnt_list, &ns->list);",
                        "",
                        "\terr = vfs_path_lookup(m->mnt_root, m,",
                        "\t\t\tname, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);",
                        "",
                        "\tput_mnt_ns(ns);",
                        "",
                        "\tif (err)",
                        "\t\treturn ERR_PTR(err);",
                        "",
                        "\t/* trade a vfsmount reference for active sb one */",
                        "\ts = path.mnt->mnt_sb;",
                        "\tatomic_inc(&s->s_active);",
                        "\tmntput(path.mnt);",
                        "\t/* lock the sucker */",
                        "\tdown_write(&s->s_umount);",
                        "\t/* ... and return the root of (sub)tree on it */",
                        "\treturn path.dentry;",
                        "}",
                        "EXPORT_SYMBOL(mount_subtree);",
                        "",
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3353,
                    "highlight": 3390
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812109b9"
        },
        "818": {
            "name": "__x64_sys_mount(indirect)",
            "parent_idx": 817,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=805c6d3c#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b6f5ee"
        },
        "817": {
            "name": "do_syscall_64",
            "parent_idx": 816,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=805c6d3c#n118",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 118
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "816": {
            "name": "84_syscall_15",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1043": {
            "name": "+0x41",
            "parent_idx": 1040,
            "source_line": [
                {
                    "file": "fs/jfs/jfs_imap.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jfs/jfs_imap.c?id=805c6d3c#n852",
                    "code": [
                        "/*",
                        " * NAME:\tdiFree(ip)",
                        " *",
                        " * FUNCTION:\tfree a specified inode from the inode working map",
                        " *\t\tfor a fileset or aggregate.",
                        " *",
                        " *\t\tif the inode to be freed represents the first (only)",
                        " *\t\tfree inode within the iag, the iag will be placed on",
                        " *\t\tthe ag free inode list.",
                        " *",
                        " *\t\tfreeing the inode will cause the inode extent to be",
                        " *\t\tfreed if the inode is the only allocated inode within",
                        " *\t\tthe extent.  in this case all the disk resource backing",
                        " *\t\tup the inode extent will be freed. in addition, the iag",
                        " *\t\twill be placed on the ag extent free list if the extent",
                        " *\t\tis the first free extent in the iag.  if freeing the",
                        " *\t\textent also means that no free inodes will exist for",
                        " *\t\tthe iag, the iag will also be removed from the ag free",
                        " *\t\tinode list.",
                        " *",
                        " *\t\tthe iag describing the inode will be freed if the extent",
                        " *\t\tis to be freed and it is the only backed extent within",
                        " *\t\tthe iag.  in this case, the iag will be removed from the",
                        " *\t\tag free extent list and ag free inode list and placed on",
                        " *\t\tthe inode map's free iag list.",
                        " *",
                        " *\t\ta careful update approach is used to provide consistency",
                        " *\t\tin the face of updates to multiple buffers.  under this",
                        " *\t\tapproach, all required buffers are obtained before making",
                        " *\t\tany updates and are held until all updates are complete.",
                        " *",
                        " * PARAMETERS:",
                        " *\tip\t- inode to be freed.",
                        " *",
                        " * RETURN VALUES:",
                        " *\t0\t- success",
                        " *\t-EIO\t- i/o error.",
                        " */",
                        "int diFree(struct inode *ip)",
                        "{",
                        "\tint rc;",
                        "\tino_t inum = ip->i_ino;",
                        "\tstruct iag *iagp, *aiagp, *biagp, *ciagp, *diagp;",
                        "\tstruct metapage *mp, *amp, *bmp, *cmp, *dmp;",
                        "\tint iagno, ino, extno, bitno, sword, agno;",
                        "\tint back, fwd;",
                        "\tu32 bitmap, mask;",
                        "\tstruct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap;",
                        "\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;",
                        "\tpxd_t freepxd;",
                        "\ttid_t tid;",
                        "\tstruct inode *iplist[3];",
                        "\tstruct tlock *tlck;",
                        "\tstruct pxd_lock *pxdlock;",
                        "",
                        "\t/*",
                        "\t * This is just to suppress compiler warnings.  The same logic that",
                        "\t * references these variables is used to initialize them.",
                        "\t */",
                        "\taiagp = biagp = ciagp = diagp = NULL;",
                        "",
                        "\t/* get the iag number containing the inode.",
                        "\t */",
                        "\tiagno = INOTOIAG(inum);",
                        "",
                        "\t/* make sure that the iag is contained within",
                        "\t * the map.",
                        "\t */",
                        "\tif (iagno >= imap->im_nextiag) {",
                        "\t\tprint_hex_dump(KERN_ERR, \"imap: \", DUMP_PREFIX_ADDRESS, 16, 4,",
                        "\t\t\t       imap, 32, 0);",
                        "\t\tjfs_error(ip->i_sb, \"inum = %d, iagno = %d, nextiag = %d\\n\",",
                        "\t\t\t  (uint) inum, iagno, imap->im_nextiag);",
                        "\t\treturn -EIO;",
                        "\t}",
                        "",
                        "\t/* get the allocation group for this ino.",
                        "\t */",
                        "\tagno = BLKTOAG(JFS_IP(ip)->agstart, JFS_SBI(ip->i_sb));",
                        "",
                        "\t/* Lock the AG specific inode map information",
                        "\t */",
                        "\tAG_LOCK(imap, agno);",
                        "",
                        "\t/* Obtain read lock in imap inode.  Don't release it until we have",
                        "\t * read all of the IAG's that we are going to.",
                        "\t */",
                        "\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);",
                        "",
                        "\t/* read the iag.",
                        "\t */",
                        "\tif ((rc = diIAGRead(imap, iagno, &mp))) {",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "\t\treturn (rc);",
                        "\t}",
                        "\tiagp = (struct iag *) mp->data;",
                        "",
                        "\t/* get the inode number and extent number of the inode within",
                        "\t * the iag and the inode number within the extent.",
                        "\t */",
                        "\tino = inum & (INOSPERIAG - 1);",
                        "\textno = ino >> L2INOSPEREXT;",
                        "\tbitno = ino & (INOSPEREXT - 1);",
                        "\tmask = HIGHORDER >> bitno;",
                        "",
                        "\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {",
                        "\t\tjfs_error(ip->i_sb, \"wmap shows inode already free\\n\");",
                        "\t}",
                        "",
                        "\tif (!addressPXD(&iagp->inoext[extno])) {",
                        "\t\trelease_metapage(mp);",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "\t\tjfs_error(ip->i_sb, \"invalid inoext\\n\");",
                        "\t\treturn -EIO;",
                        "\t}",
                        "",
                        "\t/* compute the bitmap for the extent reflecting the freed inode.",
                        "\t */",
                        "\tbitmap = le32_to_cpu(iagp->wmap[extno]) & ~mask;",
                        "",
                        "\tif (imap->im_agctl[agno].numfree > imap->im_agctl[agno].numinos) {",
                        "\t\trelease_metapage(mp);",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");",
                        "\t\treturn -EIO;",
                        "\t}",
                        "\t/*",
                        "\t *\tinode extent still has some inodes or below low water mark:",
                        "\t *\tkeep the inode extent;",
                        "\t */",
                        "\tif (bitmap ||",
                        "\t    imap->im_agctl[agno].numfree < 96 ||",
                        "\t    (imap->im_agctl[agno].numfree < 288 &&",
                        "\t     (((imap->im_agctl[agno].numfree * 100) /",
                        "\t       imap->im_agctl[agno].numinos) <= 25))) {",
                        "\t\t/* if the iag currently has no free inodes (i.e.,",
                        "\t\t * the inode being freed is the first free inode of iag),",
                        "\t\t * insert the iag at head of the inode free list for the ag.",
                        "\t\t */",
                        "\t\tif (iagp->nfreeinos == 0) {",
                        "\t\t\t/* check if there are any iags on the ag inode",
                        "\t\t\t * free list.  if so, read the first one so that",
                        "\t\t\t * we can link the current iag onto the list at",
                        "\t\t\t * the head.",
                        "\t\t\t */",
                        "\t\t\tif ((fwd = imap->im_agctl[agno].inofree) >= 0) {",
                        "\t\t\t\t/* read the iag that currently is the head",
                        "\t\t\t\t * of the list.",
                        "\t\t\t\t */",
                        "\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp))) {",
                        "\t\t\t\t\tIREAD_UNLOCK(ipimap);",
                        "\t\t\t\t\tAG_UNLOCK(imap, agno);",
                        "\t\t\t\t\trelease_metapage(mp);",
                        "\t\t\t\t\treturn (rc);",
                        "\t\t\t\t}",
                        "\t\t\t\taiagp = (struct iag *) amp->data;",
                        "",
                        "\t\t\t\t/* make current head point back to the iag.",
                        "\t\t\t\t */",
                        "\t\t\t\taiagp->inofreeback = cpu_to_le32(iagno);",
                        "",
                        "\t\t\t\twrite_metapage(amp);",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* iag points forward to current head and iag",
                        "\t\t\t * becomes the new head of the list.",
                        "\t\t\t */",
                        "\t\t\tiagp->inofreefwd =",
                        "\t\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);",
                        "\t\t\tiagp->inofreeback = cpu_to_le32(-1);",
                        "\t\t\timap->im_agctl[agno].inofree = iagno;",
                        "\t\t}",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "",
                        "\t\t/* update the free inode summary map for the extent if",
                        "\t\t * freeing the inode means the extent will now have free",
                        "\t\t * inodes (i.e., the inode being freed is the first free",
                        "\t\t * inode of extent),",
                        "\t\t */",
                        "\t\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {",
                        "\t\t\tsword = extno >> L2EXTSPERSUM;",
                        "\t\t\tbitno = extno & (EXTSPERSUM - 1);",
                        "\t\t\tiagp->inosmap[sword] &=",
                        "\t\t\t    cpu_to_le32(~(HIGHORDER >> bitno));",
                        "\t\t}",
                        "",
                        "\t\t/* update the bitmap.",
                        "\t\t */",
                        "\t\tiagp->wmap[extno] = cpu_to_le32(bitmap);",
                        "",
                        "\t\t/* update the free inode counts at the iag, ag and",
                        "\t\t * map level.",
                        "\t\t */",
                        "\t\tle32_add_cpu(&iagp->nfreeinos, 1);",
                        "\t\timap->im_agctl[agno].numfree += 1;",
                        "\t\tatomic_inc(&imap->im_numfree);",
                        "",
                        "\t\t/* release the AG inode map lock",
                        "\t\t */",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "",
                        "\t\t/* write the iag */",
                        "\t\twrite_metapage(mp);",
                        "",
                        "\t\treturn (0);",
                        "\t}",
                        "",
                        "",
                        "\t/*",
                        "\t *\tinode extent has become free and above low water mark:",
                        "\t *\tfree the inode extent;",
                        "\t */",
                        "",
                        "\t/*",
                        "\t *\tprepare to update iag list(s) (careful update step 1)",
                        "\t */",
                        "\tamp = bmp = cmp = dmp = NULL;",
                        "\tfwd = back = -1;",
                        "",
                        "\t/* check if the iag currently has no free extents.  if so,",
                        "\t * it will be placed on the head of the ag extent free list.",
                        "\t */",
                        "\tif (iagp->nfreeexts == 0) {",
                        "\t\t/* check if the ag extent free list has any iags.",
                        "\t\t * if so, read the iag at the head of the list now.",
                        "\t\t * this (head) iag will be updated later to reflect",
                        "\t\t * the addition of the current iag at the head of",
                        "\t\t * the list.",
                        "\t\t */",
                        "\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {",
                        "\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))",
                        "\t\t\t\tgoto error_out;",
                        "\t\t\taiagp = (struct iag *) amp->data;",
                        "\t\t}",
                        "\t} else {",
                        "\t\t/* iag has free extents. check if the addition of a free",
                        "\t\t * extent will cause all extents to be free within this",
                        "\t\t * iag.  if so, the iag will be removed from the ag extent",
                        "\t\t * free list and placed on the inode map's free iag list.",
                        "\t\t */",
                        "\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {",
                        "\t\t\t/* in preparation for removing the iag from the",
                        "\t\t\t * ag extent free list, read the iags preceding",
                        "\t\t\t * and following the iag on the ag extent free",
                        "\t\t\t * list.",
                        "\t\t\t */",
                        "\t\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {",
                        "\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\taiagp = (struct iag *) amp->data;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {",
                        "\t\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\tbiagp = (struct iag *) bmp->data;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* remove the iag from the ag inode free list if freeing",
                        "\t * this extent cause the iag to have no free inodes.",
                        "\t */",
                        "\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {",
                        "\t\tint inofreeback = le32_to_cpu(iagp->inofreeback);",
                        "\t\tint inofreefwd = le32_to_cpu(iagp->inofreefwd);",
                        "",
                        "\t\t/* in preparation for removing the iag from the",
                        "\t\t * ag inode free list, read the iags preceding",
                        "\t\t * and following the iag on the ag inode free",
                        "\t\t * list.  before reading these iags, we must make",
                        "\t\t * sure that we already don't have them in hand",
                        "\t\t * from up above, since re-reading an iag (buffer)",
                        "\t\t * we are currently holding would cause a deadlock.",
                        "\t\t */",
                        "\t\tif (inofreefwd >= 0) {",
                        "",
                        "\t\t\tif (inofreefwd == fwd)",
                        "\t\t\t\tciagp = (struct iag *) amp->data;",
                        "\t\t\telse if (inofreefwd == back)",
                        "\t\t\t\tciagp = (struct iag *) bmp->data;",
                        "\t\t\telse {",
                        "\t\t\t\tif ((rc =",
                        "\t\t\t\t     diIAGRead(imap, inofreefwd, &cmp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\tciagp = (struct iag *) cmp->data;",
                        "\t\t\t}",
                        "\t\t\tassert(ciagp != NULL);",
                        "\t\t}",
                        "",
                        "\t\tif (inofreeback >= 0) {",
                        "\t\t\tif (inofreeback == fwd)",
                        "\t\t\t\tdiagp = (struct iag *) amp->data;",
                        "\t\t\telse if (inofreeback == back)",
                        "\t\t\t\tdiagp = (struct iag *) bmp->data;",
                        "\t\t\telse {",
                        "\t\t\t\tif ((rc =",
                        "\t\t\t\t     diIAGRead(imap, inofreeback, &dmp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\tdiagp = (struct iag *) dmp->data;",
                        "\t\t\t}",
                        "\t\t\tassert(diagp != NULL);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tIREAD_UNLOCK(ipimap);",
                        "",
                        "\t/*",
                        "\t * invalidate any page of the inode extent freed from buffer cache;",
                        "\t */",
                        "\tfreepxd = iagp->inoext[extno];",
                        "\tinvalidate_pxd_metapages(ip, freepxd);",
                        "",
                        "\t/*",
                        "\t *\tupdate iag list(s) (careful update step 2)",
                        "\t */",
                        "\t/* add the iag to the ag extent free list if this is the",
                        "\t * first free extent for the iag.",
                        "\t */",
                        "\tif (iagp->nfreeexts == 0) {",
                        "\t\tif (fwd >= 0)",
                        "\t\t\taiagp->extfreeback = cpu_to_le32(iagno);",
                        "",
                        "\t\tiagp->extfreefwd =",
                        "\t\t    cpu_to_le32(imap->im_agctl[agno].extfree);",
                        "\t\tiagp->extfreeback = cpu_to_le32(-1);",
                        "\t\timap->im_agctl[agno].extfree = iagno;",
                        "\t} else {",
                        "\t\t/* remove the iag from the ag extent list if all extents",
                        "\t\t * are now free and place it on the inode map iag free list.",
                        "\t\t */",
                        "\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {",
                        "\t\t\tif (fwd >= 0)",
                        "\t\t\t\taiagp->extfreeback = iagp->extfreeback;",
                        "",
                        "\t\t\tif (back >= 0)",
                        "\t\t\t\tbiagp->extfreefwd = iagp->extfreefwd;",
                        "\t\t\telse",
                        "\t\t\t\timap->im_agctl[agno].extfree =",
                        "\t\t\t\t    le32_to_cpu(iagp->extfreefwd);",
                        "",
                        "\t\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);",
                        "",
                        "\t\t\tIAGFREE_LOCK(imap);",
                        "\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);",
                        "\t\t\timap->im_freeiag = iagno;",
                        "\t\t\tIAGFREE_UNLOCK(imap);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* remove the iag from the ag inode free list if freeing",
                        "\t * this extent causes the iag to have no free inodes.",
                        "\t */",
                        "\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {",
                        "\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0)",
                        "\t\t\tciagp->inofreeback = iagp->inofreeback;",
                        "",
                        "\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0)",
                        "\t\t\tdiagp->inofreefwd = iagp->inofreefwd;",
                        "\t\telse",
                        "\t\t\timap->im_agctl[agno].inofree =",
                        "\t\t\t    le32_to_cpu(iagp->inofreefwd);",
                        "",
                        "\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);",
                        "\t}",
                        "",
                        "\t/* update the inode extent address and working map",
                        "\t * to reflect the free extent.",
                        "\t * the permanent map should have been updated already",
                        "\t * for the inode being freed.",
                        "\t */",
                        "\tif (iagp->pmap[extno] != 0) {",
                        "\t\tjfs_error(ip->i_sb, \"the pmap does not show inode free\\n\");",
                        "\t}",
                        "\tiagp->wmap[extno] = 0;",
                        "\tPXDlength(&iagp->inoext[extno], 0);",
                        "\tPXDaddress(&iagp->inoext[extno], 0);",
                        "",
                        "\t/* update the free extent and free inode summary maps",
                        "\t * to reflect the freed extent.",
                        "\t * the inode summary map is marked to indicate no inodes",
                        "\t * available for the freed extent.",
                        "\t */",
                        "\tsword = extno >> L2EXTSPERSUM;",
                        "\tbitno = extno & (EXTSPERSUM - 1);",
                        "\tmask = HIGHORDER >> bitno;",
                        "\tiagp->inosmap[sword] |= cpu_to_le32(mask);",
                        "\tiagp->extsmap[sword] &= cpu_to_le32(~mask);",
                        "",
                        "\t/* update the number of free inodes and number of free extents",
                        "\t * for the iag.",
                        "\t */",
                        "\tle32_add_cpu(&iagp->nfreeinos, -(INOSPEREXT - 1));",
                        "\tle32_add_cpu(&iagp->nfreeexts, 1);",
                        "",
                        "\t/* update the number of free inodes and backed inodes",
                        "\t * at the ag and inode map level.",
                        "\t */",
                        "\timap->im_agctl[agno].numfree -= (INOSPEREXT - 1);",
                        "\timap->im_agctl[agno].numinos -= INOSPEREXT;",
                        "\tatomic_sub(INOSPEREXT - 1, &imap->im_numfree);",
                        "\tatomic_sub(INOSPEREXT, &imap->im_numinos);",
                        "",
                        "\tif (amp)",
                        "\t\twrite_metapage(amp);",
                        "\tif (bmp)",
                        "\t\twrite_metapage(bmp);",
                        "\tif (cmp)",
                        "\t\twrite_metapage(cmp);",
                        "\tif (dmp)",
                        "\t\twrite_metapage(dmp);",
                        "",
                        "\t/*",
                        "\t * start transaction to update block allocation map",
                        "\t * for the inode extent freed;",
                        "\t *",
                        "\t * N.B. AG_LOCK is released and iag will be released below, and",
                        "\t * other thread may allocate inode from/reusing the ixad freed",
                        "\t * BUT with new/different backing inode extent from the extent",
                        "\t * to be freed by the transaction;",
                        "\t */",
                        "\ttid = txBegin(ipimap->i_sb, COMMIT_FORCE);",
                        "\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);",
                        "",
                        "\t/* acquire tlock of the iag page of the freed ixad",
                        "\t * to force the page NOHOMEOK (even though no data is",
                        "\t * logged from the iag page) until NOREDOPAGE|FREEXTENT log",
                        "\t * for the free of the extent is committed;",
                        "\t * write FREEXTENT|NOREDOPAGE log record",
                        "\t * N.B. linelock is overlaid as freed extent descriptor;",
                        "\t */",
                        "\ttlck = txLock(tid, ipimap, mp, tlckINODE | tlckFREE);",
                        "\tpxdlock = (struct pxd_lock *) & tlck->lock;",
                        "\tpxdlock->flag = mlckFREEPXD;",
                        "\tpxdlock->pxd = freepxd;",
                        "\tpxdlock->index = 1;",
                        "",
                        "\twrite_metapage(mp);",
                        "",
                        "\tiplist[0] = ipimap;",
                        "",
                        "\t/*",
                        "\t * logredo needs the IAG number and IAG extent index in order",
                        "\t * to ensure that the IMap is consistent.  The least disruptive",
                        "\t * way to pass these values through  to the transaction manager",
                        "\t * is in the iplist array.",
                        "\t *",
                        "\t * It's not pretty, but it works.",
                        "\t */",
                        "\tiplist[1] = (struct inode *) (size_t)iagno;",
                        "\tiplist[2] = (struct inode *) (size_t)extno;",
                        "",
                        "\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);",
                        "",
                        "\ttxEnd(tid);",
                        "\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);",
                        "",
                        "\t/* unlock the AG inode map information */",
                        "\tAG_UNLOCK(imap, agno);",
                        "",
                        "\treturn (0);",
                        "",
                        "      error_out:",
                        "\tIREAD_UNLOCK(ipimap);",
                        "",
                        "\tif (amp)",
                        "\t\trelease_metapage(amp);",
                        "\tif (bmp)",
                        "\t\trelease_metapage(bmp);",
                        "\tif (cmp)",
                        "\t\trelease_metapage(cmp);",
                        "\tif (dmp)",
                        "\t\trelease_metapage(dmp);",
                        "",
                        "\tAG_UNLOCK(imap, agno);",
                        "",
                        "\trelease_metapage(mp);",
                        "",
                        "\treturn (rc);",
                        "}"
                    ],
                    "start": 805,
                    "highlight": 852
                }
            ],
            "ins_idx": 38,
            "addr": "0xffffffff8136ac71"
        },
        "1042": {
            "name": "+0x35",
            "parent_idx": 1040,
            "source_line": [
                {
                    "file": "fs/jfs/jfs_incore.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jfs/jfs_incore.h?id=805c6d3c#n209",
                    "code": [
                        "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)",
                        "{",
                        "\treturn sb->s_fs_info;",
                        "}"
                    ],
                    "start": 207,
                    "highlight": 209
                },
                {
                    "file": "fs/jfs/jfs_imap.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jfs/jfs_imap.c?id=805c6d3c#n852",
                    "code": [
                        "/*",
                        " * NAME:\tdiFree(ip)",
                        " *",
                        " * FUNCTION:\tfree a specified inode from the inode working map",
                        " *\t\tfor a fileset or aggregate.",
                        " *",
                        " *\t\tif the inode to be freed represents the first (only)",
                        " *\t\tfree inode within the iag, the iag will be placed on",
                        " *\t\tthe ag free inode list.",
                        " *",
                        " *\t\tfreeing the inode will cause the inode extent to be",
                        " *\t\tfreed if the inode is the only allocated inode within",
                        " *\t\tthe extent.  in this case all the disk resource backing",
                        " *\t\tup the inode extent will be freed. in addition, the iag",
                        " *\t\twill be placed on the ag extent free list if the extent",
                        " *\t\tis the first free extent in the iag.  if freeing the",
                        " *\t\textent also means that no free inodes will exist for",
                        " *\t\tthe iag, the iag will also be removed from the ag free",
                        " *\t\tinode list.",
                        " *",
                        " *\t\tthe iag describing the inode will be freed if the extent",
                        " *\t\tis to be freed and it is the only backed extent within",
                        " *\t\tthe iag.  in this case, the iag will be removed from the",
                        " *\t\tag free extent list and ag free inode list and placed on",
                        " *\t\tthe inode map's free iag list.",
                        " *",
                        " *\t\ta careful update approach is used to provide consistency",
                        " *\t\tin the face of updates to multiple buffers.  under this",
                        " *\t\tapproach, all required buffers are obtained before making",
                        " *\t\tany updates and are held until all updates are complete.",
                        " *",
                        " * PARAMETERS:",
                        " *\tip\t- inode to be freed.",
                        " *",
                        " * RETURN VALUES:",
                        " *\t0\t- success",
                        " *\t-EIO\t- i/o error.",
                        " */",
                        "int diFree(struct inode *ip)",
                        "{",
                        "\tint rc;",
                        "\tino_t inum = ip->i_ino;",
                        "\tstruct iag *iagp, *aiagp, *biagp, *ciagp, *diagp;",
                        "\tstruct metapage *mp, *amp, *bmp, *cmp, *dmp;",
                        "\tint iagno, ino, extno, bitno, sword, agno;",
                        "\tint back, fwd;",
                        "\tu32 bitmap, mask;",
                        "\tstruct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap;",
                        "\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;",
                        "\tpxd_t freepxd;",
                        "\ttid_t tid;",
                        "\tstruct inode *iplist[3];",
                        "\tstruct tlock *tlck;",
                        "\tstruct pxd_lock *pxdlock;",
                        "",
                        "\t/*",
                        "\t * This is just to suppress compiler warnings.  The same logic that",
                        "\t * references these variables is used to initialize them.",
                        "\t */",
                        "\taiagp = biagp = ciagp = diagp = NULL;",
                        "",
                        "\t/* get the iag number containing the inode.",
                        "\t */",
                        "\tiagno = INOTOIAG(inum);",
                        "",
                        "\t/* make sure that the iag is contained within",
                        "\t * the map.",
                        "\t */",
                        "\tif (iagno >= imap->im_nextiag) {",
                        "\t\tprint_hex_dump(KERN_ERR, \"imap: \", DUMP_PREFIX_ADDRESS, 16, 4,",
                        "\t\t\t       imap, 32, 0);",
                        "\t\tjfs_error(ip->i_sb, \"inum = %d, iagno = %d, nextiag = %d\\n\",",
                        "\t\t\t  (uint) inum, iagno, imap->im_nextiag);",
                        "\t\treturn -EIO;",
                        "\t}",
                        "",
                        "\t/* get the allocation group for this ino.",
                        "\t */",
                        "\tagno = BLKTOAG(JFS_IP(ip)->agstart, JFS_SBI(ip->i_sb));",
                        "",
                        "\t/* Lock the AG specific inode map information",
                        "\t */",
                        "\tAG_LOCK(imap, agno);",
                        "",
                        "\t/* Obtain read lock in imap inode.  Don't release it until we have",
                        "\t * read all of the IAG's that we are going to.",
                        "\t */",
                        "\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);",
                        "",
                        "\t/* read the iag.",
                        "\t */",
                        "\tif ((rc = diIAGRead(imap, iagno, &mp))) {",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "\t\treturn (rc);",
                        "\t}",
                        "\tiagp = (struct iag *) mp->data;",
                        "",
                        "\t/* get the inode number and extent number of the inode within",
                        "\t * the iag and the inode number within the extent.",
                        "\t */",
                        "\tino = inum & (INOSPERIAG - 1);",
                        "\textno = ino >> L2INOSPEREXT;",
                        "\tbitno = ino & (INOSPEREXT - 1);",
                        "\tmask = HIGHORDER >> bitno;",
                        "",
                        "\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {",
                        "\t\tjfs_error(ip->i_sb, \"wmap shows inode already free\\n\");",
                        "\t}",
                        "",
                        "\tif (!addressPXD(&iagp->inoext[extno])) {",
                        "\t\trelease_metapage(mp);",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "\t\tjfs_error(ip->i_sb, \"invalid inoext\\n\");",
                        "\t\treturn -EIO;",
                        "\t}",
                        "",
                        "\t/* compute the bitmap for the extent reflecting the freed inode.",
                        "\t */",
                        "\tbitmap = le32_to_cpu(iagp->wmap[extno]) & ~mask;",
                        "",
                        "\tif (imap->im_agctl[agno].numfree > imap->im_agctl[agno].numinos) {",
                        "\t\trelease_metapage(mp);",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");",
                        "\t\treturn -EIO;",
                        "\t}",
                        "\t/*",
                        "\t *\tinode extent still has some inodes or below low water mark:",
                        "\t *\tkeep the inode extent;",
                        "\t */",
                        "\tif (bitmap ||",
                        "\t    imap->im_agctl[agno].numfree < 96 ||",
                        "\t    (imap->im_agctl[agno].numfree < 288 &&",
                        "\t     (((imap->im_agctl[agno].numfree * 100) /",
                        "\t       imap->im_agctl[agno].numinos) <= 25))) {",
                        "\t\t/* if the iag currently has no free inodes (i.e.,",
                        "\t\t * the inode being freed is the first free inode of iag),",
                        "\t\t * insert the iag at head of the inode free list for the ag.",
                        "\t\t */",
                        "\t\tif (iagp->nfreeinos == 0) {",
                        "\t\t\t/* check if there are any iags on the ag inode",
                        "\t\t\t * free list.  if so, read the first one so that",
                        "\t\t\t * we can link the current iag onto the list at",
                        "\t\t\t * the head.",
                        "\t\t\t */",
                        "\t\t\tif ((fwd = imap->im_agctl[agno].inofree) >= 0) {",
                        "\t\t\t\t/* read the iag that currently is the head",
                        "\t\t\t\t * of the list.",
                        "\t\t\t\t */",
                        "\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp))) {",
                        "\t\t\t\t\tIREAD_UNLOCK(ipimap);",
                        "\t\t\t\t\tAG_UNLOCK(imap, agno);",
                        "\t\t\t\t\trelease_metapage(mp);",
                        "\t\t\t\t\treturn (rc);",
                        "\t\t\t\t}",
                        "\t\t\t\taiagp = (struct iag *) amp->data;",
                        "",
                        "\t\t\t\t/* make current head point back to the iag.",
                        "\t\t\t\t */",
                        "\t\t\t\taiagp->inofreeback = cpu_to_le32(iagno);",
                        "",
                        "\t\t\t\twrite_metapage(amp);",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* iag points forward to current head and iag",
                        "\t\t\t * becomes the new head of the list.",
                        "\t\t\t */",
                        "\t\t\tiagp->inofreefwd =",
                        "\t\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);",
                        "\t\t\tiagp->inofreeback = cpu_to_le32(-1);",
                        "\t\t\timap->im_agctl[agno].inofree = iagno;",
                        "\t\t}",
                        "\t\tIREAD_UNLOCK(ipimap);",
                        "",
                        "\t\t/* update the free inode summary map for the extent if",
                        "\t\t * freeing the inode means the extent will now have free",
                        "\t\t * inodes (i.e., the inode being freed is the first free",
                        "\t\t * inode of extent),",
                        "\t\t */",
                        "\t\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {",
                        "\t\t\tsword = extno >> L2EXTSPERSUM;",
                        "\t\t\tbitno = extno & (EXTSPERSUM - 1);",
                        "\t\t\tiagp->inosmap[sword] &=",
                        "\t\t\t    cpu_to_le32(~(HIGHORDER >> bitno));",
                        "\t\t}",
                        "",
                        "\t\t/* update the bitmap.",
                        "\t\t */",
                        "\t\tiagp->wmap[extno] = cpu_to_le32(bitmap);",
                        "",
                        "\t\t/* update the free inode counts at the iag, ag and",
                        "\t\t * map level.",
                        "\t\t */",
                        "\t\tle32_add_cpu(&iagp->nfreeinos, 1);",
                        "\t\timap->im_agctl[agno].numfree += 1;",
                        "\t\tatomic_inc(&imap->im_numfree);",
                        "",
                        "\t\t/* release the AG inode map lock",
                        "\t\t */",
                        "\t\tAG_UNLOCK(imap, agno);",
                        "",
                        "\t\t/* write the iag */",
                        "\t\twrite_metapage(mp);",
                        "",
                        "\t\treturn (0);",
                        "\t}",
                        "",
                        "",
                        "\t/*",
                        "\t *\tinode extent has become free and above low water mark:",
                        "\t *\tfree the inode extent;",
                        "\t */",
                        "",
                        "\t/*",
                        "\t *\tprepare to update iag list(s) (careful update step 1)",
                        "\t */",
                        "\tamp = bmp = cmp = dmp = NULL;",
                        "\tfwd = back = -1;",
                        "",
                        "\t/* check if the iag currently has no free extents.  if so,",
                        "\t * it will be placed on the head of the ag extent free list.",
                        "\t */",
                        "\tif (iagp->nfreeexts == 0) {",
                        "\t\t/* check if the ag extent free list has any iags.",
                        "\t\t * if so, read the iag at the head of the list now.",
                        "\t\t * this (head) iag will be updated later to reflect",
                        "\t\t * the addition of the current iag at the head of",
                        "\t\t * the list.",
                        "\t\t */",
                        "\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {",
                        "\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))",
                        "\t\t\t\tgoto error_out;",
                        "\t\t\taiagp = (struct iag *) amp->data;",
                        "\t\t}",
                        "\t} else {",
                        "\t\t/* iag has free extents. check if the addition of a free",
                        "\t\t * extent will cause all extents to be free within this",
                        "\t\t * iag.  if so, the iag will be removed from the ag extent",
                        "\t\t * free list and placed on the inode map's free iag list.",
                        "\t\t */",
                        "\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {",
                        "\t\t\t/* in preparation for removing the iag from the",
                        "\t\t\t * ag extent free list, read the iags preceding",
                        "\t\t\t * and following the iag on the ag extent free",
                        "\t\t\t * list.",
                        "\t\t\t */",
                        "\t\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {",
                        "\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\taiagp = (struct iag *) amp->data;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {",
                        "\t\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\tbiagp = (struct iag *) bmp->data;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* remove the iag from the ag inode free list if freeing",
                        "\t * this extent cause the iag to have no free inodes.",
                        "\t */",
                        "\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {",
                        "\t\tint inofreeback = le32_to_cpu(iagp->inofreeback);",
                        "\t\tint inofreefwd = le32_to_cpu(iagp->inofreefwd);",
                        "",
                        "\t\t/* in preparation for removing the iag from the",
                        "\t\t * ag inode free list, read the iags preceding",
                        "\t\t * and following the iag on the ag inode free",
                        "\t\t * list.  before reading these iags, we must make",
                        "\t\t * sure that we already don't have them in hand",
                        "\t\t * from up above, since re-reading an iag (buffer)",
                        "\t\t * we are currently holding would cause a deadlock.",
                        "\t\t */",
                        "\t\tif (inofreefwd >= 0) {",
                        "",
                        "\t\t\tif (inofreefwd == fwd)",
                        "\t\t\t\tciagp = (struct iag *) amp->data;",
                        "\t\t\telse if (inofreefwd == back)",
                        "\t\t\t\tciagp = (struct iag *) bmp->data;",
                        "\t\t\telse {",
                        "\t\t\t\tif ((rc =",
                        "\t\t\t\t     diIAGRead(imap, inofreefwd, &cmp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\tciagp = (struct iag *) cmp->data;",
                        "\t\t\t}",
                        "\t\t\tassert(ciagp != NULL);",
                        "\t\t}",
                        "",
                        "\t\tif (inofreeback >= 0) {",
                        "\t\t\tif (inofreeback == fwd)",
                        "\t\t\t\tdiagp = (struct iag *) amp->data;",
                        "\t\t\telse if (inofreeback == back)",
                        "\t\t\t\tdiagp = (struct iag *) bmp->data;",
                        "\t\t\telse {",
                        "\t\t\t\tif ((rc =",
                        "\t\t\t\t     diIAGRead(imap, inofreeback, &dmp)))",
                        "\t\t\t\t\tgoto error_out;",
                        "\t\t\t\tdiagp = (struct iag *) dmp->data;",
                        "\t\t\t}",
                        "\t\t\tassert(diagp != NULL);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tIREAD_UNLOCK(ipimap);",
                        "",
                        "\t/*",
                        "\t * invalidate any page of the inode extent freed from buffer cache;",
                        "\t */",
                        "\tfreepxd = iagp->inoext[extno];",
                        "\tinvalidate_pxd_metapages(ip, freepxd);",
                        "",
                        "\t/*",
                        "\t *\tupdate iag list(s) (careful update step 2)",
                        "\t */",
                        "\t/* add the iag to the ag extent free list if this is the",
                        "\t * first free extent for the iag.",
                        "\t */",
                        "\tif (iagp->nfreeexts == 0) {",
                        "\t\tif (fwd >= 0)",
                        "\t\t\taiagp->extfreeback = cpu_to_le32(iagno);",
                        "",
                        "\t\tiagp->extfreefwd =",
                        "\t\t    cpu_to_le32(imap->im_agctl[agno].extfree);",
                        "\t\tiagp->extfreeback = cpu_to_le32(-1);",
                        "\t\timap->im_agctl[agno].extfree = iagno;",
                        "\t} else {",
                        "\t\t/* remove the iag from the ag extent list if all extents",
                        "\t\t * are now free and place it on the inode map iag free list.",
                        "\t\t */",
                        "\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {",
                        "\t\t\tif (fwd >= 0)",
                        "\t\t\t\taiagp->extfreeback = iagp->extfreeback;",
                        "",
                        "\t\t\tif (back >= 0)",
                        "\t\t\t\tbiagp->extfreefwd = iagp->extfreefwd;",
                        "\t\t\telse",
                        "\t\t\t\timap->im_agctl[agno].extfree =",
                        "\t\t\t\t    le32_to_cpu(iagp->extfreefwd);",
                        "",
                        "\t\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);",
                        "",
                        "\t\t\tIAGFREE_LOCK(imap);",
                        "\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);",
                        "\t\t\timap->im_freeiag = iagno;",
                        "\t\t\tIAGFREE_UNLOCK(imap);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* remove the iag from the ag inode free list if freeing",
                        "\t * this extent causes the iag to have no free inodes.",
                        "\t */",
                        "\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {",
                        "\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0)",
                        "\t\t\tciagp->inofreeback = iagp->inofreeback;",
                        "",
                        "\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0)",
                        "\t\t\tdiagp->inofreefwd = iagp->inofreefwd;",
                        "\t\telse",
                        "\t\t\timap->im_agctl[agno].inofree =",
                        "\t\t\t    le32_to_cpu(iagp->inofreefwd);",
                        "",
                        "\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);",
                        "\t}",
                        "",
                        "\t/* update the inode extent address and working map",
                        "\t * to reflect the free extent.",
                        "\t * the permanent map should have been updated already",
                        "\t * for the inode being freed.",
                        "\t */",
                        "\tif (iagp->pmap[extno] != 0) {",
                        "\t\tjfs_error(ip->i_sb, \"the pmap does not show inode free\\n\");",
                        "\t}",
                        "\tiagp->wmap[extno] = 0;",
                        "\tPXDlength(&iagp->inoext[extno], 0);",
                        "\tPXDaddress(&iagp->inoext[extno], 0);",
                        "",
                        "\t/* update the free extent and free inode summary maps",
                        "\t * to reflect the freed extent.",
                        "\t * the inode summary map is marked to indicate no inodes",
                        "\t * available for the freed extent.",
                        "\t */",
                        "\tsword = extno >> L2EXTSPERSUM;",
                        "\tbitno = extno & (EXTSPERSUM - 1);",
                        "\tmask = HIGHORDER >> bitno;",
                        "\tiagp->inosmap[sword] |= cpu_to_le32(mask);",
                        "\tiagp->extsmap[sword] &= cpu_to_le32(~mask);",
                        "",
                        "\t/* update the number of free inodes and number of free extents",
                        "\t * for the iag.",
                        "\t */",
                        "\tle32_add_cpu(&iagp->nfreeinos, -(INOSPEREXT - 1));",
                        "\tle32_add_cpu(&iagp->nfreeexts, 1);",
                        "",
                        "\t/* update the number of free inodes and backed inodes",
                        "\t * at the ag and inode map level.",
                        "\t */",
                        "\timap->im_agctl[agno].numfree -= (INOSPEREXT - 1);",
                        "\timap->im_agctl[agno].numinos -= INOSPEREXT;",
                        "\tatomic_sub(INOSPEREXT - 1, &imap->im_numfree);",
                        "\tatomic_sub(INOSPEREXT, &imap->im_numinos);",
                        "",
                        "\tif (amp)",
                        "\t\twrite_metapage(amp);",
                        "\tif (bmp)",
                        "\t\twrite_metapage(bmp);",
                        "\tif (cmp)",
                        "\t\twrite_metapage(cmp);",
                        "\tif (dmp)",
                        "\t\twrite_metapage(dmp);",
                        "",
                        "\t/*",
                        "\t * start transaction to update block allocation map",
                        "\t * for the inode extent freed;",
                        "\t *",
                        "\t * N.B. AG_LOCK is released and iag will be released below, and",
                        "\t * other thread may allocate inode from/reusing the ixad freed",
                        "\t * BUT with new/different backing inode extent from the extent",
                        "\t * to be freed by the transaction;",
                        "\t */",
                        "\ttid = txBegin(ipimap->i_sb, COMMIT_FORCE);",
                        "\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);",
                        "",
                        "\t/* acquire tlock of the iag page of the freed ixad",
                        "\t * to force the page NOHOMEOK (even though no data is",
                        "\t * logged from the iag page) until NOREDOPAGE|FREEXTENT log",
                        "\t * for the free of the extent is committed;",
                        "\t * write FREEXTENT|NOREDOPAGE log record",
                        "\t * N.B. linelock is overlaid as freed extent descriptor;",
                        "\t */",
                        "\ttlck = txLock(tid, ipimap, mp, tlckINODE | tlckFREE);",
                        "\tpxdlock = (struct pxd_lock *) & tlck->lock;",
                        "\tpxdlock->flag = mlckFREEPXD;",
                        "\tpxdlock->pxd = freepxd;",
                        "\tpxdlock->index = 1;",
                        "",
                        "\twrite_metapage(mp);",
                        "",
                        "\tiplist[0] = ipimap;",
                        "",
                        "\t/*",
                        "\t * logredo needs the IAG number and IAG extent index in order",
                        "\t * to ensure that the IMap is consistent.  The least disruptive",
                        "\t * way to pass these values through  to the transaction manager",
                        "\t * is in the iplist array.",
                        "\t *",
                        "\t * It's not pretty, but it works.",
                        "\t */",
                        "\tiplist[1] = (struct inode *) (size_t)iagno;",
                        "\tiplist[2] = (struct inode *) (size_t)extno;",
                        "",
                        "\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);",
                        "",
                        "\ttxEnd(tid);",
                        "\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);",
                        "",
                        "\t/* unlock the AG inode map information */",
                        "\tAG_UNLOCK(imap, agno);",
                        "",
                        "\treturn (0);",
                        "",
                        "      error_out:",
                        "\tIREAD_UNLOCK(ipimap);",
                        "",
                        "\tif (amp)",
                        "\t\trelease_metapage(amp);",
                        "\tif (bmp)",
                        "\t\trelease_metapage(bmp);",
                        "\tif (cmp)",
                        "\t\trelease_metapage(cmp);",
                        "\tif (dmp)",
                        "\t\trelease_metapage(dmp);",
                        "",
                        "\tAG_UNLOCK(imap, agno);",
                        "",
                        "\trelease_metapage(mp);",
                        "",
                        "\treturn (rc);",
                        "}"
                    ],
                    "start": 805,
                    "highlight": 852
                }
            ],
            "ins_idx": 60,
            "addr": "0xffffffff8136ac65"
        },
        "894": {
            "name": "+0x4a",
            "parent_idx": 889,
            "source_line": [
                {
                    "file": "fs/jfs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jfs/super.c?id=805c6d3c#n504",
                    "code": [
                        "static int jfs_fill_super(struct super_block *sb, void *data, int silent)",
                        "{",
                        "\tstruct jfs_sb_info *sbi;",
                        "\tstruct inode *inode;",
                        "\tint rc;",
                        "\ts64 newLVSize = 0;",
                        "\tint flag, ret = -EINVAL;",
                        "",
                        "\tjfs_info(\"In jfs_read_super: s_flags=0x%lx\", sb->s_flags);",
                        "",
                        "\tsbi = kzalloc(sizeof(struct jfs_sb_info), GFP_KERNEL);",
                        "\tif (!sbi)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tsb->s_fs_info = sbi;",
                        "\tsb->s_max_links = JFS_LINK_MAX;",
                        "\tsb->s_time_min = 0;",
                        "\tsb->s_time_max = U32_MAX;",
                        "\tsbi->sb = sb;",
                        "\tsbi->uid = INVALID_UID;",
                        "\tsbi->gid = INVALID_GID;",
                        "\tsbi->umask = -1;",
                        "",
                        "\t/* initialize the mount flag and determine the default error handler */",
                        "\tflag = JFS_ERR_REMOUNT_RO;",
                        "",
                        "\tif (!parse_options((char *) data, sb, &newLVSize, &flag))",
                        "\t\tgoto out_kfree;",
                        "\tsbi->flag = flag;",
                        "",
                        "#ifdef CONFIG_JFS_POSIX_ACL",
                        "\tsb->s_flags |= SB_POSIXACL;",
                        "#endif",
                        "",
                        "\tif (newLVSize) {",
                        "\t\tpr_err(\"resize option for remount only\\n\");",
                        "\t\tgoto out_kfree;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Initialize blocksize to 4K.",
                        "\t */",
                        "\tsb_set_blocksize(sb, PSIZE);",
                        "",
                        "\t/*",
                        "\t * Set method vectors.",
                        "\t */",
                        "\tsb->s_op = &jfs_super_operations;",
                        "\tsb->s_export_op = &jfs_export_operations;",
                        "\tsb->s_xattr = jfs_xattr_handlers;",
                        "#ifdef CONFIG_QUOTA",
                        "\tsb->dq_op = &dquot_operations;",
                        "\tsb->s_qcop = &jfs_quotactl_ops;",
                        "\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;",
                        "#endif",
                        "",
                        "\t/*",
                        "\t * Initialize direct-mapping inode/address-space",
                        "\t */",
                        "\tinode = new_inode(sb);",
                        "\tif (inode == NULL) {",
                        "\t\tret = -ENOMEM;",
                        "\t\tgoto out_unload;",
                        "\t}",
                        "\tinode->i_ino = 0;",
                        "\tinode->i_size = i_size_read(sb->s_bdev->bd_inode);",
                        "\tinode->i_mapping->a_ops = &jfs_metapage_aops;",
                        "\tinode_fake_hash(inode);",
                        "\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);",
                        "",
                        "\tsbi->direct_inode = inode;",
                        "",
                        "\trc = jfs_mount(sb);",
                        "\tif (rc) {",
                        "\t\tif (!silent)",
                        "\t\t\tjfs_err(\"jfs_mount failed w/return code = %d\", rc);",
                        "\t\tgoto out_mount_failed;",
                        "\t}",
                        "\tif (sb_rdonly(sb))",
                        "\t\tsbi->log = NULL;",
                        "\telse {",
                        "\t\trc = jfs_mount_rw(sb, 0);",
                        "\t\tif (rc) {",
                        "\t\t\tif (!silent) {",
                        "\t\t\t\tjfs_err(\"jfs_mount_rw failed, return code = %d\",",
                        "\t\t\t\t\trc);",
                        "\t\t\t}",
                        "\t\t\tgoto out_no_rw;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tsb->s_magic = JFS_SUPER_MAGIC;",
                        "",
                        "\tif (sbi->mntflag & JFS_OS2)",
                        "\t\tsb->s_d_op = &jfs_ci_dentry_operations;",
                        "",
                        "\tinode = jfs_iget(sb, ROOT_I);",
                        "\tif (IS_ERR(inode)) {",
                        "\t\tret = PTR_ERR(inode);",
                        "\t\tgoto out_no_rw;",
                        "\t}",
                        "\tsb->s_root = d_make_root(inode);",
                        "\tif (!sb->s_root)",
                        "\t\tgoto out_no_root;",
                        "",
                        "\t/* logical blocks are represented by 40 bits in pxd_t, etc.",
                        "\t * and page cache is indexed by long",
                        "\t */",
                        "\tsb->s_maxbytes = min(((loff_t)sb->s_blocksize) << 40, MAX_LFS_FILESIZE);",
                        "\tsb->s_time_gran = 1;",
                        "\treturn 0;",
                        "",
                        "out_no_root:",
                        "\tjfs_err(\"jfs_read_super: get root dentry failed\");",
                        "",
                        "out_no_rw:",
                        "\trc = jfs_umount(sb);",
                        "\tif (rc)",
                        "\t\tjfs_err(\"jfs_umount failed with return code %d\", rc);",
                        "out_mount_failed:",
                        "\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);",
                        "\ttruncate_inode_pages(sbi->direct_inode->i_mapping, 0);",
                        "\tmake_bad_inode(sbi->direct_inode);",
                        "\tiput(sbi->direct_inode);",
                        "\tsbi->direct_inode = NULL;",
                        "out_unload:",
                        "\tunload_nls(sbi->nls_tab);",
                        "out_kfree:",
                        "\tkfree(sbi);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 490,
                    "highlight": 504
                }
            ],
            "ins_idx": 89,
            "addr": "0xffffffff8135fe1a"
        },
        "893": {
            "name": "+0xd2",
            "parent_idx": 892,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=805c6d3c#n2931",
                    "code": [
                        "#ifdef CONFIG_NUMA",
                        "void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)",
                        "{",
                        "\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);",
                        "",
                        "\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,",
                        "\t\t\t\t    s->object_size, s->size, gfpflags, node);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2925,
                    "highlight": 2931
                }
            ],
            "ins_idx": 61,
            "addr": "0xffffffff811dba52"
        },
        "892": {
            "name": "kmem_cache_alloc_trace",
            "parent_idx": 889,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=805c6d3c#n554",
                    "code": [
                        "/**",
                        " * kmalloc - allocate memory",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate.",
                        " *",
                        " * kmalloc is the normal method of allocating memory",
                        " * for objects smaller than page size in the kernel.",
                        " *",
                        " * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN",
                        " * bytes. For @size of power of two bytes, the alignment is also guaranteed",
                        " * to be at least to the size.",
                        " *",
                        " * The @flags argument may be one of the GFP flags defined at",
                        " * include/linux/gfp.h and described at",
                        " * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`",
                        " *",
                        " * The recommended usage of the @flags is described at",
                        " * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`",
                        " *",
                        " * Below is a brief outline of the most useful GFP flags",
                        " *",
                        " * %GFP_KERNEL",
                        " *\tAllocate normal kernel ram. May sleep.",
                        " *",
                        " * %GFP_NOWAIT",
                        " *\tAllocation will not sleep.",
                        " *",
                        " * %GFP_ATOMIC",
                        " *\tAllocation will not sleep.  May use emergency pools.",
                        " *",
                        " * %GFP_HIGHUSER",
                        " *\tAllocate memory from high memory on behalf of user.",
                        " *",
                        " * Also it is possible to set different flags by OR'ing",
                        " * in one or more of the following additional @flags:",
                        " *",
                        " * %__GFP_HIGH",
                        " *\tThis allocation has high priority and may use emergency pools.",
                        " *",
                        " * %__GFP_NOFAIL",
                        " *\tIndicate that this allocation is in no way allowed to fail",
                        " *\t(think twice before using).",
                        " *",
                        " * %__GFP_NORETRY",
                        " *\tIf memory is not immediately available,",
                        " *\tthen give up at once.",
                        " *",
                        " * %__GFP_NOWARN",
                        " *\tIf allocation fails, don't issue any warnings.",
                        " *",
                        " * %__GFP_RETRY_MAYFAIL",
                        " *\tTry really hard to succeed the allocation but fail",
                        " *\teventually.",
                        " */",
                        "static __always_inline void *kmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\tif (__builtin_constant_p(size)) {",
                        "#ifndef CONFIG_SLOB",
                        "\t\tunsigned int index;",
                        "#endif",
                        "\t\tif (size > KMALLOC_MAX_CACHE_SIZE)",
                        "\t\t\treturn kmalloc_large(size, flags);",
                        "#ifndef CONFIG_SLOB",
                        "\t\tindex = kmalloc_index(size);",
                        "",
                        "\t\tif (!index)",
                        "\t\t\treturn ZERO_SIZE_PTR;",
                        "",
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 486,
                    "highlight": 554
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=805c6d3c#n666",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 659,
                    "highlight": 666
                },
                {
                    "file": "fs/jfs/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jfs/super.c?id=805c6d3c#n500",
                    "code": [
                        "static int jfs_fill_super(struct super_block *sb, void *data, int silent)",
                        "{",
                        "\tstruct jfs_sb_info *sbi;",
                        "\tstruct inode *inode;",
                        "\tint rc;",
                        "\ts64 newLVSize = 0;",
                        "\tint flag, ret = -EINVAL;",
                        "",
                        "\tjfs_info(\"In jfs_read_super: s_flags=0x%lx\", sb->s_flags);",
                        "",
                        "\tsbi = kzalloc(sizeof(struct jfs_sb_info), GFP_KERNEL);",
                        "\tif (!sbi)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tsb->s_fs_info = sbi;",
                        "\tsb->s_max_links = JFS_LINK_MAX;",
                        "\tsb->s_time_min = 0;",
                        "\tsb->s_time_max = U32_MAX;",
                        "\tsbi->sb = sb;",
                        "\tsbi->uid = INVALID_UID;",
                        "\tsbi->gid = INVALID_GID;",
                        "\tsbi->umask = -1;",
                        "",
                        "\t/* initialize the mount flag and determine the default error handler */",
                        "\tflag = JFS_ERR_REMOUNT_RO;",
                        "",
                        "\tif (!parse_options((char *) data, sb, &newLVSize, &flag))",
                        "\t\tgoto out_kfree;",
                        "\tsbi->flag = flag;",
                        "",
                        "#ifdef CONFIG_JFS_POSIX_ACL",
                        "\tsb->s_flags |= SB_POSIXACL;",
                        "#endif",
                        "",
                        "\tif (newLVSize) {",
                        "\t\tpr_err(\"resize option for remount only\\n\");",
                        "\t\tgoto out_kfree;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Initialize blocksize to 4K.",
                        "\t */",
                        "\tsb_set_blocksize(sb, PSIZE);",
                        "",
                        "\t/*",
                        "\t * Set method vectors.",
                        "\t */",
                        "\tsb->s_op = &jfs_super_operations;",
                        "\tsb->s_export_op = &jfs_export_operations;",
                        "\tsb->s_xattr = jfs_xattr_handlers;",
                        "#ifdef CONFIG_QUOTA",
                        "\tsb->dq_op = &dquot_operations;",
                        "\tsb->s_qcop = &jfs_quotactl_ops;",
                        "\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;",
                        "#endif",
                        "",
                        "\t/*",
                        "\t * Initialize direct-mapping inode/address-space",
                        "\t */",
                        "\tinode = new_inode(sb);",
                        "\tif (inode == NULL) {",
                        "\t\tret = -ENOMEM;",
                        "\t\tgoto out_unload;",
                        "\t}",
                        "\tinode->i_ino = 0;",
                        "\tinode->i_size = i_size_read(sb->s_bdev->bd_inode);",
                        "\tinode->i_mapping->a_ops = &jfs_metapage_aops;",
                        "\tinode_fake_hash(inode);",
                        "\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);",
                        "",
                        "\tsbi->direct_inode = inode;",
                        "",
                        "\trc = jfs_mount(sb);",
                        "\tif (rc) {",
                        "\t\tif (!silent)",
                        "\t\t\tjfs_err(\"jfs_mount failed w/return code = %d\", rc);",
                        "\t\tgoto out_mount_failed;",
                        "\t}",
                        "\tif (sb_rdonly(sb))",
                        "\t\tsbi->log = NULL;",
                        "\telse {",
                        "\t\trc = jfs_mount_rw(sb, 0);",
                        "\t\tif (rc) {",
                        "\t\t\tif (!silent) {",
                        "\t\t\t\tjfs_err(\"jfs_mount_rw failed, return code = %d\",",
                        "\t\t\t\t\trc);",
                        "\t\t\t}",
                        "\t\t\tgoto out_no_rw;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tsb->s_magic = JFS_SUPER_MAGIC;",
                        "",
                        "\tif (sbi->mntflag & JFS_OS2)",
                        "\t\tsb->s_d_op = &jfs_ci_dentry_operations;",
                        "",
                        "\tinode = jfs_iget(sb, ROOT_I);",
                        "\tif (IS_ERR(inode)) {",
                        "\t\tret = PTR_ERR(inode);",
                        "\t\tgoto out_no_rw;",
                        "\t}",
                        "\tsb->s_root = d_make_root(inode);",
                        "\tif (!sb->s_root)",
                        "\t\tgoto out_no_root;",
                        "",
                        "\t/* logical blocks are represented by 40 bits in pxd_t, etc.",
                        "\t * and page cache is indexed by long",
                        "\t */",
                        "\tsb->s_maxbytes = min(((loff_t)sb->s_blocksize) << 40, MAX_LFS_FILESIZE);",
                        "\tsb->s_time_gran = 1;",
                        "\treturn 0;",
                        "",
                        "out_no_root:",
                        "\tjfs_err(\"jfs_read_super: get root dentry failed\");",
                        "",
                        "out_no_rw:",
                        "\trc = jfs_umount(sb);",
                        "\tif (rc)",
                        "\t\tjfs_err(\"jfs_umount failed with return code %d\", rc);",
                        "out_mount_failed:",
                        "\tfilemap_write_and_wait(sbi->direct_inode->i_mapping);",
                        "\ttruncate_inode_pages(sbi->direct_inode->i_mapping, 0);",
                        "\tmake_bad_inode(sbi->direct_inode);",
                        "\tiput(sbi->direct_inode);",
                        "\tsbi->direct_inode = NULL;",
                        "out_unload:",
                        "\tunload_nls(sbi->nls_tab);",
                        "out_kfree:",
                        "\tkfree(sbi);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 490,
                    "highlight": 500
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8135fe09"
        }
    },
    "ins": {
        "16": {
            "name": "mov r14, qword ptr [rcx - 0x80]",
            "desc": "Invalid Memory Access",
            "call_idx": 1044,
            "inputs": [
                1606,
                1607
            ],
            "outputs": [
                1608
            ]
        },
        "38": {
            "name": "mov rcx, qword ptr [rax + 0x28]",
            "desc": "Heap Use Before Initialization",
            "call_idx": 1043,
            "inputs": [
                1603,
                1604
            ],
            "outputs": [
                1605
            ]
        },
        "60": {
            "name": "mov rax, qword ptr [rax + 0x370]",
            "desc": "",
            "call_idx": 1042,
            "inputs": [
                1600,
                1601
            ],
            "outputs": [
                1602
            ]
        },
        "89": {
            "name": "mov qword ptr [rbp + 0x370], rax",
            "desc": "",
            "call_idx": 894,
            "inputs": [
                1372,
                1373
            ],
            "outputs": [
                1374
            ]
        },
        "61": {
            "name": "ret ",
            "desc": "",
            "call_idx": 893,
            "inputs": [],
            "outputs": [
                1371
            ]
        }
    },
    "data": {
        "1606": {
            "name": "RCX",
            "ins_idx": 16,
            "value": "0x0",
            "sources": []
        },
        "1607": {
            "name": "[0xffffffffffffff80]",
            "ins_idx": 16,
            "value": "0x0",
            "sources": []
        },
        "1608": {
            "name": "R14",
            "ins_idx": 16,
            "value": "0x0",
            "sources": []
        },
        "1603": {
            "name": "RAX",
            "ins_idx": 38,
            "value": "0xffff888235973200",
            "sources": []
        },
        "1604": {
            "name": "[0xffff888235973228]",
            "ins_idx": 38,
            "value": "0x0",
            "sources": []
        },
        "1605": {
            "name": "RCX",
            "ins_idx": 38,
            "value": "0x0",
            "sources": [
                1606
            ]
        },
        "1600": {
            "name": "RAX",
            "ins_idx": 60,
            "value": "0xffff888235ec1000",
            "sources": []
        },
        "1601": {
            "name": "[0xffff888235ec1370]",
            "ins_idx": 60,
            "value": "0xffff888235973200",
            "sources": []
        },
        "1602": {
            "name": "RAX",
            "ins_idx": 60,
            "value": "0xffff888235973200",
            "sources": [
                1603
            ]
        },
        "1372": {
            "name": "RBP",
            "ins_idx": 89,
            "value": "0xffff888235ec1000",
            "sources": []
        },
        "1373": {
            "name": "RAX",
            "ins_idx": 89,
            "value": "0xffff888235973200",
            "sources": []
        },
        "1374": {
            "name": "[0xffff888235ec1370]",
            "ins_idx": 89,
            "value": "0xffff888235973200",
            "sources": [
                1601
            ]
        },
        "1371": {
            "name": "RAX",
            "ins_idx": 61,
            "value": "0xffff888235973200",
            "sources": [
                1373
            ]
        }
    },
    "chain": {
        "16": [
            38
        ],
        "38": [
            60
        ],
        "60": [
            89
        ],
        "89": [
            61
        ]
    }
}