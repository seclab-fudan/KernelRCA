{
    "report": "https://syzkaller.appspot.com/bug?id=a0f577f4d29a70db15c142ad1115adb3ce2e9958",
    "title": "general protection fault in io_disable_sqo_submit",
    "call": {
        "3759": {
            "name": "+0x45",
            "parent_idx": 3750,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n6929",
                    "code": [
                        "static inline void io_ring_set_wakeup_flag(struct io_ring_ctx *ctx)",
                        "{",
                        "\t/* Tell userspace we may need a wakeup call */",
                        "\tspin_lock_irq(&ctx->completion_lock);",
                        "\tctx->rings->sq_flags |= IORING_SQ_NEED_WAKEUP;",
                        "\tspin_unlock_irq(&ctx->completion_lock);",
                        "}"
                    ],
                    "start": 6925,
                    "highlight": 6929
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n8891",
                    "code": [
                        "static void io_disable_sqo_submit(struct io_ring_ctx *ctx)",
                        "{",
                        "\tWARN_ON_ONCE(ctx->sqo_task != current);",
                        "",
                        "\tmutex_lock(&ctx->uring_lock);",
                        "\tctx->sqo_dead = 1;",
                        "\tmutex_unlock(&ctx->uring_lock);",
                        "",
                        "\t/* make sure callers enter the ring to get error */",
                        "\tio_ring_set_wakeup_flag(ctx);",
                        "}"
                    ],
                    "start": 8882,
                    "highlight": 8891
                }
            ],
            "ins_idx": 41,
            "addr": "0xffffffff8123ef05"
        },
        "3750": {
            "name": "io_disable_sqo_submit",
            "parent_idx": 3721,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n9711",
                    "code": [
                        "\ttrace_io_uring_create(ret, ctx, p->sq_entries, p->cq_entries, p->flags);",
                        "\treturn ret;",
                        "err:",
                        "\tio_disable_sqo_submit(ctx);",
                        "\tio_ring_ctx_wait_and_kill(ctx);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9708,
                    "highlight": 9711
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n9739",
                    "code": [
                        "/*",
                        " * Sets up an aio uring context, and returns the fd. Applications asks for a",
                        " * ring size, we return the actual sq/cq ring sizes (among other things) in the",
                        " * params structure passed in.",
                        " */",
                        "static long io_uring_setup(u32 entries, struct io_uring_params __user *params)",
                        "{",
                        "\tstruct io_uring_params p;",
                        "\tint i;",
                        "",
                        "\tif (copy_from_user(&p, params, sizeof(p)))",
                        "\t\treturn -EFAULT;",
                        "\tfor (i = 0; i < ARRAY_SIZE(p.resv); i++) {",
                        "\t\tif (p.resv[i])",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (p.flags & ~(IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL |",
                        "\t\t\tIORING_SETUP_SQ_AFF | IORING_SETUP_CQSIZE |",
                        "\t\t\tIORING_SETUP_CLAMP | IORING_SETUP_ATTACH_WQ |",
                        "\t\t\tIORING_SETUP_R_DISABLED))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\treturn  io_uring_create(entries, &p, params);",
                        "}"
                    ],
                    "start": 9716,
                    "highlight": 9739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8124c445"
        },
        "3721": {
            "name": "io_uring_setup(indirect)",
            "parent_idx": 3720,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b9416e"
        },
        "3720": {
            "name": "do_syscall_64",
            "parent_idx": 3719,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n120",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 120
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "3719": {
            "name": "536_syscall_184",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "3758": {
            "name": "+0x3e",
            "parent_idx": 3750,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n6929",
                    "code": [
                        "static inline void io_ring_set_wakeup_flag(struct io_ring_ctx *ctx)",
                        "{",
                        "\t/* Tell userspace we may need a wakeup call */",
                        "\tspin_lock_irq(&ctx->completion_lock);",
                        "\tctx->rings->sq_flags |= IORING_SQ_NEED_WAKEUP;",
                        "\tspin_unlock_irq(&ctx->completion_lock);",
                        "}"
                    ],
                    "start": 6925,
                    "highlight": 6929
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n8891",
                    "code": [
                        "static void io_disable_sqo_submit(struct io_ring_ctx *ctx)",
                        "{",
                        "\tWARN_ON_ONCE(ctx->sqo_task != current);",
                        "",
                        "\tmutex_lock(&ctx->uring_lock);",
                        "\tctx->sqo_dead = 1;",
                        "\tmutex_unlock(&ctx->uring_lock);",
                        "",
                        "\t/* make sure callers enter the ring to get error */",
                        "\tio_ring_set_wakeup_flag(ctx);",
                        "}"
                    ],
                    "start": 8882,
                    "highlight": 8891
                }
            ],
            "ins_idx": 89,
            "addr": "0xffffffff8123eefe"
        },
        "3724": {
            "name": "+0xdd",
            "parent_idx": 3723,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n2930",
                    "code": [
                        "#ifdef CONFIG_NUMA",
                        "void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)",
                        "{",
                        "\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);",
                        "",
                        "\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,",
                        "\t\t\t\t    s->object_size, s->size, gfpflags, node);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2924,
                    "highlight": 2930
                }
            ],
            "ins_idx": 147,
            "addr": "0xffffffff811da0fd"
        },
        "3723": {
            "name": "kmem_cache_alloc_trace",
            "parent_idx": 3721,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n552",
                    "code": [
                        "/**",
                        " * kmalloc - allocate memory",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate.",
                        " *",
                        " * kmalloc is the normal method of allocating memory",
                        " * for objects smaller than page size in the kernel.",
                        " *",
                        " * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN",
                        " * bytes. For @size of power of two bytes, the alignment is also guaranteed",
                        " * to be at least to the size.",
                        " *",
                        " * The @flags argument may be one of the GFP flags defined at",
                        " * include/linux/gfp.h and described at",
                        " * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`",
                        " *",
                        " * The recommended usage of the @flags is described at",
                        " * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`",
                        " *",
                        " * Below is a brief outline of the most useful GFP flags",
                        " *",
                        " * %GFP_KERNEL",
                        " *\tAllocate normal kernel ram. May sleep.",
                        " *",
                        " * %GFP_NOWAIT",
                        " *\tAllocation will not sleep.",
                        " *",
                        " * %GFP_ATOMIC",
                        " *\tAllocation will not sleep.  May use emergency pools.",
                        " *",
                        " * %GFP_HIGHUSER",
                        " *\tAllocate memory from high memory on behalf of user.",
                        " *",
                        " * Also it is possible to set different flags by OR'ing",
                        " * in one or more of the following additional @flags:",
                        " *",
                        " * %__GFP_HIGH",
                        " *\tThis allocation has high priority and may use emergency pools.",
                        " *",
                        " * %__GFP_NOFAIL",
                        " *\tIndicate that this allocation is in no way allowed to fail",
                        " *\t(think twice before using).",
                        " *",
                        " * %__GFP_NORETRY",
                        " *\tIf memory is not immediately available,",
                        " *\tthen give up at once.",
                        " *",
                        " * %__GFP_NOWARN",
                        " *\tIf allocation fails, don't issue any warnings.",
                        " *",
                        " * %__GFP_RETRY_MAYFAIL",
                        " *\tTry really hard to succeed the allocation but fail",
                        " *\teventually.",
                        " */",
                        "static __always_inline void *kmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\tif (__builtin_constant_p(size)) {",
                        "#ifndef CONFIG_SLOB",
                        "\t\tunsigned int index;",
                        "#endif",
                        "\t\tif (size > KMALLOC_MAX_CACHE_SIZE)",
                        "\t\t\treturn kmalloc_large(size, flags);",
                        "#ifndef CONFIG_SLOB",
                        "\t\tindex = kmalloc_index(size);",
                        "",
                        "\t\tif (!index)",
                        "\t\t\treturn ZERO_SIZE_PTR;",
                        "",
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 484,
                    "highlight": 552
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n682",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 675,
                    "highlight": 682
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n1276",
                    "code": [
                        "static struct io_ring_ctx *io_ring_ctx_alloc(struct io_uring_params *p)",
                        "{",
                        "\tstruct io_ring_ctx *ctx;",
                        "\tint hash_bits;",
                        "",
                        "\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);",
                        "\tif (!ctx)",
                        "\t\treturn NULL;",
                        "",
                        "\tctx->fallback_req = kmem_cache_alloc(req_cachep, GFP_KERNEL);",
                        "\tif (!ctx->fallback_req)",
                        "\t\tgoto err;",
                        "",
                        "\t/*",
                        "\t * Use 5 bits less than the max cq entries, that should give us around",
                        "\t * 32 entries per hash list if totally full and uniformly spread.",
                        "\t */",
                        "\thash_bits = ilog2(p->cq_entries);",
                        "\thash_bits -= 5;",
                        "\tif (hash_bits <= 0)",
                        "\t\thash_bits = 1;",
                        "\tctx->cancel_hash_bits = hash_bits;",
                        "\tctx->cancel_hash = kmalloc((1U << hash_bits) * sizeof(struct hlist_head),",
                        "\t\t\t\t\tGFP_KERNEL);",
                        "\tif (!ctx->cancel_hash)",
                        "\t\tgoto err;",
                        "\t__hash_init(ctx->cancel_hash, 1U << hash_bits);",
                        "",
                        "\tif (percpu_ref_init(&ctx->refs, io_ring_ctx_ref_free,",
                        "\t\t\t    PERCPU_REF_ALLOW_REINIT, GFP_KERNEL))",
                        "\t\tgoto err;",
                        "",
                        "\tctx->flags = p->flags;",
                        "\tinit_waitqueue_head(&ctx->sqo_sq_wait);",
                        "\tINIT_LIST_HEAD(&ctx->sqd_list);",
                        "\tinit_waitqueue_head(&ctx->cq_wait);",
                        "\tINIT_LIST_HEAD(&ctx->cq_overflow_list);",
                        "\tinit_completion(&ctx->ref_comp);",
                        "\tinit_completion(&ctx->sq_thread_comp);",
                        "\tidr_init(&ctx->io_buffer_idr);",
                        "\tidr_init(&ctx->personality_idr);",
                        "\tmutex_init(&ctx->uring_lock);",
                        "\tinit_waitqueue_head(&ctx->wait);",
                        "\tspin_lock_init(&ctx->completion_lock);",
                        "\tINIT_LIST_HEAD(&ctx->iopoll_list);",
                        "\tINIT_LIST_HEAD(&ctx->defer_list);",
                        "\tINIT_LIST_HEAD(&ctx->timeout_list);",
                        "\tspin_lock_init(&ctx->inflight_lock);",
                        "\tINIT_LIST_HEAD(&ctx->inflight_list);",
                        "\tINIT_DELAYED_WORK(&ctx->file_put_work, io_file_put_work);",
                        "\tinit_llist_head(&ctx->file_put_llist);",
                        "\treturn ctx;",
                        "err:",
                        "\tif (ctx->fallback_req)",
                        "\t\tkmem_cache_free(req_cachep, ctx->fallback_req);",
                        "\tkfree(ctx->cancel_hash);",
                        "\tkfree(ctx);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 1271,
                    "highlight": 1276
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n9596",
                    "code": [
                        "static int io_uring_create(unsigned entries, struct io_uring_params *p,",
                        "\t\t\t   struct io_uring_params __user *params)",
                        "{",
                        "\tstruct user_struct *user = NULL;",
                        "\tstruct io_ring_ctx *ctx;",
                        "\tstruct file *file;",
                        "\tbool limit_mem;",
                        "\tint ret;",
                        "",
                        "\tif (!entries)",
                        "\t\treturn -EINVAL;",
                        "\tif (entries > IORING_MAX_ENTRIES) {",
                        "\t\tif (!(p->flags & IORING_SETUP_CLAMP))",
                        "\t\t\treturn -EINVAL;",
                        "\t\tentries = IORING_MAX_ENTRIES;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Use twice as many entries for the CQ ring. It's possible for the",
                        "\t * application to drive a higher depth than the size of the SQ ring,",
                        "\t * since the sqes are only used at submission time. This allows for",
                        "\t * some flexibility in overcommitting a bit. If the application has",
                        "\t * set IORING_SETUP_CQSIZE, it will have passed in the desired number",
                        "\t * of CQ ring entries manually.",
                        "\t */",
                        "\tp->sq_entries = roundup_pow_of_two(entries);",
                        "\tif (p->flags & IORING_SETUP_CQSIZE) {",
                        "\t\t/*",
                        "\t\t * If IORING_SETUP_CQSIZE is set, we do the same roundup",
                        "\t\t * to a power-of-two, if it isn't already. We do NOT impose",
                        "\t\t * any cq vs sq ring sizing.",
                        "\t\t */",
                        "\t\tif (!p->cq_entries)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tif (p->cq_entries > IORING_MAX_CQ_ENTRIES) {",
                        "\t\t\tif (!(p->flags & IORING_SETUP_CLAMP))",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\tp->cq_entries = IORING_MAX_CQ_ENTRIES;",
                        "\t\t}",
                        "\t\tp->cq_entries = roundup_pow_of_two(p->cq_entries);",
                        "\t\tif (p->cq_entries < p->sq_entries)",
                        "\t\t\treturn -EINVAL;",
                        "\t} else {",
                        "\t\tp->cq_entries = 2 * p->sq_entries;",
                        "\t}",
                        "",
                        "\tuser = get_uid(current_user());",
                        "\tlimit_mem = !capable(CAP_IPC_LOCK);",
                        "",
                        "\tif (limit_mem) {",
                        "\t\tret = __io_account_mem(user,",
                        "\t\t\t\tring_pages(p->sq_entries, p->cq_entries));",
                        "\t\tif (ret) {",
                        "\t\t\tfree_uid(user);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tctx = io_ring_ctx_alloc(p);",
                        "\tif (!ctx) {",
                        "\t\tif (limit_mem)",
                        "\t\t\t__io_unaccount_mem(user, ring_pages(p->sq_entries,",
                        "\t\t\t\t\t\t\t\tp->cq_entries));",
                        "\t\tfree_uid(user);",
                        "\t\treturn -ENOMEM;",
                        "\t}",
                        "\tctx->compat = in_compat_syscall();",
                        "\tctx->user = user;",
                        "\tctx->creds = get_current_cred();",
                        "#ifdef CONFIG_AUDIT",
                        "\tctx->loginuid = current->loginuid;",
                        "\tctx->sessionid = current->sessionid;",
                        "#endif",
                        "\tctx->sqo_task = get_task_struct(current);",
                        "",
                        "\t/*",
                        "\t * This is just grabbed for accounting purposes. When a process exits,",
                        "\t * the mm is exited and dropped before the files, hence we need to hang",
                        "\t * on to this mm purely for the purposes of being able to unaccount",
                        "\t * memory (locked/pinned vm). It's not used for anything else.",
                        "\t */",
                        "\tmmgrab(current->mm);",
                        "\tctx->mm_account = current->mm;",
                        "",
                        "#ifdef CONFIG_BLK_CGROUP",
                        "\t/*",
                        "\t * The sq thread will belong to the original cgroup it was inited in.",
                        "\t * If the cgroup goes offline (e.g. disabling the io controller), then",
                        "\t * issued bios will be associated with the closest cgroup later in the",
                        "\t * block layer.",
                        "\t */",
                        "\trcu_read_lock();",
                        "\tctx->sqo_blkcg_css = blkcg_css();",
                        "\tret = css_tryget_online(ctx->sqo_blkcg_css);",
                        "\trcu_read_unlock();",
                        "\tif (!ret) {",
                        "\t\t/* don't init against a dying cgroup, have the user try again */",
                        "\t\tctx->sqo_blkcg_css = NULL;",
                        "\t\tret = -ENODEV;",
                        "\t\tgoto err;",
                        "\t}",
                        "#endif",
                        "",
                        "\t/*",
                        "\t * Account memory _before_ installing the file descriptor. Once",
                        "\t * the descriptor is installed, it can get closed at any time. Also",
                        "\t * do this before hitting the general error path, as ring freeing",
                        "\t * will un-account as well.",
                        "\t */",
                        "\tio_account_mem(ctx, ring_pages(p->sq_entries, p->cq_entries),",
                        "\t\t       ACCT_LOCKED);",
                        "\tctx->limit_mem = limit_mem;",
                        "",
                        "\tret = io_allocate_scq_urings(ctx, p);",
                        "\tif (ret)",
                        "\t\tgoto err;",
                        "",
                        "\tret = io_sq_offload_create(ctx, p);",
                        "\tif (ret)",
                        "\t\tgoto err;",
                        "",
                        "\tif (!(p->flags & IORING_SETUP_R_DISABLED))",
                        "\t\tio_sq_offload_start(ctx);",
                        "",
                        "\tmemset(&p->sq_off, 0, sizeof(p->sq_off));",
                        "\tp->sq_off.head = offsetof(struct io_rings, sq.head);",
                        "\tp->sq_off.tail = offsetof(struct io_rings, sq.tail);",
                        "\tp->sq_off.ring_mask = offsetof(struct io_rings, sq_ring_mask);",
                        "\tp->sq_off.ring_entries = offsetof(struct io_rings, sq_ring_entries);",
                        "\tp->sq_off.flags = offsetof(struct io_rings, sq_flags);",
                        "\tp->sq_off.dropped = offsetof(struct io_rings, sq_dropped);",
                        "\tp->sq_off.array = (char *)ctx->sq_array - (char *)ctx->rings;",
                        "",
                        "\tmemset(&p->cq_off, 0, sizeof(p->cq_off));",
                        "\tp->cq_off.head = offsetof(struct io_rings, cq.head);",
                        "\tp->cq_off.tail = offsetof(struct io_rings, cq.tail);",
                        "\tp->cq_off.ring_mask = offsetof(struct io_rings, cq_ring_mask);",
                        "\tp->cq_off.ring_entries = offsetof(struct io_rings, cq_ring_entries);",
                        "\tp->cq_off.overflow = offsetof(struct io_rings, cq_overflow);",
                        "\tp->cq_off.cqes = offsetof(struct io_rings, cqes);",
                        "\tp->cq_off.flags = offsetof(struct io_rings, cq_flags);",
                        "",
                        "\tp->features = IORING_FEAT_SINGLE_MMAP | IORING_FEAT_NODROP |",
                        "\t\t\tIORING_FEAT_SUBMIT_STABLE | IORING_FEAT_RW_CUR_POS |",
                        "\t\t\tIORING_FEAT_CUR_PERSONALITY | IORING_FEAT_FAST_POLL |",
                        "\t\t\tIORING_FEAT_POLL_32BITS | IORING_FEAT_SQPOLL_NONFIXED |",
                        "\t\t\tIORING_FEAT_EXT_ARG;",
                        "",
                        "\tif (copy_to_user(params, p, sizeof(*p))) {",
                        "\t\tret = -EFAULT;",
                        "\t\tgoto err;",
                        "\t}",
                        "",
                        "\tfile = io_uring_get_file(ctx);",
                        "\tif (IS_ERR(file)) {",
                        "\t\tret = PTR_ERR(file);",
                        "\t\tgoto err;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Install ring fd as the very last thing, so we don't risk someone",
                        "\t * having closed it before we finish setup",
                        "\t */",
                        "\tret = io_uring_install_fd(ctx, file);",
                        "\tif (ret < 0) {",
                        "\t\t/* fput will clean it up */",
                        "\t\tfput(file);",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\ttrace_io_uring_create(ret, ctx, p->sq_entries, p->cq_entries, p->flags);",
                        "\treturn ret;",
                        "err:",
                        "\tio_disable_sqo_submit(ctx);",
                        "\tio_ring_ctx_wait_and_kill(ctx);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9538,
                    "highlight": 9596
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n9739",
                    "code": [
                        "/*",
                        " * Sets up an aio uring context, and returns the fd. Applications asks for a",
                        " * ring size, we return the actual sq/cq ring sizes (among other things) in the",
                        " * params structure passed in.",
                        " */",
                        "static long io_uring_setup(u32 entries, struct io_uring_params __user *params)",
                        "{",
                        "\tstruct io_uring_params p;",
                        "\tint i;",
                        "",
                        "\tif (copy_from_user(&p, params, sizeof(p)))",
                        "\t\treturn -EFAULT;",
                        "\tfor (i = 0; i < ARRAY_SIZE(p.resv); i++) {",
                        "\t\tif (p.resv[i])",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (p.flags & ~(IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL |",
                        "\t\t\tIORING_SETUP_SQ_AFF | IORING_SETUP_CQSIZE |",
                        "\t\t\tIORING_SETUP_CLAMP | IORING_SETUP_ATTACH_WQ |",
                        "\t\t\tIORING_SETUP_R_DISABLED))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\treturn  io_uring_create(entries, &p, params);",
                        "}"
                    ],
                    "start": 9716,
                    "highlight": 9739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8124bd6d"
        },
        "3757": {
            "name": "+0x34",
            "parent_idx": 3754,
            "source_line": [
                {
                    "file": "kernel/sched/core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/sched/core.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n6686",
                    "code": [
                        "/*",
                        " * __cond_resched_lock() - if a reschedule is pending, drop the given lock,",
                        " * call schedule, and on return reacquire the lock.",
                        " *",
                        " * This works OK both with and without CONFIG_PREEMPTION. We do strange low-level",
                        " * operations here to prevent schedule() from being called twice (once via",
                        " * spin_unlock(), once by hand).",
                        " */",
                        "int __cond_resched_lock(spinlock_t *lock)",
                        "{",
                        "\tint resched = should_resched(PREEMPT_LOCK_OFFSET);",
                        "\tint ret = 0;",
                        "",
                        "\tlockdep_assert_held(lock);",
                        "",
                        "\tif (spin_needbreak(lock) || resched) {",
                        "\t\tspin_unlock(lock);",
                        "\t\tif (resched)",
                        "\t\t\tpreempt_schedule_common();",
                        "\t\telse",
                        "\t\t\tcpu_relax();",
                        "\t\tret = 1;",
                        "\t\tspin_lock(lock);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 6670,
                    "highlight": 6686
                }
            ],
            "ins_idx": 146,
            "addr": "0xffffffff81b99b54"
        },
        "3754": {
            "name": "_cond_resched",
            "parent_idx": 3752,
            "source_line": [
                {
                    "file": "kernel/locking/mutex.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/locking/mutex.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n281",
                    "code": [
                        "/**",
                        " * mutex_lock - acquire the mutex",
                        " * @lock: the mutex to be acquired",
                        " *",
                        " * Lock the mutex exclusively for this task. If the mutex is not",
                        " * available right now, it will sleep until it can get it.",
                        " *",
                        " * The mutex must later on be released by the same task that",
                        " * acquired it. Recursive locking is not allowed. The task",
                        " * may not exit without first unlocking the mutex. Also, kernel",
                        " * memory where the mutex resides must not be freed with",
                        " * the mutex still locked. The mutex must first be initialized",
                        " * (or statically defined) before it can be locked. memset()-ing",
                        " * the mutex to 0 is not allowed.",
                        " *",
                        " * (The CONFIG_DEBUG_MUTEXES .config option turns on debugging",
                        " * checks that will enforce the restrictions and will also do",
                        " * deadlock debugging)",
                        " *",
                        " * This function is similar to (but not equivalent to) down().",
                        " */",
                        "void __sched mutex_lock(struct mutex *lock)",
                        "{",
                        "\tmight_sleep();",
                        "",
                        "\tif (!__mutex_trylock_fast(lock))",
                        "\t\t__mutex_lock_slowpath(lock);",
                        "}"
                    ],
                    "start": 258,
                    "highlight": 281
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b9b994"
        },
        "3752": {
            "name": "mutex_lock",
            "parent_idx": 3750,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n8886",
                    "code": [
                        "static void io_disable_sqo_submit(struct io_ring_ctx *ctx)",
                        "{",
                        "\tWARN_ON_ONCE(ctx->sqo_task != current);",
                        "",
                        "\tmutex_lock(&ctx->uring_lock);",
                        "\tctx->sqo_dead = 1;",
                        "\tmutex_unlock(&ctx->uring_lock);",
                        "",
                        "\t/* make sure callers enter the ring to get error */",
                        "\tio_ring_set_wakeup_flag(ctx);",
                        "}"
                    ],
                    "start": 8882,
                    "highlight": 8886
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8123eee1"
        },
        "3755": {
            "name": "+0x0",
            "parent_idx": 3754,
            "source_line": [
                {
                    "file": "kernel/sched/core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/sched/core.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n6679",
                    "code": [
                        "/*",
                        " * __cond_resched_lock() - if a reschedule is pending, drop the given lock,",
                        " * call schedule, and on return reacquire the lock.",
                        " *",
                        " * This works OK both with and without CONFIG_PREEMPTION. We do strange low-level",
                        " * operations here to prevent schedule() from being called twice (once via",
                        " * spin_unlock(), once by hand).",
                        " */",
                        "int __cond_resched_lock(spinlock_t *lock)",
                        "{",
                        "\tint resched = should_resched(PREEMPT_LOCK_OFFSET);",
                        "\tint ret = 0;",
                        "",
                        "\tlockdep_assert_held(lock);",
                        "",
                        "\tif (spin_needbreak(lock) || resched) {",
                        "\t\tspin_unlock(lock);",
                        "\t\tif (resched)",
                        "\t\t\tpreempt_schedule_common();",
                        "\t\telse",
                        "\t\t\tcpu_relax();",
                        "\t\tret = 1;",
                        "\t\tspin_lock(lock);",
                        "\t}",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 6670,
                    "highlight": 6679
                }
            ],
            "ins_idx": 219,
            "addr": "0xffffffff81b99b20"
        },
        "3751": {
            "name": "+0xb",
            "parent_idx": 3750,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n8883",
                    "code": [
                        "static void io_disable_sqo_submit(struct io_ring_ctx *ctx)",
                        "{",
                        "\tWARN_ON_ONCE(ctx->sqo_task != current);",
                        "",
                        "\tmutex_lock(&ctx->uring_lock);",
                        "\tctx->sqo_dead = 1;",
                        "\tmutex_unlock(&ctx->uring_lock);",
                        "",
                        "\t/* make sure callers enter the ring to get error */",
                        "\tio_ring_set_wakeup_flag(ctx);",
                        "}"
                    ],
                    "start": 8882,
                    "highlight": 8883
                }
            ],
            "ins_idx": 299,
            "addr": "0xffffffff8123eecb"
        },
        "3749": {
            "name": "+0x8a2",
            "parent_idx": 3721,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n9711",
                    "code": [
                        "\ttrace_io_uring_create(ret, ctx, p->sq_entries, p->cq_entries, p->flags);",
                        "\treturn ret;",
                        "err:",
                        "\tio_disable_sqo_submit(ctx);",
                        "\tio_ring_ctx_wait_and_kill(ctx);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9708,
                    "highlight": 9711
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n9739",
                    "code": [
                        "/*",
                        " * Sets up an aio uring context, and returns the fd. Applications asks for a",
                        " * ring size, we return the actual sq/cq ring sizes (among other things) in the",
                        " * params structure passed in.",
                        " */",
                        "static long io_uring_setup(u32 entries, struct io_uring_params __user *params)",
                        "{",
                        "\tstruct io_uring_params p;",
                        "\tint i;",
                        "",
                        "\tif (copy_from_user(&p, params, sizeof(p)))",
                        "\t\treturn -EFAULT;",
                        "\tfor (i = 0; i < ARRAY_SIZE(p.resv); i++) {",
                        "\t\tif (p.resv[i])",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (p.flags & ~(IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL |",
                        "\t\t\tIORING_SETUP_SQ_AFF | IORING_SETUP_CQSIZE |",
                        "\t\t\tIORING_SETUP_CLAMP | IORING_SETUP_ATTACH_WQ |",
                        "\t\t\tIORING_SETUP_R_DISABLED))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\treturn  io_uring_create(entries, &p, params);",
                        "}"
                    ],
                    "start": 9716,
                    "highlight": 9739
                }
            ],
            "ins_idx": 403,
            "addr": "0xffffffff8124c442"
        },
        "3725": {
            "name": "+0x1d2",
            "parent_idx": 3721,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n552",
                    "code": [
                        "/**",
                        " * kmalloc - allocate memory",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate.",
                        " *",
                        " * kmalloc is the normal method of allocating memory",
                        " * for objects smaller than page size in the kernel.",
                        " *",
                        " * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN",
                        " * bytes. For @size of power of two bytes, the alignment is also guaranteed",
                        " * to be at least to the size.",
                        " *",
                        " * The @flags argument may be one of the GFP flags defined at",
                        " * include/linux/gfp.h and described at",
                        " * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`",
                        " *",
                        " * The recommended usage of the @flags is described at",
                        " * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`",
                        " *",
                        " * Below is a brief outline of the most useful GFP flags",
                        " *",
                        " * %GFP_KERNEL",
                        " *\tAllocate normal kernel ram. May sleep.",
                        " *",
                        " * %GFP_NOWAIT",
                        " *\tAllocation will not sleep.",
                        " *",
                        " * %GFP_ATOMIC",
                        " *\tAllocation will not sleep.  May use emergency pools.",
                        " *",
                        " * %GFP_HIGHUSER",
                        " *\tAllocate memory from high memory on behalf of user.",
                        " *",
                        " * Also it is possible to set different flags by OR'ing",
                        " * in one or more of the following additional @flags:",
                        " *",
                        " * %__GFP_HIGH",
                        " *\tThis allocation has high priority and may use emergency pools.",
                        " *",
                        " * %__GFP_NOFAIL",
                        " *\tIndicate that this allocation is in no way allowed to fail",
                        " *\t(think twice before using).",
                        " *",
                        " * %__GFP_NORETRY",
                        " *\tIf memory is not immediately available,",
                        " *\tthen give up at once.",
                        " *",
                        " * %__GFP_NOWARN",
                        " *\tIf allocation fails, don't issue any warnings.",
                        " *",
                        " * %__GFP_RETRY_MAYFAIL",
                        " *\tTry really hard to succeed the allocation but fail",
                        " *\teventually.",
                        " */",
                        "static __always_inline void *kmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\tif (__builtin_constant_p(size)) {",
                        "#ifndef CONFIG_SLOB",
                        "\t\tunsigned int index;",
                        "#endif",
                        "\t\tif (size > KMALLOC_MAX_CACHE_SIZE)",
                        "\t\t\treturn kmalloc_large(size, flags);",
                        "#ifndef CONFIG_SLOB",
                        "\t\tindex = kmalloc_index(size);",
                        "",
                        "\t\tif (!index)",
                        "\t\t\treturn ZERO_SIZE_PTR;",
                        "",
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 484,
                    "highlight": 552
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n682",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 675,
                    "highlight": 682
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n1276",
                    "code": [
                        "static struct io_ring_ctx *io_ring_ctx_alloc(struct io_uring_params *p)",
                        "{",
                        "\tstruct io_ring_ctx *ctx;",
                        "\tint hash_bits;",
                        "",
                        "\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);",
                        "\tif (!ctx)",
                        "\t\treturn NULL;",
                        "",
                        "\tctx->fallback_req = kmem_cache_alloc(req_cachep, GFP_KERNEL);",
                        "\tif (!ctx->fallback_req)",
                        "\t\tgoto err;",
                        "",
                        "\t/*",
                        "\t * Use 5 bits less than the max cq entries, that should give us around",
                        "\t * 32 entries per hash list if totally full and uniformly spread.",
                        "\t */",
                        "\thash_bits = ilog2(p->cq_entries);",
                        "\thash_bits -= 5;",
                        "\tif (hash_bits <= 0)",
                        "\t\thash_bits = 1;",
                        "\tctx->cancel_hash_bits = hash_bits;",
                        "\tctx->cancel_hash = kmalloc((1U << hash_bits) * sizeof(struct hlist_head),",
                        "\t\t\t\t\tGFP_KERNEL);",
                        "\tif (!ctx->cancel_hash)",
                        "\t\tgoto err;",
                        "\t__hash_init(ctx->cancel_hash, 1U << hash_bits);",
                        "",
                        "\tif (percpu_ref_init(&ctx->refs, io_ring_ctx_ref_free,",
                        "\t\t\t    PERCPU_REF_ALLOW_REINIT, GFP_KERNEL))",
                        "\t\tgoto err;",
                        "",
                        "\tctx->flags = p->flags;",
                        "\tinit_waitqueue_head(&ctx->sqo_sq_wait);",
                        "\tINIT_LIST_HEAD(&ctx->sqd_list);",
                        "\tinit_waitqueue_head(&ctx->cq_wait);",
                        "\tINIT_LIST_HEAD(&ctx->cq_overflow_list);",
                        "\tinit_completion(&ctx->ref_comp);",
                        "\tinit_completion(&ctx->sq_thread_comp);",
                        "\tidr_init(&ctx->io_buffer_idr);",
                        "\tidr_init(&ctx->personality_idr);",
                        "\tmutex_init(&ctx->uring_lock);",
                        "\tinit_waitqueue_head(&ctx->wait);",
                        "\tspin_lock_init(&ctx->completion_lock);",
                        "\tINIT_LIST_HEAD(&ctx->iopoll_list);",
                        "\tINIT_LIST_HEAD(&ctx->defer_list);",
                        "\tINIT_LIST_HEAD(&ctx->timeout_list);",
                        "\tspin_lock_init(&ctx->inflight_lock);",
                        "\tINIT_LIST_HEAD(&ctx->inflight_list);",
                        "\tINIT_DELAYED_WORK(&ctx->file_put_work, io_file_put_work);",
                        "\tinit_llist_head(&ctx->file_put_llist);",
                        "\treturn ctx;",
                        "err:",
                        "\tif (ctx->fallback_req)",
                        "\t\tkmem_cache_free(req_cachep, ctx->fallback_req);",
                        "\tkfree(ctx->cancel_hash);",
                        "\tkfree(ctx);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 1271,
                    "highlight": 1276
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n9596",
                    "code": [
                        "static int io_uring_create(unsigned entries, struct io_uring_params *p,",
                        "\t\t\t   struct io_uring_params __user *params)",
                        "{",
                        "\tstruct user_struct *user = NULL;",
                        "\tstruct io_ring_ctx *ctx;",
                        "\tstruct file *file;",
                        "\tbool limit_mem;",
                        "\tint ret;",
                        "",
                        "\tif (!entries)",
                        "\t\treturn -EINVAL;",
                        "\tif (entries > IORING_MAX_ENTRIES) {",
                        "\t\tif (!(p->flags & IORING_SETUP_CLAMP))",
                        "\t\t\treturn -EINVAL;",
                        "\t\tentries = IORING_MAX_ENTRIES;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Use twice as many entries for the CQ ring. It's possible for the",
                        "\t * application to drive a higher depth than the size of the SQ ring,",
                        "\t * since the sqes are only used at submission time. This allows for",
                        "\t * some flexibility in overcommitting a bit. If the application has",
                        "\t * set IORING_SETUP_CQSIZE, it will have passed in the desired number",
                        "\t * of CQ ring entries manually.",
                        "\t */",
                        "\tp->sq_entries = roundup_pow_of_two(entries);",
                        "\tif (p->flags & IORING_SETUP_CQSIZE) {",
                        "\t\t/*",
                        "\t\t * If IORING_SETUP_CQSIZE is set, we do the same roundup",
                        "\t\t * to a power-of-two, if it isn't already. We do NOT impose",
                        "\t\t * any cq vs sq ring sizing.",
                        "\t\t */",
                        "\t\tif (!p->cq_entries)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tif (p->cq_entries > IORING_MAX_CQ_ENTRIES) {",
                        "\t\t\tif (!(p->flags & IORING_SETUP_CLAMP))",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\tp->cq_entries = IORING_MAX_CQ_ENTRIES;",
                        "\t\t}",
                        "\t\tp->cq_entries = roundup_pow_of_two(p->cq_entries);",
                        "\t\tif (p->cq_entries < p->sq_entries)",
                        "\t\t\treturn -EINVAL;",
                        "\t} else {",
                        "\t\tp->cq_entries = 2 * p->sq_entries;",
                        "\t}",
                        "",
                        "\tuser = get_uid(current_user());",
                        "\tlimit_mem = !capable(CAP_IPC_LOCK);",
                        "",
                        "\tif (limit_mem) {",
                        "\t\tret = __io_account_mem(user,",
                        "\t\t\t\tring_pages(p->sq_entries, p->cq_entries));",
                        "\t\tif (ret) {",
                        "\t\t\tfree_uid(user);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tctx = io_ring_ctx_alloc(p);",
                        "\tif (!ctx) {",
                        "\t\tif (limit_mem)",
                        "\t\t\t__io_unaccount_mem(user, ring_pages(p->sq_entries,",
                        "\t\t\t\t\t\t\t\tp->cq_entries));",
                        "\t\tfree_uid(user);",
                        "\t\treturn -ENOMEM;",
                        "\t}",
                        "\tctx->compat = in_compat_syscall();",
                        "\tctx->user = user;",
                        "\tctx->creds = get_current_cred();",
                        "#ifdef CONFIG_AUDIT",
                        "\tctx->loginuid = current->loginuid;",
                        "\tctx->sessionid = current->sessionid;",
                        "#endif",
                        "\tctx->sqo_task = get_task_struct(current);",
                        "",
                        "\t/*",
                        "\t * This is just grabbed for accounting purposes. When a process exits,",
                        "\t * the mm is exited and dropped before the files, hence we need to hang",
                        "\t * on to this mm purely for the purposes of being able to unaccount",
                        "\t * memory (locked/pinned vm). It's not used for anything else.",
                        "\t */",
                        "\tmmgrab(current->mm);",
                        "\tctx->mm_account = current->mm;",
                        "",
                        "#ifdef CONFIG_BLK_CGROUP",
                        "\t/*",
                        "\t * The sq thread will belong to the original cgroup it was inited in.",
                        "\t * If the cgroup goes offline (e.g. disabling the io controller), then",
                        "\t * issued bios will be associated with the closest cgroup later in the",
                        "\t * block layer.",
                        "\t */",
                        "\trcu_read_lock();",
                        "\tctx->sqo_blkcg_css = blkcg_css();",
                        "\tret = css_tryget_online(ctx->sqo_blkcg_css);",
                        "\trcu_read_unlock();",
                        "\tif (!ret) {",
                        "\t\t/* don't init against a dying cgroup, have the user try again */",
                        "\t\tctx->sqo_blkcg_css = NULL;",
                        "\t\tret = -ENODEV;",
                        "\t\tgoto err;",
                        "\t}",
                        "#endif",
                        "",
                        "\t/*",
                        "\t * Account memory _before_ installing the file descriptor. Once",
                        "\t * the descriptor is installed, it can get closed at any time. Also",
                        "\t * do this before hitting the general error path, as ring freeing",
                        "\t * will un-account as well.",
                        "\t */",
                        "\tio_account_mem(ctx, ring_pages(p->sq_entries, p->cq_entries),",
                        "\t\t       ACCT_LOCKED);",
                        "\tctx->limit_mem = limit_mem;",
                        "",
                        "\tret = io_allocate_scq_urings(ctx, p);",
                        "\tif (ret)",
                        "\t\tgoto err;",
                        "",
                        "\tret = io_sq_offload_create(ctx, p);",
                        "\tif (ret)",
                        "\t\tgoto err;",
                        "",
                        "\tif (!(p->flags & IORING_SETUP_R_DISABLED))",
                        "\t\tio_sq_offload_start(ctx);",
                        "",
                        "\tmemset(&p->sq_off, 0, sizeof(p->sq_off));",
                        "\tp->sq_off.head = offsetof(struct io_rings, sq.head);",
                        "\tp->sq_off.tail = offsetof(struct io_rings, sq.tail);",
                        "\tp->sq_off.ring_mask = offsetof(struct io_rings, sq_ring_mask);",
                        "\tp->sq_off.ring_entries = offsetof(struct io_rings, sq_ring_entries);",
                        "\tp->sq_off.flags = offsetof(struct io_rings, sq_flags);",
                        "\tp->sq_off.dropped = offsetof(struct io_rings, sq_dropped);",
                        "\tp->sq_off.array = (char *)ctx->sq_array - (char *)ctx->rings;",
                        "",
                        "\tmemset(&p->cq_off, 0, sizeof(p->cq_off));",
                        "\tp->cq_off.head = offsetof(struct io_rings, cq.head);",
                        "\tp->cq_off.tail = offsetof(struct io_rings, cq.tail);",
                        "\tp->cq_off.ring_mask = offsetof(struct io_rings, cq_ring_mask);",
                        "\tp->cq_off.ring_entries = offsetof(struct io_rings, cq_ring_entries);",
                        "\tp->cq_off.overflow = offsetof(struct io_rings, cq_overflow);",
                        "\tp->cq_off.cqes = offsetof(struct io_rings, cqes);",
                        "\tp->cq_off.flags = offsetof(struct io_rings, cq_flags);",
                        "",
                        "\tp->features = IORING_FEAT_SINGLE_MMAP | IORING_FEAT_NODROP |",
                        "\t\t\tIORING_FEAT_SUBMIT_STABLE | IORING_FEAT_RW_CUR_POS |",
                        "\t\t\tIORING_FEAT_CUR_PERSONALITY | IORING_FEAT_FAST_POLL |",
                        "\t\t\tIORING_FEAT_POLL_32BITS | IORING_FEAT_SQPOLL_NONFIXED |",
                        "\t\t\tIORING_FEAT_EXT_ARG;",
                        "",
                        "\tif (copy_to_user(params, p, sizeof(*p))) {",
                        "\t\tret = -EFAULT;",
                        "\t\tgoto err;",
                        "\t}",
                        "",
                        "\tfile = io_uring_get_file(ctx);",
                        "\tif (IS_ERR(file)) {",
                        "\t\tret = PTR_ERR(file);",
                        "\t\tgoto err;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Install ring fd as the very last thing, so we don't risk someone",
                        "\t * having closed it before we finish setup",
                        "\t */",
                        "\tret = io_uring_install_fd(ctx, file);",
                        "\tif (ret < 0) {",
                        "\t\t/* fput will clean it up */",
                        "\t\tfput(file);",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\ttrace_io_uring_create(ret, ctx, p->sq_entries, p->cq_entries, p->flags);",
                        "\treturn ret;",
                        "err:",
                        "\tio_disable_sqo_submit(ctx);",
                        "\tio_ring_ctx_wait_and_kill(ctx);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 9538,
                    "highlight": 9596
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=7c53f6b671f4aba70ff15e1b05148b10d58c2837#n9739",
                    "code": [
                        "/*",
                        " * Sets up an aio uring context, and returns the fd. Applications asks for a",
                        " * ring size, we return the actual sq/cq ring sizes (among other things) in the",
                        " * params structure passed in.",
                        " */",
                        "static long io_uring_setup(u32 entries, struct io_uring_params __user *params)",
                        "{",
                        "\tstruct io_uring_params p;",
                        "\tint i;",
                        "",
                        "\tif (copy_from_user(&p, params, sizeof(p)))",
                        "\t\treturn -EFAULT;",
                        "\tfor (i = 0; i < ARRAY_SIZE(p.resv); i++) {",
                        "\t\tif (p.resv[i])",
                        "\t\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tif (p.flags & ~(IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL |",
                        "\t\t\tIORING_SETUP_SQ_AFF | IORING_SETUP_CQSIZE |",
                        "\t\t\tIORING_SETUP_CLAMP | IORING_SETUP_ATTACH_WQ |",
                        "\t\t\tIORING_SETUP_R_DISABLED))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\treturn  io_uring_create(entries, &p, params);",
                        "}"
                    ],
                    "start": 9716,
                    "highlight": 9739
                }
            ],
            "ins_idx": 1101,
            "addr": "0xffffffff8124bd72"
        }
    },
    "ins": {
        "41": {
            "name": "or dword ptr [rax + 0x114], 1",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x114\nInvalid Base Address 0x114",
            "call_idx": 3759,
            "inputs": [
                7310,
                7311
            ],
            "outputs": [
                7312
            ]
        },
        "89": {
            "name": "mov rax, qword ptr [rbx + 0xc0]",
            "desc": "Heap Use Before Initialization\nSource of base address MEMALLOC 0x0",
            "call_idx": 3758,
            "inputs": [
                7307,
                7308
            ],
            "outputs": [
                7309
            ]
        },
        "147": {
            "name": "ret ",
            "desc": "Source of base address MEMALLOC 0x0",
            "call_idx": 3724,
            "inputs": [],
            "outputs": [
                7259
            ]
        },
        "146": {
            "name": "pop rbx",
            "desc": "",
            "call_idx": 3757,
            "inputs": [
                7304,
                7305
            ],
            "outputs": [
                7306
            ]
        },
        "219": {
            "name": "push rbx",
            "desc": "",
            "call_idx": 3755,
            "inputs": [
                7300,
                7301
            ],
            "outputs": [
                7302
            ]
        },
        "299": {
            "name": "mov rbx, rdi",
            "desc": "",
            "call_idx": 3751,
            "inputs": [
                7297
            ],
            "outputs": [
                7298
            ]
        },
        "403": {
            "name": "mov rdi, rbp",
            "desc": "",
            "call_idx": 3749,
            "inputs": [
                7295
            ],
            "outputs": [
                7296
            ]
        },
        "1101": {
            "name": "mov rbp, rax",
            "desc": "",
            "call_idx": 3725,
            "inputs": [
                7260
            ],
            "outputs": [
                7261
            ]
        }
    },
    "data": {
        "7310": {
            "name": "RAX",
            "ins_idx": 41,
            "value": "0x0",
            "sources": []
        },
        "7311": {
            "name": "[0x114]",
            "ins_idx": 41,
            "value": "0x0",
            "sources": []
        },
        "7312": {
            "name": "[0x114]",
            "ins_idx": 41,
            "value": "0x1",
            "sources": []
        },
        "7307": {
            "name": "RBX",
            "ins_idx": 89,
            "value": "0xffff888100ea1000",
            "sources": []
        },
        "7308": {
            "name": "[0xffff888100ea10c0]",
            "ins_idx": 89,
            "value": "0x0",
            "sources": []
        },
        "7309": {
            "name": "RAX",
            "ins_idx": 89,
            "value": "0x0",
            "sources": [
                7310
            ]
        },
        "7259": {
            "name": "RAX",
            "ins_idx": 147,
            "value": "0xffff888100ea1000",
            "sources": [
                7260
            ]
        },
        "7304": {
            "name": "RSP",
            "ins_idx": 146,
            "value": "0xffffc90000237e38",
            "sources": []
        },
        "7305": {
            "name": "[0xffffc90000237e38]",
            "ins_idx": 146,
            "value": "0xffff888100ea1000",
            "sources": []
        },
        "7306": {
            "name": "RBX",
            "ins_idx": 146,
            "value": "0xffff888100ea1000",
            "sources": [
                7307
            ]
        },
        "7300": {
            "name": "RSP",
            "ins_idx": 219,
            "value": "0xffffc90000237e40",
            "sources": []
        },
        "7301": {
            "name": "RBX",
            "ins_idx": 219,
            "value": "0xffff888100ea1000",
            "sources": []
        },
        "7302": {
            "name": "[0xffffc90000237e38]",
            "ins_idx": 219,
            "value": "0xffff888100ea1000",
            "sources": [
                7305
            ]
        },
        "7297": {
            "name": "RDI",
            "ins_idx": 299,
            "value": "0xffff888100ea1000",
            "sources": []
        },
        "7298": {
            "name": "RBX",
            "ins_idx": 299,
            "value": "0xffff888100ea1000",
            "sources": [
                7301
            ]
        },
        "7295": {
            "name": "RBP",
            "ins_idx": 403,
            "value": "0xffff888100ea1000",
            "sources": []
        },
        "7296": {
            "name": "RDI",
            "ins_idx": 403,
            "value": "0xffff888100ea1000",
            "sources": [
                7297
            ]
        },
        "7260": {
            "name": "RAX",
            "ins_idx": 1101,
            "value": "0xffff888100ea1000",
            "sources": []
        },
        "7261": {
            "name": "RBP",
            "ins_idx": 1101,
            "value": "0xffff888100ea1000",
            "sources": [
                7295
            ]
        }
    },
    "chain": {
        "41": [
            89
        ],
        "89": [
            147,
            146
        ],
        "146": [
            219
        ],
        "219": [
            299
        ],
        "299": [
            403
        ],
        "403": [
            1101
        ],
        "1101": [
            147
        ]
    }
}