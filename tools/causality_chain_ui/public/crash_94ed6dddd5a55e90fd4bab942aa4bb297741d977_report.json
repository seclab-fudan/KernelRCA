{
    "report": "https://syzkaller.appspot.com/bug?id=94ed6dddd5a55e90fd4bab942aa4bb297741d977",
    "title": "KASAN: use-after-free Read in si470x_int_in_callback (2)",
    "call": {
        "41163": {
            "name": "+0x50",
            "parent_idx": 41160,
            "source_line": [
                {
                    "file": "drivers/media/radio/si470x/radio-si470x-usb.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/media/radio/si470x/radio-si470x-usb.c?id=f40ddce88593482919761f74910f42f4b84c004b#n378",
                    "code": [
                        "/*",
                        " * si470x_int_in_callback - rds callback and processing function",
                        " *",
                        " * TODO: do we need to use mutex locks in some sections?",
                        " */",
                        "static void si470x_int_in_callback(struct urb *urb)",
                        "{",
                        "\tstruct si470x_device *radio = urb->context;",
                        "\tint retval;",
                        "\tunsigned char regnr;",
                        "\tunsigned char blocknum;",
                        "\tunsigned short bler; /* rds block errors */",
                        "\tunsigned short rds;",
                        "\tunsigned char tmpbuf[3];",
                        "",
                        "\tif (urb->status) {",
                        "\t\tif (urb->status == -ENOENT ||",
                        "\t\t\t\turb->status == -ECONNRESET ||",
                        "\t\t\t\turb->status == -ESHUTDOWN) {",
                        "\t\t\treturn;",
                        "\t\t} else {",
                        "\t\t\tdev_warn(&radio->intf->dev,",
                        "\t\t\t \"non-zero urb status (%d)\\n\", urb->status);",
                        "\t\t\tgoto resubmit; /* Maybe we can recover. */",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* Sometimes the device returns len 0 packets */",
                        "\tif (urb->actual_length != RDS_REPORT_SIZE)",
                        "\t\tgoto resubmit;",
                        "",
                        "\tradio->registers[STATUSRSSI] =",
                        "\t\tget_unaligned_be16(&radio->int_in_buffer[1]);",
                        "",
                        "\tif (radio->registers[STATUSRSSI] & STATUSRSSI_STC)",
                        "\t\tcomplete(&radio->completion);",
                        "",
                        "\tif ((radio->registers[SYSCONFIG1] & SYSCONFIG1_RDS)) {",
                        "\t\t/* Update RDS registers with URB data */",
                        "\t\tfor (regnr = 1; regnr < RDS_REGISTER_NUM; regnr++)",
                        "\t\t\tradio->registers[STATUSRSSI + regnr] =",
                        "\t\t\t    get_unaligned_be16(&radio->int_in_buffer[",
                        "\t\t\t\tregnr * RADIO_REGISTER_SIZE + 1]);",
                        "\t\t/* get rds blocks */",
                        "\t\tif ((radio->registers[STATUSRSSI] & STATUSRSSI_RDSR) == 0) {",
                        "\t\t\t/* No RDS group ready, better luck next time */",
                        "\t\t\tgoto resubmit;",
                        "\t\t}",
                        "\t\tif ((radio->registers[STATUSRSSI] & STATUSRSSI_RDSS) == 0) {",
                        "\t\t\t/* RDS decoder not synchronized */",
                        "\t\t\tgoto resubmit;",
                        "\t\t}",
                        "\t\tfor (blocknum = 0; blocknum < 4; blocknum++) {",
                        "\t\t\tswitch (blocknum) {",
                        "\t\t\tdefault:",
                        "\t\t\t\tbler = (radio->registers[STATUSRSSI] &",
                        "\t\t\t\t\t\tSTATUSRSSI_BLERA) >> 9;",
                        "\t\t\t\trds = radio->registers[RDSA];",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 1:",
                        "\t\t\t\tbler = (radio->registers[READCHAN] &",
                        "\t\t\t\t\t\tREADCHAN_BLERB) >> 14;",
                        "\t\t\t\trds = radio->registers[RDSB];",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 2:",
                        "\t\t\t\tbler = (radio->registers[READCHAN] &",
                        "\t\t\t\t\t\tREADCHAN_BLERC) >> 12;",
                        "\t\t\t\trds = radio->registers[RDSC];",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 3:",
                        "\t\t\t\tbler = (radio->registers[READCHAN] &",
                        "\t\t\t\t\t\tREADCHAN_BLERD) >> 10;",
                        "\t\t\t\trds = radio->registers[RDSD];",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* Fill the V4L2 RDS buffer */",
                        "\t\t\tput_unaligned_le16(rds, &tmpbuf);",
                        "\t\t\ttmpbuf[2] = blocknum;\t\t/* offset name */",
                        "\t\t\ttmpbuf[2] |= blocknum << 3;\t/* received offset */",
                        "\t\t\tif (bler > max_rds_errors)",
                        "\t\t\t\ttmpbuf[2] |= 0x80; /* uncorrectable errors */",
                        "\t\t\telse if (bler > 0)",
                        "\t\t\t\ttmpbuf[2] |= 0x40; /* corrected error(s) */",
                        "",
                        "\t\t\t/* copy RDS block to internal buffer */",
                        "\t\t\tmemcpy(&radio->buffer[radio->wr_index], &tmpbuf, 3);",
                        "\t\t\tradio->wr_index += 3;",
                        "",
                        "\t\t\t/* wrap write pointer */",
                        "\t\t\tif (radio->wr_index >= radio->buf_size)",
                        "\t\t\t\tradio->wr_index = 0;",
                        "",
                        "\t\t\t/* check for overflow */",
                        "\t\t\tif (radio->wr_index == radio->rd_index) {",
                        "\t\t\t\t/* increment and wrap read pointer */",
                        "\t\t\t\tradio->rd_index += 3;",
                        "\t\t\t\tif (radio->rd_index >= radio->buf_size)",
                        "\t\t\t\t\tradio->rd_index = 0;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (radio->wr_index != radio->rd_index)",
                        "\t\t\twake_up_interruptible(&radio->read_queue);",
                        "\t}",
                        "",
                        "resubmit:",
                        "\t/* Resubmit if we're still running. */",
                        "\tif (radio->int_in_running && radio->usbdev) {",
                        "\t\tretval = usb_submit_urb(radio->int_in_urb, GFP_ATOMIC);",
                        "\t\tif (retval) {",
                        "\t\t\tdev_warn(&radio->intf->dev,",
                        "\t\t\t       \"resubmitting urb failed (%d)\", retval);",
                        "\t\t\tradio->int_in_running = 0;",
                        "\t\t}",
                        "\t}",
                        "\tradio->status_rssi_auto_update = radio->int_in_running;",
                        "}"
                    ],
                    "start": 357,
                    "highlight": 378
                }
            ],
            "ins_idx": 396,
            "addr": "0xffffffff8239aefb"
        },
        "41160": {
            "name": "si470x_int_in_callback(indirect)",
            "parent_idx": 41145,
            "source_line": [
                {
                    "file": "drivers/usb/core/hcd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hcd.c?id=f40ddce88593482919761f74910f42f4b84c004b#n1656",
                    "code": [
                        "static void __usb_hcd_giveback_urb(struct urb *urb)",
                        "{",
                        "\tstruct usb_hcd *hcd = bus_to_hcd(urb->dev->bus);",
                        "\tstruct usb_anchor *anchor = urb->anchor;",
                        "\tint status = urb->unlinked;",
                        "",
                        "\turb->hcpriv = NULL;",
                        "\tif (unlikely((urb->transfer_flags & URB_SHORT_NOT_OK) &&",
                        "\t    urb->actual_length < urb->transfer_buffer_length &&",
                        "\t    !status))",
                        "\t\tstatus = -EREMOTEIO;",
                        "",
                        "\tunmap_urb_for_dma(hcd, urb);",
                        "\tusbmon_urb_complete(&hcd->self, urb, status);",
                        "\tusb_anchor_suspend_wakeups(anchor);",
                        "\tusb_unanchor_urb(urb);",
                        "\tif (likely(status == 0))",
                        "\t\tusb_led_activity(USB_LED_EVENT_HOST);",
                        "",
                        "\t/* pass ownership to the completion handler */",
                        "\turb->status = status;",
                        "\t/*",
                        "\t * This function can be called in task context inside another remote",
                        "\t * coverage collection section, but kcov doesn't support that kind of",
                        "\t * recursion yet. Only collect coverage in softirq context for now.",
                        "\t */",
                        "\tkcov_remote_start_usb_softirq((u64)urb->dev->bus->busnum);",
                        "\turb->complete(urb);",
                        "\tkcov_remote_stop_softirq();",
                        "",
                        "\tusb_anchor_resume_wakeups(anchor);",
                        "\tatomic_dec(&urb->use_count);",
                        "\tif (unlikely(atomic_read(&urb->reject)))",
                        "\t\twake_up(&usb_kill_urb_queue);",
                        "\tusb_put_urb(urb);",
                        "}"
                    ],
                    "start": 1629,
                    "highlight": 1656
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c9bf67"
        },
        "41145": {
            "name": "usb_hcd_giveback_urb",
            "parent_idx": 41120,
            "source_line": [
                {
                    "file": "drivers/usb/gadget/udc/dummy_hcd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/gadget/udc/dummy_hcd.c?id=f40ddce88593482919761f74910f42f4b84c004b#n1971",
                    "code": [
                        "/*",
                        " * Drive both sides of the transfers; looks like irq handlers to both",
                        " * drivers except that the callbacks are invoked from soft interrupt",
                        " * context.",
                        " */",
                        "static void dummy_timer(struct timer_list *t)",
                        "{",
                        "\tstruct dummy_hcd\t*dum_hcd = from_timer(dum_hcd, t, timer);",
                        "\tstruct dummy\t\t*dum = dum_hcd->dum;",
                        "\tstruct urbp\t\t*urbp, *tmp;",
                        "\tunsigned long\t\tflags;",
                        "\tint\t\t\tlimit, total;",
                        "\tint\t\t\ti;",
                        "",
                        "\t/* simplistic model for one frame's bandwidth */",
                        "\t/* FIXME: account for transaction and packet overhead */",
                        "\tswitch (dum->gadget.speed) {",
                        "\tcase USB_SPEED_LOW:",
                        "\t\ttotal = 8/*bytes*/ * 12/*packets*/;",
                        "\t\tbreak;",
                        "\tcase USB_SPEED_FULL:",
                        "\t\ttotal = 64/*bytes*/ * 19/*packets*/;",
                        "\t\tbreak;",
                        "\tcase USB_SPEED_HIGH:",
                        "\t\ttotal = 512/*bytes*/ * 13/*packets*/ * 8/*uframes*/;",
                        "\t\tbreak;",
                        "\tcase USB_SPEED_SUPER:",
                        "\t\t/* Bus speed is 500000 bytes/ms, so use a little less */",
                        "\t\ttotal = 490000;",
                        "\t\tbreak;",
                        "\tdefault:\t/* Can't happen */",
                        "\t\tdev_err(dummy_dev(dum_hcd), \"bogus device speed\\n\");",
                        "\t\ttotal = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\t/* FIXME if HZ != 1000 this will probably misbehave ... */",
                        "",
                        "\t/* look at each urb queued by the host side driver */",
                        "\tspin_lock_irqsave(&dum->lock, flags);",
                        "",
                        "\tif (!dum_hcd->udev) {",
                        "\t\tdev_err(dummy_dev(dum_hcd),",
                        "\t\t\t\t\"timer fired with no URBs pending?\\n\");",
                        "\t\tspin_unlock_irqrestore(&dum->lock, flags);",
                        "\t\treturn;",
                        "\t}",
                        "\tdum_hcd->next_frame_urbp = NULL;",
                        "",
                        "\tfor (i = 0; i < DUMMY_ENDPOINTS; i++) {",
                        "\t\tif (!ep_info[i].name)",
                        "\t\t\tbreak;",
                        "\t\tdum->ep[i].already_seen = 0;",
                        "\t}",
                        "",
                        "restart:",
                        "\tlist_for_each_entry_safe(urbp, tmp, &dum_hcd->urbp_list, urbp_list) {",
                        "\t\tstruct urb\t\t*urb;",
                        "\t\tstruct dummy_request\t*req;",
                        "\t\tu8\t\t\taddress;",
                        "\t\tstruct dummy_ep\t\t*ep = NULL;",
                        "\t\tint\t\t\tstatus = -EINPROGRESS;",
                        "",
                        "\t\t/* stop when we reach URBs queued after the timer interrupt */",
                        "\t\tif (urbp == dum_hcd->next_frame_urbp)",
                        "\t\t\tbreak;",
                        "",
                        "\t\turb = urbp->urb;",
                        "\t\tif (urb->unlinked)",
                        "\t\t\tgoto return_urb;",
                        "\t\telse if (dum_hcd->rh_state != DUMMY_RH_RUNNING)",
                        "\t\t\tcontinue;",
                        "",
                        "\t\t/* Used up this frame's bandwidth? */",
                        "\t\tif (total <= 0)",
                        "\t\t\tcontinue;",
                        "",
                        "\t\t/* find the gadget's ep for this request (if configured) */",
                        "\t\taddress = usb_pipeendpoint (urb->pipe);",
                        "\t\tif (usb_urb_dir_in(urb))",
                        "\t\t\taddress |= USB_DIR_IN;",
                        "\t\tep = find_endpoint(dum, address);",
                        "\t\tif (!ep) {",
                        "\t\t\t/* set_configuration() disagreement */",
                        "\t\t\tdev_dbg(dummy_dev(dum_hcd),",
                        "\t\t\t\t\"no ep configured for urb %p\\n\",",
                        "\t\t\t\turb);",
                        "\t\t\tstatus = -EPROTO;",
                        "\t\t\tgoto return_urb;",
                        "\t\t}",
                        "",
                        "\t\tif (ep->already_seen)",
                        "\t\t\tcontinue;",
                        "\t\tep->already_seen = 1;",
                        "\t\tif (ep == &dum->ep[0] && urb->error_count) {",
                        "\t\t\tep->setup_stage = 1;\t/* a new urb */",
                        "\t\t\turb->error_count = 0;",
                        "\t\t}",
                        "\t\tif (ep->halted && !ep->setup_stage) {",
                        "\t\t\t/* NOTE: must not be iso! */",
                        "\t\t\tdev_dbg(dummy_dev(dum_hcd), \"ep %s halted, urb %p\\n\",",
                        "\t\t\t\t\tep->ep.name, urb);",
                        "\t\t\tstatus = -EPIPE;",
                        "\t\t\tgoto return_urb;",
                        "\t\t}",
                        "\t\t/* FIXME make sure both ends agree on maxpacket */",
                        "",
                        "\t\t/* handle control requests */",
                        "\t\tif (ep == &dum->ep[0] && ep->setup_stage) {",
                        "\t\t\tstruct usb_ctrlrequest\t\tsetup;",
                        "\t\t\tint\t\t\t\tvalue = 1;",
                        "",
                        "\t\t\tsetup = *(struct usb_ctrlrequest *) urb->setup_packet;",
                        "\t\t\t/* paranoia, in case of stale queued data */",
                        "\t\t\tlist_for_each_entry(req, &ep->queue, queue) {",
                        "\t\t\t\tlist_del_init(&req->queue);",
                        "\t\t\t\treq->req.status = -EOVERFLOW;",
                        "\t\t\t\tdev_dbg(udc_dev(dum), \"stale req = %p\\n\",",
                        "\t\t\t\t\t\treq);",
                        "",
                        "\t\t\t\tspin_unlock(&dum->lock);",
                        "\t\t\t\tusb_gadget_giveback_request(&ep->ep, &req->req);",
                        "\t\t\t\tspin_lock(&dum->lock);",
                        "\t\t\t\tep->already_seen = 0;",
                        "\t\t\t\tgoto restart;",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* gadget driver never sees set_address or operations",
                        "\t\t\t * on standard feature flags.  some hardware doesn't",
                        "\t\t\t * even expose them.",
                        "\t\t\t */",
                        "\t\t\tep->last_io = jiffies;",
                        "\t\t\tep->setup_stage = 0;",
                        "\t\t\tep->halted = 0;",
                        "",
                        "\t\t\tvalue = handle_control_request(dum_hcd, urb, &setup,",
                        "\t\t\t\t\t\t       &status);",
                        "",
                        "\t\t\t/* gadget driver handles all other requests.  block",
                        "\t\t\t * until setup() returns; no reentrancy issues etc.",
                        "\t\t\t */",
                        "\t\t\tif (value > 0) {",
                        "\t\t\t\t++dum->callback_usage;",
                        "\t\t\t\tspin_unlock(&dum->lock);",
                        "\t\t\t\tvalue = dum->driver->setup(&dum->gadget,",
                        "\t\t\t\t\t\t&setup);",
                        "\t\t\t\tspin_lock(&dum->lock);",
                        "\t\t\t\t--dum->callback_usage;",
                        "",
                        "\t\t\t\tif (value >= 0) {",
                        "\t\t\t\t\t/* no delays (max 64KB data stage) */",
                        "\t\t\t\t\tlimit = 64*1024;",
                        "\t\t\t\t\tgoto treat_control_like_bulk;",
                        "\t\t\t\t}",
                        "\t\t\t\t/* error, see below */",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (value < 0) {",
                        "\t\t\t\tif (value != -EOPNOTSUPP)",
                        "\t\t\t\t\tdev_dbg(udc_dev(dum),",
                        "\t\t\t\t\t\t\"setup --> %d\\n\",",
                        "\t\t\t\t\t\tvalue);",
                        "\t\t\t\tstatus = -EPIPE;",
                        "\t\t\t\turb->actual_length = 0;",
                        "\t\t\t}",
                        "",
                        "\t\t\tgoto return_urb;",
                        "\t\t}",
                        "",
                        "\t\t/* non-control requests */",
                        "\t\tlimit = total;",
                        "\t\tswitch (usb_pipetype(urb->pipe)) {",
                        "\t\tcase PIPE_ISOCHRONOUS:",
                        "\t\t\t/*",
                        "\t\t\t * We don't support isochronous.  But if we did,",
                        "\t\t\t * here are some of the issues we'd have to face:",
                        "\t\t\t *",
                        "\t\t\t * Is it urb->interval since the last xfer?",
                        "\t\t\t * Use urb->iso_frame_desc[i].",
                        "\t\t\t * Complete whether or not ep has requests queued.",
                        "\t\t\t * Report random errors, to debug drivers.",
                        "\t\t\t */",
                        "\t\t\tlimit = max(limit, periodic_bytes(dum, ep));",
                        "\t\t\tstatus = -EINVAL;\t/* fail all xfers */",
                        "\t\t\tbreak;",
                        "",
                        "\t\tcase PIPE_INTERRUPT:",
                        "\t\t\t/* FIXME is it urb->interval since the last xfer?",
                        "\t\t\t * this almost certainly polls too fast.",
                        "\t\t\t */",
                        "\t\t\tlimit = max(limit, periodic_bytes(dum, ep));",
                        "\t\t\tfallthrough;",
                        "",
                        "\t\tdefault:",
                        "treat_control_like_bulk:",
                        "\t\t\tep->last_io = jiffies;",
                        "\t\t\ttotal -= transfer(dum_hcd, urb, ep, limit, &status);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\t/* incomplete transfer? */",
                        "\t\tif (status == -EINPROGRESS)",
                        "\t\t\tcontinue;",
                        "",
                        "return_urb:",
                        "\t\tlist_del(&urbp->urbp_list);",
                        "\t\tkfree(urbp);",
                        "\t\tif (ep)",
                        "\t\t\tep->already_seen = ep->setup_stage = 0;",
                        "",
                        "\t\tusb_hcd_unlink_urb_from_ep(dummy_hcd_to_hcd(dum_hcd), urb);",
                        "\t\tspin_unlock(&dum->lock);",
                        "\t\tusb_hcd_giveback_urb(dummy_hcd_to_hcd(dum_hcd), urb, status);",
                        "\t\tspin_lock(&dum->lock);",
                        "",
                        "\t\tgoto restart;",
                        "\t}",
                        "",
                        "\tif (list_empty(&dum_hcd->urbp_list)) {",
                        "\t\tusb_put_dev(dum_hcd->udev);",
                        "\t\tdum_hcd->udev = NULL;",
                        "\t} else if (dum_hcd->rh_state == DUMMY_RH_RUNNING) {",
                        "\t\t/* want a 1 msec delay here */",
                        "\t\tmod_timer(&dum_hcd->timer, jiffies + msecs_to_jiffies(1));",
                        "\t}",
                        "",
                        "\tspin_unlock_irqrestore(&dum->lock, flags);",
                        "}"
                    ],
                    "start": 1759,
                    "highlight": 1971
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81d1b835"
        },
        "41120": {
            "name": "dummy_timer(indirect)",
            "parent_idx": 41117,
            "source_line": [
                {
                    "file": "kernel/time/timer.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/time/timer.c?id=f40ddce88593482919761f74910f42f4b84c004b#n1417",
                    "code": [
                        "static void call_timer_fn(struct timer_list *timer,",
                        "\t\t\t  void (*fn)(struct timer_list *),",
                        "\t\t\t  unsigned long baseclk)",
                        "{",
                        "\tint count = preempt_count();",
                        "",
                        "#ifdef CONFIG_LOCKDEP",
                        "\t/*",
                        "\t * It is permissible to free the timer from inside the",
                        "\t * function that is called from it, this we need to take into",
                        "\t * account for lockdep too. To avoid bogus \"held lock freed\"",
                        "\t * warnings as well as problems when looking into",
                        "\t * timer->lockdep_map, make a copy and use that here.",
                        "\t */",
                        "\tstruct lockdep_map lockdep_map;",
                        "",
                        "\tlockdep_copy_map(&lockdep_map, &timer->lockdep_map);",
                        "#endif",
                        "\t/*",
                        "\t * Couple the lock chain with the lock chain at",
                        "\t * del_timer_sync() by acquiring the lock_map around the fn()",
                        "\t * call here and in del_timer_sync().",
                        "\t */",
                        "\tlock_map_acquire(&lockdep_map);",
                        "",
                        "\ttrace_timer_expire_entry(timer, baseclk);",
                        "\tfn(timer);",
                        "\ttrace_timer_expire_exit(timer);",
                        "",
                        "\tlock_map_release(&lockdep_map);",
                        "",
                        "\tif (count != preempt_count()) {",
                        "\t\tWARN_ONCE(1, \"timer: %pS preempt leak: %08x -> %08x\\n\",",
                        "\t\t\t  fn, count, preempt_count());",
                        "\t\t/*",
                        "\t\t * Restore the preempt count. That gives us a decent",
                        "\t\t * chance to survive and extract information. If the",
                        "\t\t * callback kept a lock held, bad luck, but not worse",
                        "\t\t * than the BUG() we had.",
                        "\t\t */",
                        "\t\tpreempt_count_set(count);",
                        "\t}",
                        "}"
                    ],
                    "start": 1391,
                    "highlight": 1417
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8116ee7c"
        },
        "41117": {
            "name": "call_timer_fn",
            "parent_idx": 41084,
            "source_line": [
                {
                    "file": "kernel/time/timer.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/time/timer.c?id=f40ddce88593482919761f74910f42f4b84c004b#n1462",
                    "code": [
                        "static void expire_timers(struct timer_base *base, struct hlist_head *head)",
                        "{",
                        "\t/*",
                        "\t * This value is required only for tracing. base->clk was",
                        "\t * incremented directly before expire_timers was called. But expiry",
                        "\t * is related to the old base->clk value.",
                        "\t */",
                        "\tunsigned long baseclk = base->clk - 1;",
                        "",
                        "\twhile (!hlist_empty(head)) {",
                        "\t\tstruct timer_list *timer;",
                        "\t\tvoid (*fn)(struct timer_list *);",
                        "",
                        "\t\ttimer = hlist_entry(head->first, struct timer_list, entry);",
                        "",
                        "\t\tbase->running_timer = timer;",
                        "\t\tdetach_timer(timer, true);",
                        "",
                        "\t\tfn = timer->function;",
                        "",
                        "\t\tif (timer->flags & TIMER_IRQSAFE) {",
                        "\t\t\traw_spin_unlock(&base->lock);",
                        "\t\t\tcall_timer_fn(timer, fn, baseclk);",
                        "\t\t\tbase->running_timer = NULL;",
                        "\t\t\traw_spin_lock(&base->lock);",
                        "\t\t} else {",
                        "\t\t\traw_spin_unlock_irq(&base->lock);",
                        "\t\t\tcall_timer_fn(timer, fn, baseclk);",
                        "\t\t\tbase->running_timer = NULL;",
                        "\t\t\ttimer_sync_wait_running(base);",
                        "\t\t\traw_spin_lock_irq(&base->lock);",
                        "\t\t}",
                        "\t}",
                        "}"
                    ],
                    "start": 1435,
                    "highlight": 1462
                },
                {
                    "file": "kernel/time/timer.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/time/timer.c?id=f40ddce88593482919761f74910f42f4b84c004b#n1731",
                    "code": [
                        "/**",
                        " * __run_timers - run all expired timers (if any) on this CPU.",
                        " * @base: the timer vector to be processed.",
                        " */",
                        "static inline void __run_timers(struct timer_base *base)",
                        "{",
                        "\tstruct hlist_head heads[LVL_DEPTH];",
                        "\tint levels;",
                        "",
                        "\tif (time_before(jiffies, base->next_expiry))",
                        "\t\treturn;",
                        "",
                        "\ttimer_base_lock_expiry(base);",
                        "\traw_spin_lock_irq(&base->lock);",
                        "",
                        "\twhile (time_after_eq(jiffies, base->clk) &&",
                        "\t       time_after_eq(jiffies, base->next_expiry)) {",
                        "\t\tlevels = collect_expired_timers(base, heads);",
                        "\t\t/*",
                        "\t\t * The only possible reason for not finding any expired",
                        "\t\t * timer at this clk is that all matching timers have been",
                        "\t\t * dequeued.",
                        "\t\t */",
                        "\t\tWARN_ON_ONCE(!levels && !base->next_expiry_recalc);",
                        "\t\tbase->clk++;",
                        "\t\tbase->next_expiry = __next_timer_interrupt(base);",
                        "",
                        "\t\twhile (levels--)",
                        "\t\t\texpire_timers(base, heads + levels);",
                        "\t}",
                        "\traw_spin_unlock_irq(&base->lock);",
                        "\ttimer_base_unlock_expiry(base);",
                        "}"
                    ],
                    "start": 1703,
                    "highlight": 1731
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8116f385"
        },
        "41084": {
            "name": "__run_timers",
            "parent_idx": 41080,
            "source_line": [
                {
                    "file": "kernel/time/timer.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/time/timer.c?id=f40ddce88593482919761f74910f42f4b84c004b#n1712",
                    "code": [
                        "/**",
                        " * __run_timers - run all expired timers (if any) on this CPU.",
                        " * @base: the timer vector to be processed.",
                        " */",
                        "static inline void __run_timers(struct timer_base *base)",
                        "{",
                        "\tstruct hlist_head heads[LVL_DEPTH];",
                        "\tint levels;",
                        "",
                        "\tif (time_before(jiffies, base->next_expiry))",
                        "\t\treturn;",
                        "",
                        "\ttimer_base_lock_expiry(base);",
                        "\traw_spin_lock_irq(&base->lock);",
                        "",
                        "\twhile (time_after_eq(jiffies, base->clk) &&",
                        "\t       time_after_eq(jiffies, base->next_expiry)) {",
                        "\t\tlevels = collect_expired_timers(base, heads);",
                        "\t\t/*",
                        "\t\t * The only possible reason for not finding any expired",
                        "\t\t * timer at this clk is that all matching timers have been",
                        "\t\t * dequeued.",
                        "\t\t */",
                        "\t\tWARN_ON_ONCE(!levels && !base->next_expiry_recalc);",
                        "\t\tbase->clk++;",
                        "\t\tbase->next_expiry = __next_timer_interrupt(base);",
                        "",
                        "\t\twhile (levels--)",
                        "\t\t\texpire_timers(base, heads + levels);",
                        "\t}",
                        "\traw_spin_unlock_irq(&base->lock);",
                        "\ttimer_base_unlock_expiry(base);",
                        "}"
                    ],
                    "start": 1703,
                    "highlight": 1712
                },
                {
                    "file": "kernel/time/timer.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/time/timer.c?id=f40ddce88593482919761f74910f42f4b84c004b#n1744",
                    "code": [
                        "/*",
                        " * This function runs timers and the timer-tq in bottom half context.",
                        " */",
                        "static __latent_entropy void run_timer_softirq(struct softirq_action *h)",
                        "{",
                        "\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);",
                        "",
                        "\t__run_timers(base);",
                        "\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON))",
                        "\t\t__run_timers(this_cpu_ptr(&timer_bases[BASE_DEF]));",
                        "}"
                    ],
                    "start": 1737,
                    "highlight": 1744
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8116f466"
        },
        "41080": {
            "name": "run_timer_softirq(indirect)",
            "parent_idx": 41078,
            "source_line": [
                {
                    "file": "kernel/softirq.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/softirq.c?id=f40ddce88593482919761f74910f42f4b84c004b#n353",
                    "code": [
                        "asmlinkage __visible void __softirq_entry __do_softirq(void)",
                        "{",
                        "\tunsigned long end = jiffies + MAX_SOFTIRQ_TIME;",
                        "\tunsigned long old_flags = current->flags;",
                        "\tint max_restart = MAX_SOFTIRQ_RESTART;",
                        "\tstruct softirq_action *h;",
                        "\tbool in_hardirq;",
                        "\t__u32 pending;",
                        "\tint softirq_bit;",
                        "",
                        "\t/*",
                        "\t * Mask out PF_MEMALLOC as the current task context is borrowed for the",
                        "\t * softirq. A softirq handled, such as network RX, might set PF_MEMALLOC",
                        "\t * again if the socket is related to swapping.",
                        "\t */",
                        "\tcurrent->flags &= ~PF_MEMALLOC;",
                        "",
                        "\tpending = local_softirq_pending();",
                        "",
                        "\t__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);",
                        "\tin_hardirq = lockdep_softirq_start();",
                        "\taccount_softirq_enter(current);",
                        "",
                        "restart:",
                        "\t/* Reset the pending bitmask before enabling irqs */",
                        "\tset_softirq_pending(0);",
                        "",
                        "\tlocal_irq_enable();",
                        "",
                        "\th = softirq_vec;",
                        "",
                        "\twhile ((softirq_bit = ffs(pending))) {",
                        "\t\tunsigned int vec_nr;",
                        "\t\tint prev_count;",
                        "",
                        "\t\th += softirq_bit - 1;",
                        "",
                        "\t\tvec_nr = h - softirq_vec;",
                        "\t\tprev_count = preempt_count();",
                        "",
                        "\t\tkstat_incr_softirqs_this_cpu(vec_nr);",
                        "",
                        "\t\ttrace_softirq_entry(vec_nr);",
                        "\t\th->action(h);",
                        "\t\ttrace_softirq_exit(vec_nr);",
                        "\t\tif (unlikely(prev_count != preempt_count())) {",
                        "\t\t\tpr_err(\"huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\\n\",",
                        "\t\t\t       vec_nr, softirq_to_name[vec_nr], h->action,",
                        "\t\t\t       prev_count, preempt_count());",
                        "\t\t\tpreempt_count_set(prev_count);",
                        "\t\t}",
                        "\t\th++;",
                        "\t\tpending >>= softirq_bit;",
                        "\t}",
                        "",
                        "\tif (__this_cpu_read(ksoftirqd) == current)",
                        "\t\trcu_softirq_qs();",
                        "\tlocal_irq_disable();",
                        "",
                        "\tpending = local_softirq_pending();",
                        "\tif (pending) {",
                        "\t\tif (time_before(jiffies, end) && !need_resched() &&",
                        "\t\t    --max_restart)",
                        "\t\t\tgoto restart;",
                        "",
                        "\t\twakeup_softirqd();",
                        "\t}",
                        "",
                        "\taccount_softirq_exit(current);",
                        "\tlockdep_softirq_end(in_hardirq);",
                        "\t__local_bh_enable(SOFTIRQ_OFFSET);",
                        "\tWARN_ON_ONCE(in_interrupt());",
                        "\tcurrent_restore_flags(old_flags, PF_MEMALLOC);",
                        "}"
                    ],
                    "start": 300,
                    "highlight": 353
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82600124"
        },
        "41078": {
            "name": "1257_softirq_433",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "8147": {
            "name": "+0xe3",
            "parent_idx": 8146,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=f40ddce88593482919761f74910f42f4b84c004b#n4180",
                    "code": [
                        "/*",
                        " * kmem_cache_shrink discards empty slabs and promotes the slabs filled",
                        " * up most to the head of the partial lists. New allocations will then",
                        " * fill those up and thus they can be removed from the partial lists.",
                        " *",
                        " * The slabs with the least items are placed last. This results in them",
                        " * being allocated from last increasing the chance that the last objects",
                        " * are freed in them.",
                        " */",
                        "int __kmem_cache_shrink(struct kmem_cache *s)",
                        "{",
                        "\tint node;",
                        "\tint i;",
                        "\tstruct kmem_cache_node *n;",
                        "\tstruct page *page;",
                        "\tstruct page *t;",
                        "\tstruct list_head discard;",
                        "\tstruct list_head promote[SHRINK_PROMOTE_MAX];",
                        "\tunsigned long flags;",
                        "\tint ret = 0;",
                        "",
                        "\tflush_all(s);",
                        "\tfor_each_kmem_cache_node(s, node, n) {",
                        "\t\tINIT_LIST_HEAD(&discard);",
                        "\t\tfor (i = 0; i < SHRINK_PROMOTE_MAX; i++)",
                        "\t\t\tINIT_LIST_HEAD(promote + i);",
                        "",
                        "\t\tspin_lock_irqsave(&n->list_lock, flags);",
                        "",
                        "\t\t/*",
                        "\t\t * Build lists of slabs to discard or promote.",
                        "\t\t *",
                        "\t\t * Note that concurrent frees may occur while we hold the",
                        "\t\t * list_lock. page->inuse here is the upper limit.",
                        "\t\t */",
                        "\t\tlist_for_each_entry_safe(page, t, &n->partial, slab_list) {",
                        "\t\t\tint free = page->objects - page->inuse;",
                        "",
                        "\t\t\t/* Do not reread page->inuse */",
                        "\t\t\tbarrier();",
                        "",
                        "\t\t\t/* We do not keep full slabs on the list */",
                        "\t\t\tBUG_ON(free <= 0);",
                        "",
                        "\t\t\tif (free == page->objects) {",
                        "\t\t\t\tlist_move(&page->slab_list, &discard);",
                        "\t\t\t\tn->nr_partial--;",
                        "\t\t\t} else if (free <= SHRINK_PROMOTE_MAX)",
                        "\t\t\t\tlist_move(&page->slab_list, promote + free - 1);",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * Promote the slabs filled up most to the head of the",
                        "\t\t * partial list.",
                        "\t\t */",
                        "\t\tfor (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)",
                        "\t\t\tlist_splice(promote + i, &n->partial);",
                        "",
                        "\t\tspin_unlock_irqrestore(&n->list_lock, flags);",
                        "",
                        "\t\t/* Release empty slabs */",
                        "\t\tlist_for_each_entry_safe(page, t, &discard, slab_list)",
                        "\t\t\tdiscard_slab(s, page);",
                        "",
                        "\t\tif (slabs_node(s, node))",
                        "\t\t\tret = 1;",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 4145,
                    "highlight": 4180
                }
            ],
            "ins_idx": 386,
            "addr": "0xffffffff8130d453"
        },
        "8146": {
            "name": "kfree",
            "parent_idx": 7310,
            "source_line": [
                {
                    "file": "drivers/media/radio/si470x/radio-si470x-usb.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/media/radio/si470x/radio-si470x-usb.c?id=f40ddce88593482919761f74910f42f4b84c004b#n766",
                    "code": [
                        "/*",
                        " * si470x_usb_driver_probe - probe for the device",
                        " */",
                        "static int si470x_usb_driver_probe(struct usb_interface *intf,",
                        "\t\tconst struct usb_device_id *id)",
                        "{",
                        "\tstruct si470x_device *radio;",
                        "\tstruct usb_host_interface *iface_desc;",
                        "\tstruct usb_endpoint_descriptor *endpoint;",
                        "\tint i, int_end_size, retval;",
                        "\tunsigned char version_warning = 0;",
                        "",
                        "\t/* private data allocation and initialization */",
                        "\tradio = kzalloc(sizeof(struct si470x_device), GFP_KERNEL);",
                        "\tif (!radio) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_initial;",
                        "\t}",
                        "\tradio->usb_buf = kmalloc(MAX_REPORT_SIZE, GFP_KERNEL);",
                        "\tif (radio->usb_buf == NULL) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_radio;",
                        "\t}",
                        "\tradio->usbdev = interface_to_usbdev(intf);",
                        "\tradio->intf = intf;",
                        "\tradio->band = 1; /* Default to 76 - 108 MHz */",
                        "\tmutex_init(&radio->lock);",
                        "\tinit_completion(&radio->completion);",
                        "",
                        "\tradio->get_register = si470x_get_register;",
                        "\tradio->set_register = si470x_set_register;",
                        "\tradio->fops_open = si470x_fops_open;",
                        "\tradio->fops_release = si470x_fops_release;",
                        "\tradio->vidioc_querycap = si470x_vidioc_querycap;",
                        "",
                        "\tiface_desc = intf->cur_altsetting;",
                        "",
                        "\t/* Set up interrupt endpoint information. */",
                        "\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {",
                        "\t\tendpoint = &iface_desc->endpoint[i].desc;",
                        "\t\tif (usb_endpoint_is_int_in(endpoint))",
                        "\t\t\tradio->int_in_endpoint = endpoint;",
                        "\t}",
                        "\tif (!radio->int_in_endpoint) {",
                        "\t\tdev_info(&intf->dev, \"could not find interrupt in endpoint\\n\");",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_usbbuf;",
                        "\t}",
                        "",
                        "\tint_end_size = le16_to_cpu(radio->int_in_endpoint->wMaxPacketSize);",
                        "",
                        "\tradio->int_in_buffer = kmalloc(int_end_size, GFP_KERNEL);",
                        "\tif (!radio->int_in_buffer) {",
                        "\t\tdev_info(&intf->dev, \"could not allocate int_in_buffer\");",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_usbbuf;",
                        "\t}",
                        "",
                        "\tradio->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);",
                        "\tif (!radio->int_in_urb) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_intbuffer;",
                        "\t}",
                        "",
                        "\tradio->v4l2_dev.release = si470x_usb_release;",
                        "",
                        "\t/*",
                        "\t * The si470x SiLabs reference design uses the same USB IDs as",
                        "\t * 'Thanko's Raremono' si4734 based receiver. So check here which we",
                        "\t * have: attempt to read the device ID from the si470x: the lower 12",
                        "\t * bits should be 0x0242 for the si470x.",
                        "\t *",
                        "\t * We use this check to determine which device we are dealing with.",
                        "\t */",
                        "\tif (id->idVendor == 0x10c4 && id->idProduct == 0x818a) {",
                        "\t\tretval = usb_control_msg(radio->usbdev,",
                        "\t\t\t\tusb_rcvctrlpipe(radio->usbdev, 0),",
                        "\t\t\t\tHID_REQ_GET_REPORT,",
                        "\t\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,",
                        "\t\t\t\t1, 2,",
                        "\t\t\t\tradio->usb_buf, 3, 500);",
                        "\t\tif (retval != 3 ||",
                        "\t\t    (get_unaligned_be16(&radio->usb_buf[1]) & 0xfff) != 0x0242) {",
                        "\t\t\tdev_info(&intf->dev, \"this is not a si470x device.\\n\");",
                        "\t\t\tretval = -ENODEV;",
                        "\t\t\tgoto err_urb;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);",
                        "\tif (retval < 0) {",
                        "\t\tdev_err(&intf->dev, \"couldn't register v4l2_device\\n\");",
                        "\t\tgoto err_urb;",
                        "\t}",
                        "",
                        "\tv4l2_ctrl_handler_init(&radio->hdl, 2);",
                        "\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,",
                        "\t\t\t  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);",
                        "\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,",
                        "\t\t\t  V4L2_CID_AUDIO_VOLUME, 0, 15, 1, 15);",
                        "\tif (radio->hdl.error) {",
                        "\t\tretval = radio->hdl.error;",
                        "\t\tdev_err(&intf->dev, \"couldn't register control\\n\");",
                        "\t\tgoto err_dev;",
                        "\t}",
                        "\tradio->videodev = si470x_viddev_template;",
                        "\tradio->videodev.ctrl_handler = &radio->hdl;",
                        "\tradio->videodev.lock = &radio->lock;",
                        "\tradio->videodev.v4l2_dev = &radio->v4l2_dev;",
                        "\tradio->videodev.release = video_device_release_empty;",
                        "\tradio->videodev.device_caps =",
                        "\t\tV4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_READWRITE | V4L2_CAP_TUNER |",
                        "\t\tV4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE;",
                        "\tvideo_set_drvdata(&radio->videodev, radio);",
                        "",
                        "\t/* get device and chip versions */",
                        "\tif (si470x_get_all_registers(radio) < 0) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "\tdev_info(&intf->dev, \"DeviceID=0x%4.4hx ChipID=0x%4.4hx\\n\",",
                        "\t\t\tradio->registers[DEVICEID], radio->registers[SI_CHIPID]);",
                        "\tif ((radio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE) < RADIO_FW_VERSION) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"This driver is known to work with firmware version %hu,\\n\",",
                        "\t\t\tRADIO_FW_VERSION);",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"but the device has firmware version %hu.\\n\",",
                        "\t\t\tradio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE);",
                        "\t\tversion_warning = 1;",
                        "\t}",
                        "",
                        "\t/* get software and hardware versions */",
                        "\tif (si470x_get_scratch_page_versions(radio) < 0) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "\tdev_info(&intf->dev, \"software version %d, hardware version %d\\n\",",
                        "\t\t\tradio->software_version, radio->hardware_version);",
                        "\tif (radio->hardware_version < RADIO_HW_VERSION) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"This driver is known to work with hardware version %hu,\\n\",",
                        "\t\t\tRADIO_HW_VERSION);",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"but the device has hardware version %hu.\\n\",",
                        "\t\t\tradio->hardware_version);",
                        "\t\tversion_warning = 1;",
                        "\t}",
                        "",
                        "\t/* give out version warning */",
                        "\tif (version_warning == 1) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"If you have some trouble using this driver,\\n\");",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"please report to V4L ML at linux-media@vger.kernel.org\\n\");",
                        "\t}",
                        "",
                        "\t/* set led to connect state */",
                        "\tsi470x_set_led_state(radio, BLINK_GREEN_LED);",
                        "",
                        "\t/* rds buffer allocation */",
                        "\tradio->buf_size = rds_buf * 3;",
                        "\tradio->buffer = kmalloc(radio->buf_size, GFP_KERNEL);",
                        "\tif (!radio->buffer) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "",
                        "\t/* rds buffer configuration */",
                        "\tradio->wr_index = 0;",
                        "\tradio->rd_index = 0;",
                        "\tinit_waitqueue_head(&radio->read_queue);",
                        "\tusb_set_intfdata(intf, radio);",
                        "",
                        "\t/* start radio */",
                        "\tretval = si470x_start_usb(radio);",
                        "\tif (retval < 0)",
                        "\t\tgoto err_buf;",
                        "",
                        "\t/* set initial frequency */",
                        "\tsi470x_set_freq(radio, 87.5 * FREQ_MUL); /* available in all regions */",
                        "",
                        "\t/* register video device */",
                        "\tretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO,",
                        "\t\t\tradio_nr);",
                        "\tif (retval) {",
                        "\t\tdev_err(&intf->dev, \"Could not register video device\\n\");",
                        "\t\tgoto err_all;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "err_all:",
                        "\tusb_kill_urb(radio->int_in_urb);",
                        "err_buf:",
                        "\tkfree(radio->buffer);",
                        "err_ctrl:",
                        "\tv4l2_ctrl_handler_free(&radio->hdl);",
                        "err_dev:",
                        "\tv4l2_device_unregister(&radio->v4l2_dev);",
                        "err_urb:",
                        "\tusb_free_urb(radio->int_in_urb);",
                        "err_intbuffer:",
                        "\tkfree(radio->int_in_buffer);",
                        "err_usbbuf:",
                        "\tkfree(radio->usb_buf);",
                        "err_radio:",
                        "\tkfree(radio);",
                        "err_initial:",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 560,
                    "highlight": 766
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81da3a42"
        },
        "7310": {
            "name": "si470x_usb_driver_probe(indirect)",
            "parent_idx": 7279,
            "source_line": [
                {
                    "file": "drivers/usb/core/driver.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/driver.c?id=f40ddce88593482919761f74910f42f4b84c004b#n396",
                    "code": [
                        "/* called from driver core with dev locked */",
                        "static int usb_probe_interface(struct device *dev)",
                        "{",
                        "\tstruct usb_driver *driver = to_usb_driver(dev->driver);",
                        "\tstruct usb_interface *intf = to_usb_interface(dev);",
                        "\tstruct usb_device *udev = interface_to_usbdev(intf);",
                        "\tconst struct usb_device_id *id;",
                        "\tint error = -ENODEV;",
                        "\tint lpm_disable_error = -ENODEV;",
                        "",
                        "\tdev_dbg(dev, \"%s\\n\", __func__);",
                        "",
                        "\tintf->needs_binding = 0;",
                        "",
                        "\tif (usb_device_is_owned(udev))",
                        "\t\treturn error;",
                        "",
                        "\tif (udev->authorized == 0) {",
                        "\t\tdev_err(&intf->dev, \"Device is not authorized for usage\\n\");",
                        "\t\treturn error;",
                        "\t} else if (intf->authorized == 0) {",
                        "\t\tdev_err(&intf->dev, \"Interface %d is not authorized for usage\\n\",",
                        "\t\t\t\tintf->altsetting->desc.bInterfaceNumber);",
                        "\t\treturn error;",
                        "\t}",
                        "",
                        "\tid = usb_match_dynamic_id(intf, driver);",
                        "\tif (!id)",
                        "\t\tid = usb_match_id(intf, driver->id_table);",
                        "\tif (!id)",
                        "\t\treturn error;",
                        "",
                        "\tdev_dbg(dev, \"%s - got id\\n\", __func__);",
                        "",
                        "\terror = usb_autoresume_device(udev);",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "\tintf->condition = USB_INTERFACE_BINDING;",
                        "",
                        "\t/* Probed interfaces are initially active.  They are",
                        "\t * runtime-PM-enabled only if the driver has autosuspend support.",
                        "\t * They are sensitive to their children's power states.",
                        "\t */",
                        "\tpm_runtime_set_active(dev);",
                        "\tpm_suspend_ignore_children(dev, false);",
                        "\tif (driver->supports_autosuspend)",
                        "\t\tpm_runtime_enable(dev);",
                        "",
                        "\t/* If the new driver doesn't allow hub-initiated LPM, and we can't",
                        "\t * disable hub-initiated LPM, then fail the probe.",
                        "\t *",
                        "\t * Otherwise, leaving LPM enabled should be harmless, because the",
                        "\t * endpoint intervals should remain the same, and the U1/U2 timeouts",
                        "\t * should remain the same.",
                        "\t *",
                        "\t * If we need to install alt setting 0 before probe, or another alt",
                        "\t * setting during probe, that should also be fine.  usb_set_interface()",
                        "\t * will attempt to disable LPM, and fail if it can't disable it.",
                        "\t */",
                        "\tif (driver->disable_hub_initiated_lpm) {",
                        "\t\tlpm_disable_error = usb_unlocked_disable_lpm(udev);",
                        "\t\tif (lpm_disable_error) {",
                        "\t\t\tdev_err(&intf->dev, \"%s Failed to disable LPM for driver %s\\n\",",
                        "\t\t\t\t__func__, driver->name);",
                        "\t\t\terror = lpm_disable_error;",
                        "\t\t\tgoto err;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* Carry out a deferred switch to altsetting 0 */",
                        "\tif (intf->needs_altsetting0) {",
                        "\t\terror = usb_set_interface(udev, intf->altsetting[0].",
                        "\t\t\t\tdesc.bInterfaceNumber, 0);",
                        "\t\tif (error < 0)",
                        "\t\t\tgoto err;",
                        "\t\tintf->needs_altsetting0 = 0;",
                        "\t}",
                        "",
                        "\terror = driver->probe(intf, id);",
                        "\tif (error)",
                        "\t\tgoto err;",
                        "",
                        "\tintf->condition = USB_INTERFACE_BOUND;",
                        "",
                        "\t/* If the LPM disable succeeded, balance the ref counts. */",
                        "\tif (!lpm_disable_error)",
                        "\t\tusb_unlocked_enable_lpm(udev);",
                        "",
                        "\tusb_autosuspend_device(udev);",
                        "\treturn error;",
                        "",
                        " err:",
                        "\tusb_set_intfdata(intf, NULL);",
                        "\tintf->needs_remote_wakeup = 0;",
                        "\tintf->condition = USB_INTERFACE_UNBOUND;",
                        "",
                        "\t/* If the LPM disable succeeded, balance the ref counts. */",
                        "\tif (!lpm_disable_error)",
                        "\t\tusb_unlocked_enable_lpm(udev);",
                        "",
                        "\t/* Unbound interfaces are always runtime-PM-disabled and -suspended */",
                        "\tif (driver->supports_autosuspend)",
                        "\t\tpm_runtime_disable(dev);",
                        "\tpm_runtime_set_suspended(dev);",
                        "",
                        "\tusb_autosuspend_device(udev);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 317,
                    "highlight": 396
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81ca7929"
        },
        "7279": {
            "name": "usb_probe_interface(indirect)",
            "parent_idx": 7058,
            "source_line": [
                {
                    "file": "drivers/base/dd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/dd.c?id=f40ddce88593482919761f74910f42f4b84c004b#n554",
                    "code": [
                        "static int really_probe(struct device *dev, struct device_driver *drv)",
                        "{",
                        "\tint ret = -EPROBE_DEFER;",
                        "\tint local_trigger_count = atomic_read(&deferred_trigger_count);",
                        "\tbool test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &&",
                        "\t\t\t   !drv->suppress_bind_attrs;",
                        "",
                        "\tif (defer_all_probes) {",
                        "\t\t/*",
                        "\t\t * Value of defer_all_probes can be set only by",
                        "\t\t * device_block_probing() which, in turn, will call",
                        "\t\t * wait_for_device_probe() right after that to avoid any races.",
                        "\t\t */",
                        "\t\tdev_dbg(dev, \"Driver %s force probe deferral\\n\", drv->name);",
                        "\t\tdriver_deferred_probe_add(dev);",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\tret = device_links_check_suppliers(dev);",
                        "\tif (ret == -EPROBE_DEFER)",
                        "\t\tdriver_deferred_probe_add_trigger(dev, local_trigger_count);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\tatomic_inc(&probe_count);",
                        "\tpr_debug(\"bus: '%s': %s: probing driver %s with device %s\\n\",",
                        "\t\t drv->bus->name, __func__, drv->name, dev_name(dev));",
                        "\tif (!list_empty(&dev->devres_head)) {",
                        "\t\tdev_crit(dev, \"Resources present before probing\\n\");",
                        "\t\tret = -EBUSY;",
                        "\t\tgoto done;",
                        "\t}",
                        "",
                        "re_probe:",
                        "\tdev->driver = drv;",
                        "",
                        "\t/* If using pinctrl, bind pins now before probing */",
                        "\tret = pinctrl_bind_pins(dev);",
                        "\tif (ret)",
                        "\t\tgoto pinctrl_bind_failed;",
                        "",
                        "\tif (dev->bus->dma_configure) {",
                        "\t\tret = dev->bus->dma_configure(dev);",
                        "\t\tif (ret)",
                        "\t\t\tgoto probe_failed;",
                        "\t}",
                        "",
                        "\tif (driver_sysfs_add(dev)) {",
                        "\t\tpr_err(\"%s: driver_sysfs_add(%s) failed\\n\",",
                        "\t\t       __func__, dev_name(dev));",
                        "\t\tgoto probe_failed;",
                        "\t}",
                        "",
                        "\tif (dev->pm_domain && dev->pm_domain->activate) {",
                        "\t\tret = dev->pm_domain->activate(dev);",
                        "\t\tif (ret)",
                        "\t\t\tgoto probe_failed;",
                        "\t}",
                        "",
                        "\tif (dev->bus->probe) {",
                        "\t\tret = dev->bus->probe(dev);",
                        "\t\tif (ret)",
                        "\t\t\tgoto probe_failed;",
                        "\t} else if (drv->probe) {",
                        "\t\tret = drv->probe(dev);",
                        "\t\tif (ret)",
                        "\t\t\tgoto probe_failed;",
                        "\t}",
                        "",
                        "\tif (device_add_groups(dev, drv->dev_groups)) {",
                        "\t\tdev_err(dev, \"device_add_groups() failed\\n\");",
                        "\t\tgoto dev_groups_failed;",
                        "\t}",
                        "",
                        "\tif (dev_has_sync_state(dev) &&",
                        "\t    device_create_file(dev, &dev_attr_state_synced)) {",
                        "\t\tdev_err(dev, \"state_synced sysfs add failed\\n\");",
                        "\t\tgoto dev_sysfs_state_synced_failed;",
                        "\t}",
                        "",
                        "\tif (test_remove) {",
                        "\t\ttest_remove = false;",
                        "",
                        "\t\tdevice_remove_file(dev, &dev_attr_state_synced);",
                        "\t\tdevice_remove_groups(dev, drv->dev_groups);",
                        "",
                        "\t\tif (dev->bus->remove)",
                        "\t\t\tdev->bus->remove(dev);",
                        "\t\telse if (drv->remove)",
                        "\t\t\tdrv->remove(dev);",
                        "",
                        "\t\tdevres_release_all(dev);",
                        "\t\tdriver_sysfs_remove(dev);",
                        "\t\tdev->driver = NULL;",
                        "\t\tdev_set_drvdata(dev, NULL);",
                        "\t\tif (dev->pm_domain && dev->pm_domain->dismiss)",
                        "\t\t\tdev->pm_domain->dismiss(dev);",
                        "\t\tpm_runtime_reinit(dev);",
                        "",
                        "\t\tgoto re_probe;",
                        "\t}",
                        "",
                        "\tpinctrl_init_done(dev);",
                        "",
                        "\tif (dev->pm_domain && dev->pm_domain->sync)",
                        "\t\tdev->pm_domain->sync(dev);",
                        "",
                        "\tdriver_bound(dev);",
                        "\tret = 1;",
                        "\tpr_debug(\"bus: '%s': %s: bound device %s to driver %s\\n\",",
                        "\t\t drv->bus->name, __func__, dev_name(dev), drv->name);",
                        "\tgoto done;",
                        "",
                        "dev_sysfs_state_synced_failed:",
                        "\tdevice_remove_groups(dev, drv->dev_groups);",
                        "dev_groups_failed:",
                        "\tif (dev->bus->remove)",
                        "\t\tdev->bus->remove(dev);",
                        "\telse if (drv->remove)",
                        "\t\tdrv->remove(dev);",
                        "probe_failed:",
                        "\tkfree(dev->dma_range_map);",
                        "\tdev->dma_range_map = NULL;",
                        "\tif (dev->bus)",
                        "\t\tblocking_notifier_call_chain(&dev->bus->p->bus_notifier,",
                        "\t\t\t\t\t     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);",
                        "pinctrl_bind_failed:",
                        "\tdevice_links_no_driver(dev);",
                        "\tdevres_release_all(dev);",
                        "\tarch_teardown_dma_ops(dev);",
                        "\tdriver_sysfs_remove(dev);",
                        "\tdev->driver = NULL;",
                        "\tdev_set_drvdata(dev, NULL);",
                        "\tif (dev->pm_domain && dev->pm_domain->dismiss)",
                        "\t\tdev->pm_domain->dismiss(dev);",
                        "\tpm_runtime_reinit(dev);",
                        "\tdev_pm_set_driver_flags(dev, 0);",
                        "",
                        "\tswitch (ret) {",
                        "\tcase -EPROBE_DEFER:",
                        "\t\t/* Driver requested deferred probing */",
                        "\t\tdev_dbg(dev, \"Driver %s requests probe deferral\\n\", drv->name);",
                        "\t\tdriver_deferred_probe_add_trigger(dev, local_trigger_count);",
                        "\t\tbreak;",
                        "\tcase -ENODEV:",
                        "\tcase -ENXIO:",
                        "\t\tpr_debug(\"%s: probe of %s rejects match %d\\n\",",
                        "\t\t\t drv->name, dev_name(dev), ret);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\t/* driver matched but the probe failed */",
                        "\t\tpr_warn(\"%s: probe of %s failed with error %d\\n\",",
                        "\t\t\tdrv->name, dev_name(dev), ret);",
                        "\t}",
                        "\t/*",
                        "\t * Ignore errors returned by ->probe so that the next driver can try",
                        "\t * its luck.",
                        "\t */",
                        "\tret = 0;",
                        "done:",
                        "\tatomic_dec(&probe_count);",
                        "\twake_up_all(&probe_waitqueue);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 494,
                    "highlight": 554
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b04b9c"
        },
        "7058": {
            "name": "really_probe",
            "parent_idx": 6984,
            "source_line": [
                {
                    "file": "drivers/base/dd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/dd.c?id=f40ddce88593482919761f74910f42f4b84c004b#n740",
                    "code": [
                        "/**",
                        " * driver_probe_device - attempt to bind device & driver together",
                        " * @drv: driver to bind a device to",
                        " * @dev: device to try to bind to the driver",
                        " *",
                        " * This function returns -ENODEV if the device is not registered,",
                        " * 1 if the device is bound successfully and 0 otherwise.",
                        " *",
                        " * This function must be called with @dev lock held.  When called for a",
                        " * USB interface, @dev->parent lock must be held as well.",
                        " *",
                        " * If the device has a parent, runtime-resume the parent before driver probing.",
                        " */",
                        "static int driver_probe_device(struct device_driver *drv, struct device *dev)",
                        "{",
                        "\tint ret = 0;",
                        "",
                        "\tif (!device_is_registered(dev))",
                        "\t\treturn -ENODEV;",
                        "",
                        "\tpr_debug(\"bus: '%s': %s: matched device %s with driver %s\\n\",",
                        "\t\t drv->bus->name, __func__, dev_name(dev), drv->name);",
                        "",
                        "\tpm_runtime_get_suppliers(dev);",
                        "\tif (dev->parent)",
                        "\t\tpm_runtime_get_sync(dev->parent);",
                        "",
                        "\tpm_runtime_barrier(dev);",
                        "\tif (initcall_debug)",
                        "\t\tret = really_probe_debug(dev, drv);",
                        "\telse",
                        "\t\tret = really_probe(dev, drv);",
                        "\tpm_request_idle(dev);",
                        "",
                        "\tif (dev->parent)",
                        "\t\tpm_runtime_put(dev->parent);",
                        "",
                        "\tpm_runtime_put_suppliers(dev);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 709,
                    "highlight": 740
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b050f8"
        },
        "6984": {
            "name": "__device_attach_driver(indirect)",
            "parent_idx": 6770,
            "source_line": [
                {
                    "file": "drivers/base/bus.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/bus.c?id=f40ddce88593482919761f74910f42f4b84c004b#n431",
                    "code": [
                        "/**",
                        " * bus_for_each_drv - driver iterator",
                        " * @bus: bus we're dealing with.",
                        " * @start: driver to start iterating on.",
                        " * @data: data to pass to the callback.",
                        " * @fn: function to call for each driver.",
                        " *",
                        " * This is nearly identical to the device iterator above.",
                        " * We iterate over each driver that belongs to @bus, and call",
                        " * @fn for each. If @fn returns anything but 0, we break out",
                        " * and return it. If @start is not NULL, we use it as the head",
                        " * of the list.",
                        " *",
                        " * NOTE: we don't return the driver that returns a non-zero",
                        " * value, nor do we leave the reference count incremented for that",
                        " * driver. If the caller needs to know that info, it must set it",
                        " * in the callback. It must also be sure to increment the refcount",
                        " * so it doesn't disappear before returning to the caller.",
                        " */",
                        "int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,",
                        "\t\t     void *data, int (*fn)(struct device_driver *, void *))",
                        "{",
                        "\tstruct klist_iter i;",
                        "\tstruct device_driver *drv;",
                        "\tint error = 0;",
                        "",
                        "\tif (!bus)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tklist_iter_init_node(&bus->p->klist_drivers, &i,",
                        "\t\t\t     start ? &start->p->knode_bus : NULL);",
                        "\twhile ((drv = next_driver(&i)) && !error)",
                        "\t\terror = fn(drv, data);",
                        "\tklist_iter_exit(&i);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 399,
                    "highlight": 431
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b018b2"
        },
        "6770": {
            "name": "bus_for_each_drv",
            "parent_idx": 6752,
            "source_line": [
                {
                    "file": "drivers/base/dd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/dd.c?id=f40ddce88593482919761f74910f42f4b84c004b#n914",
                    "code": [
                        "static int __device_attach(struct device *dev, bool allow_async)",
                        "{",
                        "\tint ret = 0;",
                        "",
                        "\tdevice_lock(dev);",
                        "\tif (dev->p->dead) {",
                        "\t\tgoto out_unlock;",
                        "\t} else if (dev->driver) {",
                        "\t\tif (device_is_bound(dev)) {",
                        "\t\t\tret = 1;",
                        "\t\t\tgoto out_unlock;",
                        "\t\t}",
                        "\t\tret = device_bind_driver(dev);",
                        "\t\tif (ret == 0)",
                        "\t\t\tret = 1;",
                        "\t\telse {",
                        "\t\t\tdev->driver = NULL;",
                        "\t\t\tret = 0;",
                        "\t\t}",
                        "\t} else {",
                        "\t\tstruct device_attach_data data = {",
                        "\t\t\t.dev = dev,",
                        "\t\t\t.check_async = allow_async,",
                        "\t\t\t.want_async = false,",
                        "\t\t};",
                        "",
                        "\t\tif (dev->parent)",
                        "\t\t\tpm_runtime_get_sync(dev->parent);",
                        "",
                        "\t\tret = bus_for_each_drv(dev->bus, NULL, &data,",
                        "\t\t\t\t\t__device_attach_driver);",
                        "\t\tif (!ret && allow_async && data.have_async) {",
                        "\t\t\t/*",
                        "\t\t\t * If we could not find appropriate driver",
                        "\t\t\t * synchronously and we are allowed to do",
                        "\t\t\t * async probes and there are drivers that",
                        "\t\t\t * want to probe asynchronously, we'll",
                        "\t\t\t * try them.",
                        "\t\t\t */",
                        "\t\t\tdev_dbg(dev, \"scheduling asynchronous probe\\n\");",
                        "\t\t\tget_device(dev);",
                        "\t\t\tasync_schedule_dev(__device_attach_async_helper, dev);",
                        "\t\t} else {",
                        "\t\t\tpm_request_idle(dev);",
                        "\t\t}",
                        "",
                        "\t\tif (dev->parent)",
                        "\t\t\tpm_runtime_put(dev->parent);",
                        "\t}",
                        "out_unlock:",
                        "\tdevice_unlock(dev);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 885,
                    "highlight": 914
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b053ea"
        },
        "6752": {
            "name": "device_initial_probe",
            "parent_idx": 6749,
            "source_line": [
                {
                    "file": "drivers/base/bus.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/bus.c?id=f40ddce88593482919761f74910f42f4b84c004b#n491",
                    "code": [
                        "/**",
                        " * bus_probe_device - probe drivers for a new device",
                        " * @dev: device to probe",
                        " *",
                        " * - Automatically probe for a driver if the bus allows it.",
                        " */",
                        "void bus_probe_device(struct device *dev)",
                        "{",
                        "\tstruct bus_type *bus = dev->bus;",
                        "\tstruct subsys_interface *sif;",
                        "",
                        "\tif (!bus)",
                        "\t\treturn;",
                        "",
                        "\tif (bus->p->drivers_autoprobe)",
                        "\t\tdevice_initial_probe(dev);",
                        "",
                        "\tmutex_lock(&bus->p->mutex);",
                        "\tlist_for_each_entry(sif, &bus->p->interfaces, node)",
                        "\t\tif (sif->add_dev)",
                        "\t\t\tsif->add_dev(dev, sif);",
                        "\tmutex_unlock(&bus->p->mutex);",
                        "}"
                    ],
                    "start": 476,
                    "highlight": 491
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b03573"
        },
        "6749": {
            "name": "bus_probe_device",
            "parent_idx": 5763,
            "source_line": [
                {
                    "file": "drivers/base/core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/core.c?id=f40ddce88593482919761f74910f42f4b84c004b#n3109",
                    "code": [
                        "/**",
                        " * device_add - add device to device hierarchy.",
                        " * @dev: device.",
                        " *",
                        " * This is part 2 of device_register(), though may be called",
                        " * separately _iff_ device_initialize() has been called separately.",
                        " *",
                        " * This adds @dev to the kobject hierarchy via kobject_add(), adds it",
                        " * to the global and sibling lists for the device, then",
                        " * adds it to the other relevant subsystems of the driver model.",
                        " *",
                        " * Do not call this routine or device_register() more than once for",
                        " * any device structure.  The driver model core is not designed to work",
                        " * with devices that get unregistered and then spring back to life.",
                        " * (Among other things, it's very hard to guarantee that all references",
                        " * to the previous incarnation of @dev have been dropped.)  Allocate",
                        " * and register a fresh new struct device instead.",
                        " *",
                        " * NOTE: _Never_ directly free @dev after calling this function, even",
                        " * if it returned an error! Always use put_device() to give up your",
                        " * reference instead.",
                        " *",
                        " * Rule of thumb is: if device_add() succeeds, you should call",
                        " * device_del() when you want to get rid of it. If device_add() has",
                        " * *not* succeeded, use *only* put_device() to drop the reference",
                        " * count.",
                        " */",
                        "int device_add(struct device *dev)",
                        "{",
                        "\tstruct device *parent;",
                        "\tstruct kobject *kobj;",
                        "\tstruct class_interface *class_intf;",
                        "\tint error = -EINVAL;",
                        "\tstruct kobject *glue_dir = NULL;",
                        "",
                        "\tdev = get_device(dev);",
                        "\tif (!dev)",
                        "\t\tgoto done;",
                        "",
                        "\tif (!dev->p) {",
                        "\t\terror = device_private_init(dev);",
                        "\t\tif (error)",
                        "\t\t\tgoto done;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * for statically allocated devices, which should all be converted",
                        "\t * some day, we need to initialize the name. We prevent reading back",
                        "\t * the name, and force the use of dev_name()",
                        "\t */",
                        "\tif (dev->init_name) {",
                        "\t\tdev_set_name(dev, \"%s\", dev->init_name);",
                        "\t\tdev->init_name = NULL;",
                        "\t}",
                        "",
                        "\t/* subsystems can specify simple device enumeration */",
                        "\tif (!dev_name(dev) && dev->bus && dev->bus->dev_name)",
                        "\t\tdev_set_name(dev, \"%s%u\", dev->bus->dev_name, dev->id);",
                        "",
                        "\tif (!dev_name(dev)) {",
                        "\t\terror = -EINVAL;",
                        "\t\tgoto name_error;",
                        "\t}",
                        "",
                        "\tpr_debug(\"device: '%s': %s\\n\", dev_name(dev), __func__);",
                        "",
                        "\tparent = get_device(dev->parent);",
                        "\tkobj = get_device_parent(dev, parent);",
                        "\tif (IS_ERR(kobj)) {",
                        "\t\terror = PTR_ERR(kobj);",
                        "\t\tgoto parent_error;",
                        "\t}",
                        "\tif (kobj)",
                        "\t\tdev->kobj.parent = kobj;",
                        "",
                        "\t/* use parent numa_node */",
                        "\tif (parent && (dev_to_node(dev) == NUMA_NO_NODE))",
                        "\t\tset_dev_node(dev, dev_to_node(parent));",
                        "",
                        "\t/* first, register with generic layer. */",
                        "\t/* we require the name to be set before, and pass NULL */",
                        "\terror = kobject_add(&dev->kobj, dev->kobj.parent, NULL);",
                        "\tif (error) {",
                        "\t\tglue_dir = get_glue_dir(dev);",
                        "\t\tgoto Error;",
                        "\t}",
                        "",
                        "\t/* notify platform of device entry */",
                        "\terror = device_platform_notify(dev, KOBJ_ADD);",
                        "\tif (error)",
                        "\t\tgoto platform_error;",
                        "",
                        "\terror = device_create_file(dev, &dev_attr_uevent);",
                        "\tif (error)",
                        "\t\tgoto attrError;",
                        "",
                        "\terror = device_add_class_symlinks(dev);",
                        "\tif (error)",
                        "\t\tgoto SymlinkError;",
                        "\terror = device_add_attrs(dev);",
                        "\tif (error)",
                        "\t\tgoto AttrsError;",
                        "\terror = bus_add_device(dev);",
                        "\tif (error)",
                        "\t\tgoto BusError;",
                        "\terror = dpm_sysfs_add(dev);",
                        "\tif (error)",
                        "\t\tgoto DPMError;",
                        "\tdevice_pm_add(dev);",
                        "",
                        "\tif (MAJOR(dev->devt)) {",
                        "\t\terror = device_create_file(dev, &dev_attr_dev);",
                        "\t\tif (error)",
                        "\t\t\tgoto DevAttrError;",
                        "",
                        "\t\terror = device_create_sys_dev_entry(dev);",
                        "\t\tif (error)",
                        "\t\t\tgoto SysEntryError;",
                        "",
                        "\t\tdevtmpfs_create_node(dev);",
                        "\t}",
                        "",
                        "\t/* Notify clients of device addition.  This call must come",
                        "\t * after dpm_sysfs_add() and before kobject_uevent().",
                        "\t */",
                        "\tif (dev->bus)",
                        "\t\tblocking_notifier_call_chain(&dev->bus->p->bus_notifier,",
                        "\t\t\t\t\t     BUS_NOTIFY_ADD_DEVICE, dev);",
                        "",
                        "\tkobject_uevent(&dev->kobj, KOBJ_ADD);",
                        "",
                        "\t/*",
                        "\t * Check if any of the other devices (consumers) have been waiting for",
                        "\t * this device (supplier) to be added so that they can create a device",
                        "\t * link to it.",
                        "\t *",
                        "\t * This needs to happen after device_pm_add() because device_link_add()",
                        "\t * requires the supplier be registered before it's called.",
                        "\t *",
                        "\t * But this also needs to happen before bus_probe_device() to make sure",
                        "\t * waiting consumers can link to it before the driver is bound to the",
                        "\t * device and the driver sync_state callback is called for this device.",
                        "\t */",
                        "\tif (dev->fwnode && !dev->fwnode->dev) {",
                        "\t\tdev->fwnode->dev = dev;",
                        "\t\tfw_devlink_link_device(dev);",
                        "\t}",
                        "",
                        "\tbus_probe_device(dev);",
                        "\tif (parent)",
                        "\t\tklist_add_tail(&dev->p->knode_parent,",
                        "\t\t\t       &parent->p->klist_children);",
                        "",
                        "\tif (dev->class) {",
                        "\t\tmutex_lock(&dev->class->p->mutex);",
                        "\t\t/* tie the class to the device */",
                        "\t\tklist_add_tail(&dev->p->knode_class,",
                        "\t\t\t       &dev->class->p->klist_devices);",
                        "",
                        "\t\t/* notify any interfaces that the device is here */",
                        "\t\tlist_for_each_entry(class_intf,",
                        "\t\t\t\t    &dev->class->p->interfaces, node)",
                        "\t\t\tif (class_intf->add_dev)",
                        "\t\t\t\tclass_intf->add_dev(dev, class_intf);",
                        "\t\tmutex_unlock(&dev->class->p->mutex);",
                        "\t}",
                        "done:",
                        "\tput_device(dev);",
                        "\treturn error;",
                        " SysEntryError:",
                        "\tif (MAJOR(dev->devt))",
                        "\t\tdevice_remove_file(dev, &dev_attr_dev);",
                        " DevAttrError:",
                        "\tdevice_pm_remove(dev);",
                        "\tdpm_sysfs_remove(dev);",
                        " DPMError:",
                        "\tbus_remove_device(dev);",
                        " BusError:",
                        "\tdevice_remove_attrs(dev);",
                        " AttrsError:",
                        "\tdevice_remove_class_symlinks(dev);",
                        " SymlinkError:",
                        "\tdevice_remove_file(dev, &dev_attr_uevent);",
                        " attrError:",
                        "\tdevice_platform_notify(dev, KOBJ_REMOVE);",
                        "platform_error:",
                        "\tkobject_uevent(&dev->kobj, KOBJ_REMOVE);",
                        "\tglue_dir = get_glue_dir(dev);",
                        "\tkobject_del(&dev->kobj);",
                        " Error:",
                        "\tcleanup_glue_dir(dev, glue_dir);",
                        "parent_error:",
                        "\tput_device(parent);",
                        "name_error:",
                        "\tkfree(dev->p);",
                        "\tdev->p = NULL;",
                        "\tgoto done;",
                        "}"
                    ],
                    "start": 2961,
                    "highlight": 3109
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81aff6f6"
        },
        "5763": {
            "name": "device_add",
            "parent_idx": 5599,
            "source_line": [
                {
                    "file": "drivers/usb/core/message.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/message.c?id=f40ddce88593482919761f74910f42f4b84c004b#n2164",
                    "code": [
                        "/*",
                        " * usb_set_configuration - Makes a particular device setting be current",
                        " * @dev: the device whose configuration is being updated",
                        " * @configuration: the configuration being chosen.",
                        " *",
                        " * Context: task context, might sleep. Caller holds device lock.",
                        " *",
                        " * This is used to enable non-default device modes.  Not all devices",
                        " * use this kind of configurability; many devices only have one",
                        " * configuration.",
                        " *",
                        " * @configuration is the value of the configuration to be installed.",
                        " * According to the USB spec (e.g. section 9.1.1.5), configuration values",
                        " * must be non-zero; a value of zero indicates that the device in",
                        " * unconfigured.  However some devices erroneously use 0 as one of their",
                        " * configuration values.  To help manage such devices, this routine will",
                        " * accept @configuration = -1 as indicating the device should be put in",
                        " * an unconfigured state.",
                        " *",
                        " * USB device configurations may affect Linux interoperability,",
                        " * power consumption and the functionality available.  For example,",
                        " * the default configuration is limited to using 100mA of bus power,",
                        " * so that when certain device functionality requires more power,",
                        " * and the device is bus powered, that functionality should be in some",
                        " * non-default device configuration.  Other device modes may also be",
                        " * reflected as configuration options, such as whether two ISDN",
                        " * channels are available independently; and choosing between open",
                        " * standard device protocols (like CDC) or proprietary ones.",
                        " *",
                        " * Note that a non-authorized device (dev->authorized == 0) will only",
                        " * be put in unconfigured mode.",
                        " *",
                        " * Note that USB has an additional level of device configurability,",
                        " * associated with interfaces.  That configurability is accessed using",
                        " * usb_set_interface().",
                        " *",
                        " * This call is synchronous. The calling context must be able to sleep,",
                        " * must own the device lock, and must not hold the driver model's USB",
                        " * bus mutex; usb interface driver probe() methods cannot use this routine.",
                        " *",
                        " * Returns zero on success, or else the status code returned by the",
                        " * underlying call that failed.  On successful completion, each interface",
                        " * in the original device configuration has been destroyed, and each one",
                        " * in the new configuration has been probed by all relevant usb device",
                        " * drivers currently known to the kernel.",
                        " */",
                        "int usb_set_configuration(struct usb_device *dev, int configuration)",
                        "{",
                        "\tint i, ret;",
                        "\tstruct usb_host_config *cp = NULL;",
                        "\tstruct usb_interface **new_interfaces = NULL;",
                        "\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);",
                        "\tint n, nintf;",
                        "",
                        "\tif (dev->authorized == 0 || configuration == -1)",
                        "\t\tconfiguration = 0;",
                        "\telse {",
                        "\t\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++) {",
                        "\t\t\tif (dev->config[i].desc.bConfigurationValue ==",
                        "\t\t\t\t\tconfiguration) {",
                        "\t\t\t\tcp = &dev->config[i];",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "\tif ((!cp && configuration != 0))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\t/* The USB spec says configuration 0 means unconfigured.",
                        "\t * But if a device includes a configuration numbered 0,",
                        "\t * we will accept it as a correctly configured state.",
                        "\t * Use -1 if you really want to unconfigure the device.",
                        "\t */",
                        "\tif (cp && configuration == 0)",
                        "\t\tdev_warn(&dev->dev, \"config 0 descriptor??\\n\");",
                        "",
                        "\t/* Allocate memory for new interfaces before doing anything else,",
                        "\t * so that if we run out then nothing will have changed. */",
                        "\tn = nintf = 0;",
                        "\tif (cp) {",
                        "\t\tnintf = cp->desc.bNumInterfaces;",
                        "\t\tnew_interfaces = kmalloc_array(nintf, sizeof(*new_interfaces),",
                        "\t\t\t\t\t       GFP_NOIO);",
                        "\t\tif (!new_interfaces)",
                        "\t\t\treturn -ENOMEM;",
                        "",
                        "\t\tfor (; n < nintf; ++n) {",
                        "\t\t\tnew_interfaces[n] = kzalloc(",
                        "\t\t\t\t\tsizeof(struct usb_interface),",
                        "\t\t\t\t\tGFP_NOIO);",
                        "\t\t\tif (!new_interfaces[n]) {",
                        "\t\t\t\tret = -ENOMEM;",
                        "free_interfaces:",
                        "\t\t\t\twhile (--n >= 0)",
                        "\t\t\t\t\tkfree(new_interfaces[n]);",
                        "\t\t\t\tkfree(new_interfaces);",
                        "\t\t\t\treturn ret;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\ti = dev->bus_mA - usb_get_max_power(dev, cp);",
                        "\t\tif (i < 0)",
                        "\t\t\tdev_warn(&dev->dev, \"new config #%d exceeds power \"",
                        "\t\t\t\t\t\"limit by %dmA\\n\",",
                        "\t\t\t\t\tconfiguration, -i);",
                        "\t}",
                        "",
                        "\t/* Wake up the device so we can send it the Set-Config request */",
                        "\tret = usb_autoresume_device(dev);",
                        "\tif (ret)",
                        "\t\tgoto free_interfaces;",
                        "",
                        "\t/* if it's already configured, clear out old state first.",
                        "\t * getting rid of old interfaces means unbinding their drivers.",
                        "\t */",
                        "\tif (dev->state != USB_STATE_ADDRESS)",
                        "\t\tusb_disable_device(dev, 1);\t/* Skip ep0 */",
                        "",
                        "\t/* Get rid of pending async Set-Config requests for this device */",
                        "\tcancel_async_set_config(dev);",
                        "",
                        "\t/* Make sure we have bandwidth (and available HCD resources) for this",
                        "\t * configuration.  Remove endpoints from the schedule if we're dropping",
                        "\t * this configuration to set configuration 0.  After this point, the",
                        "\t * host controller will not allow submissions to dropped endpoints.  If",
                        "\t * this call fails, the device state is unchanged.",
                        "\t */",
                        "\tmutex_lock(hcd->bandwidth_mutex);",
                        "\t/* Disable LPM, and re-enable it once the new configuration is",
                        "\t * installed, so that the xHCI driver can recalculate the U1/U2",
                        "\t * timeouts.",
                        "\t */",
                        "\tif (dev->actconfig && usb_disable_lpm(dev)) {",
                        "\t\tdev_err(&dev->dev, \"%s Failed to disable LPM\\n\", __func__);",
                        "\t\tmutex_unlock(hcd->bandwidth_mutex);",
                        "\t\tret = -ENOMEM;",
                        "\t\tgoto free_interfaces;",
                        "\t}",
                        "\tret = usb_hcd_alloc_bandwidth(dev, cp, NULL, NULL);",
                        "\tif (ret < 0) {",
                        "\t\tif (dev->actconfig)",
                        "\t\t\tusb_enable_lpm(dev);",
                        "\t\tmutex_unlock(hcd->bandwidth_mutex);",
                        "\t\tusb_autosuspend_device(dev);",
                        "\t\tgoto free_interfaces;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Initialize the new interface structures and the",
                        "\t * hc/hcd/usbcore interface/endpoint state.",
                        "\t */",
                        "\tfor (i = 0; i < nintf; ++i) {",
                        "\t\tstruct usb_interface_cache *intfc;",
                        "\t\tstruct usb_interface *intf;",
                        "\t\tstruct usb_host_interface *alt;",
                        "\t\tu8 ifnum;",
                        "",
                        "\t\tcp->interface[i] = intf = new_interfaces[i];",
                        "\t\tintfc = cp->intf_cache[i];",
                        "\t\tintf->altsetting = intfc->altsetting;",
                        "\t\tintf->num_altsetting = intfc->num_altsetting;",
                        "\t\tintf->authorized = !!HCD_INTF_AUTHORIZED(hcd);",
                        "\t\tkref_get(&intfc->ref);",
                        "",
                        "\t\talt = usb_altnum_to_altsetting(intf, 0);",
                        "",
                        "\t\t/* No altsetting 0?  We'll assume the first altsetting.",
                        "\t\t * We could use a GetInterface call, but if a device is",
                        "\t\t * so non-compliant that it doesn't have altsetting 0",
                        "\t\t * then I wouldn't trust its reply anyway.",
                        "\t\t */",
                        "\t\tif (!alt)",
                        "\t\t\talt = &intf->altsetting[0];",
                        "",
                        "\t\tifnum = alt->desc.bInterfaceNumber;",
                        "\t\tintf->intf_assoc = find_iad(dev, cp, ifnum);",
                        "\t\tintf->cur_altsetting = alt;",
                        "\t\tusb_enable_interface(dev, intf, true);",
                        "\t\tintf->dev.parent = &dev->dev;",
                        "\t\tif (usb_of_has_combined_node(dev)) {",
                        "\t\t\tdevice_set_of_node_from_dev(&intf->dev, &dev->dev);",
                        "\t\t} else {",
                        "\t\t\tintf->dev.of_node = usb_of_get_interface_node(dev,",
                        "\t\t\t\t\tconfiguration, ifnum);",
                        "\t\t}",
                        "\t\tACPI_COMPANION_SET(&intf->dev, ACPI_COMPANION(&dev->dev));",
                        "\t\tintf->dev.driver = NULL;",
                        "\t\tintf->dev.bus = &usb_bus_type;",
                        "\t\tintf->dev.type = &usb_if_device_type;",
                        "\t\tintf->dev.groups = usb_interface_groups;",
                        "\t\tINIT_WORK(&intf->reset_ws, __usb_queue_reset_device);",
                        "\t\tintf->minor = -1;",
                        "\t\tdevice_initialize(&intf->dev);",
                        "\t\tpm_runtime_no_callbacks(&intf->dev);",
                        "\t\tdev_set_name(&intf->dev, \"%d-%s:%d.%d\", dev->bus->busnum,",
                        "\t\t\t\tdev->devpath, configuration, ifnum);",
                        "\t\tusb_get_dev(dev);",
                        "\t}",
                        "\tkfree(new_interfaces);",
                        "",
                        "\tret = usb_control_msg_send(dev, 0, USB_REQ_SET_CONFIGURATION, 0,",
                        "\t\t\t\t   configuration, 0, NULL, 0,",
                        "\t\t\t\t   USB_CTRL_SET_TIMEOUT, GFP_NOIO);",
                        "\tif (ret && cp) {",
                        "\t\t/*",
                        "\t\t * All the old state is gone, so what else can we do?",
                        "\t\t * The device is probably useless now anyway.",
                        "\t\t */",
                        "\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);",
                        "\t\tfor (i = 0; i < nintf; ++i) {",
                        "\t\t\tusb_disable_interface(dev, cp->interface[i], true);",
                        "\t\t\tput_device(&cp->interface[i]->dev);",
                        "\t\t\tcp->interface[i] = NULL;",
                        "\t\t}",
                        "\t\tcp = NULL;",
                        "\t}",
                        "",
                        "\tdev->actconfig = cp;",
                        "\tmutex_unlock(hcd->bandwidth_mutex);",
                        "",
                        "\tif (!cp) {",
                        "\t\tusb_set_device_state(dev, USB_STATE_ADDRESS);",
                        "",
                        "\t\t/* Leave LPM disabled while the device is unconfigured. */",
                        "\t\tusb_autosuspend_device(dev);",
                        "\t\treturn ret;",
                        "\t}",
                        "\tusb_set_device_state(dev, USB_STATE_CONFIGURED);",
                        "",
                        "\tif (cp->string == NULL &&",
                        "\t\t\t!(dev->quirks & USB_QUIRK_CONFIG_INTF_STRINGS))",
                        "\t\tcp->string = usb_cache_string(dev, cp->desc.iConfiguration);",
                        "",
                        "\t/* Now that the interfaces are installed, re-enable LPM. */",
                        "\tusb_unlocked_enable_lpm(dev);",
                        "\t/* Enable LTM if it was turned off by usb_disable_device. */",
                        "\tusb_enable_ltm(dev);",
                        "",
                        "\t/* Now that all the interfaces are set up, register them",
                        "\t * to trigger binding of drivers to interfaces.  probe()",
                        "\t * routines may install different altsettings and may",
                        "\t * claim() any interfaces not yet bound.  Many class drivers",
                        "\t * need that: CDC, audio, video, etc.",
                        "\t */",
                        "\tfor (i = 0; i < nintf; ++i) {",
                        "\t\tstruct usb_interface *intf = cp->interface[i];",
                        "",
                        "\t\tif (intf->dev.of_node &&",
                        "\t\t    !of_device_is_available(intf->dev.of_node)) {",
                        "\t\t\tdev_info(&dev->dev, \"skipping disabled interface %d\\n\",",
                        "\t\t\t\t intf->cur_altsetting->desc.bInterfaceNumber);",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "",
                        "\t\tdev_dbg(&dev->dev,",
                        "\t\t\t\"adding %s (config #%d, interface %d)\\n\",",
                        "\t\t\tdev_name(&intf->dev), configuration,",
                        "\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);",
                        "\t\tdevice_enable_async_suspend(&intf->dev);",
                        "\t\tret = device_add(&intf->dev);",
                        "\t\tif (ret != 0) {",
                        "\t\t\tdev_err(&dev->dev, \"device_add(%s) --> %d\\n\",",
                        "\t\t\t\tdev_name(&intf->dev), ret);",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "\t\tcreate_intf_ep_devs(intf);",
                        "\t}",
                        "",
                        "\tusb_autosuspend_device(dev);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1905,
                    "highlight": 2164
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81ca4cb6"
        },
        "5599": {
            "name": "usb_set_configuration",
            "parent_idx": 5586,
            "source_line": [
                {
                    "file": "drivers/usb/core/generic.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/generic.c?id=f40ddce88593482919761f74910f42f4b84c004b#n238",
                    "code": [
                        "int usb_generic_driver_probe(struct usb_device *udev)",
                        "{",
                        "\tint err, c;",
                        "",
                        "\t/* Choose and set the configuration.  This registers the interfaces",
                        "\t * with the driver core and lets interface drivers bind to them.",
                        "\t */",
                        "\tif (udev->authorized == 0)",
                        "\t\tdev_err(&udev->dev, \"Device is not authorized for usage\\n\");",
                        "\telse {",
                        "\t\tc = usb_choose_configuration(udev);",
                        "\t\tif (c >= 0) {",
                        "\t\t\terr = usb_set_configuration(udev, c);",
                        "\t\t\tif (err && err != -ENODEV) {",
                        "\t\t\t\tdev_err(&udev->dev, \"can't set config #%d, error %d\\n\",",
                        "\t\t\t\t\tc, err);",
                        "\t\t\t\t/* This need not be fatal.  The user can try to",
                        "\t\t\t\t * set other configurations. */",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "\t/* USB device state == configured ... usable */",
                        "\tusb_notify_add_device(udev);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 226,
                    "highlight": 238
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81cb4d61"
        },
        "5586": {
            "name": "usb_generic_driver_probe(indirect)",
            "parent_idx": 5582,
            "source_line": [
                {
                    "file": "drivers/usb/core/driver.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/driver.c?id=f40ddce88593482919761f74910f42f4b84c004b#n293",
                    "code": [
                        "/* called from driver core with dev locked */",
                        "static int usb_probe_device(struct device *dev)",
                        "{",
                        "\tstruct usb_device_driver *udriver = to_usb_device_driver(dev->driver);",
                        "\tstruct usb_device *udev = to_usb_device(dev);",
                        "\tint error = 0;",
                        "",
                        "\tdev_dbg(dev, \"%s\\n\", __func__);",
                        "",
                        "\t/* TODO: Add real matching code */",
                        "",
                        "\t/* The device should always appear to be in use",
                        "\t * unless the driver supports autosuspend.",
                        "\t */",
                        "\tif (!udriver->supports_autosuspend)",
                        "\t\terror = usb_autoresume_device(udev);",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "\tif (udriver->generic_subclass)",
                        "\t\terror = usb_generic_driver_probe(udev);",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "\t/* Probe the USB device with the driver in hand, but only",
                        "\t * defer to a generic driver in case the current USB",
                        "\t * device driver has an id_table or a match function; i.e.,",
                        "\t * when the device driver was explicitly matched against",
                        "\t * a device.",
                        "\t *",
                        "\t * If the device driver does not have either of these,",
                        "\t * then we assume that it can bind to any device and is",
                        "\t * not truly a more specialized/non-generic driver, so a",
                        "\t * return value of -ENODEV should not force the device",
                        "\t * to be handled by the generic USB driver, as there",
                        "\t * can still be another, more specialized, device driver.",
                        "\t *",
                        "\t * This accommodates the usbip driver.",
                        "\t *",
                        "\t * TODO: What if, in the future, there are multiple",
                        "\t * specialized USB device drivers for a particular device?",
                        "\t * In such cases, there is a need to try all matching",
                        "\t * specialised device drivers prior to setting the",
                        "\t * use_generic_driver bit.",
                        "\t */",
                        "\terror = udriver->probe(udev);",
                        "\tif (error == -ENODEV && udriver != &usb_generic_driver &&",
                        "\t    (udriver->id_table || udriver->match)) {",
                        "\t\tudev->use_generic_driver = 1;",
                        "\t\treturn -EPROBE_DEFER;",
                        "\t}",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 248,
                    "highlight": 293
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81ca7261"
        },
        "5582": {
            "name": "usb_probe_device(indirect)",
            "parent_idx": 5569,
            "source_line": [
                {
                    "file": "drivers/base/dd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/dd.c?id=f40ddce88593482919761f74910f42f4b84c004b#n554",
                    "code": [
                        "static int really_probe(struct device *dev, struct device_driver *drv)",
                        "{",
                        "\tint ret = -EPROBE_DEFER;",
                        "\tint local_trigger_count = atomic_read(&deferred_trigger_count);",
                        "\tbool test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &&",
                        "\t\t\t   !drv->suppress_bind_attrs;",
                        "",
                        "\tif (defer_all_probes) {",
                        "\t\t/*",
                        "\t\t * Value of defer_all_probes can be set only by",
                        "\t\t * device_block_probing() which, in turn, will call",
                        "\t\t * wait_for_device_probe() right after that to avoid any races.",
                        "\t\t */",
                        "\t\tdev_dbg(dev, \"Driver %s force probe deferral\\n\", drv->name);",
                        "\t\tdriver_deferred_probe_add(dev);",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\tret = device_links_check_suppliers(dev);",
                        "\tif (ret == -EPROBE_DEFER)",
                        "\t\tdriver_deferred_probe_add_trigger(dev, local_trigger_count);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\tatomic_inc(&probe_count);",
                        "\tpr_debug(\"bus: '%s': %s: probing driver %s with device %s\\n\",",
                        "\t\t drv->bus->name, __func__, drv->name, dev_name(dev));",
                        "\tif (!list_empty(&dev->devres_head)) {",
                        "\t\tdev_crit(dev, \"Resources present before probing\\n\");",
                        "\t\tret = -EBUSY;",
                        "\t\tgoto done;",
                        "\t}",
                        "",
                        "re_probe:",
                        "\tdev->driver = drv;",
                        "",
                        "\t/* If using pinctrl, bind pins now before probing */",
                        "\tret = pinctrl_bind_pins(dev);",
                        "\tif (ret)",
                        "\t\tgoto pinctrl_bind_failed;",
                        "",
                        "\tif (dev->bus->dma_configure) {",
                        "\t\tret = dev->bus->dma_configure(dev);",
                        "\t\tif (ret)",
                        "\t\t\tgoto probe_failed;",
                        "\t}",
                        "",
                        "\tif (driver_sysfs_add(dev)) {",
                        "\t\tpr_err(\"%s: driver_sysfs_add(%s) failed\\n\",",
                        "\t\t       __func__, dev_name(dev));",
                        "\t\tgoto probe_failed;",
                        "\t}",
                        "",
                        "\tif (dev->pm_domain && dev->pm_domain->activate) {",
                        "\t\tret = dev->pm_domain->activate(dev);",
                        "\t\tif (ret)",
                        "\t\t\tgoto probe_failed;",
                        "\t}",
                        "",
                        "\tif (dev->bus->probe) {",
                        "\t\tret = dev->bus->probe(dev);",
                        "\t\tif (ret)",
                        "\t\t\tgoto probe_failed;",
                        "\t} else if (drv->probe) {",
                        "\t\tret = drv->probe(dev);",
                        "\t\tif (ret)",
                        "\t\t\tgoto probe_failed;",
                        "\t}",
                        "",
                        "\tif (device_add_groups(dev, drv->dev_groups)) {",
                        "\t\tdev_err(dev, \"device_add_groups() failed\\n\");",
                        "\t\tgoto dev_groups_failed;",
                        "\t}",
                        "",
                        "\tif (dev_has_sync_state(dev) &&",
                        "\t    device_create_file(dev, &dev_attr_state_synced)) {",
                        "\t\tdev_err(dev, \"state_synced sysfs add failed\\n\");",
                        "\t\tgoto dev_sysfs_state_synced_failed;",
                        "\t}",
                        "",
                        "\tif (test_remove) {",
                        "\t\ttest_remove = false;",
                        "",
                        "\t\tdevice_remove_file(dev, &dev_attr_state_synced);",
                        "\t\tdevice_remove_groups(dev, drv->dev_groups);",
                        "",
                        "\t\tif (dev->bus->remove)",
                        "\t\t\tdev->bus->remove(dev);",
                        "\t\telse if (drv->remove)",
                        "\t\t\tdrv->remove(dev);",
                        "",
                        "\t\tdevres_release_all(dev);",
                        "\t\tdriver_sysfs_remove(dev);",
                        "\t\tdev->driver = NULL;",
                        "\t\tdev_set_drvdata(dev, NULL);",
                        "\t\tif (dev->pm_domain && dev->pm_domain->dismiss)",
                        "\t\t\tdev->pm_domain->dismiss(dev);",
                        "\t\tpm_runtime_reinit(dev);",
                        "",
                        "\t\tgoto re_probe;",
                        "\t}",
                        "",
                        "\tpinctrl_init_done(dev);",
                        "",
                        "\tif (dev->pm_domain && dev->pm_domain->sync)",
                        "\t\tdev->pm_domain->sync(dev);",
                        "",
                        "\tdriver_bound(dev);",
                        "\tret = 1;",
                        "\tpr_debug(\"bus: '%s': %s: bound device %s to driver %s\\n\",",
                        "\t\t drv->bus->name, __func__, dev_name(dev), drv->name);",
                        "\tgoto done;",
                        "",
                        "dev_sysfs_state_synced_failed:",
                        "\tdevice_remove_groups(dev, drv->dev_groups);",
                        "dev_groups_failed:",
                        "\tif (dev->bus->remove)",
                        "\t\tdev->bus->remove(dev);",
                        "\telse if (drv->remove)",
                        "\t\tdrv->remove(dev);",
                        "probe_failed:",
                        "\tkfree(dev->dma_range_map);",
                        "\tdev->dma_range_map = NULL;",
                        "\tif (dev->bus)",
                        "\t\tblocking_notifier_call_chain(&dev->bus->p->bus_notifier,",
                        "\t\t\t\t\t     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);",
                        "pinctrl_bind_failed:",
                        "\tdevice_links_no_driver(dev);",
                        "\tdevres_release_all(dev);",
                        "\tarch_teardown_dma_ops(dev);",
                        "\tdriver_sysfs_remove(dev);",
                        "\tdev->driver = NULL;",
                        "\tdev_set_drvdata(dev, NULL);",
                        "\tif (dev->pm_domain && dev->pm_domain->dismiss)",
                        "\t\tdev->pm_domain->dismiss(dev);",
                        "\tpm_runtime_reinit(dev);",
                        "\tdev_pm_set_driver_flags(dev, 0);",
                        "",
                        "\tswitch (ret) {",
                        "\tcase -EPROBE_DEFER:",
                        "\t\t/* Driver requested deferred probing */",
                        "\t\tdev_dbg(dev, \"Driver %s requests probe deferral\\n\", drv->name);",
                        "\t\tdriver_deferred_probe_add_trigger(dev, local_trigger_count);",
                        "\t\tbreak;",
                        "\tcase -ENODEV:",
                        "\tcase -ENXIO:",
                        "\t\tpr_debug(\"%s: probe of %s rejects match %d\\n\",",
                        "\t\t\t drv->name, dev_name(dev), ret);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\t/* driver matched but the probe failed */",
                        "\t\tpr_warn(\"%s: probe of %s failed with error %d\\n\",",
                        "\t\t\tdrv->name, dev_name(dev), ret);",
                        "\t}",
                        "\t/*",
                        "\t * Ignore errors returned by ->probe so that the next driver can try",
                        "\t * its luck.",
                        "\t */",
                        "\tret = 0;",
                        "done:",
                        "\tatomic_dec(&probe_count);",
                        "\twake_up_all(&probe_waitqueue);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 494,
                    "highlight": 554
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b04b9c"
        },
        "5569": {
            "name": "really_probe",
            "parent_idx": 5532,
            "source_line": [
                {
                    "file": "drivers/base/dd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/dd.c?id=f40ddce88593482919761f74910f42f4b84c004b#n740",
                    "code": [
                        "/**",
                        " * driver_probe_device - attempt to bind device & driver together",
                        " * @drv: driver to bind a device to",
                        " * @dev: device to try to bind to the driver",
                        " *",
                        " * This function returns -ENODEV if the device is not registered,",
                        " * 1 if the device is bound successfully and 0 otherwise.",
                        " *",
                        " * This function must be called with @dev lock held.  When called for a",
                        " * USB interface, @dev->parent lock must be held as well.",
                        " *",
                        " * If the device has a parent, runtime-resume the parent before driver probing.",
                        " */",
                        "static int driver_probe_device(struct device_driver *drv, struct device *dev)",
                        "{",
                        "\tint ret = 0;",
                        "",
                        "\tif (!device_is_registered(dev))",
                        "\t\treturn -ENODEV;",
                        "",
                        "\tpr_debug(\"bus: '%s': %s: matched device %s with driver %s\\n\",",
                        "\t\t drv->bus->name, __func__, dev_name(dev), drv->name);",
                        "",
                        "\tpm_runtime_get_suppliers(dev);",
                        "\tif (dev->parent)",
                        "\t\tpm_runtime_get_sync(dev->parent);",
                        "",
                        "\tpm_runtime_barrier(dev);",
                        "\tif (initcall_debug)",
                        "\t\tret = really_probe_debug(dev, drv);",
                        "\telse",
                        "\t\tret = really_probe(dev, drv);",
                        "\tpm_request_idle(dev);",
                        "",
                        "\tif (dev->parent)",
                        "\t\tpm_runtime_put(dev->parent);",
                        "",
                        "\tpm_runtime_put_suppliers(dev);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 709,
                    "highlight": 740
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b050f8"
        },
        "5532": {
            "name": "__device_attach_driver(indirect)",
            "parent_idx": 5499,
            "source_line": [
                {
                    "file": "drivers/base/bus.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/bus.c?id=f40ddce88593482919761f74910f42f4b84c004b#n431",
                    "code": [
                        "/**",
                        " * bus_for_each_drv - driver iterator",
                        " * @bus: bus we're dealing with.",
                        " * @start: driver to start iterating on.",
                        " * @data: data to pass to the callback.",
                        " * @fn: function to call for each driver.",
                        " *",
                        " * This is nearly identical to the device iterator above.",
                        " * We iterate over each driver that belongs to @bus, and call",
                        " * @fn for each. If @fn returns anything but 0, we break out",
                        " * and return it. If @start is not NULL, we use it as the head",
                        " * of the list.",
                        " *",
                        " * NOTE: we don't return the driver that returns a non-zero",
                        " * value, nor do we leave the reference count incremented for that",
                        " * driver. If the caller needs to know that info, it must set it",
                        " * in the callback. It must also be sure to increment the refcount",
                        " * so it doesn't disappear before returning to the caller.",
                        " */",
                        "int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,",
                        "\t\t     void *data, int (*fn)(struct device_driver *, void *))",
                        "{",
                        "\tstruct klist_iter i;",
                        "\tstruct device_driver *drv;",
                        "\tint error = 0;",
                        "",
                        "\tif (!bus)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tklist_iter_init_node(&bus->p->klist_drivers, &i,",
                        "\t\t\t     start ? &start->p->knode_bus : NULL);",
                        "\twhile ((drv = next_driver(&i)) && !error)",
                        "\t\terror = fn(drv, data);",
                        "\tklist_iter_exit(&i);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 399,
                    "highlight": 431
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b018b2"
        },
        "5499": {
            "name": "bus_for_each_drv",
            "parent_idx": 5488,
            "source_line": [
                {
                    "file": "drivers/base/dd.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/dd.c?id=f40ddce88593482919761f74910f42f4b84c004b#n914",
                    "code": [
                        "static int __device_attach(struct device *dev, bool allow_async)",
                        "{",
                        "\tint ret = 0;",
                        "",
                        "\tdevice_lock(dev);",
                        "\tif (dev->p->dead) {",
                        "\t\tgoto out_unlock;",
                        "\t} else if (dev->driver) {",
                        "\t\tif (device_is_bound(dev)) {",
                        "\t\t\tret = 1;",
                        "\t\t\tgoto out_unlock;",
                        "\t\t}",
                        "\t\tret = device_bind_driver(dev);",
                        "\t\tif (ret == 0)",
                        "\t\t\tret = 1;",
                        "\t\telse {",
                        "\t\t\tdev->driver = NULL;",
                        "\t\t\tret = 0;",
                        "\t\t}",
                        "\t} else {",
                        "\t\tstruct device_attach_data data = {",
                        "\t\t\t.dev = dev,",
                        "\t\t\t.check_async = allow_async,",
                        "\t\t\t.want_async = false,",
                        "\t\t};",
                        "",
                        "\t\tif (dev->parent)",
                        "\t\t\tpm_runtime_get_sync(dev->parent);",
                        "",
                        "\t\tret = bus_for_each_drv(dev->bus, NULL, &data,",
                        "\t\t\t\t\t__device_attach_driver);",
                        "\t\tif (!ret && allow_async && data.have_async) {",
                        "\t\t\t/*",
                        "\t\t\t * If we could not find appropriate driver",
                        "\t\t\t * synchronously and we are allowed to do",
                        "\t\t\t * async probes and there are drivers that",
                        "\t\t\t * want to probe asynchronously, we'll",
                        "\t\t\t * try them.",
                        "\t\t\t */",
                        "\t\t\tdev_dbg(dev, \"scheduling asynchronous probe\\n\");",
                        "\t\t\tget_device(dev);",
                        "\t\t\tasync_schedule_dev(__device_attach_async_helper, dev);",
                        "\t\t} else {",
                        "\t\t\tpm_request_idle(dev);",
                        "\t\t}",
                        "",
                        "\t\tif (dev->parent)",
                        "\t\t\tpm_runtime_put(dev->parent);",
                        "\t}",
                        "out_unlock:",
                        "\tdevice_unlock(dev);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 885,
                    "highlight": 914
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b053ea"
        },
        "5488": {
            "name": "device_initial_probe",
            "parent_idx": 5485,
            "source_line": [
                {
                    "file": "drivers/base/bus.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/bus.c?id=f40ddce88593482919761f74910f42f4b84c004b#n491",
                    "code": [
                        "/**",
                        " * bus_probe_device - probe drivers for a new device",
                        " * @dev: device to probe",
                        " *",
                        " * - Automatically probe for a driver if the bus allows it.",
                        " */",
                        "void bus_probe_device(struct device *dev)",
                        "{",
                        "\tstruct bus_type *bus = dev->bus;",
                        "\tstruct subsys_interface *sif;",
                        "",
                        "\tif (!bus)",
                        "\t\treturn;",
                        "",
                        "\tif (bus->p->drivers_autoprobe)",
                        "\t\tdevice_initial_probe(dev);",
                        "",
                        "\tmutex_lock(&bus->p->mutex);",
                        "\tlist_for_each_entry(sif, &bus->p->interfaces, node)",
                        "\t\tif (sif->add_dev)",
                        "\t\t\tsif->add_dev(dev, sif);",
                        "\tmutex_unlock(&bus->p->mutex);",
                        "}"
                    ],
                    "start": 476,
                    "highlight": 491
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b03573"
        },
        "5485": {
            "name": "bus_probe_device",
            "parent_idx": 4867,
            "source_line": [
                {
                    "file": "drivers/base/core.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/core.c?id=f40ddce88593482919761f74910f42f4b84c004b#n3109",
                    "code": [
                        "/**",
                        " * device_add - add device to device hierarchy.",
                        " * @dev: device.",
                        " *",
                        " * This is part 2 of device_register(), though may be called",
                        " * separately _iff_ device_initialize() has been called separately.",
                        " *",
                        " * This adds @dev to the kobject hierarchy via kobject_add(), adds it",
                        " * to the global and sibling lists for the device, then",
                        " * adds it to the other relevant subsystems of the driver model.",
                        " *",
                        " * Do not call this routine or device_register() more than once for",
                        " * any device structure.  The driver model core is not designed to work",
                        " * with devices that get unregistered and then spring back to life.",
                        " * (Among other things, it's very hard to guarantee that all references",
                        " * to the previous incarnation of @dev have been dropped.)  Allocate",
                        " * and register a fresh new struct device instead.",
                        " *",
                        " * NOTE: _Never_ directly free @dev after calling this function, even",
                        " * if it returned an error! Always use put_device() to give up your",
                        " * reference instead.",
                        " *",
                        " * Rule of thumb is: if device_add() succeeds, you should call",
                        " * device_del() when you want to get rid of it. If device_add() has",
                        " * *not* succeeded, use *only* put_device() to drop the reference",
                        " * count.",
                        " */",
                        "int device_add(struct device *dev)",
                        "{",
                        "\tstruct device *parent;",
                        "\tstruct kobject *kobj;",
                        "\tstruct class_interface *class_intf;",
                        "\tint error = -EINVAL;",
                        "\tstruct kobject *glue_dir = NULL;",
                        "",
                        "\tdev = get_device(dev);",
                        "\tif (!dev)",
                        "\t\tgoto done;",
                        "",
                        "\tif (!dev->p) {",
                        "\t\terror = device_private_init(dev);",
                        "\t\tif (error)",
                        "\t\t\tgoto done;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * for statically allocated devices, which should all be converted",
                        "\t * some day, we need to initialize the name. We prevent reading back",
                        "\t * the name, and force the use of dev_name()",
                        "\t */",
                        "\tif (dev->init_name) {",
                        "\t\tdev_set_name(dev, \"%s\", dev->init_name);",
                        "\t\tdev->init_name = NULL;",
                        "\t}",
                        "",
                        "\t/* subsystems can specify simple device enumeration */",
                        "\tif (!dev_name(dev) && dev->bus && dev->bus->dev_name)",
                        "\t\tdev_set_name(dev, \"%s%u\", dev->bus->dev_name, dev->id);",
                        "",
                        "\tif (!dev_name(dev)) {",
                        "\t\terror = -EINVAL;",
                        "\t\tgoto name_error;",
                        "\t}",
                        "",
                        "\tpr_debug(\"device: '%s': %s\\n\", dev_name(dev), __func__);",
                        "",
                        "\tparent = get_device(dev->parent);",
                        "\tkobj = get_device_parent(dev, parent);",
                        "\tif (IS_ERR(kobj)) {",
                        "\t\terror = PTR_ERR(kobj);",
                        "\t\tgoto parent_error;",
                        "\t}",
                        "\tif (kobj)",
                        "\t\tdev->kobj.parent = kobj;",
                        "",
                        "\t/* use parent numa_node */",
                        "\tif (parent && (dev_to_node(dev) == NUMA_NO_NODE))",
                        "\t\tset_dev_node(dev, dev_to_node(parent));",
                        "",
                        "\t/* first, register with generic layer. */",
                        "\t/* we require the name to be set before, and pass NULL */",
                        "\terror = kobject_add(&dev->kobj, dev->kobj.parent, NULL);",
                        "\tif (error) {",
                        "\t\tglue_dir = get_glue_dir(dev);",
                        "\t\tgoto Error;",
                        "\t}",
                        "",
                        "\t/* notify platform of device entry */",
                        "\terror = device_platform_notify(dev, KOBJ_ADD);",
                        "\tif (error)",
                        "\t\tgoto platform_error;",
                        "",
                        "\terror = device_create_file(dev, &dev_attr_uevent);",
                        "\tif (error)",
                        "\t\tgoto attrError;",
                        "",
                        "\terror = device_add_class_symlinks(dev);",
                        "\tif (error)",
                        "\t\tgoto SymlinkError;",
                        "\terror = device_add_attrs(dev);",
                        "\tif (error)",
                        "\t\tgoto AttrsError;",
                        "\terror = bus_add_device(dev);",
                        "\tif (error)",
                        "\t\tgoto BusError;",
                        "\terror = dpm_sysfs_add(dev);",
                        "\tif (error)",
                        "\t\tgoto DPMError;",
                        "\tdevice_pm_add(dev);",
                        "",
                        "\tif (MAJOR(dev->devt)) {",
                        "\t\terror = device_create_file(dev, &dev_attr_dev);",
                        "\t\tif (error)",
                        "\t\t\tgoto DevAttrError;",
                        "",
                        "\t\terror = device_create_sys_dev_entry(dev);",
                        "\t\tif (error)",
                        "\t\t\tgoto SysEntryError;",
                        "",
                        "\t\tdevtmpfs_create_node(dev);",
                        "\t}",
                        "",
                        "\t/* Notify clients of device addition.  This call must come",
                        "\t * after dpm_sysfs_add() and before kobject_uevent().",
                        "\t */",
                        "\tif (dev->bus)",
                        "\t\tblocking_notifier_call_chain(&dev->bus->p->bus_notifier,",
                        "\t\t\t\t\t     BUS_NOTIFY_ADD_DEVICE, dev);",
                        "",
                        "\tkobject_uevent(&dev->kobj, KOBJ_ADD);",
                        "",
                        "\t/*",
                        "\t * Check if any of the other devices (consumers) have been waiting for",
                        "\t * this device (supplier) to be added so that they can create a device",
                        "\t * link to it.",
                        "\t *",
                        "\t * This needs to happen after device_pm_add() because device_link_add()",
                        "\t * requires the supplier be registered before it's called.",
                        "\t *",
                        "\t * But this also needs to happen before bus_probe_device() to make sure",
                        "\t * waiting consumers can link to it before the driver is bound to the",
                        "\t * device and the driver sync_state callback is called for this device.",
                        "\t */",
                        "\tif (dev->fwnode && !dev->fwnode->dev) {",
                        "\t\tdev->fwnode->dev = dev;",
                        "\t\tfw_devlink_link_device(dev);",
                        "\t}",
                        "",
                        "\tbus_probe_device(dev);",
                        "\tif (parent)",
                        "\t\tklist_add_tail(&dev->p->knode_parent,",
                        "\t\t\t       &parent->p->klist_children);",
                        "",
                        "\tif (dev->class) {",
                        "\t\tmutex_lock(&dev->class->p->mutex);",
                        "\t\t/* tie the class to the device */",
                        "\t\tklist_add_tail(&dev->p->knode_class,",
                        "\t\t\t       &dev->class->p->klist_devices);",
                        "",
                        "\t\t/* notify any interfaces that the device is here */",
                        "\t\tlist_for_each_entry(class_intf,",
                        "\t\t\t\t    &dev->class->p->interfaces, node)",
                        "\t\t\tif (class_intf->add_dev)",
                        "\t\t\t\tclass_intf->add_dev(dev, class_intf);",
                        "\t\tmutex_unlock(&dev->class->p->mutex);",
                        "\t}",
                        "done:",
                        "\tput_device(dev);",
                        "\treturn error;",
                        " SysEntryError:",
                        "\tif (MAJOR(dev->devt))",
                        "\t\tdevice_remove_file(dev, &dev_attr_dev);",
                        " DevAttrError:",
                        "\tdevice_pm_remove(dev);",
                        "\tdpm_sysfs_remove(dev);",
                        " DPMError:",
                        "\tbus_remove_device(dev);",
                        " BusError:",
                        "\tdevice_remove_attrs(dev);",
                        " AttrsError:",
                        "\tdevice_remove_class_symlinks(dev);",
                        " SymlinkError:",
                        "\tdevice_remove_file(dev, &dev_attr_uevent);",
                        " attrError:",
                        "\tdevice_platform_notify(dev, KOBJ_REMOVE);",
                        "platform_error:",
                        "\tkobject_uevent(&dev->kobj, KOBJ_REMOVE);",
                        "\tglue_dir = get_glue_dir(dev);",
                        "\tkobject_del(&dev->kobj);",
                        " Error:",
                        "\tcleanup_glue_dir(dev, glue_dir);",
                        "parent_error:",
                        "\tput_device(parent);",
                        "name_error:",
                        "\tkfree(dev->p);",
                        "\tdev->p = NULL;",
                        "\tgoto done;",
                        "}"
                    ],
                    "start": 2961,
                    "highlight": 3109
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81aff6f6"
        },
        "4867": {
            "name": "device_add",
            "parent_idx": 4465,
            "source_line": [
                {
                    "file": "drivers/usb/core/hub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=f40ddce88593482919761f74910f42f4b84c004b#n2555",
                    "code": [
                        "/**",
                        " * usb_new_device - perform initial device setup (usbcore-internal)",
                        " * @udev: newly addressed device (in ADDRESS state)",
                        " *",
                        " * This is called with devices which have been detected but not fully",
                        " * enumerated.  The device descriptor is available, but not descriptors",
                        " * for any device configuration.  The caller must have locked either",
                        " * the parent hub (if udev is a normal device) or else the",
                        " * usb_bus_idr_lock (if udev is a root hub).  The parent's pointer to",
                        " * udev has already been installed, but udev is not yet visible through",
                        " * sysfs or other filesystem code.",
                        " *",
                        " * This call is synchronous, and may not be used in an interrupt context.",
                        " *",
                        " * Only the hub driver or root-hub registrar should ever call this.",
                        " *",
                        " * Return: Whether the device is configured properly or not. Zero if the",
                        " * interface was registered with the driver core; else a negative errno",
                        " * value.",
                        " *",
                        " */",
                        "int usb_new_device(struct usb_device *udev)",
                        "{",
                        "\tint err;",
                        "",
                        "\tif (udev->parent) {",
                        "\t\t/* Initialize non-root-hub device wakeup to disabled;",
                        "\t\t * device (un)configuration controls wakeup capable",
                        "\t\t * sysfs power/wakeup controls wakeup enabled/disabled",
                        "\t\t */",
                        "\t\tdevice_init_wakeup(&udev->dev, 0);",
                        "\t}",
                        "",
                        "\t/* Tell the runtime-PM framework the device is active */",
                        "\tpm_runtime_set_active(&udev->dev);",
                        "\tpm_runtime_get_noresume(&udev->dev);",
                        "\tpm_runtime_use_autosuspend(&udev->dev);",
                        "\tpm_runtime_enable(&udev->dev);",
                        "",
                        "\t/* By default, forbid autosuspend for all devices.  It will be",
                        "\t * allowed for hubs during binding.",
                        "\t */",
                        "\tusb_disable_autosuspend(udev);",
                        "",
                        "\terr = usb_enumerate_device(udev);\t/* Read descriptors */",
                        "\tif (err < 0)",
                        "\t\tgoto fail;",
                        "\tdev_dbg(&udev->dev, \"udev %d, busnum %d, minor = %d\\n\",",
                        "\t\t\tudev->devnum, udev->bus->busnum,",
                        "\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));",
                        "\t/* export the usbdev device-node for libusb */",
                        "\tudev->dev.devt = MKDEV(USB_DEVICE_MAJOR,",
                        "\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));",
                        "",
                        "\t/* Tell the world! */",
                        "\tannounce_device(udev);",
                        "",
                        "\tif (udev->serial)",
                        "\t\tadd_device_randomness(udev->serial, strlen(udev->serial));",
                        "\tif (udev->product)",
                        "\t\tadd_device_randomness(udev->product, strlen(udev->product));",
                        "\tif (udev->manufacturer)",
                        "\t\tadd_device_randomness(udev->manufacturer,",
                        "\t\t\t\t      strlen(udev->manufacturer));",
                        "",
                        "\tdevice_enable_async_suspend(&udev->dev);",
                        "",
                        "\t/* check whether the hub or firmware marks this port as non-removable */",
                        "\tif (udev->parent)",
                        "\t\tset_usb_port_removable(udev);",
                        "",
                        "\t/* Register the device.  The device driver is responsible",
                        "\t * for configuring the device and invoking the add-device",
                        "\t * notifier chain (used by usbfs and possibly others).",
                        "\t */",
                        "\terr = device_add(&udev->dev);",
                        "\tif (err) {",
                        "\t\tdev_err(&udev->dev, \"can't device_add, error %d\\n\", err);",
                        "\t\tgoto fail;",
                        "\t}",
                        "",
                        "\t/* Create link files between child device and usb port device. */",
                        "\tif (udev->parent) {",
                        "\t\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);",
                        "\t\tint port1 = udev->portnum;",
                        "\t\tstruct usb_port\t*port_dev = hub->ports[port1 - 1];",
                        "",
                        "\t\terr = sysfs_create_link(&udev->dev.kobj,",
                        "\t\t\t\t&port_dev->dev.kobj, \"port\");",
                        "\t\tif (err)",
                        "\t\t\tgoto fail;",
                        "",
                        "\t\terr = sysfs_create_link(&port_dev->dev.kobj,",
                        "\t\t\t\t&udev->dev.kobj, \"device\");",
                        "\t\tif (err) {",
                        "\t\t\tsysfs_remove_link(&udev->dev.kobj, \"port\");",
                        "\t\t\tgoto fail;",
                        "\t\t}",
                        "",
                        "\t\tif (!test_and_set_bit(port1, hub->child_usage_bits))",
                        "\t\t\tpm_runtime_get_sync(&port_dev->dev);",
                        "\t}",
                        "",
                        "\t(void) usb_create_ep_devs(&udev->dev, &udev->ep0, udev);",
                        "\tusb_mark_last_busy(udev);",
                        "\tpm_runtime_put_sync_autosuspend(&udev->dev);",
                        "\treturn err;",
                        "",
                        "fail:",
                        "\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);",
                        "\tpm_runtime_disable(&udev->dev);",
                        "\tpm_runtime_set_suspended(&udev->dev);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2480,
                    "highlight": 2555
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8237a274"
        },
        "4465": {
            "name": "usb_new_device",
            "parent_idx": 3254,
            "source_line": [
                {
                    "file": "drivers/usb/core/hub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=f40ddce88593482919761f74910f42f4b84c004b#n5223",
                    "code": [
                        "static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,",
                        "\t\tu16 portchange)",
                        "{",
                        "\tint status = -ENODEV;",
                        "\tint i;",
                        "\tunsigned unit_load;",
                        "\tstruct usb_device *hdev = hub->hdev;",
                        "\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);",
                        "\tstruct usb_port *port_dev = hub->ports[port1 - 1];",
                        "\tstruct usb_device *udev = port_dev->child;",
                        "\tstatic int unreliable_port = -1;",
                        "",
                        "\t/* Disconnect any existing devices under this port */",
                        "\tif (udev) {",
                        "\t\tif (hcd->usb_phy && !hdev->parent)",
                        "\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);",
                        "\t\tusb_disconnect(&port_dev->child);",
                        "\t}",
                        "",
                        "\t/* We can forget about a \"removed\" device when there's a physical",
                        "\t * disconnect or the connect status changes.",
                        "\t */",
                        "\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||",
                        "\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))",
                        "\t\tclear_bit(port1, hub->removed_bits);",
                        "",
                        "\tif (portchange & (USB_PORT_STAT_C_CONNECTION |",
                        "\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {",
                        "\t\tstatus = hub_port_debounce_be_stable(hub, port1);",
                        "\t\tif (status < 0) {",
                        "\t\t\tif (status != -ENODEV &&",
                        "\t\t\t\tport1 != unreliable_port &&",
                        "\t\t\t\tprintk_ratelimit())",
                        "\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");",
                        "\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;",
                        "\t\t\tunreliable_port = port1;",
                        "\t\t} else {",
                        "\t\t\tportstatus = status;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* Return now if debouncing failed or nothing is connected or",
                        "\t * the device was \"removed\".",
                        "\t */",
                        "\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||",
                        "\t\t\ttest_bit(port1, hub->removed_bits)) {",
                        "",
                        "\t\t/*",
                        "\t\t * maybe switch power back on (e.g. root hub was reset)",
                        "\t\t * but only if the port isn't owned by someone else.",
                        "\t\t */",
                        "\t\tif (hub_is_port_power_switchable(hub)",
                        "\t\t\t\t&& !port_is_power_on(hub, portstatus)",
                        "\t\t\t\t&& !port_dev->port_owner)",
                        "\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);",
                        "",
                        "\t\tif (portstatus & USB_PORT_STAT_ENABLE)",
                        "\t\t\tgoto done;",
                        "\t\treturn;",
                        "\t}",
                        "\tif (hub_is_superspeed(hub->hdev))",
                        "\t\tunit_load = 150;",
                        "\telse",
                        "\t\tunit_load = 100;",
                        "",
                        "\tstatus = 0;",
                        "\tfor (i = 0; i < PORT_INIT_TRIES; i++) {",
                        "",
                        "\t\t/* reallocate for each attempt, since references",
                        "\t\t * to the previous one can escape in various ways",
                        "\t\t */",
                        "\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);",
                        "\t\tif (!udev) {",
                        "\t\t\tdev_err(&port_dev->dev,",
                        "\t\t\t\t\t\"couldn't allocate usb_device\\n\");",
                        "\t\t\tgoto done;",
                        "\t\t}",
                        "",
                        "\t\tusb_set_device_state(udev, USB_STATE_POWERED);",
                        "\t\tudev->bus_mA = hub->mA_per_port;",
                        "\t\tudev->level = hdev->level + 1;",
                        "\t\tudev->wusb = hub_is_wusb(hub);",
                        "",
                        "\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */",
                        "\t\tif (hub_is_superspeed(hub->hdev))",
                        "\t\t\tudev->speed = USB_SPEED_SUPER;",
                        "\t\telse",
                        "\t\t\tudev->speed = USB_SPEED_UNKNOWN;",
                        "",
                        "\t\tchoose_devnum(udev);",
                        "\t\tif (udev->devnum <= 0) {",
                        "\t\t\tstatus = -ENOTCONN;\t/* Don't retry */",
                        "\t\t\tgoto loop;",
                        "\t\t}",
                        "",
                        "\t\t/* reset (non-USB 3.0 devices) and get descriptor */",
                        "\t\tusb_lock_port(port_dev);",
                        "\t\tstatus = hub_port_init(hub, udev, port1, i);",
                        "\t\tusb_unlock_port(port_dev);",
                        "\t\tif (status < 0)",
                        "\t\t\tgoto loop;",
                        "",
                        "\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)",
                        "\t\t\tmsleep(2000);",
                        "",
                        "\t\t/* consecutive bus-powered hubs aren't reliable; they can",
                        "\t\t * violate the voltage drop budget.  if the new child has",
                        "\t\t * a \"powered\" LED, users should notice we didn't enable it",
                        "\t\t * (without reading syslog), even without per-port LEDs",
                        "\t\t * on the parent.",
                        "\t\t */",
                        "\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB",
                        "\t\t\t\t&& udev->bus_mA <= unit_load) {",
                        "\t\t\tu16\tdevstat;",
                        "",
                        "\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,",
                        "\t\t\t\t\t&devstat);",
                        "\t\t\tif (status) {",
                        "\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);",
                        "\t\t\t\tgoto loop_disable;",
                        "\t\t\t}",
                        "\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {",
                        "\t\t\t\tdev_err(&udev->dev,",
                        "\t\t\t\t\t\"can't connect bus-powered hub \"",
                        "\t\t\t\t\t\"to this port\\n\");",
                        "\t\t\t\tif (hub->has_indicators) {",
                        "\t\t\t\t\thub->indicator[port1-1] =",
                        "\t\t\t\t\t\tINDICATOR_AMBER_BLINK;",
                        "\t\t\t\t\tqueue_delayed_work(",
                        "\t\t\t\t\t\tsystem_power_efficient_wq,",
                        "\t\t\t\t\t\t&hub->leds, 0);",
                        "\t\t\t\t}",
                        "\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */",
                        "\t\t\t\tgoto loop_disable;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\t/* check for devices running slower than they could */",
                        "\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200",
                        "\t\t\t\t&& udev->speed == USB_SPEED_FULL",
                        "\t\t\t\t&& highspeed_hubs != 0)",
                        "\t\t\tcheck_highspeed(hub, udev, port1);",
                        "",
                        "\t\t/* Store the parent's children[] pointer.  At this point",
                        "\t\t * udev becomes globally accessible, although presumably",
                        "\t\t * no one will look at it until hdev is unlocked.",
                        "\t\t */",
                        "\t\tstatus = 0;",
                        "",
                        "\t\tmutex_lock(&usb_port_peer_mutex);",
                        "",
                        "\t\t/* We mustn't add new devices if the parent hub has",
                        "\t\t * been disconnected; we would race with the",
                        "\t\t * recursively_mark_NOTATTACHED() routine.",
                        "\t\t */",
                        "\t\tspin_lock_irq(&device_state_lock);",
                        "\t\tif (hdev->state == USB_STATE_NOTATTACHED)",
                        "\t\t\tstatus = -ENOTCONN;",
                        "\t\telse",
                        "\t\t\tport_dev->child = udev;",
                        "\t\tspin_unlock_irq(&device_state_lock);",
                        "\t\tmutex_unlock(&usb_port_peer_mutex);",
                        "",
                        "\t\t/* Run it through the hoops (find a driver, etc) */",
                        "\t\tif (!status) {",
                        "\t\t\tstatus = usb_new_device(udev);",
                        "\t\t\tif (status) {",
                        "\t\t\t\tmutex_lock(&usb_port_peer_mutex);",
                        "\t\t\t\tspin_lock_irq(&device_state_lock);",
                        "\t\t\t\tport_dev->child = NULL;",
                        "\t\t\t\tspin_unlock_irq(&device_state_lock);",
                        "\t\t\t\tmutex_unlock(&usb_port_peer_mutex);",
                        "\t\t\t} else {",
                        "\t\t\t\tif (hcd->usb_phy && !hdev->parent)",
                        "\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,",
                        "\t\t\t\t\t\t\tudev->speed);",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (status)",
                        "\t\t\tgoto loop_disable;",
                        "",
                        "\t\tstatus = hub_power_remaining(hub);",
                        "\t\tif (status)",
                        "\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);",
                        "",
                        "\t\treturn;",
                        "",
                        "loop_disable:",
                        "\t\thub_port_disable(hub, port1, 1);",
                        "loop:",
                        "\t\tusb_ep0_reinit(udev);",
                        "\t\trelease_devnum(udev);",
                        "\t\thub_free_dev(udev);",
                        "\t\tusb_put_dev(udev);",
                        "\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))",
                        "\t\t\tbreak;",
                        "",
                        "\t\t/* When halfway through our retry count, power-cycle the port */",
                        "\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {",
                        "\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");",
                        "\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);",
                        "\t\t\tmsleep(2 * hub_power_on_good_delay(hub));",
                        "\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);",
                        "\t\t\tmsleep(hub_power_on_good_delay(hub));",
                        "\t\t}",
                        "\t}",
                        "\tif (hub->hdev->parent ||",
                        "\t\t\t!hcd->driver->port_handed_over ||",
                        "\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {",
                        "\t\tif (status != -ENOTCONN && status != -ENODEV)",
                        "\t\t\tdev_err(&port_dev->dev,",
                        "\t\t\t\t\t\"unable to enumerate USB device\\n\");",
                        "\t}",
                        "",
                        "done:",
                        "\thub_port_disable(hub, port1, 1);",
                        "\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {",
                        "\t\tif (status != -ENOTCONN && status != -ENODEV)",
                        "\t\t\thcd->driver->relinquish_port(hcd, port1);",
                        "\t}",
                        "}"
                    ],
                    "start": 5058,
                    "highlight": 5223
                },
                {
                    "file": "drivers/usb/core/hub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=f40ddce88593482919761f74910f42f4b84c004b#n5363",
                    "code": [
                        "/* Handle physical or logical connection change events.",
                        " * This routine is called when:",
                        " *\ta port connection-change occurs;",
                        " *\ta port enable-change occurs (often caused by EMI);",
                        " *\tusb_reset_and_verify_device() encounters changed descriptors (as from",
                        " *\t\ta firmware download)",
                        " * caller already locked the hub",
                        " */",
                        "static void hub_port_connect_change(struct usb_hub *hub, int port1,",
                        "\t\t\t\t\tu16 portstatus, u16 portchange)",
                        "\t\t__must_hold(&port_dev->status_lock)",
                        "{",
                        "\tstruct usb_port *port_dev = hub->ports[port1 - 1];",
                        "\tstruct usb_device *udev = port_dev->child;",
                        "\tstruct usb_device_descriptor descriptor;",
                        "\tint status = -ENODEV;",
                        "\tint retval;",
                        "",
                        "\tdev_dbg(&port_dev->dev, \"status %04x, change %04x, %s\\n\", portstatus,",
                        "\t\t\tportchange, portspeed(hub, portstatus));",
                        "",
                        "\tif (hub->has_indicators) {",
                        "\t\tset_port_led(hub, port1, HUB_LED_AUTO);",
                        "\t\thub->indicator[port1-1] = INDICATOR_AUTO;",
                        "\t}",
                        "",
                        "#ifdef\tCONFIG_USB_OTG",
                        "\t/* during HNP, don't repeat the debounce */",
                        "\tif (hub->hdev->bus->is_b_host)",
                        "\t\tportchange &= ~(USB_PORT_STAT_C_CONNECTION |",
                        "\t\t\t\tUSB_PORT_STAT_C_ENABLE);",
                        "#endif",
                        "",
                        "\t/* Try to resuscitate an existing device */",
                        "\tif ((portstatus & USB_PORT_STAT_CONNECTION) && udev &&",
                        "\t\t\tudev->state != USB_STATE_NOTATTACHED) {",
                        "\t\tif (portstatus & USB_PORT_STAT_ENABLE) {",
                        "\t\t\t/*",
                        "\t\t\t * USB-3 connections are initialized automatically by",
                        "\t\t\t * the hostcontroller hardware. Therefore check for",
                        "\t\t\t * changed device descriptors before resuscitating the",
                        "\t\t\t * device.",
                        "\t\t\t */",
                        "\t\t\tdescriptor = udev->descriptor;",
                        "\t\t\tretval = usb_get_device_descriptor(udev,",
                        "\t\t\t\t\tsizeof(udev->descriptor));",
                        "\t\t\tif (retval < 0) {",
                        "\t\t\t\tdev_dbg(&udev->dev,",
                        "\t\t\t\t\t\t\"can't read device descriptor %d\\n\",",
                        "\t\t\t\t\t\tretval);",
                        "\t\t\t} else {",
                        "\t\t\t\tif (descriptors_changed(udev, &descriptor,",
                        "\t\t\t\t\t\tudev->bos)) {",
                        "\t\t\t\t\tdev_dbg(&udev->dev,",
                        "\t\t\t\t\t\t\t\"device descriptor has changed\\n\");",
                        "\t\t\t\t\t/* for disconnect() calls */",
                        "\t\t\t\t\tudev->descriptor = descriptor;",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tstatus = 0; /* Nothing to do */",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "#ifdef CONFIG_PM",
                        "\t\t} else if (udev->state == USB_STATE_SUSPENDED &&",
                        "\t\t\t\tudev->persist_enabled) {",
                        "\t\t\t/* For a suspended device, treat this as a",
                        "\t\t\t * remote wakeup event.",
                        "\t\t\t */",
                        "\t\t\tusb_unlock_port(port_dev);",
                        "\t\t\tstatus = usb_remote_wakeup(udev);",
                        "\t\t\tusb_lock_port(port_dev);",
                        "#endif",
                        "\t\t} else {",
                        "\t\t\t/* Don't resuscitate */;",
                        "\t\t}",
                        "\t}",
                        "\tclear_bit(port1, hub->change_bits);",
                        "",
                        "\t/* successfully revalidated the connection */",
                        "\tif (status == 0)",
                        "\t\treturn;",
                        "",
                        "\tusb_unlock_port(port_dev);",
                        "\thub_port_connect(hub, port1, portstatus, portchange);",
                        "\tusb_lock_port(port_dev);",
                        "}"
                    ],
                    "start": 5281,
                    "highlight": 5363
                },
                {
                    "file": "drivers/usb/core/hub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=f40ddce88593482919761f74910f42f4b84c004b#n5509",
                    "code": [
                        "static void port_event(struct usb_hub *hub, int port1)",
                        "\t\t__must_hold(&port_dev->status_lock)",
                        "{",
                        "\tint connect_change;",
                        "\tstruct usb_port *port_dev = hub->ports[port1 - 1];",
                        "\tstruct usb_device *udev = port_dev->child;",
                        "\tstruct usb_device *hdev = hub->hdev;",
                        "\tu16 portstatus, portchange;",
                        "",
                        "\tconnect_change = test_bit(port1, hub->change_bits);",
                        "\tclear_bit(port1, hub->event_bits);",
                        "\tclear_bit(port1, hub->wakeup_bits);",
                        "",
                        "\tif (hub_port_status(hub, port1, &portstatus, &portchange) < 0)",
                        "\t\treturn;",
                        "",
                        "\tif (portchange & USB_PORT_STAT_C_CONNECTION) {",
                        "\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);",
                        "\t\tconnect_change = 1;",
                        "\t}",
                        "",
                        "\tif (portchange & USB_PORT_STAT_C_ENABLE) {",
                        "\t\tif (!connect_change)",
                        "\t\t\tdev_dbg(&port_dev->dev, \"enable change, status %08x\\n\",",
                        "\t\t\t\t\tportstatus);",
                        "\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);",
                        "",
                        "\t\t/*",
                        "\t\t * EM interference sometimes causes badly shielded USB devices",
                        "\t\t * to be shutdown by the hub, this hack enables them again.",
                        "\t\t * Works at least with mouse driver.",
                        "\t\t */",
                        "\t\tif (!(portstatus & USB_PORT_STAT_ENABLE)",
                        "\t\t    && !connect_change && udev) {",
                        "\t\t\tdev_err(&port_dev->dev, \"disabled by hub (EMI?), re-enabling...\\n\");",
                        "\t\t\tconnect_change = 1;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (portchange & USB_PORT_STAT_C_OVERCURRENT) {",
                        "\t\tu16 status = 0, unused;",
                        "\t\tport_dev->over_current_count++;",
                        "\t\tport_over_current_notify(port_dev);",
                        "",
                        "\t\tdev_dbg(&port_dev->dev, \"over-current change #%u\\n\",",
                        "\t\t\tport_dev->over_current_count);",
                        "\t\tusb_clear_port_feature(hdev, port1,",
                        "\t\t\t\tUSB_PORT_FEAT_C_OVER_CURRENT);",
                        "\t\tmsleep(100);\t/* Cool down */",
                        "\t\thub_power_on(hub, true);",
                        "\t\thub_port_status(hub, port1, &status, &unused);",
                        "\t\tif (status & USB_PORT_STAT_OVERCURRENT)",
                        "\t\t\tdev_err(&port_dev->dev, \"over-current condition\\n\");",
                        "\t}",
                        "",
                        "\tif (portchange & USB_PORT_STAT_C_RESET) {",
                        "\t\tdev_dbg(&port_dev->dev, \"reset change\\n\");",
                        "\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_RESET);",
                        "\t}",
                        "\tif ((portchange & USB_PORT_STAT_C_BH_RESET)",
                        "\t    && hub_is_superspeed(hdev)) {",
                        "\t\tdev_dbg(&port_dev->dev, \"warm reset change\\n\");",
                        "\t\tusb_clear_port_feature(hdev, port1,",
                        "\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);",
                        "\t}",
                        "\tif (portchange & USB_PORT_STAT_C_LINK_STATE) {",
                        "\t\tdev_dbg(&port_dev->dev, \"link state change\\n\");",
                        "\t\tusb_clear_port_feature(hdev, port1,",
                        "\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);",
                        "\t}",
                        "\tif (portchange & USB_PORT_STAT_C_CONFIG_ERROR) {",
                        "\t\tdev_warn(&port_dev->dev, \"config error\\n\");",
                        "\t\tusb_clear_port_feature(hdev, port1,",
                        "\t\t\t\tUSB_PORT_FEAT_C_PORT_CONFIG_ERROR);",
                        "\t}",
                        "",
                        "\t/* skip port actions that require the port to be powered on */",
                        "\tif (!pm_runtime_active(&port_dev->dev))",
                        "\t\treturn;",
                        "",
                        "\tif (hub_handle_remote_wakeup(hub, port1, portstatus, portchange))",
                        "\t\tconnect_change = 1;",
                        "",
                        "\t/*",
                        "\t * Warm reset a USB3 protocol port if it's in",
                        "\t * SS.Inactive state.",
                        "\t */",
                        "\tif (hub_port_warm_reset_required(hub, port1, portstatus)) {",
                        "\t\tdev_dbg(&port_dev->dev, \"do warm reset\\n\");",
                        "\t\tif (!udev || !(portstatus & USB_PORT_STAT_CONNECTION)",
                        "\t\t\t\t|| udev->state == USB_STATE_NOTATTACHED) {",
                        "\t\t\tif (hub_port_reset(hub, port1, NULL,",
                        "\t\t\t\t\tHUB_BH_RESET_TIME, true) < 0)",
                        "\t\t\t\thub_port_disable(hub, port1, 1);",
                        "\t\t} else {",
                        "\t\t\tusb_unlock_port(port_dev);",
                        "\t\t\tusb_lock_device(udev);",
                        "\t\t\tusb_reset_device(udev);",
                        "\t\t\tusb_unlock_device(udev);",
                        "\t\t\tusb_lock_port(port_dev);",
                        "\t\t\tconnect_change = 0;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (connect_change)",
                        "\t\thub_port_connect_change(hub, port1, portstatus, portchange);",
                        "}"
                    ],
                    "start": 5404,
                    "highlight": 5509
                },
                {
                    "file": "drivers/usb/core/hub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/usb/core/hub.c?id=f40ddce88593482919761f74910f42f4b84c004b#n5591",
                    "code": [
                        "static void hub_event(struct work_struct *work)",
                        "{",
                        "\tstruct usb_device *hdev;",
                        "\tstruct usb_interface *intf;",
                        "\tstruct usb_hub *hub;",
                        "\tstruct device *hub_dev;",
                        "\tu16 hubstatus;",
                        "\tu16 hubchange;",
                        "\tint i, ret;",
                        "",
                        "\thub = container_of(work, struct usb_hub, events);",
                        "\thdev = hub->hdev;",
                        "\thub_dev = hub->intfdev;",
                        "\tintf = to_usb_interface(hub_dev);",
                        "",
                        "\tkcov_remote_start_usb((u64)hdev->bus->busnum);",
                        "",
                        "\tdev_dbg(hub_dev, \"state %d ports %d chg %04x evt %04x\\n\",",
                        "\t\t\thdev->state, hdev->maxchild,",
                        "\t\t\t/* NOTE: expects max 15 ports... */",
                        "\t\t\t(u16) hub->change_bits[0],",
                        "\t\t\t(u16) hub->event_bits[0]);",
                        "",
                        "\t/* Lock the device, then check to see if we were",
                        "\t * disconnected while waiting for the lock to succeed. */",
                        "\tusb_lock_device(hdev);",
                        "\tif (unlikely(hub->disconnected))",
                        "\t\tgoto out_hdev_lock;",
                        "",
                        "\t/* If the hub has died, clean up after it */",
                        "\tif (hdev->state == USB_STATE_NOTATTACHED) {",
                        "\t\thub->error = -ENODEV;",
                        "\t\thub_quiesce(hub, HUB_DISCONNECT);",
                        "\t\tgoto out_hdev_lock;",
                        "\t}",
                        "",
                        "\t/* Autoresume */",
                        "\tret = usb_autopm_get_interface(intf);",
                        "\tif (ret) {",
                        "\t\tdev_dbg(hub_dev, \"Can't autoresume: %d\\n\", ret);",
                        "\t\tgoto out_hdev_lock;",
                        "\t}",
                        "",
                        "\t/* If this is an inactive hub, do nothing */",
                        "\tif (hub->quiescing)",
                        "\t\tgoto out_autopm;",
                        "",
                        "\tif (hub->error) {",
                        "\t\tdev_dbg(hub_dev, \"resetting for error %d\\n\", hub->error);",
                        "",
                        "\t\tret = usb_reset_device(hdev);",
                        "\t\tif (ret) {",
                        "\t\t\tdev_dbg(hub_dev, \"error resetting hub: %d\\n\", ret);",
                        "\t\t\tgoto out_autopm;",
                        "\t\t}",
                        "",
                        "\t\thub->nerrors = 0;",
                        "\t\thub->error = 0;",
                        "\t}",
                        "",
                        "\t/* deal with port status changes */",
                        "\tfor (i = 1; i <= hdev->maxchild; i++) {",
                        "\t\tstruct usb_port *port_dev = hub->ports[i - 1];",
                        "",
                        "\t\tif (test_bit(i, hub->event_bits)",
                        "\t\t\t\t|| test_bit(i, hub->change_bits)",
                        "\t\t\t\t|| test_bit(i, hub->wakeup_bits)) {",
                        "\t\t\t/*",
                        "\t\t\t * The get_noresume and barrier ensure that if",
                        "\t\t\t * the port was in the process of resuming, we",
                        "\t\t\t * flush that work and keep the port active for",
                        "\t\t\t * the duration of the port_event().  However,",
                        "\t\t\t * if the port is runtime pm suspended",
                        "\t\t\t * (powered-off), we leave it in that state, run",
                        "\t\t\t * an abbreviated port_event(), and move on.",
                        "\t\t\t */",
                        "\t\t\tpm_runtime_get_noresume(&port_dev->dev);",
                        "\t\t\tpm_runtime_barrier(&port_dev->dev);",
                        "\t\t\tusb_lock_port(port_dev);",
                        "\t\t\tport_event(hub, i);",
                        "\t\t\tusb_unlock_port(port_dev);",
                        "\t\t\tpm_runtime_put_sync(&port_dev->dev);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* deal with hub status changes */",
                        "\tif (test_and_clear_bit(0, hub->event_bits) == 0)",
                        "\t\t;\t/* do nothing */",
                        "\telse if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)",
                        "\t\tdev_err(hub_dev, \"get_hub_status failed\\n\");",
                        "\telse {",
                        "\t\tif (hubchange & HUB_CHANGE_LOCAL_POWER) {",
                        "\t\t\tdev_dbg(hub_dev, \"power change\\n\");",
                        "\t\t\tclear_hub_feature(hdev, C_HUB_LOCAL_POWER);",
                        "\t\t\tif (hubstatus & HUB_STATUS_LOCAL_POWER)",
                        "\t\t\t\t/* FIXME: Is this always true? */",
                        "\t\t\t\thub->limited_power = 1;",
                        "\t\t\telse",
                        "\t\t\t\thub->limited_power = 0;",
                        "\t\t}",
                        "\t\tif (hubchange & HUB_CHANGE_OVERCURRENT) {",
                        "\t\t\tu16 status = 0;",
                        "\t\t\tu16 unused;",
                        "",
                        "\t\t\tdev_dbg(hub_dev, \"over-current change\\n\");",
                        "\t\t\tclear_hub_feature(hdev, C_HUB_OVER_CURRENT);",
                        "\t\t\tmsleep(500);\t/* Cool down */",
                        "\t\t\thub_power_on(hub, true);",
                        "\t\t\thub_hub_status(hub, &status, &unused);",
                        "\t\t\tif (status & HUB_STATUS_OVERCURRENT)",
                        "\t\t\t\tdev_err(hub_dev, \"over-current condition\\n\");",
                        "\t\t}",
                        "\t}",
                        "",
                        "out_autopm:",
                        "\t/* Balance the usb_autopm_get_interface() above */",
                        "\tusb_autopm_put_interface_no_suspend(intf);",
                        "out_hdev_lock:",
                        "\tusb_unlock_device(hdev);",
                        "",
                        "\t/* Balance the stuff in kick_hub_wq() and allow autosuspend */",
                        "\tusb_autopm_put_interface(intf);",
                        "\tkref_put(&hub->kref, hub_release);",
                        "",
                        "\tkcov_remote_stop();",
                        "}"
                    ],
                    "start": 5512,
                    "highlight": 5591
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c99f66"
        },
        "3254": {
            "name": "hub_event(indirect)",
            "parent_idx": 3251,
            "source_line": [
                {
                    "file": "kernel/workqueue.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/workqueue.c?id=f40ddce88593482919761f74910f42f4b84c004b#n2291",
                    "code": [
                        "/**",
                        " * process_one_work - process single work",
                        " * @worker: self",
                        " * @work: work to process",
                        " *",
                        " * Process @work.  This function contains all the logics necessary to",
                        " * process a single work including synchronization against and",
                        " * interaction with other workers on the same cpu, queueing and",
                        " * flushing.  As long as context requirement is met, any worker can",
                        " * call this function to process a work.",
                        " *",
                        " * CONTEXT:",
                        " * raw_spin_lock_irq(pool->lock) which is released and regrabbed.",
                        " */",
                        "static void process_one_work(struct worker *worker, struct work_struct *work)",
                        "__releases(&pool->lock)",
                        "__acquires(&pool->lock)",
                        "{",
                        "\tstruct pool_workqueue *pwq = get_work_pwq(work);",
                        "\tstruct worker_pool *pool = worker->pool;",
                        "\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;",
                        "\tint work_color;",
                        "\tstruct worker *collision;",
                        "#ifdef CONFIG_LOCKDEP",
                        "\t/*",
                        "\t * It is permissible to free the struct work_struct from",
                        "\t * inside the function that is called from it, this we need to",
                        "\t * take into account for lockdep too.  To avoid bogus \"held",
                        "\t * lock freed\" warnings as well as problems when looking into",
                        "\t * work->lockdep_map, make a copy and use that here.",
                        "\t */",
                        "\tstruct lockdep_map lockdep_map;",
                        "",
                        "\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);",
                        "#endif",
                        "\t/* ensure we're on the correct CPU */",
                        "\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&",
                        "\t\t     raw_smp_processor_id() != pool->cpu);",
                        "",
                        "\t/*",
                        "\t * A single work shouldn't be executed concurrently by",
                        "\t * multiple workers on a single cpu.  Check whether anyone is",
                        "\t * already processing the work.  If so, defer the work to the",
                        "\t * currently executing one.",
                        "\t */",
                        "\tcollision = find_worker_executing_work(pool, work);",
                        "\tif (unlikely(collision)) {",
                        "\t\tmove_linked_works(work, &collision->scheduled, NULL);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* claim and dequeue */",
                        "\tdebug_work_deactivate(work);",
                        "\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);",
                        "\tworker->current_work = work;",
                        "\tworker->current_func = work->func;",
                        "\tworker->current_pwq = pwq;",
                        "\twork_color = get_work_color(work);",
                        "",
                        "\t/*",
                        "\t * Record wq name for cmdline and debug reporting, may get",
                        "\t * overridden through set_worker_desc().",
                        "\t */",
                        "\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);",
                        "",
                        "\tlist_del_init(&work->entry);",
                        "",
                        "\t/*",
                        "\t * CPU intensive works don't participate in concurrency management.",
                        "\t * They're the scheduler's responsibility.  This takes @worker out",
                        "\t * of concurrency management and the next code block will chain",
                        "\t * execution of the pending work items.",
                        "\t */",
                        "\tif (unlikely(cpu_intensive))",
                        "\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);",
                        "",
                        "\t/*",
                        "\t * Wake up another worker if necessary.  The condition is always",
                        "\t * false for normal per-cpu workers since nr_running would always",
                        "\t * be >= 1 at this point.  This is used to chain execution of the",
                        "\t * pending work items for WORKER_NOT_RUNNING workers such as the",
                        "\t * UNBOUND and CPU_INTENSIVE ones.",
                        "\t */",
                        "\tif (need_more_worker(pool))",
                        "\t\twake_up_worker(pool);",
                        "",
                        "\t/*",
                        "\t * Record the last pool and clear PENDING which should be the last",
                        "\t * update to @work.  Also, do this inside @pool->lock so that",
                        "\t * PENDING and queued state changes happen together while IRQ is",
                        "\t * disabled.",
                        "\t */",
                        "\tset_work_pool_and_clear_pending(work, pool->id);",
                        "",
                        "\traw_spin_unlock_irq(&pool->lock);",
                        "",
                        "\tlock_map_acquire(&pwq->wq->lockdep_map);",
                        "\tlock_map_acquire(&lockdep_map);",
                        "\t/*",
                        "\t * Strictly speaking we should mark the invariant state without holding",
                        "\t * any locks, that is, before these two lock_map_acquire()'s.",
                        "\t *",
                        "\t * However, that would result in:",
                        "\t *",
                        "\t *   A(W1)",
                        "\t *   WFC(C)",
                        "\t *\t\tA(W1)",
                        "\t *\t\tC(C)",
                        "\t *",
                        "\t * Which would create W1->C->W1 dependencies, even though there is no",
                        "\t * actual deadlock possible. There are two solutions, using a",
                        "\t * read-recursive acquire on the work(queue) 'locks', but this will then",
                        "\t * hit the lockdep limitation on recursive locks, or simply discard",
                        "\t * these locks.",
                        "\t *",
                        "\t * AFAICT there is no possible deadlock scenario between the",
                        "\t * flush_work() and complete() primitives (except for single-threaded",
                        "\t * workqueues), so hiding them isn't a problem.",
                        "\t */",
                        "\tlockdep_invariant_state(true);",
                        "\ttrace_workqueue_execute_start(work);",
                        "\tworker->current_func(work);",
                        "\t/*",
                        "\t * While we must be careful to not use \"work\" after this, the trace",
                        "\t * point will only record its address.",
                        "\t */",
                        "\ttrace_workqueue_execute_end(work, worker->current_func);",
                        "\tlock_map_release(&lockdep_map);",
                        "\tlock_map_release(&pwq->wq->lockdep_map);",
                        "",
                        "\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {",
                        "\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"",
                        "\t\t       \"     last function: %ps\\n\",",
                        "\t\t       current->comm, preempt_count(), task_pid_nr(current),",
                        "\t\t       worker->current_func);",
                        "\t\tdebug_show_held_locks(current);",
                        "\t\tdump_stack();",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * The following prevents a kworker from hogging CPU on !PREEMPTION",
                        "\t * kernels, where a requeueing work item waiting for something to",
                        "\t * happen could deadlock with stop_machine as such work item could",
                        "\t * indefinitely requeue itself while all other CPUs are trapped in",
                        "\t * stop_machine. At the same time, report a quiescent RCU state so",
                        "\t * the same condition doesn't freeze RCU.",
                        "\t */",
                        "\tcond_resched();",
                        "",
                        "\traw_spin_lock_irq(&pool->lock);",
                        "",
                        "\t/* clear cpu intensive status */",
                        "\tif (unlikely(cpu_intensive))",
                        "\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);",
                        "",
                        "\t/* tag the worker for identification in schedule() */",
                        "\tworker->last_func = worker->current_func;",
                        "",
                        "\t/* we're done with it, release */",
                        "\thash_del(&worker->hentry);",
                        "\tworker->current_work = NULL;",
                        "\tworker->current_func = NULL;",
                        "\tworker->current_pwq = NULL;",
                        "\tpwq_dec_nr_in_flight(pwq, work_color);",
                        "}"
                    ],
                    "start": 2154,
                    "highlight": 2291
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff810d6397"
        },
        "3251": {
            "name": "1255_work_10",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "41162": {
            "name": "+0x21",
            "parent_idx": 41160,
            "source_line": [
                {
                    "file": "drivers/media/radio/si470x/radio-si470x-usb.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/media/radio/si470x/radio-si470x-usb.c?id=f40ddce88593482919761f74910f42f4b84c004b#n364",
                    "code": [
                        "/*",
                        " * si470x_int_in_callback - rds callback and processing function",
                        " *",
                        " * TODO: do we need to use mutex locks in some sections?",
                        " */",
                        "static void si470x_int_in_callback(struct urb *urb)",
                        "{",
                        "\tstruct si470x_device *radio = urb->context;",
                        "\tint retval;",
                        "\tunsigned char regnr;",
                        "\tunsigned char blocknum;",
                        "\tunsigned short bler; /* rds block errors */",
                        "\tunsigned short rds;",
                        "\tunsigned char tmpbuf[3];",
                        "",
                        "\tif (urb->status) {",
                        "\t\tif (urb->status == -ENOENT ||",
                        "\t\t\t\turb->status == -ECONNRESET ||",
                        "\t\t\t\turb->status == -ESHUTDOWN) {",
                        "\t\t\treturn;",
                        "\t\t} else {",
                        "\t\t\tdev_warn(&radio->intf->dev,",
                        "\t\t\t \"non-zero urb status (%d)\\n\", urb->status);",
                        "\t\t\tgoto resubmit; /* Maybe we can recover. */",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* Sometimes the device returns len 0 packets */",
                        "\tif (urb->actual_length != RDS_REPORT_SIZE)",
                        "\t\tgoto resubmit;",
                        "",
                        "\tradio->registers[STATUSRSSI] =",
                        "\t\tget_unaligned_be16(&radio->int_in_buffer[1]);",
                        "",
                        "\tif (radio->registers[STATUSRSSI] & STATUSRSSI_STC)",
                        "\t\tcomplete(&radio->completion);",
                        "",
                        "\tif ((radio->registers[SYSCONFIG1] & SYSCONFIG1_RDS)) {",
                        "\t\t/* Update RDS registers with URB data */",
                        "\t\tfor (regnr = 1; regnr < RDS_REGISTER_NUM; regnr++)",
                        "\t\t\tradio->registers[STATUSRSSI + regnr] =",
                        "\t\t\t    get_unaligned_be16(&radio->int_in_buffer[",
                        "\t\t\t\tregnr * RADIO_REGISTER_SIZE + 1]);",
                        "\t\t/* get rds blocks */",
                        "\t\tif ((radio->registers[STATUSRSSI] & STATUSRSSI_RDSR) == 0) {",
                        "\t\t\t/* No RDS group ready, better luck next time */",
                        "\t\t\tgoto resubmit;",
                        "\t\t}",
                        "\t\tif ((radio->registers[STATUSRSSI] & STATUSRSSI_RDSS) == 0) {",
                        "\t\t\t/* RDS decoder not synchronized */",
                        "\t\t\tgoto resubmit;",
                        "\t\t}",
                        "\t\tfor (blocknum = 0; blocknum < 4; blocknum++) {",
                        "\t\t\tswitch (blocknum) {",
                        "\t\t\tdefault:",
                        "\t\t\t\tbler = (radio->registers[STATUSRSSI] &",
                        "\t\t\t\t\t\tSTATUSRSSI_BLERA) >> 9;",
                        "\t\t\t\trds = radio->registers[RDSA];",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 1:",
                        "\t\t\t\tbler = (radio->registers[READCHAN] &",
                        "\t\t\t\t\t\tREADCHAN_BLERB) >> 14;",
                        "\t\t\t\trds = radio->registers[RDSB];",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 2:",
                        "\t\t\t\tbler = (radio->registers[READCHAN] &",
                        "\t\t\t\t\t\tREADCHAN_BLERC) >> 12;",
                        "\t\t\t\trds = radio->registers[RDSC];",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase 3:",
                        "\t\t\t\tbler = (radio->registers[READCHAN] &",
                        "\t\t\t\t\t\tREADCHAN_BLERD) >> 10;",
                        "\t\t\t\trds = radio->registers[RDSD];",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "",
                        "\t\t\t/* Fill the V4L2 RDS buffer */",
                        "\t\t\tput_unaligned_le16(rds, &tmpbuf);",
                        "\t\t\ttmpbuf[2] = blocknum;\t\t/* offset name */",
                        "\t\t\ttmpbuf[2] |= blocknum << 3;\t/* received offset */",
                        "\t\t\tif (bler > max_rds_errors)",
                        "\t\t\t\ttmpbuf[2] |= 0x80; /* uncorrectable errors */",
                        "\t\t\telse if (bler > 0)",
                        "\t\t\t\ttmpbuf[2] |= 0x40; /* corrected error(s) */",
                        "",
                        "\t\t\t/* copy RDS block to internal buffer */",
                        "\t\t\tmemcpy(&radio->buffer[radio->wr_index], &tmpbuf, 3);",
                        "\t\t\tradio->wr_index += 3;",
                        "",
                        "\t\t\t/* wrap write pointer */",
                        "\t\t\tif (radio->wr_index >= radio->buf_size)",
                        "\t\t\t\tradio->wr_index = 0;",
                        "",
                        "\t\t\t/* check for overflow */",
                        "\t\t\tif (radio->wr_index == radio->rd_index) {",
                        "\t\t\t\t/* increment and wrap read pointer */",
                        "\t\t\t\tradio->rd_index += 3;",
                        "\t\t\t\tif (radio->rd_index >= radio->buf_size)",
                        "\t\t\t\t\tradio->rd_index = 0;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (radio->wr_index != radio->rd_index)",
                        "\t\t\twake_up_interruptible(&radio->read_queue);",
                        "\t}",
                        "",
                        "resubmit:",
                        "\t/* Resubmit if we're still running. */",
                        "\tif (radio->int_in_running && radio->usbdev) {",
                        "\t\tretval = usb_submit_urb(radio->int_in_urb, GFP_ATOMIC);",
                        "\t\tif (retval) {",
                        "\t\t\tdev_warn(&radio->intf->dev,",
                        "\t\t\t       \"resubmitting urb failed (%d)\", retval);",
                        "\t\t\tradio->int_in_running = 0;",
                        "\t\t}",
                        "\t}",
                        "\tradio->status_rssi_auto_update = radio->int_in_running;",
                        "}"
                    ],
                    "start": 357,
                    "highlight": 364
                }
            ],
            "ins_idx": 810,
            "addr": "0xffffffff81da2d21"
        },
        "8145": {
            "name": "+0x5bf",
            "parent_idx": 7310,
            "source_line": [
                {
                    "file": "drivers/media/radio/si470x/radio-si470x-usb.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/media/radio/si470x/radio-si470x-usb.c?id=f40ddce88593482919761f74910f42f4b84c004b#n766",
                    "code": [
                        "/*",
                        " * si470x_usb_driver_probe - probe for the device",
                        " */",
                        "static int si470x_usb_driver_probe(struct usb_interface *intf,",
                        "\t\tconst struct usb_device_id *id)",
                        "{",
                        "\tstruct si470x_device *radio;",
                        "\tstruct usb_host_interface *iface_desc;",
                        "\tstruct usb_endpoint_descriptor *endpoint;",
                        "\tint i, int_end_size, retval;",
                        "\tunsigned char version_warning = 0;",
                        "",
                        "\t/* private data allocation and initialization */",
                        "\tradio = kzalloc(sizeof(struct si470x_device), GFP_KERNEL);",
                        "\tif (!radio) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_initial;",
                        "\t}",
                        "\tradio->usb_buf = kmalloc(MAX_REPORT_SIZE, GFP_KERNEL);",
                        "\tif (radio->usb_buf == NULL) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_radio;",
                        "\t}",
                        "\tradio->usbdev = interface_to_usbdev(intf);",
                        "\tradio->intf = intf;",
                        "\tradio->band = 1; /* Default to 76 - 108 MHz */",
                        "\tmutex_init(&radio->lock);",
                        "\tinit_completion(&radio->completion);",
                        "",
                        "\tradio->get_register = si470x_get_register;",
                        "\tradio->set_register = si470x_set_register;",
                        "\tradio->fops_open = si470x_fops_open;",
                        "\tradio->fops_release = si470x_fops_release;",
                        "\tradio->vidioc_querycap = si470x_vidioc_querycap;",
                        "",
                        "\tiface_desc = intf->cur_altsetting;",
                        "",
                        "\t/* Set up interrupt endpoint information. */",
                        "\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {",
                        "\t\tendpoint = &iface_desc->endpoint[i].desc;",
                        "\t\tif (usb_endpoint_is_int_in(endpoint))",
                        "\t\t\tradio->int_in_endpoint = endpoint;",
                        "\t}",
                        "\tif (!radio->int_in_endpoint) {",
                        "\t\tdev_info(&intf->dev, \"could not find interrupt in endpoint\\n\");",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_usbbuf;",
                        "\t}",
                        "",
                        "\tint_end_size = le16_to_cpu(radio->int_in_endpoint->wMaxPacketSize);",
                        "",
                        "\tradio->int_in_buffer = kmalloc(int_end_size, GFP_KERNEL);",
                        "\tif (!radio->int_in_buffer) {",
                        "\t\tdev_info(&intf->dev, \"could not allocate int_in_buffer\");",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_usbbuf;",
                        "\t}",
                        "",
                        "\tradio->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);",
                        "\tif (!radio->int_in_urb) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_intbuffer;",
                        "\t}",
                        "",
                        "\tradio->v4l2_dev.release = si470x_usb_release;",
                        "",
                        "\t/*",
                        "\t * The si470x SiLabs reference design uses the same USB IDs as",
                        "\t * 'Thanko's Raremono' si4734 based receiver. So check here which we",
                        "\t * have: attempt to read the device ID from the si470x: the lower 12",
                        "\t * bits should be 0x0242 for the si470x.",
                        "\t *",
                        "\t * We use this check to determine which device we are dealing with.",
                        "\t */",
                        "\tif (id->idVendor == 0x10c4 && id->idProduct == 0x818a) {",
                        "\t\tretval = usb_control_msg(radio->usbdev,",
                        "\t\t\t\tusb_rcvctrlpipe(radio->usbdev, 0),",
                        "\t\t\t\tHID_REQ_GET_REPORT,",
                        "\t\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,",
                        "\t\t\t\t1, 2,",
                        "\t\t\t\tradio->usb_buf, 3, 500);",
                        "\t\tif (retval != 3 ||",
                        "\t\t    (get_unaligned_be16(&radio->usb_buf[1]) & 0xfff) != 0x0242) {",
                        "\t\t\tdev_info(&intf->dev, \"this is not a si470x device.\\n\");",
                        "\t\t\tretval = -ENODEV;",
                        "\t\t\tgoto err_urb;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);",
                        "\tif (retval < 0) {",
                        "\t\tdev_err(&intf->dev, \"couldn't register v4l2_device\\n\");",
                        "\t\tgoto err_urb;",
                        "\t}",
                        "",
                        "\tv4l2_ctrl_handler_init(&radio->hdl, 2);",
                        "\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,",
                        "\t\t\t  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);",
                        "\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,",
                        "\t\t\t  V4L2_CID_AUDIO_VOLUME, 0, 15, 1, 15);",
                        "\tif (radio->hdl.error) {",
                        "\t\tretval = radio->hdl.error;",
                        "\t\tdev_err(&intf->dev, \"couldn't register control\\n\");",
                        "\t\tgoto err_dev;",
                        "\t}",
                        "\tradio->videodev = si470x_viddev_template;",
                        "\tradio->videodev.ctrl_handler = &radio->hdl;",
                        "\tradio->videodev.lock = &radio->lock;",
                        "\tradio->videodev.v4l2_dev = &radio->v4l2_dev;",
                        "\tradio->videodev.release = video_device_release_empty;",
                        "\tradio->videodev.device_caps =",
                        "\t\tV4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_READWRITE | V4L2_CAP_TUNER |",
                        "\t\tV4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE;",
                        "\tvideo_set_drvdata(&radio->videodev, radio);",
                        "",
                        "\t/* get device and chip versions */",
                        "\tif (si470x_get_all_registers(radio) < 0) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "\tdev_info(&intf->dev, \"DeviceID=0x%4.4hx ChipID=0x%4.4hx\\n\",",
                        "\t\t\tradio->registers[DEVICEID], radio->registers[SI_CHIPID]);",
                        "\tif ((radio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE) < RADIO_FW_VERSION) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"This driver is known to work with firmware version %hu,\\n\",",
                        "\t\t\tRADIO_FW_VERSION);",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"but the device has firmware version %hu.\\n\",",
                        "\t\t\tradio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE);",
                        "\t\tversion_warning = 1;",
                        "\t}",
                        "",
                        "\t/* get software and hardware versions */",
                        "\tif (si470x_get_scratch_page_versions(radio) < 0) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "\tdev_info(&intf->dev, \"software version %d, hardware version %d\\n\",",
                        "\t\t\tradio->software_version, radio->hardware_version);",
                        "\tif (radio->hardware_version < RADIO_HW_VERSION) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"This driver is known to work with hardware version %hu,\\n\",",
                        "\t\t\tRADIO_HW_VERSION);",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"but the device has hardware version %hu.\\n\",",
                        "\t\t\tradio->hardware_version);",
                        "\t\tversion_warning = 1;",
                        "\t}",
                        "",
                        "\t/* give out version warning */",
                        "\tif (version_warning == 1) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"If you have some trouble using this driver,\\n\");",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"please report to V4L ML at linux-media@vger.kernel.org\\n\");",
                        "\t}",
                        "",
                        "\t/* set led to connect state */",
                        "\tsi470x_set_led_state(radio, BLINK_GREEN_LED);",
                        "",
                        "\t/* rds buffer allocation */",
                        "\tradio->buf_size = rds_buf * 3;",
                        "\tradio->buffer = kmalloc(radio->buf_size, GFP_KERNEL);",
                        "\tif (!radio->buffer) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "",
                        "\t/* rds buffer configuration */",
                        "\tradio->wr_index = 0;",
                        "\tradio->rd_index = 0;",
                        "\tinit_waitqueue_head(&radio->read_queue);",
                        "\tusb_set_intfdata(intf, radio);",
                        "",
                        "\t/* start radio */",
                        "\tretval = si470x_start_usb(radio);",
                        "\tif (retval < 0)",
                        "\t\tgoto err_buf;",
                        "",
                        "\t/* set initial frequency */",
                        "\tsi470x_set_freq(radio, 87.5 * FREQ_MUL); /* available in all regions */",
                        "",
                        "\t/* register video device */",
                        "\tretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO,",
                        "\t\t\tradio_nr);",
                        "\tif (retval) {",
                        "\t\tdev_err(&intf->dev, \"Could not register video device\\n\");",
                        "\t\tgoto err_all;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "err_all:",
                        "\tusb_kill_urb(radio->int_in_urb);",
                        "err_buf:",
                        "\tkfree(radio->buffer);",
                        "err_ctrl:",
                        "\tv4l2_ctrl_handler_free(&radio->hdl);",
                        "err_dev:",
                        "\tv4l2_device_unregister(&radio->v4l2_dev);",
                        "err_urb:",
                        "\tusb_free_urb(radio->int_in_urb);",
                        "err_intbuffer:",
                        "\tkfree(radio->int_in_buffer);",
                        "err_usbbuf:",
                        "\tkfree(radio->usb_buf);",
                        "err_radio:",
                        "\tkfree(radio);",
                        "err_initial:",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 560,
                    "highlight": 766
                }
            ],
            "ins_idx": 800,
            "addr": "0xffffffff81da3a3f"
        },
        "7929": {
            "name": "+0x116",
            "parent_idx": 7920,
            "source_line": [
                {
                    "file": "./include/linux/usb.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/usb.h?id=f40ddce88593482919761f74910f42f4b84c004b#n1702",
                    "code": [
                        "/**",
                        " * usb_fill_int_urb - macro to help initialize a interrupt urb",
                        " * @urb: pointer to the urb to initialize.",
                        " * @dev: pointer to the struct usb_device for this urb.",
                        " * @pipe: the endpoint pipe",
                        " * @transfer_buffer: pointer to the transfer buffer",
                        " * @buffer_length: length of the transfer buffer",
                        " * @complete_fn: pointer to the usb_complete_t function",
                        " * @context: what to set the urb context to.",
                        " * @interval: what to set the urb interval to, encoded like",
                        " *\tthe endpoint descriptor's bInterval value.",
                        " *",
                        " * Initializes a interrupt urb with the proper information needed to submit",
                        " * it to a device.",
                        " *",
                        " * Note that High Speed and SuperSpeed(+) interrupt endpoints use a logarithmic",
                        " * encoding of the endpoint interval, and express polling intervals in",
                        " * microframes (eight per millisecond) rather than in frames (one per",
                        " * millisecond).",
                        " *",
                        " * Wireless USB also uses the logarithmic encoding, but specifies it in units of",
                        " * 128us instead of 125us.  For Wireless USB devices, the interval is passed",
                        " * through to the host controller, rather than being translated into microframe",
                        " * units.",
                        " */",
                        "static inline void usb_fill_int_urb(struct urb *urb,",
                        "\t\t\t\t    struct usb_device *dev,",
                        "\t\t\t\t    unsigned int pipe,",
                        "\t\t\t\t    void *transfer_buffer,",
                        "\t\t\t\t    int buffer_length,",
                        "\t\t\t\t    usb_complete_t complete_fn,",
                        "\t\t\t\t    void *context,",
                        "\t\t\t\t    int interval)",
                        "{",
                        "\turb->dev = dev;",
                        "\turb->pipe = pipe;",
                        "\turb->transfer_buffer = transfer_buffer;",
                        "\turb->transfer_buffer_length = buffer_length;",
                        "\turb->complete = complete_fn;",
                        "\turb->context = context;",
                        "",
                        "\tif (dev->speed == USB_SPEED_HIGH || dev->speed >= USB_SPEED_SUPER) {",
                        "\t\t/* make sure interval is within allowed range */",
                        "\t\tinterval = clamp(interval, 1, 16);",
                        "",
                        "\t\turb->interval = 1 << (interval - 1);",
                        "\t} else {",
                        "\t\turb->interval = interval;",
                        "\t}",
                        "",
                        "\turb->start_frame = -1;",
                        "}"
                    ],
                    "start": 1663,
                    "highlight": 1702
                },
                {
                    "file": "drivers/media/radio/si470x/radio-si470x-usb.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/media/radio/si470x/radio-si470x-usb.c?id=f40ddce88593482919761f74910f42f4b84c004b#n526",
                    "code": [
                        "static int si470x_start_usb(struct si470x_device *radio)",
                        "{",
                        "\tint retval;",
                        "",
                        "\t/* initialize interrupt urb */",
                        "\tusb_fill_int_urb(radio->int_in_urb, radio->usbdev,",
                        "\t\t\tusb_rcvintpipe(radio->usbdev,",
                        "\t\t\t\tradio->int_in_endpoint->bEndpointAddress),",
                        "\t\t\tradio->int_in_buffer,",
                        "\t\t\tle16_to_cpu(radio->int_in_endpoint->wMaxPacketSize),",
                        "\t\t\tsi470x_int_in_callback,",
                        "\t\t\tradio,",
                        "\t\t\tradio->int_in_endpoint->bInterval);",
                        "",
                        "\tradio->int_in_running = 1;",
                        "\tmb();",
                        "",
                        "\tretval = usb_submit_urb(radio->int_in_urb, GFP_KERNEL);",
                        "\tif (retval) {",
                        "\t\tdev_info(&radio->intf->dev,",
                        "\t\t\t\t\"submitting int urb failed (%d)\\n\", retval);",
                        "\t\tradio->int_in_running = 0;",
                        "\t}",
                        "\tradio->status_rssi_auto_update = radio->int_in_running;",
                        "",
                        "\t/* start radio */",
                        "\tretval = si470x_start(radio);",
                        "\tif (retval < 0)",
                        "\t\treturn retval;",
                        "",
                        "\tv4l2_ctrl_handler_setup(&radio->hdl);",
                        "",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 521,
                    "highlight": 526
                }
            ],
            "ins_idx": 1243,
            "addr": "0xffffffff8239ad2f"
        },
        "7920": {
            "name": "si470x_start_usb",
            "parent_idx": 7310,
            "source_line": [
                {
                    "file": "drivers/media/radio/si470x/radio-si470x-usb.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/media/radio/si470x/radio-si470x-usb.c?id=f40ddce88593482919761f74910f42f4b84c004b#n735",
                    "code": [
                        "/*",
                        " * si470x_usb_driver_probe - probe for the device",
                        " */",
                        "static int si470x_usb_driver_probe(struct usb_interface *intf,",
                        "\t\tconst struct usb_device_id *id)",
                        "{",
                        "\tstruct si470x_device *radio;",
                        "\tstruct usb_host_interface *iface_desc;",
                        "\tstruct usb_endpoint_descriptor *endpoint;",
                        "\tint i, int_end_size, retval;",
                        "\tunsigned char version_warning = 0;",
                        "",
                        "\t/* private data allocation and initialization */",
                        "\tradio = kzalloc(sizeof(struct si470x_device), GFP_KERNEL);",
                        "\tif (!radio) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_initial;",
                        "\t}",
                        "\tradio->usb_buf = kmalloc(MAX_REPORT_SIZE, GFP_KERNEL);",
                        "\tif (radio->usb_buf == NULL) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_radio;",
                        "\t}",
                        "\tradio->usbdev = interface_to_usbdev(intf);",
                        "\tradio->intf = intf;",
                        "\tradio->band = 1; /* Default to 76 - 108 MHz */",
                        "\tmutex_init(&radio->lock);",
                        "\tinit_completion(&radio->completion);",
                        "",
                        "\tradio->get_register = si470x_get_register;",
                        "\tradio->set_register = si470x_set_register;",
                        "\tradio->fops_open = si470x_fops_open;",
                        "\tradio->fops_release = si470x_fops_release;",
                        "\tradio->vidioc_querycap = si470x_vidioc_querycap;",
                        "",
                        "\tiface_desc = intf->cur_altsetting;",
                        "",
                        "\t/* Set up interrupt endpoint information. */",
                        "\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {",
                        "\t\tendpoint = &iface_desc->endpoint[i].desc;",
                        "\t\tif (usb_endpoint_is_int_in(endpoint))",
                        "\t\t\tradio->int_in_endpoint = endpoint;",
                        "\t}",
                        "\tif (!radio->int_in_endpoint) {",
                        "\t\tdev_info(&intf->dev, \"could not find interrupt in endpoint\\n\");",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_usbbuf;",
                        "\t}",
                        "",
                        "\tint_end_size = le16_to_cpu(radio->int_in_endpoint->wMaxPacketSize);",
                        "",
                        "\tradio->int_in_buffer = kmalloc(int_end_size, GFP_KERNEL);",
                        "\tif (!radio->int_in_buffer) {",
                        "\t\tdev_info(&intf->dev, \"could not allocate int_in_buffer\");",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_usbbuf;",
                        "\t}",
                        "",
                        "\tradio->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);",
                        "\tif (!radio->int_in_urb) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_intbuffer;",
                        "\t}",
                        "",
                        "\tradio->v4l2_dev.release = si470x_usb_release;",
                        "",
                        "\t/*",
                        "\t * The si470x SiLabs reference design uses the same USB IDs as",
                        "\t * 'Thanko's Raremono' si4734 based receiver. So check here which we",
                        "\t * have: attempt to read the device ID from the si470x: the lower 12",
                        "\t * bits should be 0x0242 for the si470x.",
                        "\t *",
                        "\t * We use this check to determine which device we are dealing with.",
                        "\t */",
                        "\tif (id->idVendor == 0x10c4 && id->idProduct == 0x818a) {",
                        "\t\tretval = usb_control_msg(radio->usbdev,",
                        "\t\t\t\tusb_rcvctrlpipe(radio->usbdev, 0),",
                        "\t\t\t\tHID_REQ_GET_REPORT,",
                        "\t\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,",
                        "\t\t\t\t1, 2,",
                        "\t\t\t\tradio->usb_buf, 3, 500);",
                        "\t\tif (retval != 3 ||",
                        "\t\t    (get_unaligned_be16(&radio->usb_buf[1]) & 0xfff) != 0x0242) {",
                        "\t\t\tdev_info(&intf->dev, \"this is not a si470x device.\\n\");",
                        "\t\t\tretval = -ENODEV;",
                        "\t\t\tgoto err_urb;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);",
                        "\tif (retval < 0) {",
                        "\t\tdev_err(&intf->dev, \"couldn't register v4l2_device\\n\");",
                        "\t\tgoto err_urb;",
                        "\t}",
                        "",
                        "\tv4l2_ctrl_handler_init(&radio->hdl, 2);",
                        "\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,",
                        "\t\t\t  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);",
                        "\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,",
                        "\t\t\t  V4L2_CID_AUDIO_VOLUME, 0, 15, 1, 15);",
                        "\tif (radio->hdl.error) {",
                        "\t\tretval = radio->hdl.error;",
                        "\t\tdev_err(&intf->dev, \"couldn't register control\\n\");",
                        "\t\tgoto err_dev;",
                        "\t}",
                        "\tradio->videodev = si470x_viddev_template;",
                        "\tradio->videodev.ctrl_handler = &radio->hdl;",
                        "\tradio->videodev.lock = &radio->lock;",
                        "\tradio->videodev.v4l2_dev = &radio->v4l2_dev;",
                        "\tradio->videodev.release = video_device_release_empty;",
                        "\tradio->videodev.device_caps =",
                        "\t\tV4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_READWRITE | V4L2_CAP_TUNER |",
                        "\t\tV4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE;",
                        "\tvideo_set_drvdata(&radio->videodev, radio);",
                        "",
                        "\t/* get device and chip versions */",
                        "\tif (si470x_get_all_registers(radio) < 0) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "\tdev_info(&intf->dev, \"DeviceID=0x%4.4hx ChipID=0x%4.4hx\\n\",",
                        "\t\t\tradio->registers[DEVICEID], radio->registers[SI_CHIPID]);",
                        "\tif ((radio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE) < RADIO_FW_VERSION) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"This driver is known to work with firmware version %hu,\\n\",",
                        "\t\t\tRADIO_FW_VERSION);",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"but the device has firmware version %hu.\\n\",",
                        "\t\t\tradio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE);",
                        "\t\tversion_warning = 1;",
                        "\t}",
                        "",
                        "\t/* get software and hardware versions */",
                        "\tif (si470x_get_scratch_page_versions(radio) < 0) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "\tdev_info(&intf->dev, \"software version %d, hardware version %d\\n\",",
                        "\t\t\tradio->software_version, radio->hardware_version);",
                        "\tif (radio->hardware_version < RADIO_HW_VERSION) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"This driver is known to work with hardware version %hu,\\n\",",
                        "\t\t\tRADIO_HW_VERSION);",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"but the device has hardware version %hu.\\n\",",
                        "\t\t\tradio->hardware_version);",
                        "\t\tversion_warning = 1;",
                        "\t}",
                        "",
                        "\t/* give out version warning */",
                        "\tif (version_warning == 1) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"If you have some trouble using this driver,\\n\");",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"please report to V4L ML at linux-media@vger.kernel.org\\n\");",
                        "\t}",
                        "",
                        "\t/* set led to connect state */",
                        "\tsi470x_set_led_state(radio, BLINK_GREEN_LED);",
                        "",
                        "\t/* rds buffer allocation */",
                        "\tradio->buf_size = rds_buf * 3;",
                        "\tradio->buffer = kmalloc(radio->buf_size, GFP_KERNEL);",
                        "\tif (!radio->buffer) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "",
                        "\t/* rds buffer configuration */",
                        "\tradio->wr_index = 0;",
                        "\tradio->rd_index = 0;",
                        "\tinit_waitqueue_head(&radio->read_queue);",
                        "\tusb_set_intfdata(intf, radio);",
                        "",
                        "\t/* start radio */",
                        "\tretval = si470x_start_usb(radio);",
                        "\tif (retval < 0)",
                        "\t\tgoto err_buf;",
                        "",
                        "\t/* set initial frequency */",
                        "\tsi470x_set_freq(radio, 87.5 * FREQ_MUL); /* available in all regions */",
                        "",
                        "\t/* register video device */",
                        "\tretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO,",
                        "\t\t\tradio_nr);",
                        "\tif (retval) {",
                        "\t\tdev_err(&intf->dev, \"Could not register video device\\n\");",
                        "\t\tgoto err_all;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "err_all:",
                        "\tusb_kill_urb(radio->int_in_urb);",
                        "err_buf:",
                        "\tkfree(radio->buffer);",
                        "err_ctrl:",
                        "\tv4l2_ctrl_handler_free(&radio->hdl);",
                        "err_dev:",
                        "\tv4l2_device_unregister(&radio->v4l2_dev);",
                        "err_urb:",
                        "\tusb_free_urb(radio->int_in_urb);",
                        "err_intbuffer:",
                        "\tkfree(radio->int_in_buffer);",
                        "err_usbbuf:",
                        "\tkfree(radio->usb_buf);",
                        "err_radio:",
                        "\tkfree(radio);",
                        "err_initial:",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 560,
                    "highlight": 735
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8239b321"
        },
        "7315": {
            "name": "+0x4d",
            "parent_idx": 7310,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=f40ddce88593482919761f74910f42f4b84c004b#n552",
                    "code": [
                        "/**",
                        " * kmalloc - allocate memory",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate.",
                        " *",
                        " * kmalloc is the normal method of allocating memory",
                        " * for objects smaller than page size in the kernel.",
                        " *",
                        " * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN",
                        " * bytes. For @size of power of two bytes, the alignment is also guaranteed",
                        " * to be at least to the size.",
                        " *",
                        " * The @flags argument may be one of the GFP flags defined at",
                        " * include/linux/gfp.h and described at",
                        " * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`",
                        " *",
                        " * The recommended usage of the @flags is described at",
                        " * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`",
                        " *",
                        " * Below is a brief outline of the most useful GFP flags",
                        " *",
                        " * %GFP_KERNEL",
                        " *\tAllocate normal kernel ram. May sleep.",
                        " *",
                        " * %GFP_NOWAIT",
                        " *\tAllocation will not sleep.",
                        " *",
                        " * %GFP_ATOMIC",
                        " *\tAllocation will not sleep.  May use emergency pools.",
                        " *",
                        " * %GFP_HIGHUSER",
                        " *\tAllocate memory from high memory on behalf of user.",
                        " *",
                        " * Also it is possible to set different flags by OR'ing",
                        " * in one or more of the following additional @flags:",
                        " *",
                        " * %__GFP_HIGH",
                        " *\tThis allocation has high priority and may use emergency pools.",
                        " *",
                        " * %__GFP_NOFAIL",
                        " *\tIndicate that this allocation is in no way allowed to fail",
                        " *\t(think twice before using).",
                        " *",
                        " * %__GFP_NORETRY",
                        " *\tIf memory is not immediately available,",
                        " *\tthen give up at once.",
                        " *",
                        " * %__GFP_NOWARN",
                        " *\tIf allocation fails, don't issue any warnings.",
                        " *",
                        " * %__GFP_RETRY_MAYFAIL",
                        " *\tTry really hard to succeed the allocation but fail",
                        " *\teventually.",
                        " */",
                        "static __always_inline void *kmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\tif (__builtin_constant_p(size)) {",
                        "#ifndef CONFIG_SLOB",
                        "\t\tunsigned int index;",
                        "#endif",
                        "\t\tif (size > KMALLOC_MAX_CACHE_SIZE)",
                        "\t\t\treturn kmalloc_large(size, flags);",
                        "#ifndef CONFIG_SLOB",
                        "\t\tindex = kmalloc_index(size);",
                        "",
                        "\t\tif (!index)",
                        "\t\t\treturn ZERO_SIZE_PTR;",
                        "",
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 484,
                    "highlight": 552
                },
                {
                    "file": "drivers/media/radio/si470x/radio-si470x-usb.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/media/radio/si470x/radio-si470x-usb.c?id=f40ddce88593482919761f74910f42f4b84c004b#n578",
                    "code": [
                        "/*",
                        " * si470x_usb_driver_probe - probe for the device",
                        " */",
                        "static int si470x_usb_driver_probe(struct usb_interface *intf,",
                        "\t\tconst struct usb_device_id *id)",
                        "{",
                        "\tstruct si470x_device *radio;",
                        "\tstruct usb_host_interface *iface_desc;",
                        "\tstruct usb_endpoint_descriptor *endpoint;",
                        "\tint i, int_end_size, retval;",
                        "\tunsigned char version_warning = 0;",
                        "",
                        "\t/* private data allocation and initialization */",
                        "\tradio = kzalloc(sizeof(struct si470x_device), GFP_KERNEL);",
                        "\tif (!radio) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_initial;",
                        "\t}",
                        "\tradio->usb_buf = kmalloc(MAX_REPORT_SIZE, GFP_KERNEL);",
                        "\tif (radio->usb_buf == NULL) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_radio;",
                        "\t}",
                        "\tradio->usbdev = interface_to_usbdev(intf);",
                        "\tradio->intf = intf;",
                        "\tradio->band = 1; /* Default to 76 - 108 MHz */",
                        "\tmutex_init(&radio->lock);",
                        "\tinit_completion(&radio->completion);",
                        "",
                        "\tradio->get_register = si470x_get_register;",
                        "\tradio->set_register = si470x_set_register;",
                        "\tradio->fops_open = si470x_fops_open;",
                        "\tradio->fops_release = si470x_fops_release;",
                        "\tradio->vidioc_querycap = si470x_vidioc_querycap;",
                        "",
                        "\tiface_desc = intf->cur_altsetting;",
                        "",
                        "\t/* Set up interrupt endpoint information. */",
                        "\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {",
                        "\t\tendpoint = &iface_desc->endpoint[i].desc;",
                        "\t\tif (usb_endpoint_is_int_in(endpoint))",
                        "\t\t\tradio->int_in_endpoint = endpoint;",
                        "\t}",
                        "\tif (!radio->int_in_endpoint) {",
                        "\t\tdev_info(&intf->dev, \"could not find interrupt in endpoint\\n\");",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_usbbuf;",
                        "\t}",
                        "",
                        "\tint_end_size = le16_to_cpu(radio->int_in_endpoint->wMaxPacketSize);",
                        "",
                        "\tradio->int_in_buffer = kmalloc(int_end_size, GFP_KERNEL);",
                        "\tif (!radio->int_in_buffer) {",
                        "\t\tdev_info(&intf->dev, \"could not allocate int_in_buffer\");",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_usbbuf;",
                        "\t}",
                        "",
                        "\tradio->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);",
                        "\tif (!radio->int_in_urb) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_intbuffer;",
                        "\t}",
                        "",
                        "\tradio->v4l2_dev.release = si470x_usb_release;",
                        "",
                        "\t/*",
                        "\t * The si470x SiLabs reference design uses the same USB IDs as",
                        "\t * 'Thanko's Raremono' si4734 based receiver. So check here which we",
                        "\t * have: attempt to read the device ID from the si470x: the lower 12",
                        "\t * bits should be 0x0242 for the si470x.",
                        "\t *",
                        "\t * We use this check to determine which device we are dealing with.",
                        "\t */",
                        "\tif (id->idVendor == 0x10c4 && id->idProduct == 0x818a) {",
                        "\t\tretval = usb_control_msg(radio->usbdev,",
                        "\t\t\t\tusb_rcvctrlpipe(radio->usbdev, 0),",
                        "\t\t\t\tHID_REQ_GET_REPORT,",
                        "\t\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,",
                        "\t\t\t\t1, 2,",
                        "\t\t\t\tradio->usb_buf, 3, 500);",
                        "\t\tif (retval != 3 ||",
                        "\t\t    (get_unaligned_be16(&radio->usb_buf[1]) & 0xfff) != 0x0242) {",
                        "\t\t\tdev_info(&intf->dev, \"this is not a si470x device.\\n\");",
                        "\t\t\tretval = -ENODEV;",
                        "\t\t\tgoto err_urb;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);",
                        "\tif (retval < 0) {",
                        "\t\tdev_err(&intf->dev, \"couldn't register v4l2_device\\n\");",
                        "\t\tgoto err_urb;",
                        "\t}",
                        "",
                        "\tv4l2_ctrl_handler_init(&radio->hdl, 2);",
                        "\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,",
                        "\t\t\t  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);",
                        "\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,",
                        "\t\t\t  V4L2_CID_AUDIO_VOLUME, 0, 15, 1, 15);",
                        "\tif (radio->hdl.error) {",
                        "\t\tretval = radio->hdl.error;",
                        "\t\tdev_err(&intf->dev, \"couldn't register control\\n\");",
                        "\t\tgoto err_dev;",
                        "\t}",
                        "\tradio->videodev = si470x_viddev_template;",
                        "\tradio->videodev.ctrl_handler = &radio->hdl;",
                        "\tradio->videodev.lock = &radio->lock;",
                        "\tradio->videodev.v4l2_dev = &radio->v4l2_dev;",
                        "\tradio->videodev.release = video_device_release_empty;",
                        "\tradio->videodev.device_caps =",
                        "\t\tV4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_READWRITE | V4L2_CAP_TUNER |",
                        "\t\tV4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE;",
                        "\tvideo_set_drvdata(&radio->videodev, radio);",
                        "",
                        "\t/* get device and chip versions */",
                        "\tif (si470x_get_all_registers(radio) < 0) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "\tdev_info(&intf->dev, \"DeviceID=0x%4.4hx ChipID=0x%4.4hx\\n\",",
                        "\t\t\tradio->registers[DEVICEID], radio->registers[SI_CHIPID]);",
                        "\tif ((radio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE) < RADIO_FW_VERSION) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"This driver is known to work with firmware version %hu,\\n\",",
                        "\t\t\tRADIO_FW_VERSION);",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"but the device has firmware version %hu.\\n\",",
                        "\t\t\tradio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE);",
                        "\t\tversion_warning = 1;",
                        "\t}",
                        "",
                        "\t/* get software and hardware versions */",
                        "\tif (si470x_get_scratch_page_versions(radio) < 0) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "\tdev_info(&intf->dev, \"software version %d, hardware version %d\\n\",",
                        "\t\t\tradio->software_version, radio->hardware_version);",
                        "\tif (radio->hardware_version < RADIO_HW_VERSION) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"This driver is known to work with hardware version %hu,\\n\",",
                        "\t\t\tRADIO_HW_VERSION);",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"but the device has hardware version %hu.\\n\",",
                        "\t\t\tradio->hardware_version);",
                        "\t\tversion_warning = 1;",
                        "\t}",
                        "",
                        "\t/* give out version warning */",
                        "\tif (version_warning == 1) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"If you have some trouble using this driver,\\n\");",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"please report to V4L ML at linux-media@vger.kernel.org\\n\");",
                        "\t}",
                        "",
                        "\t/* set led to connect state */",
                        "\tsi470x_set_led_state(radio, BLINK_GREEN_LED);",
                        "",
                        "\t/* rds buffer allocation */",
                        "\tradio->buf_size = rds_buf * 3;",
                        "\tradio->buffer = kmalloc(radio->buf_size, GFP_KERNEL);",
                        "\tif (!radio->buffer) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "",
                        "\t/* rds buffer configuration */",
                        "\tradio->wr_index = 0;",
                        "\tradio->rd_index = 0;",
                        "\tinit_waitqueue_head(&radio->read_queue);",
                        "\tusb_set_intfdata(intf, radio);",
                        "",
                        "\t/* start radio */",
                        "\tretval = si470x_start_usb(radio);",
                        "\tif (retval < 0)",
                        "\t\tgoto err_buf;",
                        "",
                        "\t/* set initial frequency */",
                        "\tsi470x_set_freq(radio, 87.5 * FREQ_MUL); /* available in all regions */",
                        "",
                        "\t/* register video device */",
                        "\tretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO,",
                        "\t\t\tradio_nr);",
                        "\tif (retval) {",
                        "\t\tdev_err(&intf->dev, \"Could not register video device\\n\");",
                        "\t\tgoto err_all;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "err_all:",
                        "\tusb_kill_urb(radio->int_in_urb);",
                        "err_buf:",
                        "\tkfree(radio->buffer);",
                        "err_ctrl:",
                        "\tv4l2_ctrl_handler_free(&radio->hdl);",
                        "err_dev:",
                        "\tv4l2_device_unregister(&radio->v4l2_dev);",
                        "err_urb:",
                        "\tusb_free_urb(radio->int_in_urb);",
                        "err_intbuffer:",
                        "\tkfree(radio->int_in_buffer);",
                        "err_usbbuf:",
                        "\tkfree(radio->usb_buf);",
                        "err_radio:",
                        "\tkfree(radio);",
                        "err_initial:",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 560,
                    "highlight": 578
                }
            ],
            "ins_idx": 1785,
            "addr": "0xffffffff81da34cd"
        },
        "7925": {
            "name": "+0xa",
            "parent_idx": 7920,
            "source_line": [
                {
                    "file": "drivers/media/radio/si470x/radio-si470x-usb.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/media/radio/si470x/radio-si470x-usb.c?id=f40ddce88593482919761f74910f42f4b84c004b#n522",
                    "code": [
                        "static int si470x_start_usb(struct si470x_device *radio)",
                        "{",
                        "\tint retval;",
                        "",
                        "\t/* initialize interrupt urb */",
                        "\tusb_fill_int_urb(radio->int_in_urb, radio->usbdev,",
                        "\t\t\tusb_rcvintpipe(radio->usbdev,",
                        "\t\t\t\tradio->int_in_endpoint->bEndpointAddress),",
                        "\t\t\tradio->int_in_buffer,",
                        "\t\t\tle16_to_cpu(radio->int_in_endpoint->wMaxPacketSize),",
                        "\t\t\tsi470x_int_in_callback,",
                        "\t\t\tradio,",
                        "\t\t\tradio->int_in_endpoint->bInterval);",
                        "",
                        "\tradio->int_in_running = 1;",
                        "\tmb();",
                        "",
                        "\tretval = usb_submit_urb(radio->int_in_urb, GFP_KERNEL);",
                        "\tif (retval) {",
                        "\t\tdev_info(&radio->intf->dev,",
                        "\t\t\t\t\"submitting int urb failed (%d)\\n\", retval);",
                        "\t\tradio->int_in_running = 0;",
                        "\t}",
                        "\tradio->status_rssi_auto_update = radio->int_in_running;",
                        "",
                        "\t/* start radio */",
                        "\tretval = si470x_start(radio);",
                        "\tif (retval < 0)",
                        "\t\treturn retval;",
                        "",
                        "\tv4l2_ctrl_handler_setup(&radio->hdl);",
                        "",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 521,
                    "highlight": 522
                }
            ],
            "ins_idx": 1810,
            "addr": "0xffffffff8239ac23"
        },
        "7919": {
            "name": "+0x30a",
            "parent_idx": 7310,
            "source_line": [
                {
                    "file": "drivers/media/radio/si470x/radio-si470x-usb.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/media/radio/si470x/radio-si470x-usb.c?id=f40ddce88593482919761f74910f42f4b84c004b#n735",
                    "code": [
                        "/*",
                        " * si470x_usb_driver_probe - probe for the device",
                        " */",
                        "static int si470x_usb_driver_probe(struct usb_interface *intf,",
                        "\t\tconst struct usb_device_id *id)",
                        "{",
                        "\tstruct si470x_device *radio;",
                        "\tstruct usb_host_interface *iface_desc;",
                        "\tstruct usb_endpoint_descriptor *endpoint;",
                        "\tint i, int_end_size, retval;",
                        "\tunsigned char version_warning = 0;",
                        "",
                        "\t/* private data allocation and initialization */",
                        "\tradio = kzalloc(sizeof(struct si470x_device), GFP_KERNEL);",
                        "\tif (!radio) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_initial;",
                        "\t}",
                        "\tradio->usb_buf = kmalloc(MAX_REPORT_SIZE, GFP_KERNEL);",
                        "\tif (radio->usb_buf == NULL) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_radio;",
                        "\t}",
                        "\tradio->usbdev = interface_to_usbdev(intf);",
                        "\tradio->intf = intf;",
                        "\tradio->band = 1; /* Default to 76 - 108 MHz */",
                        "\tmutex_init(&radio->lock);",
                        "\tinit_completion(&radio->completion);",
                        "",
                        "\tradio->get_register = si470x_get_register;",
                        "\tradio->set_register = si470x_set_register;",
                        "\tradio->fops_open = si470x_fops_open;",
                        "\tradio->fops_release = si470x_fops_release;",
                        "\tradio->vidioc_querycap = si470x_vidioc_querycap;",
                        "",
                        "\tiface_desc = intf->cur_altsetting;",
                        "",
                        "\t/* Set up interrupt endpoint information. */",
                        "\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {",
                        "\t\tendpoint = &iface_desc->endpoint[i].desc;",
                        "\t\tif (usb_endpoint_is_int_in(endpoint))",
                        "\t\t\tradio->int_in_endpoint = endpoint;",
                        "\t}",
                        "\tif (!radio->int_in_endpoint) {",
                        "\t\tdev_info(&intf->dev, \"could not find interrupt in endpoint\\n\");",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_usbbuf;",
                        "\t}",
                        "",
                        "\tint_end_size = le16_to_cpu(radio->int_in_endpoint->wMaxPacketSize);",
                        "",
                        "\tradio->int_in_buffer = kmalloc(int_end_size, GFP_KERNEL);",
                        "\tif (!radio->int_in_buffer) {",
                        "\t\tdev_info(&intf->dev, \"could not allocate int_in_buffer\");",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_usbbuf;",
                        "\t}",
                        "",
                        "\tradio->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);",
                        "\tif (!radio->int_in_urb) {",
                        "\t\tretval = -ENOMEM;",
                        "\t\tgoto err_intbuffer;",
                        "\t}",
                        "",
                        "\tradio->v4l2_dev.release = si470x_usb_release;",
                        "",
                        "\t/*",
                        "\t * The si470x SiLabs reference design uses the same USB IDs as",
                        "\t * 'Thanko's Raremono' si4734 based receiver. So check here which we",
                        "\t * have: attempt to read the device ID from the si470x: the lower 12",
                        "\t * bits should be 0x0242 for the si470x.",
                        "\t *",
                        "\t * We use this check to determine which device we are dealing with.",
                        "\t */",
                        "\tif (id->idVendor == 0x10c4 && id->idProduct == 0x818a) {",
                        "\t\tretval = usb_control_msg(radio->usbdev,",
                        "\t\t\t\tusb_rcvctrlpipe(radio->usbdev, 0),",
                        "\t\t\t\tHID_REQ_GET_REPORT,",
                        "\t\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,",
                        "\t\t\t\t1, 2,",
                        "\t\t\t\tradio->usb_buf, 3, 500);",
                        "\t\tif (retval != 3 ||",
                        "\t\t    (get_unaligned_be16(&radio->usb_buf[1]) & 0xfff) != 0x0242) {",
                        "\t\t\tdev_info(&intf->dev, \"this is not a si470x device.\\n\");",
                        "\t\t\tretval = -ENODEV;",
                        "\t\t\tgoto err_urb;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);",
                        "\tif (retval < 0) {",
                        "\t\tdev_err(&intf->dev, \"couldn't register v4l2_device\\n\");",
                        "\t\tgoto err_urb;",
                        "\t}",
                        "",
                        "\tv4l2_ctrl_handler_init(&radio->hdl, 2);",
                        "\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,",
                        "\t\t\t  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);",
                        "\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,",
                        "\t\t\t  V4L2_CID_AUDIO_VOLUME, 0, 15, 1, 15);",
                        "\tif (radio->hdl.error) {",
                        "\t\tretval = radio->hdl.error;",
                        "\t\tdev_err(&intf->dev, \"couldn't register control\\n\");",
                        "\t\tgoto err_dev;",
                        "\t}",
                        "\tradio->videodev = si470x_viddev_template;",
                        "\tradio->videodev.ctrl_handler = &radio->hdl;",
                        "\tradio->videodev.lock = &radio->lock;",
                        "\tradio->videodev.v4l2_dev = &radio->v4l2_dev;",
                        "\tradio->videodev.release = video_device_release_empty;",
                        "\tradio->videodev.device_caps =",
                        "\t\tV4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_READWRITE | V4L2_CAP_TUNER |",
                        "\t\tV4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE;",
                        "\tvideo_set_drvdata(&radio->videodev, radio);",
                        "",
                        "\t/* get device and chip versions */",
                        "\tif (si470x_get_all_registers(radio) < 0) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "\tdev_info(&intf->dev, \"DeviceID=0x%4.4hx ChipID=0x%4.4hx\\n\",",
                        "\t\t\tradio->registers[DEVICEID], radio->registers[SI_CHIPID]);",
                        "\tif ((radio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE) < RADIO_FW_VERSION) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"This driver is known to work with firmware version %hu,\\n\",",
                        "\t\t\tRADIO_FW_VERSION);",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"but the device has firmware version %hu.\\n\",",
                        "\t\t\tradio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE);",
                        "\t\tversion_warning = 1;",
                        "\t}",
                        "",
                        "\t/* get software and hardware versions */",
                        "\tif (si470x_get_scratch_page_versions(radio) < 0) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "\tdev_info(&intf->dev, \"software version %d, hardware version %d\\n\",",
                        "\t\t\tradio->software_version, radio->hardware_version);",
                        "\tif (radio->hardware_version < RADIO_HW_VERSION) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"This driver is known to work with hardware version %hu,\\n\",",
                        "\t\t\tRADIO_HW_VERSION);",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"but the device has hardware version %hu.\\n\",",
                        "\t\t\tradio->hardware_version);",
                        "\t\tversion_warning = 1;",
                        "\t}",
                        "",
                        "\t/* give out version warning */",
                        "\tif (version_warning == 1) {",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"If you have some trouble using this driver,\\n\");",
                        "\t\tdev_warn(&intf->dev,",
                        "\t\t\t\"please report to V4L ML at linux-media@vger.kernel.org\\n\");",
                        "\t}",
                        "",
                        "\t/* set led to connect state */",
                        "\tsi470x_set_led_state(radio, BLINK_GREEN_LED);",
                        "",
                        "\t/* rds buffer allocation */",
                        "\tradio->buf_size = rds_buf * 3;",
                        "\tradio->buffer = kmalloc(radio->buf_size, GFP_KERNEL);",
                        "\tif (!radio->buffer) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto err_ctrl;",
                        "\t}",
                        "",
                        "\t/* rds buffer configuration */",
                        "\tradio->wr_index = 0;",
                        "\tradio->rd_index = 0;",
                        "\tinit_waitqueue_head(&radio->read_queue);",
                        "\tusb_set_intfdata(intf, radio);",
                        "",
                        "\t/* start radio */",
                        "\tretval = si470x_start_usb(radio);",
                        "\tif (retval < 0)",
                        "\t\tgoto err_buf;",
                        "",
                        "\t/* set initial frequency */",
                        "\tsi470x_set_freq(radio, 87.5 * FREQ_MUL); /* available in all regions */",
                        "",
                        "\t/* register video device */",
                        "\tretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO,",
                        "\t\t\tradio_nr);",
                        "\tif (retval) {",
                        "\t\tdev_err(&intf->dev, \"Could not register video device\\n\");",
                        "\t\tgoto err_all;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "err_all:",
                        "\tusb_kill_urb(radio->int_in_urb);",
                        "err_buf:",
                        "\tkfree(radio->buffer);",
                        "err_ctrl:",
                        "\tv4l2_ctrl_handler_free(&radio->hdl);",
                        "err_dev:",
                        "\tv4l2_device_unregister(&radio->v4l2_dev);",
                        "err_urb:",
                        "\tusb_free_urb(radio->int_in_urb);",
                        "err_intbuffer:",
                        "\tkfree(radio->int_in_buffer);",
                        "err_usbbuf:",
                        "\tkfree(radio->usb_buf);",
                        "err_radio:",
                        "\tkfree(radio);",
                        "err_initial:",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 560,
                    "highlight": 735
                }
            ],
            "ins_idx": 2436,
            "addr": "0xffffffff8239b31e"
        }
    },
    "ins": {
        "396": {
            "name": "mov rax, qword ptr [rbx + 0x5a8]",
            "desc": "Invalid Memory Access\nUse-After-Free.",
            "call_idx": 41163,
            "inputs": [
                77923,
                77924
            ],
            "outputs": [
                77925
            ]
        },
        "386": {
            "name": "ret ",
            "desc": "pointer free",
            "call_idx": 8147,
            "inputs": [
                14072,
                14073
            ],
            "outputs": [
                14074
            ]
        },
        "810": {
            "name": "mov rbx, qword ptr [rbp + 0xa8]",
            "desc": "",
            "call_idx": 41162,
            "inputs": [
                77920,
                77921
            ],
            "outputs": [
                77922
            ]
        },
        "800": {
            "name": "mov rdi, rbp",
            "desc": "",
            "call_idx": 8145,
            "inputs": [
                14070
            ],
            "outputs": [
                14071
            ]
        },
        "1243": {
            "name": "mov qword ptr [rbp + 0xa8], rbx",
            "desc": "",
            "call_idx": 7929,
            "inputs": [
                13688,
                13689
            ],
            "outputs": [
                13690
            ]
        },
        "1785": {
            "name": "mov rbp, rax",
            "desc": "",
            "call_idx": 7315,
            "inputs": [
                12620
            ],
            "outputs": [
                12621
            ]
        },
        "1810": {
            "name": "mov rbx, rdi",
            "desc": "",
            "call_idx": 7925,
            "inputs": [
                13677
            ],
            "outputs": [
                13678
            ]
        },
        "2436": {
            "name": "mov rdi, rbp",
            "desc": "",
            "call_idx": 7919,
            "inputs": [
                13667
            ],
            "outputs": [
                13668
            ]
        }
    },
    "data": {
        "77923": {
            "name": "RBX",
            "ins_idx": 396,
            "value": "0xffff8881008cd000",
            "sources": []
        },
        "77924": {
            "name": "[0xffff8881008cd5a8]",
            "ins_idx": 396,
            "value": "0x0",
            "sources": []
        },
        "77925": {
            "name": "RAX",
            "ins_idx": 396,
            "value": "0x0",
            "sources": []
        },
        "14072": {
            "name": "RDI",
            "ins_idx": 386,
            "value": "0xffff8881008cd000",
            "sources": []
        },
        "14073": {
            "name": "[0xffff8881008cd000]",
            "ins_idx": 386,
            "value": "0x0",
            "sources": []
        },
        "14074": {
            "name": "[0xffff8881008cd000]",
            "ins_idx": 386,
            "value": "0x0",
            "sources": []
        },
        "77920": {
            "name": "RBP",
            "ins_idx": 810,
            "value": "0xffff8881002eb900",
            "sources": []
        },
        "77921": {
            "name": "[0xffff8881002eb9a8]",
            "ins_idx": 810,
            "value": "0xffff8881008cd000",
            "sources": []
        },
        "77922": {
            "name": "RBX",
            "ins_idx": 810,
            "value": "0xffff8881008cd000",
            "sources": [
                77923
            ]
        },
        "14070": {
            "name": "RBP",
            "ins_idx": 800,
            "value": "0xffff8881008cd000",
            "sources": []
        },
        "14071": {
            "name": "RDI",
            "ins_idx": 800,
            "value": "0xffff8881008cd000",
            "sources": [
                14072
            ]
        },
        "13688": {
            "name": "RBP",
            "ins_idx": 1243,
            "value": "0xffff8881002eb900",
            "sources": []
        },
        "13689": {
            "name": "RBX",
            "ins_idx": 1243,
            "value": "0xffff8881008cd000",
            "sources": []
        },
        "13690": {
            "name": "[0xffff8881002eb9a8]",
            "ins_idx": 1243,
            "value": "0xffff8881008cd000",
            "sources": [
                77921
            ]
        },
        "12620": {
            "name": "RAX",
            "ins_idx": 1785,
            "value": "0xffff8881008cd000",
            "sources": []
        },
        "12621": {
            "name": "RBP",
            "ins_idx": 1785,
            "value": "0xffff8881008cd000",
            "sources": [
                14070,
                13667
            ]
        },
        "13677": {
            "name": "RDI",
            "ins_idx": 1810,
            "value": "0xffff8881008cd000",
            "sources": []
        },
        "13678": {
            "name": "RBX",
            "ins_idx": 1810,
            "value": "0xffff8881008cd000",
            "sources": [
                13689
            ]
        },
        "13667": {
            "name": "RBP",
            "ins_idx": 2436,
            "value": "0xffff8881008cd000",
            "sources": []
        },
        "13668": {
            "name": "RDI",
            "ins_idx": 2436,
            "value": "0xffff8881008cd000",
            "sources": [
                13677
            ]
        }
    },
    "chain": {
        "396": [
            810
        ],
        "386": [
            800
        ],
        "810": [
            1243
        ],
        "800": [
            1785
        ],
        "1243": [
            1810
        ],
        "1810": [
            2436
        ],
        "2436": [
            1785
        ]
    }
}