{
    "report": "https://syzkaller.appspot.com/bug?id=91f769e6299331f7ab779fb44b4c269de4512e7b",
    "title": "general protection fault in kvm_hv_irq_routing_update",
    "call": {
        "1709": {
            "name": "+0x57",
            "parent_idx": 1692,
            "source_line": [
                {
                    "file": "arch/x86/kvm/hyperv.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/hyperv.c?id=a99163e9#n479",
                    "code": [
                        "static int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vpidx, u32 sint, int gsi)",
                        "{",
                        "\tstruct kvm_vcpu_hv_synic *synic;",
                        "",
                        "\tsynic = synic_get(kvm, vpidx);",
                        "\tif (!synic)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tatomic_set(&synic->sint_to_gsi[sint], gsi);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 471,
                    "highlight": 479
                },
                {
                    "file": "arch/x86/kvm/hyperv.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/hyperv.c?id=a99163e9#n498",
                    "code": [
                        "void kvm_hv_irq_routing_update(struct kvm *kvm)",
                        "{",
                        "\tstruct kvm_irq_routing_table *irq_rt;",
                        "\tstruct kvm_kernel_irq_routing_entry *e;",
                        "\tu32 gsi;",
                        "",
                        "\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,",
                        "\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));",
                        "",
                        "\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {",
                        "\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {",
                        "\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)",
                        "\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,",
                        "\t\t\t\t\t\t    e->hv_sint.sint, gsi);",
                        "\t\t}",
                        "\t}",
                        "}"
                    ],
                    "start": 486,
                    "highlight": 498
                }
            ],
            "ins_idx": 9,
            "addr": "0xffffffff81060fb7"
        },
        "1692": {
            "name": "kvm_arch_irq_routing_update",
            "parent_idx": 1646,
            "source_line": [
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/irqchip.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/irqchip.c?id=a99163e9#n223",
                    "code": [
                        "int kvm_set_irq_routing(struct kvm *kvm,",
                        "\t\t\tconst struct kvm_irq_routing_entry *ue,",
                        "\t\t\tunsigned nr,",
                        "\t\t\tunsigned flags)",
                        "{",
                        "\tstruct kvm_irq_routing_table *new, *old;",
                        "\tstruct kvm_kernel_irq_routing_entry *e;",
                        "\tu32 i, j, nr_rt_entries = 0;",
                        "\tint r;",
                        "",
                        "\tfor (i = 0; i < nr; ++i) {",
                        "\t\tif (ue[i].gsi >= KVM_MAX_IRQ_ROUTES)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tnr_rt_entries = max(nr_rt_entries, ue[i].gsi);",
                        "\t}",
                        "",
                        "\tnr_rt_entries += 1;",
                        "",
                        "\tnew = kzalloc(struct_size(new, map, nr_rt_entries), GFP_KERNEL_ACCOUNT);",
                        "\tif (!new)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tnew->nr_rt_entries = nr_rt_entries;",
                        "\tfor (i = 0; i < KVM_NR_IRQCHIPS; i++)",
                        "\t\tfor (j = 0; j < KVM_IRQCHIP_NUM_PINS; j++)",
                        "\t\t\tnew->chip[i][j] = -1;",
                        "",
                        "\tfor (i = 0; i < nr; ++i) {",
                        "\t\tr = -ENOMEM;",
                        "\t\te = kzalloc(sizeof(*e), GFP_KERNEL_ACCOUNT);",
                        "\t\tif (!e)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EINVAL;",
                        "\t\tswitch (ue->type) {",
                        "\t\tcase KVM_IRQ_ROUTING_MSI:",
                        "\t\t\tif (ue->flags & ~KVM_MSI_VALID_DEVID)",
                        "\t\t\t\tgoto free_entry;",
                        "\t\t\tbreak;",
                        "\t\tdefault:",
                        "\t\t\tif (ue->flags)",
                        "\t\t\t\tgoto free_entry;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tr = setup_routing_entry(kvm, new, e, ue);",
                        "\t\tif (r)",
                        "\t\t\tgoto free_entry;",
                        "\t\t++ue;",
                        "\t}",
                        "",
                        "\tmutex_lock(&kvm->irq_lock);",
                        "\told = rcu_dereference_protected(kvm->irq_routing, 1);",
                        "\trcu_assign_pointer(kvm->irq_routing, new);",
                        "\tkvm_irq_routing_update(kvm);",
                        "\tkvm_arch_irq_routing_update(kvm);",
                        "\tmutex_unlock(&kvm->irq_lock);",
                        "",
                        "\tkvm_arch_post_irq_routing_update(kvm);",
                        "",
                        "\tsynchronize_srcu_expedited(&kvm->irq_srcu);",
                        "",
                        "\tnew = old;",
                        "\tr = 0;",
                        "\tgoto out;",
                        "",
                        "free_entry:",
                        "\tkfree(e);",
                        "out:",
                        "\tfree_irq_routing_table(new);",
                        "",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 169,
                    "highlight": 223
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8102a6ab"
        },
        "1646": {
            "name": "kvm_set_irq_routing",
            "parent_idx": 1591,
            "source_line": [
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=a99163e9#n3959",
                    "code": [
                        "static long kvm_vm_ioctl(struct file *filp,",
                        "\t\t\t   unsigned int ioctl, unsigned long arg)",
                        "{",
                        "\tstruct kvm *kvm = filp->private_data;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint r;",
                        "",
                        "\tif (kvm->mm != current->mm)",
                        "\t\treturn -EIO;",
                        "\tswitch (ioctl) {",
                        "\tcase KVM_CREATE_VCPU:",
                        "\t\tr = kvm_vm_ioctl_create_vcpu(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_ENABLE_CAP: {",
                        "\t\tstruct kvm_enable_cap cap;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cap, argp, sizeof(cap)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_USER_MEMORY_REGION: {",
                        "\t\tstruct kvm_userspace_memory_region kvm_userspace_mem;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&kvm_userspace_mem, argp,",
                        "\t\t\t\t\t\tsizeof(kvm_userspace_mem)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_DIRTY_LOG: {",
                        "\t\tstruct kvm_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT",
                        "\tcase KVM_CLEAR_DIRTY_LOG: {",
                        "\t\tstruct kvm_clear_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_KVM_MMIO",
                        "\tcase KVM_REGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_UNREGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "\tcase KVM_IRQFD: {",
                        "\t\tstruct kvm_irqfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_irqfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_IOEVENTFD: {",
                        "\t\tstruct kvm_ioeventfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_ioeventfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_HAVE_KVM_MSI",
                        "\tcase KVM_SIGNAL_MSI: {",
                        "\t\tstruct kvm_msi msi;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&msi, argp, sizeof(msi)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_send_userspace_msi(kvm, &msi);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef __KVM_HAVE_IRQ_LINE",
                        "\tcase KVM_IRQ_LINE_STATUS:",
                        "\tcase KVM_IRQ_LINE: {",
                        "\t\tstruct kvm_irq_level irq_event;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&irq_event, argp, sizeof(irq_event)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_irq_line(kvm, &irq_event,",
                        "\t\t\t\t\tioctl == KVM_IRQ_LINE_STATUS);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {",
                        "\t\t\tif (copy_to_user(argp, &irq_event, sizeof(irq_event)))",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING",
                        "\tcase KVM_SET_GSI_ROUTING: {",
                        "\t\tstruct kvm_irq_routing routing;",
                        "\t\tstruct kvm_irq_routing __user *urouting;",
                        "\t\tstruct kvm_irq_routing_entry *entries = NULL;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&routing, argp, sizeof(routing)))",
                        "\t\t\tgoto out;",
                        "\t\tr = -EINVAL;",
                        "\t\tif (!kvm_arch_can_set_irq_routing(kvm))",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr > KVM_MAX_IRQ_ROUTES)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.flags)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr) {",
                        "\t\t\turouting = argp;",
                        "\t\t\tentries = vmemdup_user(urouting->entries,",
                        "\t\t\t\t\t       array_size(sizeof(*entries),",
                        "\t\t\t\t\t\t\t  routing.nr));",
                        "\t\t\tif (IS_ERR(entries)) {",
                        "\t\t\t\tr = PTR_ERR(entries);",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tr = kvm_set_irq_routing(kvm, entries, routing.nr,",
                        "\t\t\t\t\trouting.flags);",
                        "\t\tkvfree(entries);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */",
                        "\tcase KVM_CREATE_DEVICE: {",
                        "\t\tstruct kvm_create_device cd;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cd, argp, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_ioctl_create_device(kvm, &cd);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &cd, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_CHECK_EXTENSION:",
                        "\t\tr = kvm_vm_ioctl_check_extension_generic(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_RESET_DIRTY_RINGS:",
                        "\t\tr = kvm_vm_ioctl_reset_dirty_pages(kvm);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tr = kvm_arch_vm_ioctl(filp, ioctl, arg);",
                        "\t}",
                        "out:",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3807,
                    "highlight": 3959
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81027a94"
        },
        "1591": {
            "name": "kvm_vm_ioctl(indirect)",
            "parent_idx": 1550,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=a99163e9#n48",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 30,
                    "highlight": 48
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=a99163e9#n753",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 739,
                    "highlight": 753
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=a99163e9#n739",
                    "code": [
                        "/*",
                        " * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.",
                        " * It's just a simple helper for sys_ioctl and compat_sys_ioctl.",
                        " *",
                        " * When you add any new common ioctls to the switches above and below,",
                        " * please ensure they have compatible arguments in compat mode.",
                        " */",
                        "static int do_vfs_ioctl(struct file *filp, unsigned int fd,",
                        "\t\t\tunsigned int cmd, unsigned long arg)",
                        "{",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tstruct inode *inode = file_inode(filp);",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIOCLEX:",
                        "\t\tset_close_on_exec(fd, 1);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONCLEX:",
                        "\t\tset_close_on_exec(fd, 0);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONBIO:",
                        "\t\treturn ioctl_fionbio(filp, argp);",
                        "",
                        "\tcase FIOASYNC:",
                        "\t\treturn ioctl_fioasync(fd, filp, argp);",
                        "",
                        "\tcase FIOQSIZE:",
                        "\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||",
                        "\t\t    S_ISLNK(inode->i_mode)) {",
                        "\t\t\tloff_t res = inode_get_bytes(inode);",
                        "\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?",
                        "\t\t\t\t\t    -EFAULT : 0;",
                        "\t\t}",
                        "",
                        "\t\treturn -ENOTTY;",
                        "",
                        "\tcase FIFREEZE:",
                        "\t\treturn ioctl_fsfreeze(filp);",
                        "",
                        "\tcase FITHAW:",
                        "\t\treturn ioctl_fsthaw(filp);",
                        "",
                        "\tcase FS_IOC_FIEMAP:",
                        "\t\treturn ioctl_fiemap(filp, argp);",
                        "",
                        "\tcase FIGETBSZ:",
                        "\t\t/* anon_bdev filesystems may not have a block size */",
                        "\t\tif (!inode->i_sb->s_blocksize)",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
                        "",
                        "\tcase FICLONE:",
                        "\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);",
                        "",
                        "\tcase FICLONERANGE:",
                        "\t\treturn ioctl_file_clone_range(filp, argp);",
                        "",
                        "\tcase FIDEDUPERANGE:",
                        "\t\treturn ioctl_file_dedupe_range(filp, argp);",
                        "",
                        "\tcase FIONREAD:",
                        "\t\tif (!S_ISREG(inode->i_mode))",
                        "\t\t\treturn vfs_ioctl(filp, cmd, arg);",
                        "",
                        "\t\treturn put_user(i_size_read(inode) - filp->f_pos,",
                        "\t\t\t\t(int __user *)argp);",
                        "",
                        "\tdefault:",
                        "\t\tif (S_ISREG(inode->i_mode))",
                        "\t\t\treturn file_ioctl(filp, cmd, argp);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn -ENOIOCTLCMD;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 660,
                    "highlight": 739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81282209"
        },
        "1550": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 1547,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=a99163e9#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c2abae"
        },
        "1547": {
            "name": "do_syscall_64",
            "parent_idx": 1537,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=a99163e9#n112",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t * In the Xen PV case we must use iret anyway.",
                        "\t */",
                        "",
                        "\tALTERNATIVE \"\", \"jmp\tswapgs_restore_regs_and_return_to_usermode\", \\",
                        "\t\tX86_FEATURE_XENPV",
                        "",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tswapgs",
                        "\tsysretq",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 87,
                    "highlight": 112
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e00077"
        },
        "1537": {
            "name": "87_syscall_11",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1708": {
            "name": "+0x50",
            "parent_idx": 1692,
            "source_line": [
                {
                    "file": "arch/x86/kvm/hyperv.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/hyperv.h?id=a99163e9#n60",
                    "code": [
                        "static inline struct kvm_vcpu_hv *to_hv_vcpu(struct kvm_vcpu *vcpu)",
                        "{",
                        "\treturn vcpu->arch.hyperv;",
                        "}"
                    ],
                    "start": 58,
                    "highlight": 60
                },
                {
                    "file": "arch/x86/kvm/hyperv.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/hyperv.h?id=a99163e9#n65",
                    "code": [
                        "static inline struct kvm_vcpu_hv_synic *to_hv_synic(struct kvm_vcpu *vcpu)",
                        "{",
                        "\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);",
                        "",
                        "\treturn &hv_vcpu->synic;",
                        "}"
                    ],
                    "start": 63,
                    "highlight": 65
                },
                {
                    "file": "arch/x86/kvm/hyperv.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/hyperv.c?id=a99163e9#n164",
                    "code": [
                        "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)",
                        "{",
                        "\tstruct kvm_vcpu *vcpu;",
                        "\tstruct kvm_vcpu_hv_synic *synic;",
                        "",
                        "\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);",
                        "\tif (!vcpu)",
                        "\t\treturn NULL;",
                        "\tsynic = to_hv_synic(vcpu);",
                        "\treturn (synic->active) ? synic : NULL;",
                        "}"
                    ],
                    "start": 156,
                    "highlight": 164
                },
                {
                    "file": "arch/x86/kvm/hyperv.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/hyperv.c?id=a99163e9#n475",
                    "code": [
                        "static int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vpidx, u32 sint, int gsi)",
                        "{",
                        "\tstruct kvm_vcpu_hv_synic *synic;",
                        "",
                        "\tsynic = synic_get(kvm, vpidx);",
                        "\tif (!synic)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tatomic_set(&synic->sint_to_gsi[sint], gsi);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 471,
                    "highlight": 475
                },
                {
                    "file": "arch/x86/kvm/hyperv.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/hyperv.c?id=a99163e9#n498",
                    "code": [
                        "void kvm_hv_irq_routing_update(struct kvm *kvm)",
                        "{",
                        "\tstruct kvm_irq_routing_table *irq_rt;",
                        "\tstruct kvm_kernel_irq_routing_entry *e;",
                        "\tu32 gsi;",
                        "",
                        "\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,",
                        "\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));",
                        "",
                        "\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {",
                        "\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {",
                        "\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)",
                        "\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,",
                        "\t\t\t\t\t\t    e->hv_sint.sint, gsi);",
                        "\t\t}",
                        "\t}",
                        "}"
                    ],
                    "start": 486,
                    "highlight": 498
                }
            ],
            "ins_idx": 27,
            "addr": "0xffffffff81060fb0"
        },
        "1249": {
            "name": "+0x0",
            "parent_idx": 1248,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=a99163e9#n2908",
                    "code": [
                        "\ttrace_kmem_cache_alloc(_RET_IP_, ret, s->object_size,",
                        "\t\t\t\ts->size, gfpflags);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2907,
                    "highlight": 2908
                }
            ],
            "ins_idx": 47,
            "addr": "0xffffffff81260f70"
        },
        "1248": {
            "name": "kmem_cache_alloc",
            "parent_idx": 1246,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=a99163e9#n674",
                    "code": [
                        "/*",
                        " * Shortcuts",
                        " */",
                        "static inline void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)",
                        "{",
                        "\treturn kmem_cache_alloc(k, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 669,
                    "highlight": 674
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=a99163e9#n3164",
                    "code": [
                        "/*",
                        " * Creates some virtual cpus.  Good luck creating more than one.",
                        " */",
                        "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)",
                        "{",
                        "\tint r;",
                        "\tstruct kvm_vcpu *vcpu;",
                        "\tstruct page *page;",
                        "",
                        "\tif (id >= KVM_MAX_VCPU_ID)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm->created_vcpus == KVM_MAX_VCPUS) {",
                        "\t\tmutex_unlock(&kvm->lock);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tkvm->created_vcpus++;",
                        "\tmutex_unlock(&kvm->lock);",
                        "",
                        "\tr = kvm_arch_vcpu_precreate(kvm, id);",
                        "\tif (r)",
                        "\t\tgoto vcpu_decrement;",
                        "",
                        "\tvcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);",
                        "\tif (!vcpu) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_decrement;",
                        "\t}",
                        "",
                        "\tBUILD_BUG_ON(sizeof(struct kvm_run) > PAGE_SIZE);",
                        "\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);",
                        "\tif (!page) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_free;",
                        "\t}",
                        "\tvcpu->run = page_address(page);",
                        "",
                        "\tkvm_vcpu_init(vcpu, kvm, id);",
                        "",
                        "\tr = kvm_arch_vcpu_create(vcpu);",
                        "\tif (r)",
                        "\t\tgoto vcpu_free_run_page;",
                        "",
                        "\tif (kvm->dirty_ring_size) {",
                        "\t\tr = kvm_dirty_ring_alloc(&vcpu->dirty_ring,",
                        "\t\t\t\t\t id, kvm->dirty_ring_size);",
                        "\t\tif (r)",
                        "\t\t\tgoto arch_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm_get_vcpu_by_id(kvm, id)) {",
                        "\t\tr = -EEXIST;",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tvcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);",
                        "\tBUG_ON(kvm->vcpus[vcpu->vcpu_idx]);",
                        "",
                        "\t/* Now it's all set up, let userspace reach it */",
                        "\tkvm_get_kvm(kvm);",
                        "\tr = create_vcpu_fd(vcpu);",
                        "\tif (r < 0) {",
                        "\t\tkvm_put_kvm_no_destroy(kvm);",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tkvm->vcpus[vcpu->vcpu_idx] = vcpu;",
                        "",
                        "\t/*",
                        "\t * Pairs with smp_rmb() in kvm_get_vcpu.  Write kvm->vcpus",
                        "\t * before kvm->online_vcpu's incremented value.",
                        "\t */",
                        "\tsmp_wmb();",
                        "\tatomic_inc(&kvm->online_vcpus);",
                        "",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_arch_vcpu_postcreate(vcpu);",
                        "\tkvm_create_vcpu_debugfs(vcpu);",
                        "\treturn r;",
                        "",
                        "unlock_vcpu_destroy:",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_dirty_ring_free(&vcpu->dirty_ring);",
                        "arch_vcpu_destroy:",
                        "\tkvm_arch_vcpu_destroy(vcpu);",
                        "vcpu_free_run_page:",
                        "\tfree_page((unsigned long)vcpu->run);",
                        "vcpu_free:",
                        "\tkmem_cache_free(kvm_vcpu_cache, vcpu);",
                        "vcpu_decrement:",
                        "\tmutex_lock(&kvm->lock);",
                        "\tkvm->created_vcpus--;",
                        "\tmutex_unlock(&kvm->lock);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3139,
                    "highlight": 3164
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=a99163e9#n3818",
                    "code": [
                        "static long kvm_vm_ioctl(struct file *filp,",
                        "\t\t\t   unsigned int ioctl, unsigned long arg)",
                        "{",
                        "\tstruct kvm *kvm = filp->private_data;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint r;",
                        "",
                        "\tif (kvm->mm != current->mm)",
                        "\t\treturn -EIO;",
                        "\tswitch (ioctl) {",
                        "\tcase KVM_CREATE_VCPU:",
                        "\t\tr = kvm_vm_ioctl_create_vcpu(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_ENABLE_CAP: {",
                        "\t\tstruct kvm_enable_cap cap;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cap, argp, sizeof(cap)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_USER_MEMORY_REGION: {",
                        "\t\tstruct kvm_userspace_memory_region kvm_userspace_mem;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&kvm_userspace_mem, argp,",
                        "\t\t\t\t\t\tsizeof(kvm_userspace_mem)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_DIRTY_LOG: {",
                        "\t\tstruct kvm_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT",
                        "\tcase KVM_CLEAR_DIRTY_LOG: {",
                        "\t\tstruct kvm_clear_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_KVM_MMIO",
                        "\tcase KVM_REGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_UNREGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "\tcase KVM_IRQFD: {",
                        "\t\tstruct kvm_irqfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_irqfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_IOEVENTFD: {",
                        "\t\tstruct kvm_ioeventfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_ioeventfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_HAVE_KVM_MSI",
                        "\tcase KVM_SIGNAL_MSI: {",
                        "\t\tstruct kvm_msi msi;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&msi, argp, sizeof(msi)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_send_userspace_msi(kvm, &msi);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef __KVM_HAVE_IRQ_LINE",
                        "\tcase KVM_IRQ_LINE_STATUS:",
                        "\tcase KVM_IRQ_LINE: {",
                        "\t\tstruct kvm_irq_level irq_event;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&irq_event, argp, sizeof(irq_event)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_irq_line(kvm, &irq_event,",
                        "\t\t\t\t\tioctl == KVM_IRQ_LINE_STATUS);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {",
                        "\t\t\tif (copy_to_user(argp, &irq_event, sizeof(irq_event)))",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING",
                        "\tcase KVM_SET_GSI_ROUTING: {",
                        "\t\tstruct kvm_irq_routing routing;",
                        "\t\tstruct kvm_irq_routing __user *urouting;",
                        "\t\tstruct kvm_irq_routing_entry *entries = NULL;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&routing, argp, sizeof(routing)))",
                        "\t\t\tgoto out;",
                        "\t\tr = -EINVAL;",
                        "\t\tif (!kvm_arch_can_set_irq_routing(kvm))",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr > KVM_MAX_IRQ_ROUTES)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.flags)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr) {",
                        "\t\t\turouting = argp;",
                        "\t\t\tentries = vmemdup_user(urouting->entries,",
                        "\t\t\t\t\t       array_size(sizeof(*entries),",
                        "\t\t\t\t\t\t\t  routing.nr));",
                        "\t\t\tif (IS_ERR(entries)) {",
                        "\t\t\t\tr = PTR_ERR(entries);",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tr = kvm_set_irq_routing(kvm, entries, routing.nr,",
                        "\t\t\t\t\trouting.flags);",
                        "\t\tkvfree(entries);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */",
                        "\tcase KVM_CREATE_DEVICE: {",
                        "\t\tstruct kvm_create_device cd;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cd, argp, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_ioctl_create_device(kvm, &cd);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &cd, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_CHECK_EXTENSION:",
                        "\t\tr = kvm_vm_ioctl_check_extension_generic(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_RESET_DIRTY_RINGS:",
                        "\t\tr = kvm_vm_ioctl_reset_dirty_pages(kvm);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tr = kvm_arch_vm_ioctl(filp, ioctl, arg);",
                        "\t}",
                        "out:",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3807,
                    "highlight": 3818
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81027cfc"
        },
        "1246": {
            "name": "kvm_vm_ioctl(indirect)",
            "parent_idx": 1215,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=a99163e9#n48",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 30,
                    "highlight": 48
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=a99163e9#n753",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 739,
                    "highlight": 753
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=a99163e9#n739",
                    "code": [
                        "/*",
                        " * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.",
                        " * It's just a simple helper for sys_ioctl and compat_sys_ioctl.",
                        " *",
                        " * When you add any new common ioctls to the switches above and below,",
                        " * please ensure they have compatible arguments in compat mode.",
                        " */",
                        "static int do_vfs_ioctl(struct file *filp, unsigned int fd,",
                        "\t\t\tunsigned int cmd, unsigned long arg)",
                        "{",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tstruct inode *inode = file_inode(filp);",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIOCLEX:",
                        "\t\tset_close_on_exec(fd, 1);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONCLEX:",
                        "\t\tset_close_on_exec(fd, 0);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONBIO:",
                        "\t\treturn ioctl_fionbio(filp, argp);",
                        "",
                        "\tcase FIOASYNC:",
                        "\t\treturn ioctl_fioasync(fd, filp, argp);",
                        "",
                        "\tcase FIOQSIZE:",
                        "\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||",
                        "\t\t    S_ISLNK(inode->i_mode)) {",
                        "\t\t\tloff_t res = inode_get_bytes(inode);",
                        "\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?",
                        "\t\t\t\t\t    -EFAULT : 0;",
                        "\t\t}",
                        "",
                        "\t\treturn -ENOTTY;",
                        "",
                        "\tcase FIFREEZE:",
                        "\t\treturn ioctl_fsfreeze(filp);",
                        "",
                        "\tcase FITHAW:",
                        "\t\treturn ioctl_fsthaw(filp);",
                        "",
                        "\tcase FS_IOC_FIEMAP:",
                        "\t\treturn ioctl_fiemap(filp, argp);",
                        "",
                        "\tcase FIGETBSZ:",
                        "\t\t/* anon_bdev filesystems may not have a block size */",
                        "\t\tif (!inode->i_sb->s_blocksize)",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
                        "",
                        "\tcase FICLONE:",
                        "\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);",
                        "",
                        "\tcase FICLONERANGE:",
                        "\t\treturn ioctl_file_clone_range(filp, argp);",
                        "",
                        "\tcase FIDEDUPERANGE:",
                        "\t\treturn ioctl_file_dedupe_range(filp, argp);",
                        "",
                        "\tcase FIONREAD:",
                        "\t\tif (!S_ISREG(inode->i_mode))",
                        "\t\t\treturn vfs_ioctl(filp, cmd, arg);",
                        "",
                        "\t\treturn put_user(i_size_read(inode) - filp->f_pos,",
                        "\t\t\t\t(int __user *)argp);",
                        "",
                        "\tdefault:",
                        "\t\tif (S_ISREG(inode->i_mode))",
                        "\t\t\treturn file_ioctl(filp, cmd, argp);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn -ENOIOCTLCMD;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 660,
                    "highlight": 739
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81282209"
        },
        "1215": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 1212,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=a99163e9#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c2abae"
        },
        "1212": {
            "name": "do_syscall_64",
            "parent_idx": 1205,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=a99163e9#n112",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t * In the Xen PV case we must use iret anyway.",
                        "\t */",
                        "",
                        "\tALTERNATIVE \"\", \"jmp\tswapgs_restore_regs_and_return_to_usermode\", \\",
                        "\t\tX86_FEATURE_XENPV",
                        "",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tswapgs",
                        "\tsysretq",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 87,
                    "highlight": 112
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e00077"
        },
        "1205": {
            "name": "71_syscall_10",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1707": {
            "name": "+0x1f",
            "parent_idx": 1699,
            "source_line": [
                {
                    "file": "./include/linux/kvm_host.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/kvm_host.h?id=a99163e9#n567",
                    "code": [
                        "static inline struct kvm_vcpu *kvm_get_vcpu(struct kvm *kvm, int i)",
                        "{",
                        "\tint num_vcpus = atomic_read(&kvm->online_vcpus);",
                        "\ti = array_index_nospec(i, num_vcpus);",
                        "",
                        "\t/* Pairs with smp_wmb() in kvm_vm_ioctl_create_vcpu.  */",
                        "\tsmp_rmb();",
                        "\treturn kvm->vcpus[i];",
                        "}"
                    ],
                    "start": 560,
                    "highlight": 567
                },
                {
                    "file": "arch/x86/kvm/hyperv.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/hyperv.c?id=a99163e9#n147",
                    "code": [
                        "static struct kvm_vcpu *get_vcpu_by_vpidx(struct kvm *kvm, u32 vpidx)",
                        "{",
                        "\tstruct kvm_vcpu *vcpu = NULL;",
                        "\tint i;",
                        "",
                        "\tif (vpidx >= KVM_MAX_VCPUS)",
                        "\t\treturn NULL;",
                        "",
                        "\tvcpu = kvm_get_vcpu(kvm, vpidx);",
                        "\tif (vcpu && kvm_hv_get_vpindex(vcpu) == vpidx)",
                        "\t\treturn vcpu;",
                        "\tkvm_for_each_vcpu(i, vcpu, kvm)",
                        "\t\tif (kvm_hv_get_vpindex(vcpu) == vpidx)",
                        "\t\t\treturn vcpu;",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 139,
                    "highlight": 147
                }
            ],
            "ins_idx": 46,
            "addr": "0xffffffff8105ffcf"
        },
        "1699": {
            "name": "get_vcpu_by_vpidx",
            "parent_idx": 1692,
            "source_line": [
                {
                    "file": "arch/x86/kvm/hyperv.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/hyperv.c?id=a99163e9#n161",
                    "code": [
                        "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)",
                        "{",
                        "\tstruct kvm_vcpu *vcpu;",
                        "\tstruct kvm_vcpu_hv_synic *synic;",
                        "",
                        "\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);",
                        "\tif (!vcpu)",
                        "\t\treturn NULL;",
                        "\tsynic = to_hv_synic(vcpu);",
                        "\treturn (synic->active) ? synic : NULL;",
                        "}"
                    ],
                    "start": 156,
                    "highlight": 161
                },
                {
                    "file": "arch/x86/kvm/hyperv.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/hyperv.c?id=a99163e9#n475",
                    "code": [
                        "static int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vpidx, u32 sint, int gsi)",
                        "{",
                        "\tstruct kvm_vcpu_hv_synic *synic;",
                        "",
                        "\tsynic = synic_get(kvm, vpidx);",
                        "\tif (!synic)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tatomic_set(&synic->sint_to_gsi[sint], gsi);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 471,
                    "highlight": 475
                },
                {
                    "file": "arch/x86/kvm/hyperv.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/hyperv.c?id=a99163e9#n498",
                    "code": [
                        "void kvm_hv_irq_routing_update(struct kvm *kvm)",
                        "{",
                        "\tstruct kvm_irq_routing_table *irq_rt;",
                        "\tstruct kvm_kernel_irq_routing_entry *e;",
                        "\tu32 gsi;",
                        "",
                        "\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,",
                        "\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));",
                        "",
                        "\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {",
                        "\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {",
                        "\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)",
                        "\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,",
                        "\t\t\t\t\t\t    e->hv_sint.sint, gsi);",
                        "\t\t}",
                        "\t}",
                        "}"
                    ],
                    "start": 486,
                    "highlight": 498
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81060fa6"
        },
        "1368": {
            "name": "+0xa9f",
            "parent_idx": 1246,
            "source_line": [
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=a99163e9#n3208",
                    "code": [
                        "/*",
                        " * Creates some virtual cpus.  Good luck creating more than one.",
                        " */",
                        "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)",
                        "{",
                        "\tint r;",
                        "\tstruct kvm_vcpu *vcpu;",
                        "\tstruct page *page;",
                        "",
                        "\tif (id >= KVM_MAX_VCPU_ID)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm->created_vcpus == KVM_MAX_VCPUS) {",
                        "\t\tmutex_unlock(&kvm->lock);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tkvm->created_vcpus++;",
                        "\tmutex_unlock(&kvm->lock);",
                        "",
                        "\tr = kvm_arch_vcpu_precreate(kvm, id);",
                        "\tif (r)",
                        "\t\tgoto vcpu_decrement;",
                        "",
                        "\tvcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);",
                        "\tif (!vcpu) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_decrement;",
                        "\t}",
                        "",
                        "\tBUILD_BUG_ON(sizeof(struct kvm_run) > PAGE_SIZE);",
                        "\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);",
                        "\tif (!page) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_free;",
                        "\t}",
                        "\tvcpu->run = page_address(page);",
                        "",
                        "\tkvm_vcpu_init(vcpu, kvm, id);",
                        "",
                        "\tr = kvm_arch_vcpu_create(vcpu);",
                        "\tif (r)",
                        "\t\tgoto vcpu_free_run_page;",
                        "",
                        "\tif (kvm->dirty_ring_size) {",
                        "\t\tr = kvm_dirty_ring_alloc(&vcpu->dirty_ring,",
                        "\t\t\t\t\t id, kvm->dirty_ring_size);",
                        "\t\tif (r)",
                        "\t\t\tgoto arch_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm_get_vcpu_by_id(kvm, id)) {",
                        "\t\tr = -EEXIST;",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tvcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);",
                        "\tBUG_ON(kvm->vcpus[vcpu->vcpu_idx]);",
                        "",
                        "\t/* Now it's all set up, let userspace reach it */",
                        "\tkvm_get_kvm(kvm);",
                        "\tr = create_vcpu_fd(vcpu);",
                        "\tif (r < 0) {",
                        "\t\tkvm_put_kvm_no_destroy(kvm);",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tkvm->vcpus[vcpu->vcpu_idx] = vcpu;",
                        "",
                        "\t/*",
                        "\t * Pairs with smp_rmb() in kvm_get_vcpu.  Write kvm->vcpus",
                        "\t * before kvm->online_vcpu's incremented value.",
                        "\t */",
                        "\tsmp_wmb();",
                        "\tatomic_inc(&kvm->online_vcpus);",
                        "",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_arch_vcpu_postcreate(vcpu);",
                        "\tkvm_create_vcpu_debugfs(vcpu);",
                        "\treturn r;",
                        "",
                        "unlock_vcpu_destroy:",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_dirty_ring_free(&vcpu->dirty_ring);",
                        "arch_vcpu_destroy:",
                        "\tkvm_arch_vcpu_destroy(vcpu);",
                        "vcpu_free_run_page:",
                        "\tfree_page((unsigned long)vcpu->run);",
                        "vcpu_free:",
                        "\tkmem_cache_free(kvm_vcpu_cache, vcpu);",
                        "vcpu_decrement:",
                        "\tmutex_lock(&kvm->lock);",
                        "\tkvm->created_vcpus--;",
                        "\tmutex_unlock(&kvm->lock);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3139,
                    "highlight": 3208
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=a99163e9#n3818",
                    "code": [
                        "static long kvm_vm_ioctl(struct file *filp,",
                        "\t\t\t   unsigned int ioctl, unsigned long arg)",
                        "{",
                        "\tstruct kvm *kvm = filp->private_data;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint r;",
                        "",
                        "\tif (kvm->mm != current->mm)",
                        "\t\treturn -EIO;",
                        "\tswitch (ioctl) {",
                        "\tcase KVM_CREATE_VCPU:",
                        "\t\tr = kvm_vm_ioctl_create_vcpu(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_ENABLE_CAP: {",
                        "\t\tstruct kvm_enable_cap cap;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cap, argp, sizeof(cap)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_USER_MEMORY_REGION: {",
                        "\t\tstruct kvm_userspace_memory_region kvm_userspace_mem;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&kvm_userspace_mem, argp,",
                        "\t\t\t\t\t\tsizeof(kvm_userspace_mem)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_DIRTY_LOG: {",
                        "\t\tstruct kvm_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT",
                        "\tcase KVM_CLEAR_DIRTY_LOG: {",
                        "\t\tstruct kvm_clear_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_KVM_MMIO",
                        "\tcase KVM_REGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_UNREGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "\tcase KVM_IRQFD: {",
                        "\t\tstruct kvm_irqfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_irqfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_IOEVENTFD: {",
                        "\t\tstruct kvm_ioeventfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_ioeventfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_HAVE_KVM_MSI",
                        "\tcase KVM_SIGNAL_MSI: {",
                        "\t\tstruct kvm_msi msi;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&msi, argp, sizeof(msi)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_send_userspace_msi(kvm, &msi);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef __KVM_HAVE_IRQ_LINE",
                        "\tcase KVM_IRQ_LINE_STATUS:",
                        "\tcase KVM_IRQ_LINE: {",
                        "\t\tstruct kvm_irq_level irq_event;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&irq_event, argp, sizeof(irq_event)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_irq_line(kvm, &irq_event,",
                        "\t\t\t\t\tioctl == KVM_IRQ_LINE_STATUS);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {",
                        "\t\t\tif (copy_to_user(argp, &irq_event, sizeof(irq_event)))",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING",
                        "\tcase KVM_SET_GSI_ROUTING: {",
                        "\t\tstruct kvm_irq_routing routing;",
                        "\t\tstruct kvm_irq_routing __user *urouting;",
                        "\t\tstruct kvm_irq_routing_entry *entries = NULL;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&routing, argp, sizeof(routing)))",
                        "\t\t\tgoto out;",
                        "\t\tr = -EINVAL;",
                        "\t\tif (!kvm_arch_can_set_irq_routing(kvm))",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr > KVM_MAX_IRQ_ROUTES)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.flags)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr) {",
                        "\t\t\turouting = argp;",
                        "\t\t\tentries = vmemdup_user(urouting->entries,",
                        "\t\t\t\t\t       array_size(sizeof(*entries),",
                        "\t\t\t\t\t\t\t  routing.nr));",
                        "\t\t\tif (IS_ERR(entries)) {",
                        "\t\t\t\tr = PTR_ERR(entries);",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tr = kvm_set_irq_routing(kvm, entries, routing.nr,",
                        "\t\t\t\t\trouting.flags);",
                        "\t\tkvfree(entries);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */",
                        "\tcase KVM_CREATE_DEVICE: {",
                        "\t\tstruct kvm_create_device cd;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cd, argp, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_ioctl_create_device(kvm, &cd);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &cd, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_CHECK_EXTENSION:",
                        "\t\tr = kvm_vm_ioctl_check_extension_generic(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_RESET_DIRTY_RINGS:",
                        "\t\tr = kvm_vm_ioctl_reset_dirty_pages(kvm);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tr = kvm_arch_vm_ioctl(filp, ioctl, arg);",
                        "\t}",
                        "out:",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3807,
                    "highlight": 3818
                }
            ],
            "ins_idx": 73,
            "addr": "0xffffffff81027eff"
        },
        "1250": {
            "name": "+0x8a1",
            "parent_idx": 1246,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=a99163e9#n674",
                    "code": [
                        "/*",
                        " * Shortcuts",
                        " */",
                        "static inline void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)",
                        "{",
                        "\treturn kmem_cache_alloc(k, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 669,
                    "highlight": 674
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=a99163e9#n3164",
                    "code": [
                        "/*",
                        " * Creates some virtual cpus.  Good luck creating more than one.",
                        " */",
                        "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)",
                        "{",
                        "\tint r;",
                        "\tstruct kvm_vcpu *vcpu;",
                        "\tstruct page *page;",
                        "",
                        "\tif (id >= KVM_MAX_VCPU_ID)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm->created_vcpus == KVM_MAX_VCPUS) {",
                        "\t\tmutex_unlock(&kvm->lock);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\tkvm->created_vcpus++;",
                        "\tmutex_unlock(&kvm->lock);",
                        "",
                        "\tr = kvm_arch_vcpu_precreate(kvm, id);",
                        "\tif (r)",
                        "\t\tgoto vcpu_decrement;",
                        "",
                        "\tvcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);",
                        "\tif (!vcpu) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_decrement;",
                        "\t}",
                        "",
                        "\tBUILD_BUG_ON(sizeof(struct kvm_run) > PAGE_SIZE);",
                        "\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);",
                        "\tif (!page) {",
                        "\t\tr = -ENOMEM;",
                        "\t\tgoto vcpu_free;",
                        "\t}",
                        "\tvcpu->run = page_address(page);",
                        "",
                        "\tkvm_vcpu_init(vcpu, kvm, id);",
                        "",
                        "\tr = kvm_arch_vcpu_create(vcpu);",
                        "\tif (r)",
                        "\t\tgoto vcpu_free_run_page;",
                        "",
                        "\tif (kvm->dirty_ring_size) {",
                        "\t\tr = kvm_dirty_ring_alloc(&vcpu->dirty_ring,",
                        "\t\t\t\t\t id, kvm->dirty_ring_size);",
                        "\t\tif (r)",
                        "\t\t\tgoto arch_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tmutex_lock(&kvm->lock);",
                        "\tif (kvm_get_vcpu_by_id(kvm, id)) {",
                        "\t\tr = -EEXIST;",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tvcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);",
                        "\tBUG_ON(kvm->vcpus[vcpu->vcpu_idx]);",
                        "",
                        "\t/* Now it's all set up, let userspace reach it */",
                        "\tkvm_get_kvm(kvm);",
                        "\tr = create_vcpu_fd(vcpu);",
                        "\tif (r < 0) {",
                        "\t\tkvm_put_kvm_no_destroy(kvm);",
                        "\t\tgoto unlock_vcpu_destroy;",
                        "\t}",
                        "",
                        "\tkvm->vcpus[vcpu->vcpu_idx] = vcpu;",
                        "",
                        "\t/*",
                        "\t * Pairs with smp_rmb() in kvm_get_vcpu.  Write kvm->vcpus",
                        "\t * before kvm->online_vcpu's incremented value.",
                        "\t */",
                        "\tsmp_wmb();",
                        "\tatomic_inc(&kvm->online_vcpus);",
                        "",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_arch_vcpu_postcreate(vcpu);",
                        "\tkvm_create_vcpu_debugfs(vcpu);",
                        "\treturn r;",
                        "",
                        "unlock_vcpu_destroy:",
                        "\tmutex_unlock(&kvm->lock);",
                        "\tkvm_dirty_ring_free(&vcpu->dirty_ring);",
                        "arch_vcpu_destroy:",
                        "\tkvm_arch_vcpu_destroy(vcpu);",
                        "vcpu_free_run_page:",
                        "\tfree_page((unsigned long)vcpu->run);",
                        "vcpu_free:",
                        "\tkmem_cache_free(kvm_vcpu_cache, vcpu);",
                        "vcpu_decrement:",
                        "\tmutex_lock(&kvm->lock);",
                        "\tkvm->created_vcpus--;",
                        "\tmutex_unlock(&kvm->lock);",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3139,
                    "highlight": 3164
                },
                {
                    "file": "arch/x86/kvm/../../../virt/kvm/kvm_main.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kvm/../../../virt/kvm/kvm_main.c?id=a99163e9#n3818",
                    "code": [
                        "static long kvm_vm_ioctl(struct file *filp,",
                        "\t\t\t   unsigned int ioctl, unsigned long arg)",
                        "{",
                        "\tstruct kvm *kvm = filp->private_data;",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tint r;",
                        "",
                        "\tif (kvm->mm != current->mm)",
                        "\t\treturn -EIO;",
                        "\tswitch (ioctl) {",
                        "\tcase KVM_CREATE_VCPU:",
                        "\t\tr = kvm_vm_ioctl_create_vcpu(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_ENABLE_CAP: {",
                        "\t\tstruct kvm_enable_cap cap;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cap, argp, sizeof(cap)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_SET_USER_MEMORY_REGION: {",
                        "\t\tstruct kvm_userspace_memory_region kvm_userspace_mem;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&kvm_userspace_mem, argp,",
                        "\t\t\t\t\t\tsizeof(kvm_userspace_mem)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_GET_DIRTY_LOG: {",
                        "\t\tstruct kvm_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT",
                        "\tcase KVM_CLEAR_DIRTY_LOG: {",
                        "\t\tstruct kvm_clear_dirty_log log;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&log, argp, sizeof(log)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_KVM_MMIO",
                        "\tcase KVM_REGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_UNREGISTER_COALESCED_MMIO: {",
                        "\t\tstruct kvm_coalesced_mmio_zone zone;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&zone, argp, sizeof(zone)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "\tcase KVM_IRQFD: {",
                        "\t\tstruct kvm_irqfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_irqfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_IOEVENTFD: {",
                        "\t\tstruct kvm_ioeventfd data;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&data, argp, sizeof(data)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_ioeventfd(kvm, &data);",
                        "\t\tbreak;",
                        "\t}",
                        "#ifdef CONFIG_HAVE_KVM_MSI",
                        "\tcase KVM_SIGNAL_MSI: {",
                        "\t\tstruct kvm_msi msi;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&msi, argp, sizeof(msi)))",
                        "\t\t\tgoto out;",
                        "\t\tr = kvm_send_userspace_msi(kvm, &msi);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef __KVM_HAVE_IRQ_LINE",
                        "\tcase KVM_IRQ_LINE_STATUS:",
                        "\tcase KVM_IRQ_LINE: {",
                        "\t\tstruct kvm_irq_level irq_event;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&irq_event, argp, sizeof(irq_event)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_vm_ioctl_irq_line(kvm, &irq_event,",
                        "\t\t\t\t\tioctl == KVM_IRQ_LINE_STATUS);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {",
                        "\t\t\tif (copy_to_user(argp, &irq_event, sizeof(irq_event)))",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "#endif",
                        "#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING",
                        "\tcase KVM_SET_GSI_ROUTING: {",
                        "\t\tstruct kvm_irq_routing routing;",
                        "\t\tstruct kvm_irq_routing __user *urouting;",
                        "\t\tstruct kvm_irq_routing_entry *entries = NULL;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&routing, argp, sizeof(routing)))",
                        "\t\t\tgoto out;",
                        "\t\tr = -EINVAL;",
                        "\t\tif (!kvm_arch_can_set_irq_routing(kvm))",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr > KVM_MAX_IRQ_ROUTES)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.flags)",
                        "\t\t\tgoto out;",
                        "\t\tif (routing.nr) {",
                        "\t\t\turouting = argp;",
                        "\t\t\tentries = vmemdup_user(urouting->entries,",
                        "\t\t\t\t\t       array_size(sizeof(*entries),",
                        "\t\t\t\t\t\t\t  routing.nr));",
                        "\t\t\tif (IS_ERR(entries)) {",
                        "\t\t\t\tr = PTR_ERR(entries);",
                        "\t\t\t\tgoto out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tr = kvm_set_irq_routing(kvm, entries, routing.nr,",
                        "\t\t\t\t\trouting.flags);",
                        "\t\tkvfree(entries);",
                        "\t\tbreak;",
                        "\t}",
                        "#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */",
                        "\tcase KVM_CREATE_DEVICE: {",
                        "\t\tstruct kvm_create_device cd;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_from_user(&cd, argp, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = kvm_ioctl_create_device(kvm, &cd);",
                        "\t\tif (r)",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = -EFAULT;",
                        "\t\tif (copy_to_user(argp, &cd, sizeof(cd)))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tr = 0;",
                        "\t\tbreak;",
                        "\t}",
                        "\tcase KVM_CHECK_EXTENSION:",
                        "\t\tr = kvm_vm_ioctl_check_extension_generic(kvm, arg);",
                        "\t\tbreak;",
                        "\tcase KVM_RESET_DIRTY_RINGS:",
                        "\t\tr = kvm_vm_ioctl_reset_dirty_pages(kvm);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tr = kvm_arch_vm_ioctl(filp, ioctl, arg);",
                        "\t}",
                        "out:",
                        "\treturn r;",
                        "}"
                    ],
                    "start": 3807,
                    "highlight": 3818
                }
            ],
            "ins_idx": 652,
            "addr": "0xffffffff81027d01"
        }
    },
    "ins": {
        "9": {
            "name": "movzx edx, byte ptr [rax + 0x140]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x140",
            "call_idx": 1709,
            "inputs": [
                2949,
                2950
            ],
            "outputs": [
                2951
            ]
        },
        "27": {
            "name": "mov rax, qword ptr [rax + 0x18d8]",
            "desc": "Heap Use Before Initialization",
            "call_idx": 1708,
            "inputs": [
                2946,
                2947
            ],
            "outputs": [
                2948
            ]
        },
        "47": {
            "name": "push r14",
            "desc": "Source of base address MEMALLOC 0x0",
            "call_idx": 1249,
            "inputs": [],
            "outputs": [
                2162
            ]
        },
        "46": {
            "name": "mov rax, qword ptr [rdi + rax*8 + 0x40]",
            "desc": "",
            "call_idx": 1707,
            "inputs": [
                2942,
                2943,
                2944
            ],
            "outputs": [
                2945
            ]
        },
        "73": {
            "name": "mov qword ptr [r13 + rax*8 + 0x40], r15",
            "desc": "",
            "call_idx": 1368,
            "inputs": [
                2350,
                2351,
                2352
            ],
            "outputs": [
                2353
            ]
        },
        "652": {
            "name": "mov r15, rax",
            "desc": "",
            "call_idx": 1250,
            "inputs": [
                2163
            ],
            "outputs": [
                2164
            ]
        }
    },
    "data": {
        "2949": {
            "name": "RAX",
            "ins_idx": 9,
            "value": "0x0",
            "sources": []
        },
        "2950": {
            "name": "[0x140]",
            "ins_idx": 9,
            "value": "0x0",
            "sources": []
        },
        "2951": {
            "name": "RDX",
            "ins_idx": 9,
            "value": "0x0",
            "sources": []
        },
        "2946": {
            "name": "RAX",
            "ins_idx": 27,
            "value": "0xffff888101970000",
            "sources": []
        },
        "2947": {
            "name": "[0xffff8881019718d8]",
            "ins_idx": 27,
            "value": "0x0",
            "sources": []
        },
        "2948": {
            "name": "RAX",
            "ins_idx": 27,
            "value": "0x0",
            "sources": [
                2949
            ]
        },
        "2162": {
            "name": "RAX",
            "ins_idx": 47,
            "value": "0xffff888101970000",
            "sources": [
                2946,
                2163
            ]
        },
        "2942": {
            "name": "RAX",
            "ins_idx": 46,
            "value": "0x0",
            "sources": []
        },
        "2943": {
            "name": "RDI",
            "ins_idx": 46,
            "value": "0xffffc900002ad000",
            "sources": []
        },
        "2944": {
            "name": "[0xffffc900002ad040]",
            "ins_idx": 46,
            "value": "0xffff888101970000",
            "sources": []
        },
        "2945": {
            "name": "RAX",
            "ins_idx": 46,
            "value": "0xffff888101970000",
            "sources": [
                2946
            ]
        },
        "2350": {
            "name": "RAX",
            "ins_idx": 73,
            "value": "0x0",
            "sources": []
        },
        "2351": {
            "name": "R13",
            "ins_idx": 73,
            "value": "0xffffc900002ad000",
            "sources": []
        },
        "2352": {
            "name": "R15",
            "ins_idx": 73,
            "value": "0xffff888101970000",
            "sources": []
        },
        "2353": {
            "name": "[0xffffc900002ad040]",
            "ins_idx": 73,
            "value": "0xffff888101970000",
            "sources": [
                2944
            ]
        },
        "2163": {
            "name": "RAX",
            "ins_idx": 652,
            "value": "0xffff888101970000",
            "sources": []
        },
        "2164": {
            "name": "R15",
            "ins_idx": 652,
            "value": "0xffff888101970000",
            "sources": [
                2352
            ]
        }
    },
    "chain": {
        "9": [
            27
        ],
        "27": [
            47,
            46
        ],
        "46": [
            73
        ],
        "73": [
            652
        ],
        "652": [
            47
        ]
    }
}