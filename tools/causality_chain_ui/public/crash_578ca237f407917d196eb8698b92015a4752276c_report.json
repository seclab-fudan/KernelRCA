{
    "report": "https://syzkaller.appspot.com/bug?id=578ca237f407917d196eb8698b92015a4752276c",
    "title": "BUG: unable to handle kernel paging request in dqput",
    "call": {
        "7040": {
            "name": "+0x2c",
            "parent_idx": 7033,
            "source_line": [
                {
                    "file": "./arch/x86/include/asm/atomic.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./arch/x86/include/asm/atomic.h?id=98477740#n29",
                    "code": [
                        "/**",
                        " * arch_atomic_read - read atomic variable",
                        " * @v: pointer of type atomic_t",
                        " *",
                        " * Atomically reads the value of @v.",
                        " */",
                        "static __always_inline int arch_atomic_read(const atomic_t *v)",
                        "{",
                        "\t/*",
                        "\t * Note for KASAN: we deliberately don't use READ_ONCE_NOCHECK() here,",
                        "\t * it's non-inlined function that increases binary size and stack usage.",
                        "\t */",
                        "\treturn __READ_ONCE((v)->counter);",
                        "}"
                    ],
                    "start": 17,
                    "highlight": 29
                },
                {
                    "file": "./include/asm-generic/atomic-instrumented.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/asm-generic/atomic-instrumented.h?id=98477740#n28",
                    "code": [
                        "static __always_inline int",
                        "atomic_read(const atomic_t *v)",
                        "{",
                        "\tinstrument_atomic_read(v, sizeof(*v));",
                        "\treturn arch_atomic_read(v);",
                        "}"
                    ],
                    "start": 24,
                    "highlight": 28
                },
                {
                    "file": "fs/quota/dquot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=98477740#n770",
                    "code": [
                        "/*",
                        " * Put reference to dquot",
                        " */",
                        "void dqput(struct dquot *dquot)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tif (!dquot)",
                        "\t\treturn;",
                        "#ifdef CONFIG_QUOTA_DEBUG",
                        "\tif (!atomic_read(&dquot->dq_count)) {",
                        "\t\tquota_error(dquot->dq_sb, \"trying to free free dquot of %s %d\",",
                        "\t\t\t    quotatypes[dquot->dq_id.type],",
                        "\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));",
                        "\t\tBUG();",
                        "\t}",
                        "#endif",
                        "\tdqstats_inc(DQST_DROPS);",
                        "we_slept:",
                        "\tspin_lock(&dq_list_lock);",
                        "\tif (atomic_read(&dquot->dq_count) > 1) {",
                        "\t\t/* We have more than one user... nothing to do */",
                        "\t\tatomic_dec(&dquot->dq_count);",
                        "\t\t/* Releasing dquot during quotaoff phase? */",
                        "\t\tif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&",
                        "\t\t    atomic_read(&dquot->dq_count) == 1)",
                        "\t\t\twake_up(&dquot_ref_wq);",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\treturn;",
                        "\t}",
                        "\t/* Need to release dquot? */",
                        "\tif (dquot_dirty(dquot)) {",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\t/* Commit dquot before releasing */",
                        "\t\tret = dquot->dq_sb->dq_op->write_dquot(dquot);",
                        "\t\tif (ret < 0) {",
                        "\t\t\tquota_error(dquot->dq_sb, \"Can't write quota structure\"",
                        "\t\t\t\t    \" (error %d). Quota may get out of sync!\",",
                        "\t\t\t\t    ret);",
                        "\t\t\t/*",
                        "\t\t\t * We clear dirty bit anyway, so that we avoid",
                        "\t\t\t * infinite loop here",
                        "\t\t\t */",
                        "\t\t\tclear_dquot_dirty(dquot);",
                        "\t\t}",
                        "\t\tgoto we_slept;",
                        "\t}",
                        "\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\tdquot->dq_sb->dq_op->release_dquot(dquot);",
                        "\t\tgoto we_slept;",
                        "\t}",
                        "\tatomic_dec(&dquot->dq_count);",
                        "#ifdef CONFIG_QUOTA_DEBUG",
                        "\t/* sanity check */",
                        "\tBUG_ON(!list_empty(&dquot->dq_free));",
                        "#endif",
                        "\tput_dquot_last(dquot);",
                        "\tspin_unlock(&dq_list_lock);",
                        "}"
                    ],
                    "start": 750,
                    "highlight": 770
                }
            ],
            "ins_idx": 41,
            "addr": "0xffffffff812648cc"
        },
        "7033": {
            "name": "dqput",
            "parent_idx": 6646,
            "source_line": [
                {
                    "file": "fs/quota/dquot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=98477740#n757",
                    "code": [
                        "/*",
                        " * Put reference to dquot",
                        " */",
                        "void dqput(struct dquot *dquot)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tif (!dquot)",
                        "\t\treturn;",
                        "#ifdef CONFIG_QUOTA_DEBUG",
                        "\tif (!atomic_read(&dquot->dq_count)) {",
                        "\t\tquota_error(dquot->dq_sb, \"trying to free free dquot of %s %d\",",
                        "\t\t\t    quotatypes[dquot->dq_id.type],",
                        "\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));",
                        "\t\tBUG();",
                        "\t}",
                        "#endif",
                        "\tdqstats_inc(DQST_DROPS);",
                        "we_slept:",
                        "\tspin_lock(&dq_list_lock);",
                        "\tif (atomic_read(&dquot->dq_count) > 1) {",
                        "\t\t/* We have more than one user... nothing to do */",
                        "\t\tatomic_dec(&dquot->dq_count);",
                        "\t\t/* Releasing dquot during quotaoff phase? */",
                        "\t\tif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&",
                        "\t\t    atomic_read(&dquot->dq_count) == 1)",
                        "\t\t\twake_up(&dquot_ref_wq);",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\treturn;",
                        "\t}",
                        "\t/* Need to release dquot? */",
                        "\tif (dquot_dirty(dquot)) {",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\t/* Commit dquot before releasing */",
                        "\t\tret = dquot->dq_sb->dq_op->write_dquot(dquot);",
                        "\t\tif (ret < 0) {",
                        "\t\t\tquota_error(dquot->dq_sb, \"Can't write quota structure\"",
                        "\t\t\t\t    \" (error %d). Quota may get out of sync!\",",
                        "\t\t\t\t    ret);",
                        "\t\t\t/*",
                        "\t\t\t * We clear dirty bit anyway, so that we avoid",
                        "\t\t\t * infinite loop here",
                        "\t\t\t */",
                        "\t\t\tclear_dquot_dirty(dquot);",
                        "\t\t}",
                        "\t\tgoto we_slept;",
                        "\t}",
                        "\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\tdquot->dq_sb->dq_op->release_dquot(dquot);",
                        "\t\tgoto we_slept;",
                        "\t}",
                        "\tatomic_dec(&dquot->dq_count);",
                        "#ifdef CONFIG_QUOTA_DEBUG",
                        "\t/* sanity check */",
                        "\tBUG_ON(!list_empty(&dquot->dq_free));",
                        "#endif",
                        "\tput_dquot_last(dquot);",
                        "\tspin_unlock(&dq_list_lock);",
                        "}"
                    ],
                    "start": 750,
                    "highlight": 757
                },
                {
                    "file": "fs/quota/dquot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=98477740#n397",
                    "code": [
                        "static inline void dqput_all(struct dquot **dquot)",
                        "{",
                        "\tunsigned int cnt;",
                        "",
                        "\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)",
                        "\t\tdqput(dquot[cnt]);",
                        "}"
                    ],
                    "start": 392,
                    "highlight": 397
                },
                {
                    "file": "fs/quota/dquot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=98477740#n1530",
                    "code": [
                        "/*",
                        " * Initialize quota pointers in inode",
                        " *",
                        " * It is better to call this function outside of any transaction as it",
                        " * might need a lot of space in journal for dquot structure allocation.",
                        " */",
                        "static int __dquot_initialize(struct inode *inode, int type)",
                        "{",
                        "\tint cnt, init_needed = 0;",
                        "\tstruct dquot **dquots, *got[MAXQUOTAS] = {};",
                        "\tstruct super_block *sb = inode->i_sb;",
                        "\tqsize_t rsv;",
                        "\tint ret = 0;",
                        "",
                        "\tif (!dquot_active(inode))",
                        "\t\treturn 0;",
                        "",
                        "\tdquots = i_dquot(inode);",
                        "",
                        "\t/* First get references to structures we might need. */",
                        "\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {",
                        "\t\tstruct kqid qid;",
                        "\t\tkprojid_t projid;",
                        "\t\tint rc;",
                        "\t\tstruct dquot *dquot;",
                        "",
                        "\t\tif (type != -1 && cnt != type)",
                        "\t\t\tcontinue;",
                        "\t\t/*",
                        "\t\t * The i_dquot should have been initialized in most cases,",
                        "\t\t * we check it without locking here to avoid unnecessary",
                        "\t\t * dqget()/dqput() calls.",
                        "\t\t */",
                        "\t\tif (dquots[cnt])",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tif (!sb_has_quota_active(sb, cnt))",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tinit_needed = 1;",
                        "",
                        "\t\tswitch (cnt) {",
                        "\t\tcase USRQUOTA:",
                        "\t\t\tqid = make_kqid_uid(inode->i_uid);",
                        "\t\t\tbreak;",
                        "\t\tcase GRPQUOTA:",
                        "\t\t\tqid = make_kqid_gid(inode->i_gid);",
                        "\t\t\tbreak;",
                        "\t\tcase PRJQUOTA:",
                        "\t\t\trc = inode->i_sb->dq_op->get_projid(inode, &projid);",
                        "\t\t\tif (rc)",
                        "\t\t\t\tcontinue;",
                        "\t\t\tqid = make_kqid_projid(projid);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tdquot = dqget(sb, qid);",
                        "\t\tif (IS_ERR(dquot)) {",
                        "\t\t\t/* We raced with somebody turning quotas off... */",
                        "\t\t\tif (PTR_ERR(dquot) != -ESRCH) {",
                        "\t\t\t\tret = PTR_ERR(dquot);",
                        "\t\t\t\tgoto out_put;",
                        "\t\t\t}",
                        "\t\t\tdquot = NULL;",
                        "\t\t}",
                        "\t\tgot[cnt] = dquot;",
                        "\t}",
                        "",
                        "\t/* All required i_dquot has been initialized */",
                        "\tif (!init_needed)",
                        "\t\treturn 0;",
                        "",
                        "\tspin_lock(&dq_data_lock);",
                        "\tif (IS_NOQUOTA(inode))",
                        "\t\tgoto out_lock;",
                        "\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {",
                        "\t\tif (type != -1 && cnt != type)",
                        "\t\t\tcontinue;",
                        "\t\t/* Avoid races with quotaoff() */",
                        "\t\tif (!sb_has_quota_active(sb, cnt))",
                        "\t\t\tcontinue;",
                        "\t\t/* We could race with quotaon or dqget() could have failed */",
                        "\t\tif (!got[cnt])",
                        "\t\t\tcontinue;",
                        "\t\tif (!dquots[cnt]) {",
                        "\t\t\tdquots[cnt] = got[cnt];",
                        "\t\t\tgot[cnt] = NULL;",
                        "\t\t\t/*",
                        "\t\t\t * Make quota reservation system happy if someone",
                        "\t\t\t * did a write before quota was turned on",
                        "\t\t\t */",
                        "\t\t\trsv = inode_get_rsv_space(inode);",
                        "\t\t\tif (unlikely(rsv)) {",
                        "\t\t\t\tspin_lock(&inode->i_lock);",
                        "\t\t\t\t/* Get reservation again under proper lock */",
                        "\t\t\t\trsv = __inode_get_rsv_space(inode);",
                        "\t\t\t\tspin_lock(&dquots[cnt]->dq_dqb_lock);",
                        "\t\t\t\tdquots[cnt]->dq_dqb.dqb_rsvspace += rsv;",
                        "\t\t\t\tspin_unlock(&dquots[cnt]->dq_dqb_lock);",
                        "\t\t\t\tspin_unlock(&inode->i_lock);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "out_lock:",
                        "\tspin_unlock(&dq_data_lock);",
                        "out_put:",
                        "\t/* Drop unused references */",
                        "\tdqput_all(got);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1424,
                    "highlight": 1530
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81266400"
        },
        "6646": {
            "name": "dquot_initialize",
            "parent_idx": 6644,
            "source_line": [
                {
                    "file": "fs/ext4/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ext4/xattr.c?id=98477740#n2474",
                    "code": [
                        "/*",
                        " * ext4_xattr_set()",
                        " *",
                        " * Like ext4_xattr_set_handle, but start from an inode. This extended",
                        " * attribute modification is a filesystem transaction by itself.",
                        " *",
                        " * Returns 0, or a negative error number on failure.",
                        " */",
                        "int",
                        "ext4_xattr_set(struct inode *inode, int name_index, const char *name,",
                        "\t       const void *value, size_t value_len, int flags)",
                        "{",
                        "\thandle_t *handle;",
                        "\tstruct super_block *sb = inode->i_sb;",
                        "\tint error, retries = 0;",
                        "\tint credits;",
                        "",
                        "\terror = dquot_initialize(inode);",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "retry:",
                        "\terror = ext4_xattr_set_credits(inode, value_len, flags & XATTR_CREATE,",
                        "\t\t\t\t       &credits);",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "\thandle = ext4_journal_start(inode, EXT4_HT_XATTR, credits);",
                        "\tif (IS_ERR(handle)) {",
                        "\t\terror = PTR_ERR(handle);",
                        "\t} else {",
                        "\t\tint error2;",
                        "",
                        "\t\terror = ext4_xattr_set_handle(handle, inode, name_index, name,",
                        "\t\t\t\t\t      value, value_len, flags);",
                        "\t\terror2 = ext4_journal_stop(handle);",
                        "\t\tif (error == -ENOSPC &&",
                        "\t\t    ext4_should_retry_alloc(sb, &retries))",
                        "\t\t\tgoto retry;",
                        "\t\tif (error == 0)",
                        "\t\t\terror = error2;",
                        "\t}",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 2457,
                    "highlight": 2474
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812e5b86"
        },
        "6644": {
            "name": "ext4_xattr_trusted_set(indirect)",
            "parent_idx": 6641,
            "source_line": [
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=98477740#n177",
                    "code": [
                        "int",
                        "__vfs_setxattr(struct dentry *dentry, struct inode *inode, const char *name,",
                        "\t       const void *value, size_t size, int flags)",
                        "{",
                        "\tconst struct xattr_handler *handler;",
                        "",
                        "\thandler = xattr_resolve_name(inode, &name);",
                        "\tif (IS_ERR(handler))",
                        "\t\treturn PTR_ERR(handler);",
                        "\tif (!handler->set)",
                        "\t\treturn -EOPNOTSUPP;",
                        "\tif (size == 0)",
                        "\t\tvalue = \"\";  /* empty EA, do not remove */",
                        "\treturn handler->set(handler, dentry, inode, name, value, size, flags);",
                        "}"
                    ],
                    "start": 164,
                    "highlight": 177
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81212f3c"
        },
        "6641": {
            "name": "__vfs_setxattr",
            "parent_idx": 6626,
            "source_line": [
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=98477740#n208",
                    "code": [
                        "/**",
                        " *  __vfs_setxattr_noperm - perform setxattr operation without performing",
                        " *  permission checks.",
                        " *",
                        " *  @dentry - object to perform setxattr on",
                        " *  @name - xattr name to set",
                        " *  @value - value to set @name to",
                        " *  @size - size of @value",
                        " *  @flags - flags to pass into filesystem operations",
                        " *",
                        " *  returns the result of the internal setxattr or setsecurity operations.",
                        " *",
                        " *  This function requires the caller to lock the inode's i_mutex before it",
                        " *  is executed. It also assumes that the caller will make the appropriate",
                        " *  permission checks.",
                        " */",
                        "int __vfs_setxattr_noperm(struct dentry *dentry, const char *name,",
                        "\t\tconst void *value, size_t size, int flags)",
                        "{",
                        "\tstruct inode *inode = dentry->d_inode;",
                        "\tint error = -EAGAIN;",
                        "\tint issec = !strncmp(name, XATTR_SECURITY_PREFIX,",
                        "\t\t\t\t   XATTR_SECURITY_PREFIX_LEN);",
                        "",
                        "\tif (issec)",
                        "\t\tinode->i_flags &= ~S_NOSEC;",
                        "\tif (inode->i_opflags & IOP_XATTR) {",
                        "\t\terror = __vfs_setxattr(dentry, inode, name, value, size, flags);",
                        "\t\tif (!error) {",
                        "\t\t\tfsnotify_xattr(dentry);",
                        "\t\t\tsecurity_inode_post_setxattr(dentry, name, value,",
                        "\t\t\t\t\t\t     size, flags);",
                        "\t\t}",
                        "\t} else {",
                        "\t\tif (unlikely(is_bad_inode(inode)))",
                        "\t\t\treturn -EIO;",
                        "\t}",
                        "\tif (error == -EAGAIN) {",
                        "\t\terror = -EOPNOTSUPP;",
                        "",
                        "\t\tif (issec) {",
                        "\t\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;",
                        "",
                        "\t\t\terror = security_inode_setsecurity(inode, suffix, value,",
                        "\t\t\t\t\t\t\t   size, flags);",
                        "\t\t\tif (!error)",
                        "\t\t\t\tfsnotify_xattr(dentry);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 181,
                    "highlight": 208
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81214206"
        },
        "6626": {
            "name": "__vfs_setxattr_locked",
            "parent_idx": 6617,
            "source_line": [
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=98477740#n283",
                    "code": [
                        "int",
                        "vfs_setxattr(struct dentry *dentry, const char *name, const void *value,",
                        "\t\tsize_t size, int flags)",
                        "{",
                        "\tstruct inode *inode = dentry->d_inode;",
                        "\tstruct inode *delegated_inode = NULL;",
                        "\tint error;",
                        "",
                        "retry_deleg:",
                        "\tinode_lock(inode);",
                        "\terror = __vfs_setxattr_locked(dentry, name, value, size, flags,",
                        "\t    &delegated_inode);",
                        "\tinode_unlock(inode);",
                        "",
                        "\tif (delegated_inode) {",
                        "\t\terror = break_deleg_wait(&delegated_inode);",
                        "\t\tif (!error)",
                        "\t\t\tgoto retry_deleg;",
                        "\t}",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 273,
                    "highlight": 283
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812144d1"
        },
        "6617": {
            "name": "vfs_setxattr",
            "parent_idx": 6614,
            "source_line": [
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=98477740#n548",
                    "code": [
                        "\terror = vfs_setxattr(d, kname, kvalue, size, flags);",
                        "out:",
                        "\tkvfree(kvalue);",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 548,
                    "highlight": 548
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8121468b"
        },
        "6614": {
            "name": "setxattr",
            "parent_idx": 6269,
            "source_line": [
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=98477740#n567",
                    "code": [
                        "static int path_setxattr(const char __user *pathname,",
                        "\t\t\t const char __user *name, const void __user *value,",
                        "\t\t\t size_t size, int flags, unsigned int lookup_flags)",
                        "{",
                        "\tstruct path path;",
                        "\tint error;",
                        "retry:",
                        "\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);",
                        "\tif (error)",
                        "\t\treturn error;",
                        "\terror = mnt_want_write(path.mnt);",
                        "\tif (!error) {",
                        "\t\terror = setxattr(path.dentry, name, value, size, flags);",
                        "\t\tmnt_drop_write(path.mnt);",
                        "\t}",
                        "\tpath_put(&path);",
                        "\tif (retry_estale(error, lookup_flags)) {",
                        "\t\tlookup_flags |= LOOKUP_REVAL;",
                        "\t\tgoto retry;",
                        "\t}",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 555,
                    "highlight": 567
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81214860"
        },
        "6269": {
            "name": "path_setxattr",
            "parent_idx": 6266,
            "source_line": [
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=98477740#n582",
                    "code": [
                        "SYSCALL_DEFINE5(setxattr, const char __user *, pathname,",
                        "\t\tconst char __user *, name, const void __user *, value,",
                        "\t\tsize_t, size, int, flags)",
                        "{",
                        "\treturn path_setxattr(pathname, name, value, size, flags, LOOKUP_FOLLOW);",
                        "}"
                    ],
                    "start": 578,
                    "highlight": 582
                },
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=98477740#n578",
                    "code": [
                        "static int path_setxattr(const char __user *pathname,",
                        "\t\t\t const char __user *name, const void __user *value,",
                        "\t\t\t size_t size, int flags, unsigned int lookup_flags)",
                        "{",
                        "\tstruct path path;",
                        "\tint error;",
                        "retry:",
                        "\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);",
                        "\tif (error)",
                        "\t\treturn error;",
                        "\terror = mnt_want_write(path.mnt);",
                        "\tif (!error) {",
                        "\t\terror = setxattr(path.dentry, name, value, size, flags);",
                        "\t\tmnt_drop_write(path.mnt);",
                        "\t}",
                        "\tpath_put(&path);",
                        "\tif (retry_estale(error, lookup_flags)) {",
                        "\t\tlookup_flags |= LOOKUP_REVAL;",
                        "\t\tgoto retry;",
                        "\t}",
                        "\treturn error;",
                        "}",
                        "",
                        "SYSCALL_DEFINE5(setxattr, const char __user *, pathname,",
                        "\t\tconst char __user *, name, const void __user *, value,",
                        "\t\tsize_t, size, int, flags)",
                        "{",
                        "\treturn path_setxattr(pathname, name, value, size, flags, LOOKUP_FOLLOW);",
                        "}"
                    ],
                    "start": 555,
                    "highlight": 578
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8121489d"
        },
        "6266": {
            "name": "__x64_sys_setxattr(indirect)",
            "parent_idx": 6263,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=98477740#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b4e5ee"
        },
        "6263": {
            "name": "do_syscall_64",
            "parent_idx": 6256,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=98477740#n118",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 118
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "6256": {
            "name": "119_syscall_23",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "7034": {
            "name": "+0xd",
            "parent_idx": 7033,
            "source_line": [
                {
                    "file": "fs/quota/dquot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=98477740#n753",
                    "code": [
                        "/*",
                        " * Put reference to dquot",
                        " */",
                        "void dqput(struct dquot *dquot)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tif (!dquot)",
                        "\t\treturn;",
                        "#ifdef CONFIG_QUOTA_DEBUG",
                        "\tif (!atomic_read(&dquot->dq_count)) {",
                        "\t\tquota_error(dquot->dq_sb, \"trying to free free dquot of %s %d\",",
                        "\t\t\t    quotatypes[dquot->dq_id.type],",
                        "\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));",
                        "\t\tBUG();",
                        "\t}",
                        "#endif",
                        "\tdqstats_inc(DQST_DROPS);",
                        "we_slept:",
                        "\tspin_lock(&dq_list_lock);",
                        "\tif (atomic_read(&dquot->dq_count) > 1) {",
                        "\t\t/* We have more than one user... nothing to do */",
                        "\t\tatomic_dec(&dquot->dq_count);",
                        "\t\t/* Releasing dquot during quotaoff phase? */",
                        "\t\tif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&",
                        "\t\t    atomic_read(&dquot->dq_count) == 1)",
                        "\t\t\twake_up(&dquot_ref_wq);",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\treturn;",
                        "\t}",
                        "\t/* Need to release dquot? */",
                        "\tif (dquot_dirty(dquot)) {",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\t/* Commit dquot before releasing */",
                        "\t\tret = dquot->dq_sb->dq_op->write_dquot(dquot);",
                        "\t\tif (ret < 0) {",
                        "\t\t\tquota_error(dquot->dq_sb, \"Can't write quota structure\"",
                        "\t\t\t\t    \" (error %d). Quota may get out of sync!\",",
                        "\t\t\t\t    ret);",
                        "\t\t\t/*",
                        "\t\t\t * We clear dirty bit anyway, so that we avoid",
                        "\t\t\t * infinite loop here",
                        "\t\t\t */",
                        "\t\t\tclear_dquot_dirty(dquot);",
                        "\t\t}",
                        "\t\tgoto we_slept;",
                        "\t}",
                        "\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\tdquot->dq_sb->dq_op->release_dquot(dquot);",
                        "\t\tgoto we_slept;",
                        "\t}",
                        "\tatomic_dec(&dquot->dq_count);",
                        "#ifdef CONFIG_QUOTA_DEBUG",
                        "\t/* sanity check */",
                        "\tBUG_ON(!list_empty(&dquot->dq_free));",
                        "#endif",
                        "\tput_dquot_last(dquot);",
                        "\tspin_unlock(&dq_list_lock);",
                        "}"
                    ],
                    "start": 750,
                    "highlight": 753
                }
            ],
            "ins_idx": 210,
            "addr": "0xffffffff812648ad"
        },
        "7032": {
            "name": "+0x198",
            "parent_idx": 6646,
            "source_line": [
                {
                    "file": "fs/quota/dquot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=98477740#n397",
                    "code": [
                        "static inline void dqput_all(struct dquot **dquot)",
                        "{",
                        "\tunsigned int cnt;",
                        "",
                        "\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)",
                        "\t\tdqput(dquot[cnt]);",
                        "}"
                    ],
                    "start": 392,
                    "highlight": 397
                },
                {
                    "file": "fs/quota/dquot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=98477740#n1530",
                    "code": [
                        "/*",
                        " * Initialize quota pointers in inode",
                        " *",
                        " * It is better to call this function outside of any transaction as it",
                        " * might need a lot of space in journal for dquot structure allocation.",
                        " */",
                        "static int __dquot_initialize(struct inode *inode, int type)",
                        "{",
                        "\tint cnt, init_needed = 0;",
                        "\tstruct dquot **dquots, *got[MAXQUOTAS] = {};",
                        "\tstruct super_block *sb = inode->i_sb;",
                        "\tqsize_t rsv;",
                        "\tint ret = 0;",
                        "",
                        "\tif (!dquot_active(inode))",
                        "\t\treturn 0;",
                        "",
                        "\tdquots = i_dquot(inode);",
                        "",
                        "\t/* First get references to structures we might need. */",
                        "\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {",
                        "\t\tstruct kqid qid;",
                        "\t\tkprojid_t projid;",
                        "\t\tint rc;",
                        "\t\tstruct dquot *dquot;",
                        "",
                        "\t\tif (type != -1 && cnt != type)",
                        "\t\t\tcontinue;",
                        "\t\t/*",
                        "\t\t * The i_dquot should have been initialized in most cases,",
                        "\t\t * we check it without locking here to avoid unnecessary",
                        "\t\t * dqget()/dqput() calls.",
                        "\t\t */",
                        "\t\tif (dquots[cnt])",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tif (!sb_has_quota_active(sb, cnt))",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tinit_needed = 1;",
                        "",
                        "\t\tswitch (cnt) {",
                        "\t\tcase USRQUOTA:",
                        "\t\t\tqid = make_kqid_uid(inode->i_uid);",
                        "\t\t\tbreak;",
                        "\t\tcase GRPQUOTA:",
                        "\t\t\tqid = make_kqid_gid(inode->i_gid);",
                        "\t\t\tbreak;",
                        "\t\tcase PRJQUOTA:",
                        "\t\t\trc = inode->i_sb->dq_op->get_projid(inode, &projid);",
                        "\t\t\tif (rc)",
                        "\t\t\t\tcontinue;",
                        "\t\t\tqid = make_kqid_projid(projid);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tdquot = dqget(sb, qid);",
                        "\t\tif (IS_ERR(dquot)) {",
                        "\t\t\t/* We raced with somebody turning quotas off... */",
                        "\t\t\tif (PTR_ERR(dquot) != -ESRCH) {",
                        "\t\t\t\tret = PTR_ERR(dquot);",
                        "\t\t\t\tgoto out_put;",
                        "\t\t\t}",
                        "\t\t\tdquot = NULL;",
                        "\t\t}",
                        "\t\tgot[cnt] = dquot;",
                        "\t}",
                        "",
                        "\t/* All required i_dquot has been initialized */",
                        "\tif (!init_needed)",
                        "\t\treturn 0;",
                        "",
                        "\tspin_lock(&dq_data_lock);",
                        "\tif (IS_NOQUOTA(inode))",
                        "\t\tgoto out_lock;",
                        "\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {",
                        "\t\tif (type != -1 && cnt != type)",
                        "\t\t\tcontinue;",
                        "\t\t/* Avoid races with quotaoff() */",
                        "\t\tif (!sb_has_quota_active(sb, cnt))",
                        "\t\t\tcontinue;",
                        "\t\t/* We could race with quotaon or dqget() could have failed */",
                        "\t\tif (!got[cnt])",
                        "\t\t\tcontinue;",
                        "\t\tif (!dquots[cnt]) {",
                        "\t\t\tdquots[cnt] = got[cnt];",
                        "\t\t\tgot[cnt] = NULL;",
                        "\t\t\t/*",
                        "\t\t\t * Make quota reservation system happy if someone",
                        "\t\t\t * did a write before quota was turned on",
                        "\t\t\t */",
                        "\t\t\trsv = inode_get_rsv_space(inode);",
                        "\t\t\tif (unlikely(rsv)) {",
                        "\t\t\t\tspin_lock(&inode->i_lock);",
                        "\t\t\t\t/* Get reservation again under proper lock */",
                        "\t\t\t\trsv = __inode_get_rsv_space(inode);",
                        "\t\t\t\tspin_lock(&dquots[cnt]->dq_dqb_lock);",
                        "\t\t\t\tdquots[cnt]->dq_dqb.dqb_rsvspace += rsv;",
                        "\t\t\t\tspin_unlock(&dquots[cnt]->dq_dqb_lock);",
                        "\t\t\t\tspin_unlock(&inode->i_lock);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "out_lock:",
                        "\tspin_unlock(&dq_data_lock);",
                        "out_put:",
                        "\t/* Drop unused references */",
                        "\tdqput_all(got);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1424,
                    "highlight": 1530
                }
            ],
            "ins_idx": 287,
            "addr": "0xffffffff812663f8"
        },
        "6900": {
            "name": "+0x124",
            "parent_idx": 6646,
            "source_line": [
                {
                    "file": "fs/quota/dquot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=98477740#n1488",
                    "code": [
                        "/*",
                        " * Initialize quota pointers in inode",
                        " *",
                        " * It is better to call this function outside of any transaction as it",
                        " * might need a lot of space in journal for dquot structure allocation.",
                        " */",
                        "static int __dquot_initialize(struct inode *inode, int type)",
                        "{",
                        "\tint cnt, init_needed = 0;",
                        "\tstruct dquot **dquots, *got[MAXQUOTAS] = {};",
                        "\tstruct super_block *sb = inode->i_sb;",
                        "\tqsize_t rsv;",
                        "\tint ret = 0;",
                        "",
                        "\tif (!dquot_active(inode))",
                        "\t\treturn 0;",
                        "",
                        "\tdquots = i_dquot(inode);",
                        "",
                        "\t/* First get references to structures we might need. */",
                        "\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {",
                        "\t\tstruct kqid qid;",
                        "\t\tkprojid_t projid;",
                        "\t\tint rc;",
                        "\t\tstruct dquot *dquot;",
                        "",
                        "\t\tif (type != -1 && cnt != type)",
                        "\t\t\tcontinue;",
                        "\t\t/*",
                        "\t\t * The i_dquot should have been initialized in most cases,",
                        "\t\t * we check it without locking here to avoid unnecessary",
                        "\t\t * dqget()/dqput() calls.",
                        "\t\t */",
                        "\t\tif (dquots[cnt])",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tif (!sb_has_quota_active(sb, cnt))",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tinit_needed = 1;",
                        "",
                        "\t\tswitch (cnt) {",
                        "\t\tcase USRQUOTA:",
                        "\t\t\tqid = make_kqid_uid(inode->i_uid);",
                        "\t\t\tbreak;",
                        "\t\tcase GRPQUOTA:",
                        "\t\t\tqid = make_kqid_gid(inode->i_gid);",
                        "\t\t\tbreak;",
                        "\t\tcase PRJQUOTA:",
                        "\t\t\trc = inode->i_sb->dq_op->get_projid(inode, &projid);",
                        "\t\t\tif (rc)",
                        "\t\t\t\tcontinue;",
                        "\t\t\tqid = make_kqid_projid(projid);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tdquot = dqget(sb, qid);",
                        "\t\tif (IS_ERR(dquot)) {",
                        "\t\t\t/* We raced with somebody turning quotas off... */",
                        "\t\t\tif (PTR_ERR(dquot) != -ESRCH) {",
                        "\t\t\t\tret = PTR_ERR(dquot);",
                        "\t\t\t\tgoto out_put;",
                        "\t\t\t}",
                        "\t\t\tdquot = NULL;",
                        "\t\t}",
                        "\t\tgot[cnt] = dquot;",
                        "\t}",
                        "",
                        "\t/* All required i_dquot has been initialized */",
                        "\tif (!init_needed)",
                        "\t\treturn 0;",
                        "",
                        "\tspin_lock(&dq_data_lock);",
                        "\tif (IS_NOQUOTA(inode))",
                        "\t\tgoto out_lock;",
                        "\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {",
                        "\t\tif (type != -1 && cnt != type)",
                        "\t\t\tcontinue;",
                        "\t\t/* Avoid races with quotaoff() */",
                        "\t\tif (!sb_has_quota_active(sb, cnt))",
                        "\t\t\tcontinue;",
                        "\t\t/* We could race with quotaon or dqget() could have failed */",
                        "\t\tif (!got[cnt])",
                        "\t\t\tcontinue;",
                        "\t\tif (!dquots[cnt]) {",
                        "\t\t\tdquots[cnt] = got[cnt];",
                        "\t\t\tgot[cnt] = NULL;",
                        "\t\t\t/*",
                        "\t\t\t * Make quota reservation system happy if someone",
                        "\t\t\t * did a write before quota was turned on",
                        "\t\t\t */",
                        "\t\t\trsv = inode_get_rsv_space(inode);",
                        "\t\t\tif (unlikely(rsv)) {",
                        "\t\t\t\tspin_lock(&inode->i_lock);",
                        "\t\t\t\t/* Get reservation again under proper lock */",
                        "\t\t\t\trsv = __inode_get_rsv_space(inode);",
                        "\t\t\t\tspin_lock(&dquots[cnt]->dq_dqb_lock);",
                        "\t\t\t\tdquots[cnt]->dq_dqb.dqb_rsvspace += rsv;",
                        "\t\t\t\tspin_unlock(&dquots[cnt]->dq_dqb_lock);",
                        "\t\t\t\tspin_unlock(&inode->i_lock);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "out_lock:",
                        "\tspin_unlock(&dq_data_lock);",
                        "out_put:",
                        "\t/* Drop unused references */",
                        "\tdqput_all(got);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1424,
                    "highlight": 1488
                }
            ],
            "ins_idx": 360,
            "addr": "0xffffffff81266384"
        },
        "6893": {
            "name": "+0x7d",
            "parent_idx": 6652,
            "source_line": [
                {
                    "file": "fs/quota/dquot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=98477740#n921",
                    "code": [
                        "/*",
                        " * Get reference to dquot",
                        " *",
                        " * Locking is slightly tricky here. We are guarded from parallel quotaoff()",
                        " * destroying our dquot by:",
                        " *   a) checking for quota flags under dq_list_lock and",
                        " *   b) getting a reference to dquot before we release dq_list_lock",
                        " */",
                        "struct dquot *dqget(struct super_block *sb, struct kqid qid)",
                        "{",
                        "\tunsigned int hashent = hashfn(sb, qid);",
                        "\tstruct dquot *dquot, *empty = NULL;",
                        "",
                        "\tif (!qid_has_mapping(sb->s_user_ns, qid))",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "",
                        "        if (!sb_has_quota_active(sb, qid.type))",
                        "\t\treturn ERR_PTR(-ESRCH);",
                        "we_slept:",
                        "\tspin_lock(&dq_list_lock);",
                        "\tspin_lock(&dq_state_lock);",
                        "\tif (!sb_has_quota_active(sb, qid.type)) {",
                        "\t\tspin_unlock(&dq_state_lock);",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\tdquot = ERR_PTR(-ESRCH);",
                        "\t\tgoto out;",
                        "\t}",
                        "\tspin_unlock(&dq_state_lock);",
                        "",
                        "\tdquot = find_dquot(hashent, sb, qid);",
                        "\tif (!dquot) {",
                        "\t\tif (!empty) {",
                        "\t\t\tspin_unlock(&dq_list_lock);",
                        "\t\t\tempty = get_empty_dquot(sb, qid.type);",
                        "\t\t\tif (!empty)",
                        "\t\t\t\tschedule();\t/* Try to wait for a moment... */",
                        "\t\t\tgoto we_slept;",
                        "\t\t}",
                        "\t\tdquot = empty;",
                        "\t\tempty = NULL;",
                        "\t\tdquot->dq_id = qid;",
                        "\t\t/* all dquots go on the inuse_list */",
                        "\t\tput_inuse(dquot);",
                        "\t\t/* hash it first so it can be found */",
                        "\t\tinsert_dquot_hash(dquot);",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\tdqstats_inc(DQST_LOOKUPS);",
                        "\t} else {",
                        "\t\tif (!atomic_read(&dquot->dq_count))",
                        "\t\t\tremove_free_dquot(dquot);",
                        "\t\tatomic_inc(&dquot->dq_count);",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\tdqstats_inc(DQST_CACHE_HITS);",
                        "\t\tdqstats_inc(DQST_LOOKUPS);",
                        "\t}",
                        "\t/* Wait for dq_lock - after this we know that either dquot_release() is",
                        "\t * already finished or it will be canceled due to dq_count > 1 test */",
                        "\twait_on_dquot(dquot);",
                        "\t/* Read the dquot / allocate space in quota file */",
                        "\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {",
                        "\t\tint err;",
                        "",
                        "\t\terr = sb->dq_op->acquire_dquot(dquot);",
                        "\t\tif (err < 0) {",
                        "\t\t\tdqput(dquot);",
                        "\t\t\tdquot = ERR_PTR(err);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "\t/*",
                        "\t * Make sure following reads see filled structure - paired with",
                        "\t * smp_mb__before_atomic() in dquot_acquire().",
                        "\t */",
                        "\tsmp_rmb();",
                        "#ifdef CONFIG_QUOTA_DEBUG",
                        "\tBUG_ON(!dquot->dq_sb);\t/* Has somebody invalidated entry under us? */",
                        "#endif",
                        "out:",
                        "\tif (empty)",
                        "\t\tdo_destroy_dquot(empty);",
                        "",
                        "\treturn dquot;",
                        "}"
                    ],
                    "start": 839,
                    "highlight": 921
                }
            ],
            "ins_idx": 435,
            "addr": "0xffffffff81264bed"
        },
        "6652": {
            "name": "dqget",
            "parent_idx": 6646,
            "source_line": [
                {
                    "file": "fs/quota/dquot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=98477740#n1479",
                    "code": [
                        "/*",
                        " * Initialize quota pointers in inode",
                        " *",
                        " * It is better to call this function outside of any transaction as it",
                        " * might need a lot of space in journal for dquot structure allocation.",
                        " */",
                        "static int __dquot_initialize(struct inode *inode, int type)",
                        "{",
                        "\tint cnt, init_needed = 0;",
                        "\tstruct dquot **dquots, *got[MAXQUOTAS] = {};",
                        "\tstruct super_block *sb = inode->i_sb;",
                        "\tqsize_t rsv;",
                        "\tint ret = 0;",
                        "",
                        "\tif (!dquot_active(inode))",
                        "\t\treturn 0;",
                        "",
                        "\tdquots = i_dquot(inode);",
                        "",
                        "\t/* First get references to structures we might need. */",
                        "\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {",
                        "\t\tstruct kqid qid;",
                        "\t\tkprojid_t projid;",
                        "\t\tint rc;",
                        "\t\tstruct dquot *dquot;",
                        "",
                        "\t\tif (type != -1 && cnt != type)",
                        "\t\t\tcontinue;",
                        "\t\t/*",
                        "\t\t * The i_dquot should have been initialized in most cases,",
                        "\t\t * we check it without locking here to avoid unnecessary",
                        "\t\t * dqget()/dqput() calls.",
                        "\t\t */",
                        "\t\tif (dquots[cnt])",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tif (!sb_has_quota_active(sb, cnt))",
                        "\t\t\tcontinue;",
                        "",
                        "\t\tinit_needed = 1;",
                        "",
                        "\t\tswitch (cnt) {",
                        "\t\tcase USRQUOTA:",
                        "\t\t\tqid = make_kqid_uid(inode->i_uid);",
                        "\t\t\tbreak;",
                        "\t\tcase GRPQUOTA:",
                        "\t\t\tqid = make_kqid_gid(inode->i_gid);",
                        "\t\t\tbreak;",
                        "\t\tcase PRJQUOTA:",
                        "\t\t\trc = inode->i_sb->dq_op->get_projid(inode, &projid);",
                        "\t\t\tif (rc)",
                        "\t\t\t\tcontinue;",
                        "\t\t\tqid = make_kqid_projid(projid);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tdquot = dqget(sb, qid);",
                        "\t\tif (IS_ERR(dquot)) {",
                        "\t\t\t/* We raced with somebody turning quotas off... */",
                        "\t\t\tif (PTR_ERR(dquot) != -ESRCH) {",
                        "\t\t\t\tret = PTR_ERR(dquot);",
                        "\t\t\t\tgoto out_put;",
                        "\t\t\t}",
                        "\t\t\tdquot = NULL;",
                        "\t\t}",
                        "\t\tgot[cnt] = dquot;",
                        "\t}",
                        "",
                        "\t/* All required i_dquot has been initialized */",
                        "\tif (!init_needed)",
                        "\t\treturn 0;",
                        "",
                        "\tspin_lock(&dq_data_lock);",
                        "\tif (IS_NOQUOTA(inode))",
                        "\t\tgoto out_lock;",
                        "\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {",
                        "\t\tif (type != -1 && cnt != type)",
                        "\t\t\tcontinue;",
                        "\t\t/* Avoid races with quotaoff() */",
                        "\t\tif (!sb_has_quota_active(sb, cnt))",
                        "\t\t\tcontinue;",
                        "\t\t/* We could race with quotaon or dqget() could have failed */",
                        "\t\tif (!got[cnt])",
                        "\t\t\tcontinue;",
                        "\t\tif (!dquots[cnt]) {",
                        "\t\t\tdquots[cnt] = got[cnt];",
                        "\t\t\tgot[cnt] = NULL;",
                        "\t\t\t/*",
                        "\t\t\t * Make quota reservation system happy if someone",
                        "\t\t\t * did a write before quota was turned on",
                        "\t\t\t */",
                        "\t\t\trsv = inode_get_rsv_space(inode);",
                        "\t\t\tif (unlikely(rsv)) {",
                        "\t\t\t\tspin_lock(&inode->i_lock);",
                        "\t\t\t\t/* Get reservation again under proper lock */",
                        "\t\t\t\trsv = __inode_get_rsv_space(inode);",
                        "\t\t\t\tspin_lock(&dquots[cnt]->dq_dqb_lock);",
                        "\t\t\t\tdquots[cnt]->dq_dqb.dqb_rsvspace += rsv;",
                        "\t\t\t\tspin_unlock(&dquots[cnt]->dq_dqb_lock);",
                        "\t\t\t\tspin_unlock(&inode->i_lock);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "out_lock:",
                        "\tspin_unlock(&dq_data_lock);",
                        "out_put:",
                        "\t/* Drop unused references */",
                        "\tdqput_all(got);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1424,
                    "highlight": 1479
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8126636f"
        },
        "6891": {
            "name": "+0x3fd",
            "parent_idx": 6652,
            "source_line": [
                {
                    "file": "fs/quota/dquot.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/quota/dquot.c?id=98477740#n904",
                    "code": [
                        "/*",
                        " * Get reference to dquot",
                        " *",
                        " * Locking is slightly tricky here. We are guarded from parallel quotaoff()",
                        " * destroying our dquot by:",
                        " *   a) checking for quota flags under dq_list_lock and",
                        " *   b) getting a reference to dquot before we release dq_list_lock",
                        " */",
                        "struct dquot *dqget(struct super_block *sb, struct kqid qid)",
                        "{",
                        "\tunsigned int hashent = hashfn(sb, qid);",
                        "\tstruct dquot *dquot, *empty = NULL;",
                        "",
                        "\tif (!qid_has_mapping(sb->s_user_ns, qid))",
                        "\t\treturn ERR_PTR(-EINVAL);",
                        "",
                        "        if (!sb_has_quota_active(sb, qid.type))",
                        "\t\treturn ERR_PTR(-ESRCH);",
                        "we_slept:",
                        "\tspin_lock(&dq_list_lock);",
                        "\tspin_lock(&dq_state_lock);",
                        "\tif (!sb_has_quota_active(sb, qid.type)) {",
                        "\t\tspin_unlock(&dq_state_lock);",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\tdquot = ERR_PTR(-ESRCH);",
                        "\t\tgoto out;",
                        "\t}",
                        "\tspin_unlock(&dq_state_lock);",
                        "",
                        "\tdquot = find_dquot(hashent, sb, qid);",
                        "\tif (!dquot) {",
                        "\t\tif (!empty) {",
                        "\t\t\tspin_unlock(&dq_list_lock);",
                        "\t\t\tempty = get_empty_dquot(sb, qid.type);",
                        "\t\t\tif (!empty)",
                        "\t\t\t\tschedule();\t/* Try to wait for a moment... */",
                        "\t\t\tgoto we_slept;",
                        "\t\t}",
                        "\t\tdquot = empty;",
                        "\t\tempty = NULL;",
                        "\t\tdquot->dq_id = qid;",
                        "\t\t/* all dquots go on the inuse_list */",
                        "\t\tput_inuse(dquot);",
                        "\t\t/* hash it first so it can be found */",
                        "\t\tinsert_dquot_hash(dquot);",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\tdqstats_inc(DQST_LOOKUPS);",
                        "\t} else {",
                        "\t\tif (!atomic_read(&dquot->dq_count))",
                        "\t\t\tremove_free_dquot(dquot);",
                        "\t\tatomic_inc(&dquot->dq_count);",
                        "\t\tspin_unlock(&dq_list_lock);",
                        "\t\tdqstats_inc(DQST_CACHE_HITS);",
                        "\t\tdqstats_inc(DQST_LOOKUPS);",
                        "\t}",
                        "\t/* Wait for dq_lock - after this we know that either dquot_release() is",
                        "\t * already finished or it will be canceled due to dq_count > 1 test */",
                        "\twait_on_dquot(dquot);",
                        "\t/* Read the dquot / allocate space in quota file */",
                        "\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {",
                        "\t\tint err;",
                        "",
                        "\t\terr = sb->dq_op->acquire_dquot(dquot);",
                        "\t\tif (err < 0) {",
                        "\t\t\tdqput(dquot);",
                        "\t\t\tdquot = ERR_PTR(err);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "\t/*",
                        "\t * Make sure following reads see filled structure - paired with",
                        "\t * smp_mb__before_atomic() in dquot_acquire().",
                        "\t */",
                        "\tsmp_rmb();",
                        "#ifdef CONFIG_QUOTA_DEBUG",
                        "\tBUG_ON(!dquot->dq_sb);\t/* Has somebody invalidated entry under us? */",
                        "#endif",
                        "out:",
                        "\tif (empty)",
                        "\t\tdo_destroy_dquot(empty);",
                        "",
                        "\treturn dquot;",
                        "}"
                    ],
                    "start": 839,
                    "highlight": 904
                }
            ],
            "ins_idx": 502,
            "addr": "0xffffffff81264f6d"
        }
    },
    "ins": {
        "41": {
            "name": "mov eax, dword ptr [rbx + 0x64]",
            "desc": "Invalid Memory Access",
            "call_idx": 7040,
            "inputs": [
                13133,
                13134
            ],
            "outputs": [
                13135
            ]
        },
        "210": {
            "name": "mov rbx, rdi",
            "desc": "",
            "call_idx": 7034,
            "inputs": [
                13123
            ],
            "outputs": [
                13124
            ]
        },
        "287": {
            "name": "mov rdi, qword ptr [rbx]",
            "desc": "",
            "call_idx": 7032,
            "inputs": [
                13120,
                13121
            ],
            "outputs": [
                13122
            ]
        },
        "360": {
            "name": "mov qword ptr [rsp + rbx*8 + 0x18], rax",
            "desc": "",
            "call_idx": 6900,
            "inputs": [
                12900,
                12901,
                12902
            ],
            "outputs": [
                12903
            ]
        },
        "435": {
            "name": "mov rax, r15",
            "desc": "",
            "call_idx": 6893,
            "inputs": [
                12886
            ],
            "outputs": [
                12887
            ]
        },
        "502": {
            "name": "movsxd r15, ebx",
            "desc": "Overflowed Integer",
            "call_idx": 6891,
            "inputs": [
                12883
            ],
            "outputs": [
                12884
            ]
        }
    },
    "data": {
        "13133": {
            "name": "RBX",
            "ins_idx": 41,
            "value": "0xffffffff9f47f455",
            "sources": []
        },
        "13134": {
            "name": "[0xffffffff9f47f4b9]",
            "ins_idx": 41,
            "value": "0x0",
            "sources": []
        },
        "13135": {
            "name": "RAX",
            "ins_idx": 41,
            "value": "0x0",
            "sources": []
        },
        "13123": {
            "name": "RDI",
            "ins_idx": 210,
            "value": "0xffffffff9f47f455",
            "sources": []
        },
        "13124": {
            "name": "RBX",
            "ins_idx": 210,
            "value": "0xffffffff9f47f455",
            "sources": [
                13133
            ]
        },
        "13120": {
            "name": "RBX",
            "ins_idx": 287,
            "value": "0xffffc90000237c18",
            "sources": []
        },
        "13121": {
            "name": "[0xffffc90000237c18]",
            "ins_idx": 287,
            "value": "0xffffffff9f47f455",
            "sources": []
        },
        "13122": {
            "name": "RDI",
            "ins_idx": 287,
            "value": "0xffffffff9f47f455",
            "sources": [
                13123
            ]
        },
        "12900": {
            "name": "RBX",
            "ins_idx": 360,
            "value": "0x0",
            "sources": []
        },
        "12901": {
            "name": "RSP",
            "ins_idx": 360,
            "value": "0xffffc90000237c00",
            "sources": []
        },
        "12902": {
            "name": "RAX",
            "ins_idx": 360,
            "value": "0xffffffff9f47f455",
            "sources": []
        },
        "12903": {
            "name": "[0xffffc90000237c18]",
            "ins_idx": 360,
            "value": "0xffffffff9f47f455",
            "sources": [
                13121
            ]
        },
        "12886": {
            "name": "R15",
            "ins_idx": 435,
            "value": "0xffffffff9f47f455",
            "sources": []
        },
        "12887": {
            "name": "RAX",
            "ins_idx": 435,
            "value": "0xffffffff9f47f455",
            "sources": [
                12902
            ]
        },
        "12883": {
            "name": "RBX",
            "ins_idx": 502,
            "value": "0x9f47f455",
            "sources": []
        },
        "12884": {
            "name": "R15",
            "ins_idx": 502,
            "value": "0xffffffff9f47f455",
            "sources": [
                12886
            ]
        }
    },
    "chain": {
        "41": [
            210
        ],
        "210": [
            287
        ],
        "287": [
            360
        ],
        "360": [
            435
        ],
        "435": [
            502
        ]
    }
}
