{
    "report": "https://syzkaller.appspot.com/bug?id=c50f1f108950ba0955e75bb0af5c4d28375185ba",
    "title": "general protection fault in fuse_dev_do_write",
    "call": {
        "2707": {
            "name": "+0x6a6",
            "parent_idx": 2567,
            "source_line": [
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1745",
                    "code": [
                        "static int fuse_retrieve(struct fuse_conn *fc, struct inode *inode,",
                        "\t\t\t struct fuse_notify_retrieve_out *outarg)",
                        "{",
                        "\tint err;",
                        "\tstruct address_space *mapping = inode->i_mapping;",
                        "\tstruct fuse_req *req;",
                        "\tpgoff_t index;",
                        "\tloff_t file_size;",
                        "\tunsigned int num;",
                        "\tunsigned int offset;",
                        "\tsize_t total_len = 0;",
                        "\tunsigned int num_pages;",
                        "",
                        "\toffset = outarg->offset & ~PAGE_MASK;",
                        "\tfile_size = i_size_read(inode);",
                        "",
                        "\tnum = outarg->size;",
                        "\tif (outarg->offset > file_size)",
                        "\t\tnum = 0;",
                        "\telse if (outarg->offset + num > file_size)",
                        "\t\tnum = file_size - outarg->offset;",
                        "",
                        "\tnum_pages = (num + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;",
                        "\tnum_pages = min(num_pages, fc->max_pages);",
                        "",
                        "\treq = fuse_get_req(fc, num_pages);",
                        "\tif (IS_ERR(req))",
                        "\t\treturn PTR_ERR(req);",
                        "",
                        "\treq->in.h.opcode = FUSE_NOTIFY_REPLY;",
                        "\treq->in.h.nodeid = outarg->nodeid;",
                        "\treq->in.numargs = 2;",
                        "\treq->in.argpages = 1;",
                        "\treq->page_descs[0].offset = offset;",
                        "\treq->end = fuse_retrieve_end;",
                        "",
                        "\tindex = outarg->offset >> PAGE_SHIFT;",
                        "",
                        "\twhile (num && req->num_pages < num_pages) {",
                        "\t\tstruct page *page;",
                        "\t\tunsigned int this_num;",
                        "",
                        "\t\tpage = find_get_page(mapping, index);",
                        "\t\tif (!page)",
                        "\t\t\tbreak;",
                        "",
                        "\t\tthis_num = min_t(unsigned, num, PAGE_SIZE - offset);",
                        "\t\treq->pages[req->num_pages] = page;",
                        "\t\treq->page_descs[req->num_pages].length = this_num;",
                        "\t\treq->num_pages++;",
                        "",
                        "\t\toffset = 0;",
                        "\t\tnum -= this_num;",
                        "\t\ttotal_len += this_num;",
                        "\t\tindex++;",
                        "\t}",
                        "\treq->misc.retrieve_in.offset = outarg->offset;",
                        "\treq->misc.retrieve_in.size = total_len;",
                        "\treq->in.args[0].size = sizeof(req->misc.retrieve_in);",
                        "\treq->in.args[0].value = &req->misc.retrieve_in;",
                        "\treq->in.args[1].size = total_len;",
                        "",
                        "\terr = fuse_request_send_notify_reply(fc, req, outarg->notify_unique);",
                        "\tif (err) {",
                        "\t\tfuse_retrieve_end(fc, req);",
                        "\t\tfuse_put_request(fc, req);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1712,
                    "highlight": 1745
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1807",
                    "code": [
                        "static int fuse_notify_retrieve(struct fuse_conn *fc, unsigned int size,",
                        "\t\t\t\tstruct fuse_copy_state *cs)",
                        "{",
                        "\tstruct fuse_notify_retrieve_out outarg;",
                        "\tstruct inode *inode;",
                        "\tint err;",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (size != sizeof(outarg))",
                        "\t\tgoto copy_finish;",
                        "",
                        "\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));",
                        "\tif (err)",
                        "\t\tgoto copy_finish;",
                        "",
                        "\tfuse_copy_finish(cs);",
                        "",
                        "\tdown_read(&fc->killsb);",
                        "\terr = -ENOENT;",
                        "\tif (fc->sb) {",
                        "\t\tu64 nodeid = outarg.nodeid;",
                        "",
                        "\t\tinode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);",
                        "\t\tif (inode) {",
                        "\t\t\terr = fuse_retrieve(fc, inode, &outarg);",
                        "\t\t\tiput(inode);",
                        "\t\t}",
                        "\t}",
                        "\tup_read(&fc->killsb);",
                        "",
                        "\treturn err;",
                        "",
                        "copy_finish:",
                        "\tfuse_copy_finish(cs);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1783,
                    "highlight": 1807
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1840",
                    "code": [
                        "static int fuse_notify(struct fuse_conn *fc, enum fuse_notify_code code,",
                        "\t\t       unsigned int size, struct fuse_copy_state *cs)",
                        "{",
                        "\t/* Don't try to move pages (yet) */",
                        "\tcs->move_pages = 0;",
                        "",
                        "\tswitch (code) {",
                        "\tcase FUSE_NOTIFY_POLL:",
                        "\t\treturn fuse_notify_poll(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_INVAL_INODE:",
                        "\t\treturn fuse_notify_inval_inode(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_INVAL_ENTRY:",
                        "\t\treturn fuse_notify_inval_entry(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_STORE:",
                        "\t\treturn fuse_notify_store(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_RETRIEVE:",
                        "\t\treturn fuse_notify_retrieve(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_DELETE:",
                        "\t\treturn fuse_notify_delete(fc, size, cs);",
                        "",
                        "\tdefault:",
                        "\t\tfuse_copy_finish(cs);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "}"
                    ],
                    "start": 1820,
                    "highlight": 1840
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1919",
                    "code": [
                        "/*",
                        " * Write a single reply to a request.  First the header is copied from",
                        " * the write buffer.  The request is then searched on the processing",
                        " * list by the unique ID found in the header.  If found, then remove",
                        " * it from the list and copy the rest of the buffer to the request.",
                        " * The request is finished by calling request_end()",
                        " */",
                        "static ssize_t fuse_dev_do_write(struct fuse_dev *fud,",
                        "\t\t\t\t struct fuse_copy_state *cs, size_t nbytes)",
                        "{",
                        "\tint err;",
                        "\tstruct fuse_conn *fc = fud->fc;",
                        "\tstruct fuse_pqueue *fpq = &fud->pq;",
                        "\tstruct fuse_req *req;",
                        "\tstruct fuse_out_header oh;",
                        "",
                        "\tif (nbytes < sizeof(struct fuse_out_header))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\terr = fuse_copy_one(cs, &oh, sizeof(oh));",
                        "\tif (err)",
                        "\t\tgoto err_finish;",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (oh.len != nbytes)",
                        "\t\tgoto err_finish;",
                        "",
                        "\t/*",
                        "\t * Zero oh.unique indicates unsolicited notification message",
                        "\t * and error contains notification code.",
                        "\t */",
                        "\tif (!oh.unique) {",
                        "\t\terr = fuse_notify(fc, oh.error, nbytes - sizeof(oh), cs);",
                        "\t\treturn err ? err : nbytes;",
                        "\t}",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (oh.error <= -1000 || oh.error > 0)",
                        "\t\tgoto err_finish;",
                        "",
                        "\tspin_lock(&fpq->lock);",
                        "\terr = -ENOENT;",
                        "\tif (!fpq->connected)",
                        "\t\tgoto err_unlock_pq;",
                        "",
                        "\treq = request_find(fpq, oh.unique & ~FUSE_INT_REQ_BIT);",
                        "\tif (!req)",
                        "\t\tgoto err_unlock_pq;",
                        "",
                        "\t/* Is it an interrupt reply ID? */",
                        "\tif (oh.unique & FUSE_INT_REQ_BIT) {",
                        "\t\t__fuse_get_request(req);",
                        "\t\tspin_unlock(&fpq->lock);",
                        "",
                        "\t\terr = -EINVAL;",
                        "\t\tif (nbytes != sizeof(struct fuse_out_header)) {",
                        "\t\t\tfuse_put_request(fc, req);",
                        "\t\t\tgoto err_finish;",
                        "\t\t}",
                        "",
                        "\t\tif (oh.error == -ENOSYS)",
                        "\t\t\tfc->no_interrupt = 1;",
                        "\t\telse if (oh.error == -EAGAIN)",
                        "\t\t\tqueue_interrupt(&fc->iq, req);",
                        "\t\tfuse_put_request(fc, req);",
                        "",
                        "\t\tfuse_copy_finish(cs);",
                        "\t\treturn nbytes;",
                        "\t}",
                        "",
                        "\tclear_bit(FR_SENT, &req->flags);",
                        "\tlist_move(&req->list, &fpq->io);",
                        "\treq->out.h = oh;",
                        "\tset_bit(FR_LOCKED, &req->flags);",
                        "\tspin_unlock(&fpq->lock);",
                        "\tcs->req = req;",
                        "\tif (!req->out.page_replace)",
                        "\t\tcs->move_pages = 0;",
                        "",
                        "\terr = copy_out_args(cs, &req->out, nbytes);",
                        "\tfuse_copy_finish(cs);",
                        "",
                        "\tspin_lock(&fpq->lock);",
                        "\tclear_bit(FR_LOCKED, &req->flags);",
                        "\tif (!fpq->connected)",
                        "\t\terr = -ENOENT;",
                        "\telse if (err)",
                        "\t\treq->out.h.error = -EIO;",
                        "\tif (!test_bit(FR_PRIVATE, &req->flags))",
                        "\t\tlist_del_init(&req->list);",
                        "\tspin_unlock(&fpq->lock);",
                        "",
                        "\trequest_end(fc, req);",
                        "",
                        "\treturn err ? err : nbytes;",
                        "",
                        " err_unlock_pq:",
                        "\tspin_unlock(&fpq->lock);",
                        " err_finish:",
                        "\tfuse_copy_finish(cs);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1887,
                    "highlight": 1919
                }
            ],
            "ins_idx": 10,
            "addr": "0xffffffff81311266"
        },
        "2567": {
            "name": "fuse_dev_do_write",
            "parent_idx": 2562,
            "source_line": [
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n2003",
                    "code": [
                        "static ssize_t fuse_dev_write(struct kiocb *iocb, struct iov_iter *from)",
                        "{",
                        "\tstruct fuse_copy_state cs;",
                        "\tstruct fuse_dev *fud = fuse_get_dev(iocb->ki_filp);",
                        "",
                        "\tif (!fud)",
                        "\t\treturn -EPERM;",
                        "",
                        "\tif (!iter_is_iovec(from))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tfuse_copy_init(&cs, 0, from);",
                        "",
                        "\treturn fuse_dev_do_write(fud, &cs, iov_iter_count(from));",
                        "}"
                    ],
                    "start": 1990,
                    "highlight": 2003
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81311cb8"
        },
        "2562": {
            "name": "fuse_dev_write(indirect)",
            "parent_idx": 2549,
            "source_line": [
                {
                    "file": "./include/linux/fs.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/fs.h?id=7fbfee7c80ded94278f109aae4063741c323294a#n1862",
                    "code": [
                        "static inline ssize_t call_write_iter(struct file *file, struct kiocb *kio,",
                        "\t\t\t\t      struct iov_iter *iter)",
                        "{",
                        "\treturn file->f_op->write_iter(kio, iter);",
                        "}"
                    ],
                    "start": 1859,
                    "highlight": 1862
                },
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n474",
                    "code": [
                        "static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)",
                        "{",
                        "\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };",
                        "\tstruct kiocb kiocb;",
                        "\tstruct iov_iter iter;",
                        "\tssize_t ret;",
                        "",
                        "\tinit_sync_kiocb(&kiocb, filp);",
                        "\tkiocb.ki_pos = *ppos;",
                        "\tiov_iter_init(&iter, WRITE, &iov, 1, len);",
                        "",
                        "\tret = call_write_iter(filp, &kiocb, &iter);",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\tif (ret > 0)",
                        "\t\t*ppos = kiocb.ki_pos;",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 463,
                    "highlight": 474
                },
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n487",
                    "code": [
                        "ssize_t __vfs_write(struct file *file, const char __user *p, size_t count,",
                        "\t\t    loff_t *pos)",
                        "{",
                        "\tif (file->f_op->write)",
                        "\t\treturn file->f_op->write(file, p, count, pos);",
                        "\telse if (file->f_op->write_iter)",
                        "\t\treturn new_sync_write(file, p, count, pos);",
                        "\telse",
                        "\t\treturn -EINVAL;",
                        "}"
                    ],
                    "start": 481,
                    "highlight": 487
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811be1b3"
        },
        "2549": {
            "name": "__vfs_write",
            "parent_idx": 2527,
            "source_line": [
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n549",
                    "code": [
                        "\tret = rw_verify_area(WRITE, file, pos, count);",
                        "\tif (!ret) {",
                        "\t\tif (count > MAX_RW_COUNT)",
                        "\t\t\tcount =  MAX_RW_COUNT;",
                        "\t\tfile_start_write(file);",
                        "\t\tret = __vfs_write(file, buf, count, pos);",
                        "\t\tif (ret > 0) {",
                        "\t\t\tfsnotify_modify(file);",
                        "\t\t\tadd_wchar(current, ret);",
                        "\t\t}",
                        "\t\tinc_syscw(current);",
                        "\t\tfile_end_write(file);",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 544,
                    "highlight": 549
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811be3cc"
        },
        "2527": {
            "name": "vfs_write",
            "parent_idx": 2520,
            "source_line": [
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n598",
                    "code": [
                        "ssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)",
                        "{",
                        "\tstruct fd f = fdget_pos(fd);",
                        "\tssize_t ret = -EBADF;",
                        "",
                        "\tif (f.file) {",
                        "\t\tloff_t pos = file_pos_read(f.file);",
                        "\t\tret = vfs_write(f.file, buf, count, &pos);",
                        "\t\tif (ret >= 0)",
                        "\t\t\tfile_pos_write(f.file, pos);",
                        "\t\tfdput_pos(f);",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 591,
                    "highlight": 598
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811be785"
        },
        "2520": {
            "name": "__x64_sys_write(indirect)",
            "parent_idx": 2517,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n290",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\t/*",
                        "\t * NB: Native and x32 syscalls are dispatched from the same",
                        "\t * table.  The only functional difference is the x32 bit in",
                        "\t * regs->orig_ax, which changes the behavior of some syscalls.",
                        "\t */",
                        "\tnr &= __SYSCALL_MASK;",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 271,
                    "highlight": 290
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8100243e"
        },
        "2517": {
            "name": "do_syscall_64",
            "parent_idx": 2508,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=7fbfee7c80ded94278f109aae4063741c323294a#n175",
                    "code": [
                        "ENTRY(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "GLOBAL(entry_SYSCALL_64_after_hwframe)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "2508": {
            "name": "146_syscall_7",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "2706": {
            "name": "+0x697",
            "parent_idx": 2567,
            "source_line": [
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1745",
                    "code": [
                        "static int fuse_retrieve(struct fuse_conn *fc, struct inode *inode,",
                        "\t\t\t struct fuse_notify_retrieve_out *outarg)",
                        "{",
                        "\tint err;",
                        "\tstruct address_space *mapping = inode->i_mapping;",
                        "\tstruct fuse_req *req;",
                        "\tpgoff_t index;",
                        "\tloff_t file_size;",
                        "\tunsigned int num;",
                        "\tunsigned int offset;",
                        "\tsize_t total_len = 0;",
                        "\tunsigned int num_pages;",
                        "",
                        "\toffset = outarg->offset & ~PAGE_MASK;",
                        "\tfile_size = i_size_read(inode);",
                        "",
                        "\tnum = outarg->size;",
                        "\tif (outarg->offset > file_size)",
                        "\t\tnum = 0;",
                        "\telse if (outarg->offset + num > file_size)",
                        "\t\tnum = file_size - outarg->offset;",
                        "",
                        "\tnum_pages = (num + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;",
                        "\tnum_pages = min(num_pages, fc->max_pages);",
                        "",
                        "\treq = fuse_get_req(fc, num_pages);",
                        "\tif (IS_ERR(req))",
                        "\t\treturn PTR_ERR(req);",
                        "",
                        "\treq->in.h.opcode = FUSE_NOTIFY_REPLY;",
                        "\treq->in.h.nodeid = outarg->nodeid;",
                        "\treq->in.numargs = 2;",
                        "\treq->in.argpages = 1;",
                        "\treq->page_descs[0].offset = offset;",
                        "\treq->end = fuse_retrieve_end;",
                        "",
                        "\tindex = outarg->offset >> PAGE_SHIFT;",
                        "",
                        "\twhile (num && req->num_pages < num_pages) {",
                        "\t\tstruct page *page;",
                        "\t\tunsigned int this_num;",
                        "",
                        "\t\tpage = find_get_page(mapping, index);",
                        "\t\tif (!page)",
                        "\t\t\tbreak;",
                        "",
                        "\t\tthis_num = min_t(unsigned, num, PAGE_SIZE - offset);",
                        "\t\treq->pages[req->num_pages] = page;",
                        "\t\treq->page_descs[req->num_pages].length = this_num;",
                        "\t\treq->num_pages++;",
                        "",
                        "\t\toffset = 0;",
                        "\t\tnum -= this_num;",
                        "\t\ttotal_len += this_num;",
                        "\t\tindex++;",
                        "\t}",
                        "\treq->misc.retrieve_in.offset = outarg->offset;",
                        "\treq->misc.retrieve_in.size = total_len;",
                        "\treq->in.args[0].size = sizeof(req->misc.retrieve_in);",
                        "\treq->in.args[0].value = &req->misc.retrieve_in;",
                        "\treq->in.args[1].size = total_len;",
                        "",
                        "\terr = fuse_request_send_notify_reply(fc, req, outarg->notify_unique);",
                        "\tif (err) {",
                        "\t\tfuse_retrieve_end(fc, req);",
                        "\t\tfuse_put_request(fc, req);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1712,
                    "highlight": 1745
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1807",
                    "code": [
                        "static int fuse_notify_retrieve(struct fuse_conn *fc, unsigned int size,",
                        "\t\t\t\tstruct fuse_copy_state *cs)",
                        "{",
                        "\tstruct fuse_notify_retrieve_out outarg;",
                        "\tstruct inode *inode;",
                        "\tint err;",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (size != sizeof(outarg))",
                        "\t\tgoto copy_finish;",
                        "",
                        "\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));",
                        "\tif (err)",
                        "\t\tgoto copy_finish;",
                        "",
                        "\tfuse_copy_finish(cs);",
                        "",
                        "\tdown_read(&fc->killsb);",
                        "\terr = -ENOENT;",
                        "\tif (fc->sb) {",
                        "\t\tu64 nodeid = outarg.nodeid;",
                        "",
                        "\t\tinode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);",
                        "\t\tif (inode) {",
                        "\t\t\terr = fuse_retrieve(fc, inode, &outarg);",
                        "\t\t\tiput(inode);",
                        "\t\t}",
                        "\t}",
                        "\tup_read(&fc->killsb);",
                        "",
                        "\treturn err;",
                        "",
                        "copy_finish:",
                        "\tfuse_copy_finish(cs);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1783,
                    "highlight": 1807
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1840",
                    "code": [
                        "static int fuse_notify(struct fuse_conn *fc, enum fuse_notify_code code,",
                        "\t\t       unsigned int size, struct fuse_copy_state *cs)",
                        "{",
                        "\t/* Don't try to move pages (yet) */",
                        "\tcs->move_pages = 0;",
                        "",
                        "\tswitch (code) {",
                        "\tcase FUSE_NOTIFY_POLL:",
                        "\t\treturn fuse_notify_poll(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_INVAL_INODE:",
                        "\t\treturn fuse_notify_inval_inode(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_INVAL_ENTRY:",
                        "\t\treturn fuse_notify_inval_entry(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_STORE:",
                        "\t\treturn fuse_notify_store(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_RETRIEVE:",
                        "\t\treturn fuse_notify_retrieve(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_DELETE:",
                        "\t\treturn fuse_notify_delete(fc, size, cs);",
                        "",
                        "\tdefault:",
                        "\t\tfuse_copy_finish(cs);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "}"
                    ],
                    "start": 1820,
                    "highlight": 1840
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1919",
                    "code": [
                        "/*",
                        " * Write a single reply to a request.  First the header is copied from",
                        " * the write buffer.  The request is then searched on the processing",
                        " * list by the unique ID found in the header.  If found, then remove",
                        " * it from the list and copy the rest of the buffer to the request.",
                        " * The request is finished by calling request_end()",
                        " */",
                        "static ssize_t fuse_dev_do_write(struct fuse_dev *fud,",
                        "\t\t\t\t struct fuse_copy_state *cs, size_t nbytes)",
                        "{",
                        "\tint err;",
                        "\tstruct fuse_conn *fc = fud->fc;",
                        "\tstruct fuse_pqueue *fpq = &fud->pq;",
                        "\tstruct fuse_req *req;",
                        "\tstruct fuse_out_header oh;",
                        "",
                        "\tif (nbytes < sizeof(struct fuse_out_header))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\terr = fuse_copy_one(cs, &oh, sizeof(oh));",
                        "\tif (err)",
                        "\t\tgoto err_finish;",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (oh.len != nbytes)",
                        "\t\tgoto err_finish;",
                        "",
                        "\t/*",
                        "\t * Zero oh.unique indicates unsolicited notification message",
                        "\t * and error contains notification code.",
                        "\t */",
                        "\tif (!oh.unique) {",
                        "\t\terr = fuse_notify(fc, oh.error, nbytes - sizeof(oh), cs);",
                        "\t\treturn err ? err : nbytes;",
                        "\t}",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (oh.error <= -1000 || oh.error > 0)",
                        "\t\tgoto err_finish;",
                        "",
                        "\tspin_lock(&fpq->lock);",
                        "\terr = -ENOENT;",
                        "\tif (!fpq->connected)",
                        "\t\tgoto err_unlock_pq;",
                        "",
                        "\treq = request_find(fpq, oh.unique & ~FUSE_INT_REQ_BIT);",
                        "\tif (!req)",
                        "\t\tgoto err_unlock_pq;",
                        "",
                        "\t/* Is it an interrupt reply ID? */",
                        "\tif (oh.unique & FUSE_INT_REQ_BIT) {",
                        "\t\t__fuse_get_request(req);",
                        "\t\tspin_unlock(&fpq->lock);",
                        "",
                        "\t\terr = -EINVAL;",
                        "\t\tif (nbytes != sizeof(struct fuse_out_header)) {",
                        "\t\t\tfuse_put_request(fc, req);",
                        "\t\t\tgoto err_finish;",
                        "\t\t}",
                        "",
                        "\t\tif (oh.error == -ENOSYS)",
                        "\t\t\tfc->no_interrupt = 1;",
                        "\t\telse if (oh.error == -EAGAIN)",
                        "\t\t\tqueue_interrupt(&fc->iq, req);",
                        "\t\tfuse_put_request(fc, req);",
                        "",
                        "\t\tfuse_copy_finish(cs);",
                        "\t\treturn nbytes;",
                        "\t}",
                        "",
                        "\tclear_bit(FR_SENT, &req->flags);",
                        "\tlist_move(&req->list, &fpq->io);",
                        "\treq->out.h = oh;",
                        "\tset_bit(FR_LOCKED, &req->flags);",
                        "\tspin_unlock(&fpq->lock);",
                        "\tcs->req = req;",
                        "\tif (!req->out.page_replace)",
                        "\t\tcs->move_pages = 0;",
                        "",
                        "\terr = copy_out_args(cs, &req->out, nbytes);",
                        "\tfuse_copy_finish(cs);",
                        "",
                        "\tspin_lock(&fpq->lock);",
                        "\tclear_bit(FR_LOCKED, &req->flags);",
                        "\tif (!fpq->connected)",
                        "\t\terr = -ENOENT;",
                        "\telse if (err)",
                        "\t\treq->out.h.error = -EIO;",
                        "\tif (!test_bit(FR_PRIVATE, &req->flags))",
                        "\t\tlist_del_init(&req->list);",
                        "\tspin_unlock(&fpq->lock);",
                        "",
                        "\trequest_end(fc, req);",
                        "",
                        "\treturn err ? err : nbytes;",
                        "",
                        " err_unlock_pq:",
                        "\tspin_unlock(&fpq->lock);",
                        " err_finish:",
                        "\tfuse_copy_finish(cs);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1887,
                    "highlight": 1919
                }
            ],
            "ins_idx": 34,
            "addr": "0xffffffff81311257"
        },
        "2699": {
            "name": "+0x86",
            "parent_idx": 2694,
            "source_line": [
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n52",
                    "code": [
                        "static void fuse_request_init(struct fuse_req *req, struct page **pages,",
                        "\t\t\t      struct fuse_page_desc *page_descs,",
                        "\t\t\t      unsigned npages)",
                        "{",
                        "\tINIT_LIST_HEAD(&req->list);",
                        "\tINIT_LIST_HEAD(&req->intr_entry);",
                        "\tinit_waitqueue_head(&req->waitq);",
                        "\trefcount_set(&req->count, 1);",
                        "\treq->pages = pages;",
                        "\treq->page_descs = page_descs;",
                        "\treq->max_pages = npages;",
                        "\t__set_bit(FR_PENDING, &req->flags);",
                        "}"
                    ],
                    "start": 43,
                    "highlight": 52
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n89",
                    "code": [
                        "static struct fuse_req *__fuse_request_alloc(unsigned npages, gfp_t flags)",
                        "{",
                        "\tstruct fuse_req *req = kmem_cache_zalloc(fuse_req_cachep, flags);",
                        "\tif (req) {",
                        "\t\tstruct page **pages = NULL;",
                        "\t\tstruct fuse_page_desc *page_descs = NULL;",
                        "",
                        "\t\tWARN_ON(npages > FUSE_MAX_MAX_PAGES);",
                        "\t\tif (npages > FUSE_REQ_INLINE_PAGES) {",
                        "\t\t\tpages = fuse_req_pages_alloc(npages, flags,",
                        "\t\t\t\t\t\t     &page_descs);",
                        "\t\t\tif (!pages) {",
                        "\t\t\t\tkmem_cache_free(fuse_req_cachep, req);",
                        "\t\t\t\treturn NULL;",
                        "\t\t\t}",
                        "\t\t} else if (npages) {",
                        "\t\t\tpages = req->inline_pages;",
                        "\t\t\tpage_descs = req->inline_page_descs;",
                        "\t\t}",
                        "",
                        "\t\tfuse_request_init(req, pages, page_descs, npages);",
                        "\t}",
                        "\treturn req;",
                        "}"
                    ],
                    "start": 69,
                    "highlight": 89
                }
            ],
            "ins_idx": 60,
            "addr": "0xffffffff8130f826"
        },
        "2694": {
            "name": "__fuse_request_alloc",
            "parent_idx": 2692,
            "source_line": [
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n96",
                    "code": [
                        "struct fuse_req *fuse_request_alloc(unsigned npages)",
                        "{",
                        "\treturn __fuse_request_alloc(npages, GFP_KERNEL);",
                        "}"
                    ],
                    "start": 94,
                    "highlight": 96
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n204",
                    "code": [
                        "static struct fuse_req *__fuse_get_req(struct fuse_conn *fc, unsigned npages,",
                        "\t\t\t\t       bool for_background)",
                        "{",
                        "\tstruct fuse_req *req;",
                        "\tint err;",
                        "\tatomic_inc(&fc->num_waiting);",
                        "",
                        "\tif (fuse_block_alloc(fc, for_background)) {",
                        "\t\terr = -EINTR;",
                        "\t\tif (wait_event_killable_exclusive(fc->blocked_waitq,",
                        "\t\t\t\t!fuse_block_alloc(fc, for_background)))",
                        "\t\t\tgoto out;",
                        "\t}",
                        "\t/* Matches smp_wmb() in fuse_set_initialized() */",
                        "\tsmp_rmb();",
                        "",
                        "\terr = -ENOTCONN;",
                        "\tif (!fc->connected)",
                        "\t\tgoto out;",
                        "",
                        "\terr = -ECONNREFUSED;",
                        "\tif (fc->conn_error)",
                        "\t\tgoto out;",
                        "",
                        "\treq = fuse_request_alloc(npages);",
                        "\terr = -ENOMEM;",
                        "\tif (!req) {",
                        "\t\tif (for_background)",
                        "\t\t\twake_up(&fc->blocked_waitq);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\treq->in.h.uid = from_kuid(fc->user_ns, current_fsuid());",
                        "\treq->in.h.gid = from_kgid(fc->user_ns, current_fsgid());",
                        "\treq->in.h.pid = pid_nr_ns(task_pid(current), fc->pid_ns);",
                        "",
                        "\t__set_bit(FR_WAITING, &req->flags);",
                        "\tif (for_background)",
                        "\t\t__set_bit(FR_BACKGROUND, &req->flags);",
                        "",
                        "\tif (unlikely(req->in.h.uid == ((uid_t)-1) ||",
                        "\t\t     req->in.h.gid == ((gid_t)-1))) {",
                        "\t\tfuse_put_request(fc, req);",
                        "\t\treturn ERR_PTR(-EOVERFLOW);",
                        "\t}",
                        "\treturn req;",
                        "",
                        " out:",
                        "\tfuse_drop_waiting(fc);",
                        "\treturn ERR_PTR(err);",
                        "}"
                    ],
                    "start": 180,
                    "highlight": 204
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8130fc71"
        },
        "2692": {
            "name": "__fuse_get_req",
            "parent_idx": 2567,
            "source_line": [
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n234",
                    "code": [
                        "struct fuse_req *fuse_get_req(struct fuse_conn *fc, unsigned npages)",
                        "{",
                        "\treturn __fuse_get_req(fc, npages, false);",
                        "}"
                    ],
                    "start": 232,
                    "highlight": 234
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1737",
                    "code": [
                        "static int fuse_retrieve(struct fuse_conn *fc, struct inode *inode,",
                        "\t\t\t struct fuse_notify_retrieve_out *outarg)",
                        "{",
                        "\tint err;",
                        "\tstruct address_space *mapping = inode->i_mapping;",
                        "\tstruct fuse_req *req;",
                        "\tpgoff_t index;",
                        "\tloff_t file_size;",
                        "\tunsigned int num;",
                        "\tunsigned int offset;",
                        "\tsize_t total_len = 0;",
                        "\tunsigned int num_pages;",
                        "",
                        "\toffset = outarg->offset & ~PAGE_MASK;",
                        "\tfile_size = i_size_read(inode);",
                        "",
                        "\tnum = outarg->size;",
                        "\tif (outarg->offset > file_size)",
                        "\t\tnum = 0;",
                        "\telse if (outarg->offset + num > file_size)",
                        "\t\tnum = file_size - outarg->offset;",
                        "",
                        "\tnum_pages = (num + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;",
                        "\tnum_pages = min(num_pages, fc->max_pages);",
                        "",
                        "\treq = fuse_get_req(fc, num_pages);",
                        "\tif (IS_ERR(req))",
                        "\t\treturn PTR_ERR(req);",
                        "",
                        "\treq->in.h.opcode = FUSE_NOTIFY_REPLY;",
                        "\treq->in.h.nodeid = outarg->nodeid;",
                        "\treq->in.numargs = 2;",
                        "\treq->in.argpages = 1;",
                        "\treq->page_descs[0].offset = offset;",
                        "\treq->end = fuse_retrieve_end;",
                        "",
                        "\tindex = outarg->offset >> PAGE_SHIFT;",
                        "",
                        "\twhile (num && req->num_pages < num_pages) {",
                        "\t\tstruct page *page;",
                        "\t\tunsigned int this_num;",
                        "",
                        "\t\tpage = find_get_page(mapping, index);",
                        "\t\tif (!page)",
                        "\t\t\tbreak;",
                        "",
                        "\t\tthis_num = min_t(unsigned, num, PAGE_SIZE - offset);",
                        "\t\treq->pages[req->num_pages] = page;",
                        "\t\treq->page_descs[req->num_pages].length = this_num;",
                        "\t\treq->num_pages++;",
                        "",
                        "\t\toffset = 0;",
                        "\t\tnum -= this_num;",
                        "\t\ttotal_len += this_num;",
                        "\t\tindex++;",
                        "\t}",
                        "\treq->misc.retrieve_in.offset = outarg->offset;",
                        "\treq->misc.retrieve_in.size = total_len;",
                        "\treq->in.args[0].size = sizeof(req->misc.retrieve_in);",
                        "\treq->in.args[0].value = &req->misc.retrieve_in;",
                        "\treq->in.args[1].size = total_len;",
                        "",
                        "\terr = fuse_request_send_notify_reply(fc, req, outarg->notify_unique);",
                        "\tif (err) {",
                        "\t\tfuse_retrieve_end(fc, req);",
                        "\t\tfuse_put_request(fc, req);",
                        "\t}",
                        "",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1712,
                    "highlight": 1737
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1807",
                    "code": [
                        "static int fuse_notify_retrieve(struct fuse_conn *fc, unsigned int size,",
                        "\t\t\t\tstruct fuse_copy_state *cs)",
                        "{",
                        "\tstruct fuse_notify_retrieve_out outarg;",
                        "\tstruct inode *inode;",
                        "\tint err;",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (size != sizeof(outarg))",
                        "\t\tgoto copy_finish;",
                        "",
                        "\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));",
                        "\tif (err)",
                        "\t\tgoto copy_finish;",
                        "",
                        "\tfuse_copy_finish(cs);",
                        "",
                        "\tdown_read(&fc->killsb);",
                        "\terr = -ENOENT;",
                        "\tif (fc->sb) {",
                        "\t\tu64 nodeid = outarg.nodeid;",
                        "",
                        "\t\tinode = ilookup5(fc->sb, nodeid, fuse_inode_eq, &nodeid);",
                        "\t\tif (inode) {",
                        "\t\t\terr = fuse_retrieve(fc, inode, &outarg);",
                        "\t\t\tiput(inode);",
                        "\t\t}",
                        "\t}",
                        "\tup_read(&fc->killsb);",
                        "",
                        "\treturn err;",
                        "",
                        "copy_finish:",
                        "\tfuse_copy_finish(cs);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1783,
                    "highlight": 1807
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1840",
                    "code": [
                        "static int fuse_notify(struct fuse_conn *fc, enum fuse_notify_code code,",
                        "\t\t       unsigned int size, struct fuse_copy_state *cs)",
                        "{",
                        "\t/* Don't try to move pages (yet) */",
                        "\tcs->move_pages = 0;",
                        "",
                        "\tswitch (code) {",
                        "\tcase FUSE_NOTIFY_POLL:",
                        "\t\treturn fuse_notify_poll(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_INVAL_INODE:",
                        "\t\treturn fuse_notify_inval_inode(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_INVAL_ENTRY:",
                        "\t\treturn fuse_notify_inval_entry(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_STORE:",
                        "\t\treturn fuse_notify_store(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_RETRIEVE:",
                        "\t\treturn fuse_notify_retrieve(fc, size, cs);",
                        "",
                        "\tcase FUSE_NOTIFY_DELETE:",
                        "\t\treturn fuse_notify_delete(fc, size, cs);",
                        "",
                        "\tdefault:",
                        "\t\tfuse_copy_finish(cs);",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "}"
                    ],
                    "start": 1820,
                    "highlight": 1840
                },
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n1919",
                    "code": [
                        "/*",
                        " * Write a single reply to a request.  First the header is copied from",
                        " * the write buffer.  The request is then searched on the processing",
                        " * list by the unique ID found in the header.  If found, then remove",
                        " * it from the list and copy the rest of the buffer to the request.",
                        " * The request is finished by calling request_end()",
                        " */",
                        "static ssize_t fuse_dev_do_write(struct fuse_dev *fud,",
                        "\t\t\t\t struct fuse_copy_state *cs, size_t nbytes)",
                        "{",
                        "\tint err;",
                        "\tstruct fuse_conn *fc = fud->fc;",
                        "\tstruct fuse_pqueue *fpq = &fud->pq;",
                        "\tstruct fuse_req *req;",
                        "\tstruct fuse_out_header oh;",
                        "",
                        "\tif (nbytes < sizeof(struct fuse_out_header))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\terr = fuse_copy_one(cs, &oh, sizeof(oh));",
                        "\tif (err)",
                        "\t\tgoto err_finish;",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (oh.len != nbytes)",
                        "\t\tgoto err_finish;",
                        "",
                        "\t/*",
                        "\t * Zero oh.unique indicates unsolicited notification message",
                        "\t * and error contains notification code.",
                        "\t */",
                        "\tif (!oh.unique) {",
                        "\t\terr = fuse_notify(fc, oh.error, nbytes - sizeof(oh), cs);",
                        "\t\treturn err ? err : nbytes;",
                        "\t}",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (oh.error <= -1000 || oh.error > 0)",
                        "\t\tgoto err_finish;",
                        "",
                        "\tspin_lock(&fpq->lock);",
                        "\terr = -ENOENT;",
                        "\tif (!fpq->connected)",
                        "\t\tgoto err_unlock_pq;",
                        "",
                        "\treq = request_find(fpq, oh.unique & ~FUSE_INT_REQ_BIT);",
                        "\tif (!req)",
                        "\t\tgoto err_unlock_pq;",
                        "",
                        "\t/* Is it an interrupt reply ID? */",
                        "\tif (oh.unique & FUSE_INT_REQ_BIT) {",
                        "\t\t__fuse_get_request(req);",
                        "\t\tspin_unlock(&fpq->lock);",
                        "",
                        "\t\terr = -EINVAL;",
                        "\t\tif (nbytes != sizeof(struct fuse_out_header)) {",
                        "\t\t\tfuse_put_request(fc, req);",
                        "\t\t\tgoto err_finish;",
                        "\t\t}",
                        "",
                        "\t\tif (oh.error == -ENOSYS)",
                        "\t\t\tfc->no_interrupt = 1;",
                        "\t\telse if (oh.error == -EAGAIN)",
                        "\t\t\tqueue_interrupt(&fc->iq, req);",
                        "\t\tfuse_put_request(fc, req);",
                        "",
                        "\t\tfuse_copy_finish(cs);",
                        "\t\treturn nbytes;",
                        "\t}",
                        "",
                        "\tclear_bit(FR_SENT, &req->flags);",
                        "\tlist_move(&req->list, &fpq->io);",
                        "\treq->out.h = oh;",
                        "\tset_bit(FR_LOCKED, &req->flags);",
                        "\tspin_unlock(&fpq->lock);",
                        "\tcs->req = req;",
                        "\tif (!req->out.page_replace)",
                        "\t\tcs->move_pages = 0;",
                        "",
                        "\terr = copy_out_args(cs, &req->out, nbytes);",
                        "\tfuse_copy_finish(cs);",
                        "",
                        "\tspin_lock(&fpq->lock);",
                        "\tclear_bit(FR_LOCKED, &req->flags);",
                        "\tif (!fpq->connected)",
                        "\t\terr = -ENOENT;",
                        "\telse if (err)",
                        "\t\treq->out.h.error = -EIO;",
                        "\tif (!test_bit(FR_PRIVATE, &req->flags))",
                        "\t\tlist_del_init(&req->list);",
                        "\tspin_unlock(&fpq->lock);",
                        "",
                        "\trequest_end(fc, req);",
                        "",
                        "\treturn err ? err : nbytes;",
                        "",
                        " err_unlock_pq:",
                        "\tspin_unlock(&fpq->lock);",
                        " err_finish:",
                        "\tfuse_copy_finish(cs);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1887,
                    "highlight": 1919
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81311229"
        },
        "2698": {
            "name": "+0x3d",
            "parent_idx": 2694,
            "source_line": [
                {
                    "file": "fs/fuse/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fuse/dev.c?id=7fbfee7c80ded94278f109aae4063741c323294a#n74",
                    "code": [
                        "static struct fuse_req *__fuse_request_alloc(unsigned npages, gfp_t flags)",
                        "{",
                        "\tstruct fuse_req *req = kmem_cache_zalloc(fuse_req_cachep, flags);",
                        "\tif (req) {",
                        "\t\tstruct page **pages = NULL;",
                        "\t\tstruct fuse_page_desc *page_descs = NULL;",
                        "",
                        "\t\tWARN_ON(npages > FUSE_MAX_MAX_PAGES);",
                        "\t\tif (npages > FUSE_REQ_INLINE_PAGES) {",
                        "\t\t\tpages = fuse_req_pages_alloc(npages, flags,",
                        "\t\t\t\t\t\t     &page_descs);",
                        "\t\t\tif (!pages) {",
                        "\t\t\t\tkmem_cache_free(fuse_req_cachep, req);",
                        "\t\t\t\treturn NULL;",
                        "\t\t\t}",
                        "\t\t} else if (npages) {",
                        "\t\t\tpages = req->inline_pages;",
                        "\t\t\tpage_descs = req->inline_page_descs;",
                        "\t\t}",
                        "",
                        "\t\tfuse_request_init(req, pages, page_descs, npages);",
                        "\t}",
                        "\treturn req;",
                        "}"
                    ],
                    "start": 69,
                    "highlight": 74
                }
            ],
            "ins_idx": 92,
            "addr": "0xffffffff8130f7dd"
        }
    },
    "ins": {
        "10": {
            "name": "mov dword ptr [rax + 4], r14d",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x4",
            "call_idx": 2707,
            "inputs": [
                4960,
                4961
            ],
            "outputs": [
                4962
            ]
        },
        "34": {
            "name": "mov rax, qword ptr [r13 + 0x128]",
            "desc": "",
            "call_idx": 2706,
            "inputs": [
                4957,
                4958
            ],
            "outputs": [
                4959
            ]
        },
        "60": {
            "name": "mov qword ptr [r12 + 0x128], r13",
            "desc": "",
            "call_idx": 2699,
            "inputs": [
                4942,
                4943
            ],
            "outputs": [
                4944
            ]
        },
        "92": {
            "name": "xor r13d, r13d",
            "desc": "Source of base address CONST 0x0",
            "call_idx": 2698,
            "inputs": [
                4939,
                4940
            ],
            "outputs": [
                4941
            ]
        }
    },
    "data": {
        "4960": {
            "name": "RAX",
            "ins_idx": 10,
            "value": "0x0",
            "sources": []
        },
        "4961": {
            "name": "R14",
            "ins_idx": 10,
            "value": "0x0",
            "sources": []
        },
        "4962": {
            "name": "[0x4]",
            "ins_idx": 10,
            "value": "0x0",
            "sources": []
        },
        "4957": {
            "name": "R13",
            "ins_idx": 34,
            "value": "0xffff888235f5d000",
            "sources": []
        },
        "4958": {
            "name": "[0xffff888235f5d128]",
            "ins_idx": 34,
            "value": "0x0",
            "sources": []
        },
        "4959": {
            "name": "RAX",
            "ins_idx": 34,
            "value": "0x0",
            "sources": [
                4960
            ]
        },
        "4942": {
            "name": "R12",
            "ins_idx": 60,
            "value": "0xffff888235f5d000",
            "sources": []
        },
        "4943": {
            "name": "R13",
            "ins_idx": 60,
            "value": "0x0",
            "sources": []
        },
        "4944": {
            "name": "[0xffff888235f5d128]",
            "ins_idx": 60,
            "value": "0x0",
            "sources": [
                4958
            ]
        },
        "4939": {
            "name": "R13",
            "ins_idx": 92,
            "value": "0x0",
            "sources": []
        },
        "4940": {
            "name": "R13",
            "ins_idx": 92,
            "value": "0x0",
            "sources": []
        },
        "4941": {
            "name": "R13",
            "ins_idx": 92,
            "value": "0x0",
            "sources": [
                4943
            ]
        }
    },
    "chain": {
        "10": [
            34
        ],
        "34": [
            60
        ],
        "60": [
            92
        ]
    }
}