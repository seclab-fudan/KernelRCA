{
    "report": "https://syzkaller.appspot.com/bug?id=12c0ee39a5513b9a22411937566238edde02bef5",
    "title": "BUG: unable to handle kernel NULL pointer dereference in cipso_v4_sock_setattr",
    "call": {
        "408": {
            "name": "+0x3",
            "parent_idx": 407,
            "source_line": [
                {
                    "file": "arch/x86/lib/retpoline.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/lib/retpoline.S?id=ca7e1fd1026c#n32",
                    "code": [
                        "/* SPDX-License-Identifier: GPL-2.0 */",
                        "",
                        "#include <linux/stringify.h>",
                        "#include <linux/linkage.h>",
                        "#include <asm/dwarf2.h>",
                        "#include <asm/cpufeatures.h>",
                        "#include <asm/alternative-asm.h>",
                        "#include <asm/export.h>",
                        "#include <asm/nospec-branch.h>",
                        "",
                        ".macro THUNK reg",
                        "\t.section .text.__x86.indirect_thunk",
                        "",
                        "SYM_FUNC_START(__x86_indirect_thunk_\\reg)",
                        "\tCFI_STARTPROC",
                        "\tJMP_NOSPEC %\\reg",
                        "\tCFI_ENDPROC",
                        "SYM_FUNC_END(__x86_indirect_thunk_\\reg)",
                        ".endm",
                        "",
                        "/*",
                        " * Despite being an assembler file we can't just use .irp here",
                        " * because __KSYM_DEPS__ only uses the C preprocessor and would",
                        " * only see one instance of \"__x86_indirect_thunk_\\reg\" rather",
                        " * than one per register with the correct names. So we do it",
                        " * the simple and nasty way...",
                        " */",
                        "#define __EXPORT_THUNK(sym) _ASM_NOKPROBE(sym); EXPORT_SYMBOL(sym)",
                        "#define EXPORT_THUNK(reg) __EXPORT_THUNK(__x86_indirect_thunk_ ## reg)",
                        "#define GENERATE_THUNK(reg) THUNK reg ; EXPORT_THUNK(reg)",
                        "",
                        "GENERATE_THUNK(_ASM_AX)",
                        "GENERATE_THUNK(_ASM_BX)",
                        "GENERATE_THUNK(_ASM_CX)",
                        "GENERATE_THUNK(_ASM_DX)",
                        "GENERATE_THUNK(_ASM_SI)",
                        "GENERATE_THUNK(_ASM_DI)",
                        "GENERATE_THUNK(_ASM_BP)",
                        "#ifdef CONFIG_64BIT",
                        "GENERATE_THUNK(r8)",
                        "GENERATE_THUNK(r9)",
                        "GENERATE_THUNK(r10)",
                        "GENERATE_THUNK(r11)",
                        "GENERATE_THUNK(r12)",
                        "GENERATE_THUNK(r13)",
                        "GENERATE_THUNK(r14)",
                        "GENERATE_THUNK(r15)",
                        "#endif"
                    ],
                    "start": 1,
                    "highlight": 32
                }
            ],
            "ins_idx": 3,
            "addr": "0xffffffff81e01263"
        },
        "407": {
            "name": "__x86_indirect_thunk_rax(indirect)",
            "parent_idx": 388,
            "source_line": [
                {
                    "file": "net/ipv4/cipso_ipv4.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/cipso_ipv4.c?id=ca7e1fd1026c#n1888",
                    "code": [
                        "/**",
                        " * cipso_v4_sock_setattr - Add a CIPSO option to a socket",
                        " * @sk: the socket",
                        " * @doi_def: the CIPSO DOI to use",
                        " * @secattr: the specific security attributes of the socket",
                        " *",
                        " * Description:",
                        " * Set the CIPSO option on the given socket using the DOI definition and",
                        " * security attributes passed to the function.  This function requires",
                        " * exclusive access to @sk, which means it either needs to be in the",
                        " * process of being created or locked.  Returns zero on success and negative",
                        " * values on failure.",
                        " *",
                        " */",
                        "int cipso_v4_sock_setattr(struct sock *sk,",
                        "\t\t\t  const struct cipso_v4_doi *doi_def,",
                        "\t\t\t  const struct netlbl_lsm_secattr *secattr)",
                        "{",
                        "\tint ret_val = -EPERM;",
                        "\tunsigned char *buf = NULL;",
                        "\tu32 buf_len;",
                        "\tu32 opt_len;",
                        "\tstruct ip_options_rcu *old, *opt = NULL;",
                        "\tstruct inet_sock *sk_inet;",
                        "\tstruct inet_connection_sock *sk_conn;",
                        "",
                        "\t/* In the case of sock_create_lite(), the sock->sk field is not",
                        "\t * defined yet but it is not a problem as the only users of these",
                        "\t * \"lite\" PF_INET sockets are functions which do an accept() call",
                        "\t * afterwards so we will label the socket as part of the accept(). */",
                        "\tif (!sk)",
                        "\t\treturn 0;",
                        "",
                        "\t/* We allocate the maximum CIPSO option size here so we are probably",
                        "\t * being a little wasteful, but it makes our life _much_ easier later",
                        "\t * on and after all we are only talking about 40 bytes. */",
                        "\tbuf_len = CIPSO_V4_OPT_LEN_MAX;",
                        "\tbuf = kmalloc(buf_len, GFP_ATOMIC);",
                        "\tif (!buf) {",
                        "\t\tret_val = -ENOMEM;",
                        "\t\tgoto socket_setattr_failure;",
                        "\t}",
                        "",
                        "\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);",
                        "\tif (ret_val < 0)",
                        "\t\tgoto socket_setattr_failure;",
                        "\tbuf_len = ret_val;",
                        "",
                        "\t/* We can't use ip_options_get() directly because it makes a call to",
                        "\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and",
                        "\t * we won't always have CAP_NET_RAW even though we _always_ want to",
                        "\t * set the IPOPT_CIPSO option. */",
                        "\topt_len = (buf_len + 3) & ~3;",
                        "\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);",
                        "\tif (!opt) {",
                        "\t\tret_val = -ENOMEM;",
                        "\t\tgoto socket_setattr_failure;",
                        "\t}",
                        "\tmemcpy(opt->opt.__data, buf, buf_len);",
                        "\topt->opt.optlen = opt_len;",
                        "\topt->opt.cipso = sizeof(struct iphdr);",
                        "\tkfree(buf);",
                        "\tbuf = NULL;",
                        "",
                        "\tsk_inet = inet_sk(sk);",
                        "",
                        "\told = rcu_dereference_protected(sk_inet->inet_opt,",
                        "\t\t\t\t\tlockdep_sock_is_held(sk));",
                        "\tif (sk_inet->is_icsk) {",
                        "\t\tsk_conn = inet_csk(sk);",
                        "\t\tif (old)",
                        "\t\t\tsk_conn->icsk_ext_hdr_len -= old->opt.optlen;",
                        "\t\tsk_conn->icsk_ext_hdr_len += opt->opt.optlen;",
                        "\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);",
                        "\t}",
                        "\trcu_assign_pointer(sk_inet->inet_opt, opt);",
                        "\tif (old)",
                        "\t\tkfree_rcu(old, rcu);",
                        "",
                        "\treturn 0;",
                        "",
                        "socket_setattr_failure:",
                        "\tkfree(buf);",
                        "\tkfree(opt);",
                        "\treturn ret_val;",
                        "}"
                    ],
                    "start": 1815,
                    "highlight": 1888
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8196d807"
        },
        "388": {
            "name": "cipso_v4_sock_setattr",
            "parent_idx": 379,
            "source_line": [
                {
                    "file": "net/netlabel/netlabel_kapi.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlabel/netlabel_kapi.c?id=ca7e1fd1026c#n989",
                    "code": [
                        "/**",
                        " * netlbl_sock_setattr - Label a socket using the correct protocol",
                        " * @sk: the socket to label",
                        " * @family: protocol family",
                        " * @secattr: the security attributes",
                        " *",
                        " * Description:",
                        " * Attach the correct label to the given socket using the security attributes",
                        " * specified in @secattr.  This function requires exclusive access to @sk,",
                        " * which means it either needs to be in the process of being created or locked.",
                        " * Returns zero on success, -EDESTADDRREQ if the domain is configured to use",
                        " * network address selectors (can't blindly label the socket), and negative",
                        " * values on all other failures.",
                        " *",
                        " */",
                        "int netlbl_sock_setattr(struct sock *sk,",
                        "\t\t\tu16 family,",
                        "\t\t\tconst struct netlbl_lsm_secattr *secattr)",
                        "{",
                        "\tint ret_val;",
                        "\tstruct netlbl_dom_map *dom_entry;",
                        "",
                        "\trcu_read_lock();",
                        "\tdom_entry = netlbl_domhsh_getentry(secattr->domain, family);",
                        "\tif (dom_entry == NULL) {",
                        "\t\tret_val = -ENOENT;",
                        "\t\tgoto socket_setattr_return;",
                        "\t}",
                        "\tswitch (family) {",
                        "\tcase AF_INET:",
                        "\t\tswitch (dom_entry->def.type) {",
                        "\t\tcase NETLBL_NLTYPE_ADDRSELECT:",
                        "\t\t\tret_val = -EDESTADDRREQ;",
                        "\t\t\tbreak;",
                        "\t\tcase NETLBL_NLTYPE_CIPSOV4:",
                        "\t\t\tret_val = cipso_v4_sock_setattr(sk,",
                        "\t\t\t\t\t\t\tdom_entry->def.cipso,",
                        "\t\t\t\t\t\t\tsecattr);",
                        "\t\t\tbreak;",
                        "\t\tcase NETLBL_NLTYPE_UNLABELED:",
                        "\t\t\tret_val = 0;",
                        "\t\t\tbreak;",
                        "\t\tdefault:",
                        "\t\t\tret_val = -ENOENT;",
                        "\t\t}",
                        "\t\tbreak;",
                        "#if IS_ENABLED(CONFIG_IPV6)",
                        "\tcase AF_INET6:",
                        "\t\tswitch (dom_entry->def.type) {",
                        "\t\tcase NETLBL_NLTYPE_ADDRSELECT:",
                        "\t\t\tret_val = -EDESTADDRREQ;",
                        "\t\t\tbreak;",
                        "\t\tcase NETLBL_NLTYPE_CALIPSO:",
                        "\t\t\tret_val = calipso_sock_setattr(sk,",
                        "\t\t\t\t\t\t       dom_entry->def.calipso,",
                        "\t\t\t\t\t\t       secattr);",
                        "\t\t\tbreak;",
                        "\t\tcase NETLBL_NLTYPE_UNLABELED:",
                        "\t\t\tret_val = 0;",
                        "\t\t\tbreak;",
                        "\t\tdefault:",
                        "\t\t\tret_val = -ENOENT;",
                        "\t\t}",
                        "\t\tbreak;",
                        "#endif /* IPv6 */",
                        "\tdefault:",
                        "\t\tret_val = -EPROTONOSUPPORT;",
                        "\t}",
                        "",
                        "socket_setattr_return:",
                        "\trcu_read_unlock();",
                        "\treturn ret_val;",
                        "}"
                    ],
                    "start": 954,
                    "highlight": 989
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81acb438"
        },
        "379": {
            "name": "netlbl_sock_setattr",
            "parent_idx": 376,
            "source_line": [
                {
                    "file": "security/smack/smack_lsm.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=ca7e1fd1026c#n2425",
                    "code": [
                        "/**",
                        " * smack_netlabel - Set the secattr on a socket",
                        " * @sk: the socket",
                        " * @labeled: socket label scheme",
                        " *",
                        " * Convert the outbound smack value (smk_out) to a",
                        " * secattr and attach it to the socket.",
                        " *",
                        " * Returns 0 on success or an error code",
                        " */",
                        "static int smack_netlabel(struct sock *sk, int labeled)",
                        "{",
                        "\tstruct smack_known *skp;",
                        "\tstruct socket_smack *ssp = sk->sk_security;",
                        "\tint rc = 0;",
                        "",
                        "\t/*",
                        "\t * Usually the netlabel code will handle changing the",
                        "\t * packet labeling based on the label.",
                        "\t * The case of a single label host is different, because",
                        "\t * a single label host should never get a labeled packet",
                        "\t * even though the label is usually associated with a packet",
                        "\t * label.",
                        "\t */",
                        "\tlocal_bh_disable();",
                        "\tbh_lock_sock_nested(sk);",
                        "",
                        "\tif (ssp->smk_out == smack_net_ambient ||",
                        "\t    labeled == SMACK_UNLABELED_SOCKET)",
                        "\t\tnetlbl_sock_delattr(sk);",
                        "\telse {",
                        "\t\tskp = ssp->smk_out;",
                        "\t\trc = netlbl_sock_setattr(sk, sk->sk_family, &skp->smk_netlabel);",
                        "\t}",
                        "",
                        "\tbh_unlock_sock(sk);",
                        "\tlocal_bh_enable();",
                        "",
                        "\treturn rc;",
                        "}"
                    ],
                    "start": 2393,
                    "highlight": 2425
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8136e97f"
        },
        "376": {
            "name": "smack_netlabel",
            "parent_idx": 338,
            "source_line": [
                {
                    "file": "security/smack/smack_lsm.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/security/smack/smack_lsm.c?id=ca7e1fd1026c#n2716",
                    "code": [
                        "/**",
                        " * smack_inode_setsecurity - set smack xattrs",
                        " * @inode: the object",
                        " * @name: attribute name",
                        " * @value: attribute value",
                        " * @size: size of the attribute",
                        " * @flags: unused",
                        " *",
                        " * Sets the named attribute in the appropriate blob",
                        " *",
                        " * Returns 0 on success, or an error code",
                        " */",
                        "static int smack_inode_setsecurity(struct inode *inode, const char *name,",
                        "\t\t\t\t   const void *value, size_t size, int flags)",
                        "{",
                        "\tstruct smack_known *skp;",
                        "\tstruct inode_smack *nsp = smack_inode(inode);",
                        "\tstruct socket_smack *ssp;",
                        "\tstruct socket *sock;",
                        "\tint rc = 0;",
                        "",
                        "\tif (value == NULL || size > SMK_LONGLABEL || size == 0)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tskp = smk_import_entry(value, size);",
                        "\tif (IS_ERR(skp))",
                        "\t\treturn PTR_ERR(skp);",
                        "",
                        "\tif (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {",
                        "\t\tnsp->smk_inode = skp;",
                        "\t\tnsp->smk_flags |= SMK_INODE_INSTANT;",
                        "\t\treturn 0;",
                        "\t}",
                        "\t/*",
                        "\t * The rest of the Smack xattrs are only on sockets.",
                        "\t */",
                        "\tif (inode->i_sb->s_magic != SOCKFS_MAGIC)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tsock = SOCKET_I(inode);",
                        "\tif (sock == NULL || sock->sk == NULL)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\tssp = sock->sk->sk_security;",
                        "",
                        "\tif (strcmp(name, XATTR_SMACK_IPIN) == 0)",
                        "\t\tssp->smk_in = skp;",
                        "\telse if (strcmp(name, XATTR_SMACK_IPOUT) == 0) {",
                        "\t\tssp->smk_out = skp;",
                        "\t\tif (sock->sk->sk_family == PF_INET) {",
                        "\t\t\trc = smack_netlabel(sock->sk, SMACK_CIPSO_SOCKET);",
                        "\t\t\tif (rc != 0)",
                        "\t\t\t\tprintk(KERN_WARNING",
                        "\t\t\t\t\t\"Smack: \\\"%s\\\" netlbl error %d.\\n\",",
                        "\t\t\t\t\t__func__, -rc);",
                        "\t\t}",
                        "\t} else",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "#ifdef SMACK_IPV6_PORT_LABELING",
                        "\tif (sock->sk->sk_family == PF_INET6)",
                        "\t\tsmk_ipv6_port_label(sock, NULL);",
                        "#endif",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 2666,
                    "highlight": 2716
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8136eabf"
        },
        "338": {
            "name": "smack_inode_setsecurity(indirect)",
            "parent_idx": 335,
            "source_line": [
                {
                    "file": "security/security.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/security/security.c?id=ca7e1fd1026c#n1364",
                    "code": [
                        "int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)",
                        "{",
                        "\tstruct security_hook_list *hp;",
                        "\tint rc;",
                        "",
                        "\tif (unlikely(IS_PRIVATE(inode)))",
                        "\t\treturn -EOPNOTSUPP;",
                        "\t/*",
                        "\t * Only one module will provide an attribute with a given name.",
                        "\t */",
                        "\thlist_for_each_entry(hp, &security_hook_heads.inode_setsecurity, list) {",
                        "\t\trc = hp->hook.inode_setsecurity(inode, name, value, size,",
                        "\t\t\t\t\t\t\t\tflags);",
                        "\t\tif (rc != -EOPNOTSUPP)",
                        "\t\t\treturn rc;",
                        "\t}",
                        "\treturn -EOPNOTSUPP;",
                        "}"
                    ],
                    "start": 1353,
                    "highlight": 1364
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8136b898"
        },
        "335": {
            "name": "security_inode_setsecurity",
            "parent_idx": 327,
            "source_line": [
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=ca7e1fd1026c#n197",
                    "code": [
                        "/**",
                        " *  __vfs_setxattr_noperm - perform setxattr operation without performing",
                        " *  permission checks.",
                        " *",
                        " *  @dentry - object to perform setxattr on",
                        " *  @name - xattr name to set",
                        " *  @value - value to set @name to",
                        " *  @size - size of @value",
                        " *  @flags - flags to pass into filesystem operations",
                        " *",
                        " *  returns the result of the internal setxattr or setsecurity operations.",
                        " *",
                        " *  This function requires the caller to lock the inode's i_mutex before it",
                        " *  is executed. It also assumes that the caller will make the appropriate",
                        " *  permission checks.",
                        " */",
                        "int __vfs_setxattr_noperm(struct dentry *dentry, const char *name,",
                        "\t\tconst void *value, size_t size, int flags)",
                        "{",
                        "\tstruct inode *inode = dentry->d_inode;",
                        "\tint error = -EAGAIN;",
                        "\tint issec = !strncmp(name, XATTR_SECURITY_PREFIX,",
                        "\t\t\t\t   XATTR_SECURITY_PREFIX_LEN);",
                        "",
                        "\tif (issec)",
                        "\t\tinode->i_flags &= ~S_NOSEC;",
                        "\tif (inode->i_opflags & IOP_XATTR) {",
                        "\t\terror = __vfs_setxattr(dentry, inode, name, value, size, flags);",
                        "\t\tif (!error) {",
                        "\t\t\tfsnotify_xattr(dentry);",
                        "\t\t\tsecurity_inode_post_setxattr(dentry, name, value,",
                        "\t\t\t\t\t\t     size, flags);",
                        "\t\t}",
                        "\t} else {",
                        "\t\tif (unlikely(is_bad_inode(inode)))",
                        "\t\t\treturn -EIO;",
                        "\t}",
                        "\tif (error == -EAGAIN) {",
                        "\t\terror = -EOPNOTSUPP;",
                        "",
                        "\t\tif (issec) {",
                        "\t\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;",
                        "",
                        "\t\t\terror = security_inode_setsecurity(inode, suffix, value,",
                        "\t\t\t\t\t\t\t   size, flags);",
                        "\t\t\tif (!error)",
                        "\t\t\t\tfsnotify_xattr(dentry);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 154,
                    "highlight": 197
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81209f0a"
        },
        "327": {
            "name": "__vfs_setxattr_noperm",
            "parent_idx": 308,
            "source_line": [
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=ca7e1fd1026c#n224",
                    "code": [
                        "int",
                        "vfs_setxattr(struct dentry *dentry, const char *name, const void *value,",
                        "\t\tsize_t size, int flags)",
                        "{",
                        "\tstruct inode *inode = dentry->d_inode;",
                        "\tint error;",
                        "",
                        "\terror = xattr_permission(inode, name, MAY_WRITE);",
                        "\tif (error)",
                        "\t\treturn error;",
                        "",
                        "\tinode_lock(inode);",
                        "\terror = security_inode_setxattr(dentry, name, value, size, flags);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);",
                        "",
                        "out:",
                        "\tinode_unlock(inode);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 208,
                    "highlight": 224
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8120a0a7"
        },
        "308": {
            "name": "vfs_setxattr",
            "parent_idx": 300,
            "source_line": [
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=ca7e1fd1026c#n451",
                    "code": [
                        "\terror = vfs_setxattr(d, kname, kvalue, size, flags);",
                        "out:",
                        "\tkvfree(kvalue);",
                        "",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 451,
                    "highlight": 451
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8120a1db"
        },
        "300": {
            "name": "setxattr",
            "parent_idx": 274,
            "source_line": [
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=ca7e1fd1026c#n506",
                    "code": [
                        "SYSCALL_DEFINE5(fsetxattr, int, fd, const char __user *, name,",
                        "\t\tconst void __user *,value, size_t, size, int, flags)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error = -EBADF;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn error;",
                        "\taudit_file(f.file);",
                        "\terror = mnt_want_write_file(f.file);",
                        "\tif (!error) {",
                        "\t\terror = setxattr(f.file->f_path.dentry, name, value, size, flags);",
                        "\t\tmnt_drop_write_file(f.file);",
                        "\t}",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 495,
                    "highlight": 506
                },
                {
                    "file": "fs/xattr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/xattr.c?id=ca7e1fd1026c#n495",
                    "code": [
                        "SYSCALL_DEFINE5(lsetxattr, const char __user *, pathname,",
                        "\t\tconst char __user *, name, const void __user *, value,",
                        "\t\tsize_t, size, int, flags)",
                        "{",
                        "\treturn path_setxattr(pathname, name, value, size, flags, 0);",
                        "}",
                        "",
                        "SYSCALL_DEFINE5(fsetxattr, int, fd, const char __user *, name,",
                        "\t\tconst void __user *,value, size_t, size, int, flags)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error = -EBADF;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn error;",
                        "\taudit_file(f.file);",
                        "\terror = mnt_want_write_file(f.file);",
                        "\tif (!error) {",
                        "\t\terror = setxattr(f.file->f_path.dentry, name, value, size, flags);",
                        "\t\tmnt_drop_write_file(f.file);",
                        "\t}",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 488,
                    "highlight": 495
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8120a5d3"
        },
        "274": {
            "name": "__x64_sys_fsetxattr(indirect)",
            "parent_idx": 271,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=ca7e1fd1026c#n294",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 281,
                    "highlight": 294
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81002849"
        },
        "271": {
            "name": "do_syscall_64",
            "parent_idx": 264,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=ca7e1fd1026c#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "264": {
            "name": "12_syscall_3",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "406": {
            "name": "+0xd0",
            "parent_idx": 388,
            "source_line": [
                {
                    "file": "net/ipv4/cipso_ipv4.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/cipso_ipv4.c?id=ca7e1fd1026c#n1888",
                    "code": [
                        "/**",
                        " * cipso_v4_sock_setattr - Add a CIPSO option to a socket",
                        " * @sk: the socket",
                        " * @doi_def: the CIPSO DOI to use",
                        " * @secattr: the specific security attributes of the socket",
                        " *",
                        " * Description:",
                        " * Set the CIPSO option on the given socket using the DOI definition and",
                        " * security attributes passed to the function.  This function requires",
                        " * exclusive access to @sk, which means it either needs to be in the",
                        " * process of being created or locked.  Returns zero on success and negative",
                        " * values on failure.",
                        " *",
                        " */",
                        "int cipso_v4_sock_setattr(struct sock *sk,",
                        "\t\t\t  const struct cipso_v4_doi *doi_def,",
                        "\t\t\t  const struct netlbl_lsm_secattr *secattr)",
                        "{",
                        "\tint ret_val = -EPERM;",
                        "\tunsigned char *buf = NULL;",
                        "\tu32 buf_len;",
                        "\tu32 opt_len;",
                        "\tstruct ip_options_rcu *old, *opt = NULL;",
                        "\tstruct inet_sock *sk_inet;",
                        "\tstruct inet_connection_sock *sk_conn;",
                        "",
                        "\t/* In the case of sock_create_lite(), the sock->sk field is not",
                        "\t * defined yet but it is not a problem as the only users of these",
                        "\t * \"lite\" PF_INET sockets are functions which do an accept() call",
                        "\t * afterwards so we will label the socket as part of the accept(). */",
                        "\tif (!sk)",
                        "\t\treturn 0;",
                        "",
                        "\t/* We allocate the maximum CIPSO option size here so we are probably",
                        "\t * being a little wasteful, but it makes our life _much_ easier later",
                        "\t * on and after all we are only talking about 40 bytes. */",
                        "\tbuf_len = CIPSO_V4_OPT_LEN_MAX;",
                        "\tbuf = kmalloc(buf_len, GFP_ATOMIC);",
                        "\tif (!buf) {",
                        "\t\tret_val = -ENOMEM;",
                        "\t\tgoto socket_setattr_failure;",
                        "\t}",
                        "",
                        "\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);",
                        "\tif (ret_val < 0)",
                        "\t\tgoto socket_setattr_failure;",
                        "\tbuf_len = ret_val;",
                        "",
                        "\t/* We can't use ip_options_get() directly because it makes a call to",
                        "\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and",
                        "\t * we won't always have CAP_NET_RAW even though we _always_ want to",
                        "\t * set the IPOPT_CIPSO option. */",
                        "\topt_len = (buf_len + 3) & ~3;",
                        "\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);",
                        "\tif (!opt) {",
                        "\t\tret_val = -ENOMEM;",
                        "\t\tgoto socket_setattr_failure;",
                        "\t}",
                        "\tmemcpy(opt->opt.__data, buf, buf_len);",
                        "\topt->opt.optlen = opt_len;",
                        "\topt->opt.cipso = sizeof(struct iphdr);",
                        "\tkfree(buf);",
                        "\tbuf = NULL;",
                        "",
                        "\tsk_inet = inet_sk(sk);",
                        "",
                        "\told = rcu_dereference_protected(sk_inet->inet_opt,",
                        "\t\t\t\t\tlockdep_sock_is_held(sk));",
                        "\tif (sk_inet->is_icsk) {",
                        "\t\tsk_conn = inet_csk(sk);",
                        "\t\tif (old)",
                        "\t\t\tsk_conn->icsk_ext_hdr_len -= old->opt.optlen;",
                        "\t\tsk_conn->icsk_ext_hdr_len += opt->opt.optlen;",
                        "\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);",
                        "\t}",
                        "\trcu_assign_pointer(sk_inet->inet_opt, opt);",
                        "\tif (old)",
                        "\t\tkfree_rcu(old, rcu);",
                        "",
                        "\treturn 0;",
                        "",
                        "socket_setattr_failure:",
                        "\tkfree(buf);",
                        "\tkfree(opt);",
                        "\treturn ret_val;",
                        "}"
                    ],
                    "start": 1815,
                    "highlight": 1888
                }
            ],
            "ins_idx": 6,
            "addr": "0xffffffff8196d800"
        },
        "67": {
            "name": "+0x4a",
            "parent_idx": 47,
            "source_line": [
                {
                    "file": "arch/x86/lib/memset_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/lib/memset_64.S?id=ca7e1fd1026c#n98",
                    "code": [
                        "SYM_FUNC_START_LOCAL(memset_orig)",
                        "\tmovq %rdi,%r10",
                        "",
                        "\t/* expand byte value  */",
                        "\tmovzbl %sil,%ecx",
                        "\tmovabs $0x0101010101010101,%rax",
                        "\timulq  %rcx,%rax",
                        "",
                        "\t/* align dst */",
                        "\tmovl  %edi,%r9d",
                        "\tandl  $7,%r9d",
                        "\tjnz  .Lbad_alignment",
                        ".Lafter_bad_alignment:",
                        "",
                        "\tmovq  %rdx,%rcx",
                        "\tshrq  $6,%rcx",
                        "\tjz\t .Lhandle_tail",
                        "",
                        "\t.p2align 4",
                        ".Lloop_64:",
                        "\tdecq  %rcx",
                        "\tmovq  %rax,(%rdi)",
                        "\tmovq  %rax,8(%rdi)",
                        "\tmovq  %rax,16(%rdi)",
                        "\tmovq  %rax,24(%rdi)",
                        "\tmovq  %rax,32(%rdi)",
                        "\tmovq  %rax,40(%rdi)",
                        "\tmovq  %rax,48(%rdi)",
                        "\tmovq  %rax,56(%rdi)",
                        "\tleaq  64(%rdi),%rdi",
                        "\tjnz    .Lloop_64",
                        "",
                        "\t/* Handle tail in loops. The loops should be faster than hard",
                        "\t   to predict jump tables. */",
                        "\t.p2align 4",
                        ".Lhandle_tail:",
                        "\tmovl\t%edx,%ecx",
                        "\tandl    $63&(~7),%ecx",
                        "\tjz \t\t.Lhandle_7",
                        "\tshrl\t$3,%ecx",
                        "\t.p2align 4",
                        ".Lloop_8:",
                        "\tdecl   %ecx",
                        "\tmovq  %rax,(%rdi)",
                        "\tleaq  8(%rdi),%rdi",
                        "\tjnz    .Lloop_8",
                        "",
                        ".Lhandle_7:",
                        "\tandl\t$7,%edx",
                        "\tjz      .Lende",
                        "\t.p2align 4",
                        ".Lloop_1:",
                        "\tdecl    %edx",
                        "\tmovb \t%al,(%rdi)",
                        "\tleaq\t1(%rdi),%rdi",
                        "\tjnz     .Lloop_1",
                        "",
                        ".Lende:",
                        "\tmovq\t%r10,%rax",
                        "\tret",
                        "",
                        ".Lbad_alignment:",
                        "\tcmpq $7,%rdx",
                        "\tjbe\t.Lhandle_7",
                        "\tmovq %rax,(%rdi)\t/* unaligned store */",
                        "\tmovq $8,%r8",
                        "\tsubq %r9,%r8",
                        "\taddq %r8,%rdi",
                        "\tsubq %r8,%rdx",
                        "\tjmp .Lafter_bad_alignment",
                        ".Lfinal:",
                        "SYM_FUNC_END(memset_orig)"
                    ],
                    "start": 71,
                    "highlight": 98
                }
            ],
            "ins_idx": 10,
            "addr": "0xffffffff81aed79a"
        },
        "47": {
            "name": "memset",
            "parent_idx": 41,
            "source_line": [
                {
                    "file": "./include/net/sock.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/sock.h?id=ca7e1fd1026c#n1048",
                    "code": [
                        "/*",
                        " * caches using SLAB_TYPESAFE_BY_RCU should let .next pointer from nulls nodes",
                        " * un-modified. Special care is taken when initializing object to zero.",
                        " */",
                        "static inline void sk_prot_clear_nulls(struct sock *sk, int size)",
                        "{",
                        "\tif (offsetof(struct sock, sk_node.next) != 0)",
                        "\t\tmemset(sk, 0, offsetof(struct sock, sk_node.next));",
                        "\tmemset(&sk->sk_node.pprev, 0,",
                        "\t       size - offsetof(struct sock, sk_node.pprev));",
                        "}"
                    ],
                    "start": 1040,
                    "highlight": 1048
                },
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=ca7e1fd1026c#n1601",
                    "code": [
                        "static struct sock *sk_prot_alloc(struct proto *prot, gfp_t priority,",
                        "\t\tint family)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tstruct kmem_cache *slab;",
                        "",
                        "\tslab = prot->slab;",
                        "\tif (slab != NULL) {",
                        "\t\tsk = kmem_cache_alloc(slab, priority & ~__GFP_ZERO);",
                        "\t\tif (!sk)",
                        "\t\t\treturn sk;",
                        "\t\tif (want_init_on_alloc(priority))",
                        "\t\t\tsk_prot_clear_nulls(sk, prot->obj_size);",
                        "\t} else",
                        "\t\tsk = kmalloc(prot->obj_size, priority);",
                        "",
                        "\tif (sk != NULL) {",
                        "\t\tif (security_sk_alloc(sk, family, priority))",
                        "\t\t\tgoto out_free;",
                        "",
                        "\t\tif (!try_module_get(prot->owner))",
                        "\t\t\tgoto out_free_sec;",
                        "\t\tsk_tx_queue_clear(sk);",
                        "\t}",
                        "",
                        "\treturn sk;",
                        "",
                        "out_free_sec:",
                        "\tsecurity_sk_free(sk);",
                        "out_free:",
                        "\tif (slab != NULL)",
                        "\t\tkmem_cache_free(slab, sk);",
                        "\telse",
                        "\t\tkfree(sk);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 1589,
                    "highlight": 1601
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818651bd"
        },
        "41": {
            "name": "sk_prot_alloc",
            "parent_idx": 38,
            "source_line": [
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=ca7e1fd1026c#n1657",
                    "code": [
                        "/**",
                        " *\tsk_alloc - All socket objects are allocated here",
                        " *\t@net: the applicable net namespace",
                        " *\t@family: protocol family",
                        " *\t@priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc)",
                        " *\t@prot: struct proto associated with this new sock instance",
                        " *\t@kern: is this to be a kernel socket?",
                        " */",
                        "struct sock *sk_alloc(struct net *net, int family, gfp_t priority,",
                        "\t\t      struct proto *prot, int kern)",
                        "{",
                        "\tstruct sock *sk;",
                        "",
                        "\tsk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);",
                        "\tif (sk) {",
                        "\t\tsk->sk_family = family;",
                        "\t\t/*",
                        "\t\t * See comment in struct sock definition to understand",
                        "\t\t * why we need sk_prot_creator -acme",
                        "\t\t */",
                        "\t\tsk->sk_prot = sk->sk_prot_creator = prot;",
                        "\t\tsk->sk_kern_sock = kern;",
                        "\t\tsock_lock_init(sk);",
                        "\t\tsk->sk_net_refcnt = kern ? 0 : 1;",
                        "\t\tif (likely(sk->sk_net_refcnt)) {",
                        "\t\t\tget_net(net);",
                        "\t\t\tsock_inuse_add(net, 1);",
                        "\t\t}",
                        "",
                        "\t\tsock_net_set(sk, net);",
                        "\t\trefcount_set(&sk->sk_wmem_alloc, 1);",
                        "",
                        "\t\tmem_cgroup_sk_alloc(sk);",
                        "\t\tcgroup_sk_alloc(&sk->sk_cgrp_data);",
                        "\t\tsock_update_classid(&sk->sk_cgrp_data);",
                        "\t\tsock_update_netprioidx(&sk->sk_cgrp_data);",
                        "\t}",
                        "",
                        "\treturn sk;",
                        "}"
                    ],
                    "start": 1644,
                    "highlight": 1657
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818673b2"
        },
        "38": {
            "name": "sk_alloc",
            "parent_idx": 35,
            "source_line": [
                {
                    "file": "net/ipv4/af_inet.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/af_inet.c?id=ca7e1fd1026c#n321",
                    "code": [
                        "static int inet_create(struct net *net, struct socket *sock, int protocol,",
                        "\t\t       int kern)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tstruct inet_protosw *answer;",
                        "\tstruct inet_sock *inet;",
                        "\tstruct proto *answer_prot;",
                        "\tunsigned char answer_flags;",
                        "\tint try_loading_module = 0;",
                        "\tint err;",
                        "",
                        "\tif (protocol < 0 || protocol >= IPPROTO_MAX)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tsock->state = SS_UNCONNECTED;",
                        "",
                        "\t/* Look for the requested type/protocol pair. */",
                        "lookup_protocol:",
                        "\terr = -ESOCKTNOSUPPORT;",
                        "\trcu_read_lock();",
                        "\tlist_for_each_entry_rcu(answer, &inetsw[sock->type], list) {",
                        "",
                        "\t\terr = 0;",
                        "\t\t/* Check the non-wild match. */",
                        "\t\tif (protocol == answer->protocol) {",
                        "\t\t\tif (protocol != IPPROTO_IP)",
                        "\t\t\t\tbreak;",
                        "\t\t} else {",
                        "\t\t\t/* Check for the two wild cases. */",
                        "\t\t\tif (IPPROTO_IP == protocol) {",
                        "\t\t\t\tprotocol = answer->protocol;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tif (IPPROTO_IP == answer->protocol)",
                        "\t\t\t\tbreak;",
                        "\t\t}",
                        "\t\terr = -EPROTONOSUPPORT;",
                        "\t}",
                        "",
                        "\tif (unlikely(err)) {",
                        "\t\tif (try_loading_module < 2) {",
                        "\t\t\trcu_read_unlock();",
                        "\t\t\t/*",
                        "\t\t\t * Be more specific, e.g. net-pf-2-proto-132-type-1",
                        "\t\t\t * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM)",
                        "\t\t\t */",
                        "\t\t\tif (++try_loading_module == 1)",
                        "\t\t\t\trequest_module(\"net-pf-%d-proto-%d-type-%d\",",
                        "\t\t\t\t\t       PF_INET, protocol, sock->type);",
                        "\t\t\t/*",
                        "\t\t\t * Fall back to generic, e.g. net-pf-2-proto-132",
                        "\t\t\t * (net-pf-PF_INET-proto-IPPROTO_SCTP)",
                        "\t\t\t */",
                        "\t\t\telse",
                        "\t\t\t\trequest_module(\"net-pf-%d-proto-%d\",",
                        "\t\t\t\t\t       PF_INET, protocol);",
                        "\t\t\tgoto lookup_protocol;",
                        "\t\t} else",
                        "\t\t\tgoto out_rcu_unlock;",
                        "\t}",
                        "",
                        "\terr = -EPERM;",
                        "\tif (sock->type == SOCK_RAW && !kern &&",
                        "\t    !ns_capable(net->user_ns, CAP_NET_RAW))",
                        "\t\tgoto out_rcu_unlock;",
                        "",
                        "\tsock->ops = answer->ops;",
                        "\tanswer_prot = answer->prot;",
                        "\tanswer_flags = answer->flags;",
                        "\trcu_read_unlock();",
                        "",
                        "\tWARN_ON(!answer_prot->slab);",
                        "",
                        "\terr = -ENOBUFS;",
                        "\tsk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern);",
                        "\tif (!sk)",
                        "\t\tgoto out;",
                        "",
                        "\terr = 0;",
                        "\tif (INET_PROTOSW_REUSE & answer_flags)",
                        "\t\tsk->sk_reuse = SK_CAN_REUSE;",
                        "",
                        "\tinet = inet_sk(sk);",
                        "\tinet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0;",
                        "",
                        "\tinet->nodefrag = 0;",
                        "",
                        "\tif (SOCK_RAW == sock->type) {",
                        "\t\tinet->inet_num = protocol;",
                        "\t\tif (IPPROTO_RAW == protocol)",
                        "\t\t\tinet->hdrincl = 1;",
                        "\t}",
                        "",
                        "\tif (net->ipv4.sysctl_ip_no_pmtu_disc)",
                        "\t\tinet->pmtudisc = IP_PMTUDISC_DONT;",
                        "\telse",
                        "\t\tinet->pmtudisc = IP_PMTUDISC_WANT;",
                        "",
                        "\tinet->inet_id = 0;",
                        "",
                        "\tsock_init_data(sock, sk);",
                        "",
                        "\tsk->sk_destruct\t   = inet_sock_destruct;",
                        "\tsk->sk_protocol\t   = protocol;",
                        "\tsk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;",
                        "",
                        "\tinet->uc_ttl\t= -1;",
                        "\tinet->mc_loop\t= 1;",
                        "\tinet->mc_ttl\t= 1;",
                        "\tinet->mc_all\t= 1;",
                        "\tinet->mc_index\t= 0;",
                        "\tinet->mc_list\t= NULL;",
                        "\tinet->rcv_tos\t= 0;",
                        "",
                        "\tsk_refcnt_debug_inc(sk);",
                        "",
                        "\tif (inet->inet_num) {",
                        "\t\t/* It assumes that any protocol which allows",
                        "\t\t * the user to assign a number at socket",
                        "\t\t * creation time automatically",
                        "\t\t * shares.",
                        "\t\t */",
                        "\t\tinet->inet_sport = htons(inet->inet_num);",
                        "\t\t/* Add to protocol hash chains. */",
                        "\t\terr = sk->sk_prot->hash(sk);",
                        "\t\tif (err) {",
                        "\t\t\tsk_common_release(sk);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (sk->sk_prot->init) {",
                        "\t\terr = sk->sk_prot->init(sk);",
                        "\t\tif (err) {",
                        "\t\t\tsk_common_release(sk);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (!kern) {",
                        "\t\terr = BPF_CGROUP_RUN_PROG_INET_SOCK(sk);",
                        "\t\tif (err) {",
                        "\t\t\tsk_common_release(sk);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "out:",
                        "\treturn err;",
                        "out_rcu_unlock:",
                        "\trcu_read_unlock();",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 247,
                    "highlight": 321
                },
                {
                    "file": "net/ipv4/af_inet.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/af_inet.c?id=ca7e1fd1026c#n247",
                    "code": [
                        "static int inet_create(struct net *net, struct socket *sock, int protocol,",
                        "\t\t       int kern)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tstruct inet_protosw *answer;",
                        "\tstruct inet_sock *inet;",
                        "\tstruct proto *answer_prot;",
                        "\tunsigned char answer_flags;",
                        "\tint try_loading_module = 0;",
                        "\tint err;",
                        "",
                        "\tif (protocol < 0 || protocol >= IPPROTO_MAX)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tsock->state = SS_UNCONNECTED;",
                        "",
                        "\t/* Look for the requested type/protocol pair. */",
                        "lookup_protocol:",
                        "\terr = -ESOCKTNOSUPPORT;",
                        "\trcu_read_lock();",
                        "\tlist_for_each_entry_rcu(answer, &inetsw[sock->type], list) {",
                        "",
                        "\t\terr = 0;",
                        "\t\t/* Check the non-wild match. */",
                        "\t\tif (protocol == answer->protocol) {",
                        "\t\t\tif (protocol != IPPROTO_IP)",
                        "\t\t\t\tbreak;",
                        "\t\t} else {",
                        "\t\t\t/* Check for the two wild cases. */",
                        "\t\t\tif (IPPROTO_IP == protocol) {",
                        "\t\t\t\tprotocol = answer->protocol;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t\tif (IPPROTO_IP == answer->protocol)",
                        "\t\t\t\tbreak;",
                        "\t\t}",
                        "\t\terr = -EPROTONOSUPPORT;",
                        "\t}",
                        "",
                        "\tif (unlikely(err)) {",
                        "\t\tif (try_loading_module < 2) {",
                        "\t\t\trcu_read_unlock();",
                        "\t\t\t/*",
                        "\t\t\t * Be more specific, e.g. net-pf-2-proto-132-type-1",
                        "\t\t\t * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM)",
                        "\t\t\t */",
                        "\t\t\tif (++try_loading_module == 1)",
                        "\t\t\t\trequest_module(\"net-pf-%d-proto-%d-type-%d\",",
                        "\t\t\t\t\t       PF_INET, protocol, sock->type);",
                        "\t\t\t/*",
                        "\t\t\t * Fall back to generic, e.g. net-pf-2-proto-132",
                        "\t\t\t * (net-pf-PF_INET-proto-IPPROTO_SCTP)",
                        "\t\t\t */",
                        "\t\t\telse",
                        "\t\t\t\trequest_module(\"net-pf-%d-proto-%d\",",
                        "\t\t\t\t\t       PF_INET, protocol);",
                        "\t\t\tgoto lookup_protocol;",
                        "\t\t} else",
                        "\t\t\tgoto out_rcu_unlock;",
                        "\t}",
                        "",
                        "\terr = -EPERM;",
                        "\tif (sock->type == SOCK_RAW && !kern &&",
                        "\t    !ns_capable(net->user_ns, CAP_NET_RAW))",
                        "\t\tgoto out_rcu_unlock;",
                        "",
                        "\tsock->ops = answer->ops;",
                        "\tanswer_prot = answer->prot;",
                        "\tanswer_flags = answer->flags;",
                        "\trcu_read_unlock();",
                        "",
                        "\tWARN_ON(!answer_prot->slab);",
                        "",
                        "\terr = -ENOBUFS;",
                        "\tsk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern);",
                        "\tif (!sk)",
                        "\t\tgoto out;",
                        "",
                        "\terr = 0;",
                        "\tif (INET_PROTOSW_REUSE & answer_flags)",
                        "\t\tsk->sk_reuse = SK_CAN_REUSE;",
                        "",
                        "\tinet = inet_sk(sk);",
                        "\tinet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0;",
                        "",
                        "\tinet->nodefrag = 0;",
                        "",
                        "\tif (SOCK_RAW == sock->type) {",
                        "\t\tinet->inet_num = protocol;",
                        "\t\tif (IPPROTO_RAW == protocol)",
                        "\t\t\tinet->hdrincl = 1;",
                        "\t}",
                        "",
                        "\tif (net->ipv4.sysctl_ip_no_pmtu_disc)",
                        "\t\tinet->pmtudisc = IP_PMTUDISC_DONT;",
                        "\telse",
                        "\t\tinet->pmtudisc = IP_PMTUDISC_WANT;",
                        "",
                        "\tinet->inet_id = 0;",
                        "",
                        "\tsock_init_data(sock, sk);",
                        "",
                        "\tsk->sk_destruct\t   = inet_sock_destruct;",
                        "\tsk->sk_protocol\t   = protocol;",
                        "\tsk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;",
                        "",
                        "\tinet->uc_ttl\t= -1;",
                        "\tinet->mc_loop\t= 1;",
                        "\tinet->mc_ttl\t= 1;",
                        "\tinet->mc_all\t= 1;",
                        "\tinet->mc_index\t= 0;",
                        "\tinet->mc_list\t= NULL;",
                        "\tinet->rcv_tos\t= 0;",
                        "",
                        "\tsk_refcnt_debug_inc(sk);",
                        "",
                        "\tif (inet->inet_num) {",
                        "\t\t/* It assumes that any protocol which allows",
                        "\t\t * the user to assign a number at socket",
                        "\t\t * creation time automatically",
                        "\t\t * shares.",
                        "\t\t */",
                        "\t\tinet->inet_sport = htons(inet->inet_num);",
                        "\t\t/* Add to protocol hash chains. */",
                        "\t\terr = sk->sk_prot->hash(sk);",
                        "\t\tif (err) {",
                        "\t\t\tsk_common_release(sk);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (sk->sk_prot->init) {",
                        "\t\terr = sk->sk_prot->init(sk);",
                        "\t\tif (err) {",
                        "\t\t\tsk_common_release(sk);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tif (!kern) {",
                        "\t\terr = BPF_CGROUP_RUN_PROG_INET_SOCK(sk);",
                        "\t\tif (err) {",
                        "\t\t\tsk_common_release(sk);",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t}",
                        "out:",
                        "\treturn err;",
                        "out_rcu_unlock:",
                        "\trcu_read_unlock();",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 247,
                    "highlight": 247
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81945864"
        },
        "35": {
            "name": "inet_create(indirect)",
            "parent_idx": 9,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=ca7e1fd1026c#n1433",
                    "code": [
                        "int __sock_create(struct net *net, int family, int type, int protocol,",
                        "\t\t\t struct socket **res, int kern)",
                        "{",
                        "\tint err;",
                        "\tstruct socket *sock;",
                        "\tconst struct net_proto_family *pf;",
                        "",
                        "\t/*",
                        "\t *      Check protocol is in range",
                        "\t */",
                        "\tif (family < 0 || family >= NPROTO)",
                        "\t\treturn -EAFNOSUPPORT;",
                        "\tif (type < 0 || type >= SOCK_MAX)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\t/* Compatibility.",
                        "",
                        "\t   This uglymoron is moved from INET layer to here to avoid",
                        "\t   deadlock in module load.",
                        "\t */",
                        "\tif (family == PF_INET && type == SOCK_PACKET) {",
                        "\t\tpr_info_once(\"%s uses obsolete (PF_INET,SOCK_PACKET)\\n\",",
                        "\t\t\t     current->comm);",
                        "\t\tfamily = PF_PACKET;",
                        "\t}",
                        "",
                        "\terr = security_socket_create(family, type, protocol, kern);",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\t/*",
                        "\t *\tAllocate the socket and allow the family to set things up. if",
                        "\t *\tthe protocol is 0, the family is instructed to select an appropriate",
                        "\t *\tdefault.",
                        "\t */",
                        "\tsock = sock_alloc();",
                        "\tif (!sock) {",
                        "\t\tnet_warn_ratelimited(\"socket: no more sockets\\n\");",
                        "\t\treturn -ENFILE;\t/* Not exactly a match, but its the",
                        "\t\t\t\t   closest posix thing */",
                        "\t}",
                        "",
                        "\tsock->type = type;",
                        "",
                        "#ifdef CONFIG_MODULES",
                        "\t/* Attempt to load a protocol module if the find failed.",
                        "\t *",
                        "\t * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user",
                        "\t * requested real, full-featured networking support upon configuration.",
                        "\t * Otherwise module support will break!",
                        "\t */",
                        "\tif (rcu_access_pointer(net_families[family]) == NULL)",
                        "\t\trequest_module(\"net-pf-%d\", family);",
                        "#endif",
                        "",
                        "\trcu_read_lock();",
                        "\tpf = rcu_dereference(net_families[family]);",
                        "\terr = -EAFNOSUPPORT;",
                        "\tif (!pf)",
                        "\t\tgoto out_release;",
                        "",
                        "\t/*",
                        "\t * We will call the ->create function, that possibly is in a loadable",
                        "\t * module, so we have to bump that loadable module refcnt first.",
                        "\t */",
                        "\tif (!try_module_get(pf->owner))",
                        "\t\tgoto out_release;",
                        "",
                        "\t/* Now protected by module ref count */",
                        "\trcu_read_unlock();",
                        "",
                        "\terr = pf->create(net, sock, protocol, kern);",
                        "\tif (err < 0)",
                        "\t\tgoto out_module_put;",
                        "",
                        "\t/*",
                        "\t * Now to bump the refcnt of the [loadable] module that owns this",
                        "\t * socket at sock_release time we decrement its refcnt.",
                        "\t */",
                        "\tif (!try_module_get(sock->ops->owner))",
                        "\t\tgoto out_module_busy;",
                        "",
                        "\t/*",
                        "\t * Now that we're done with the ->create function, the [loadable]",
                        "\t * module can have its refcnt decremented",
                        "\t */",
                        "\tmodule_put(pf->owner);",
                        "\terr = security_socket_post_create(sock, family, type, protocol, kern);",
                        "\tif (err)",
                        "\t\tgoto out_sock_release;",
                        "\t*res = sock;",
                        "",
                        "\treturn 0;",
                        "",
                        "out_module_busy:",
                        "\terr = -EAFNOSUPPORT;",
                        "out_module_put:",
                        "\tsock->ops = NULL;",
                        "\tmodule_put(pf->owner);",
                        "out_sock_release:",
                        "\tsock_release(sock);",
                        "\treturn err;",
                        "",
                        "out_release:",
                        "\trcu_read_unlock();",
                        "\tgoto out_sock_release;",
                        "}"
                    ],
                    "start": 1362,
                    "highlight": 1433
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818602dd"
        },
        "9": {
            "name": "__sock_create",
            "parent_idx": 6,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=ca7e1fd1026c#n1484",
                    "code": [
                        "int sock_create(int family, int type, int protocol, struct socket **res)",
                        "{",
                        "\treturn __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);",
                        "}"
                    ],
                    "start": 1482,
                    "highlight": 1484
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=ca7e1fd1026c#n1526",
                    "code": [
                        "int __sys_socket(int family, int type, int protocol)",
                        "{",
                        "\tint retval;",
                        "\tstruct socket *sock;",
                        "\tint flags;",
                        "",
                        "\t/* Check the SOCK_* constants for consistency.  */",
                        "\tBUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);",
                        "\tBUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);",
                        "\tBUILD_BUG_ON(SOCK_CLOEXEC & SOCK_TYPE_MASK);",
                        "\tBUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);",
                        "",
                        "\tflags = type & ~SOCK_TYPE_MASK;",
                        "\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))",
                        "\t\treturn -EINVAL;",
                        "\ttype &= SOCK_TYPE_MASK;",
                        "",
                        "\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))",
                        "\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;",
                        "",
                        "\tretval = sock_create(family, type, protocol, &sock);",
                        "\tif (retval < 0)",
                        "\t\treturn retval;",
                        "",
                        "\treturn sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));",
                        "}"
                    ],
                    "start": 1506,
                    "highlight": 1526
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81862dbf"
        },
        "6": {
            "name": "__sys_socket",
            "parent_idx": 5,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=ca7e1fd1026c#n1535",
                    "code": [
                        "SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)",
                        "{",
                        "\treturn __sys_socket(family, type, protocol);",
                        "}"
                    ],
                    "start": 1533,
                    "highlight": 1535
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=ca7e1fd1026c#n1533",
                    "code": [
                        "int __sys_socket(int family, int type, int protocol)",
                        "{",
                        "\tint retval;",
                        "\tstruct socket *sock;",
                        "\tint flags;",
                        "",
                        "\t/* Check the SOCK_* constants for consistency.  */",
                        "\tBUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);",
                        "\tBUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);",
                        "\tBUILD_BUG_ON(SOCK_CLOEXEC & SOCK_TYPE_MASK);",
                        "\tBUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);",
                        "",
                        "\tflags = type & ~SOCK_TYPE_MASK;",
                        "\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))",
                        "\t\treturn -EINVAL;",
                        "\ttype &= SOCK_TYPE_MASK;",
                        "",
                        "\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))",
                        "\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;",
                        "",
                        "\tretval = sock_create(family, type, protocol, &sock);",
                        "\tif (retval < 0)",
                        "\t\treturn retval;",
                        "",
                        "\treturn sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)",
                        "{",
                        "\treturn __sys_socket(family, type, protocol);",
                        "}"
                    ],
                    "start": 1506,
                    "highlight": 1533
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81862e5c"
        },
        "5": {
            "name": "__x64_sys_socket(indirect)",
            "parent_idx": 4,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=ca7e1fd1026c#n294",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 281,
                    "highlight": 294
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81002849"
        },
        "4": {
            "name": "do_syscall_64",
            "parent_idx": 2,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=ca7e1fd1026c#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "2": {
            "name": "7_syscall_2",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "50": {
            "name": "+0x11",
            "parent_idx": 47,
            "source_line": [
                {
                    "file": "arch/x86/lib/memset_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/lib/memset_64.S?id=ca7e1fd1026c#n77",
                    "code": [
                        "SYM_FUNC_START_LOCAL(memset_orig)",
                        "\tmovq %rdi,%r10",
                        "",
                        "\t/* expand byte value  */",
                        "\tmovzbl %sil,%ecx",
                        "\tmovabs $0x0101010101010101,%rax",
                        "\timulq  %rcx,%rax",
                        "",
                        "\t/* align dst */",
                        "\tmovl  %edi,%r9d",
                        "\tandl  $7,%r9d",
                        "\tjnz  .Lbad_alignment",
                        ".Lafter_bad_alignment:",
                        "",
                        "\tmovq  %rdx,%rcx",
                        "\tshrq  $6,%rcx",
                        "\tjz\t .Lhandle_tail",
                        "",
                        "\t.p2align 4",
                        ".Lloop_64:",
                        "\tdecq  %rcx",
                        "\tmovq  %rax,(%rdi)",
                        "\tmovq  %rax,8(%rdi)",
                        "\tmovq  %rax,16(%rdi)",
                        "\tmovq  %rax,24(%rdi)",
                        "\tmovq  %rax,32(%rdi)",
                        "\tmovq  %rax,40(%rdi)",
                        "\tmovq  %rax,48(%rdi)",
                        "\tmovq  %rax,56(%rdi)",
                        "\tleaq  64(%rdi),%rdi",
                        "\tjnz    .Lloop_64",
                        "",
                        "\t/* Handle tail in loops. The loops should be faster than hard",
                        "\t   to predict jump tables. */",
                        "\t.p2align 4",
                        ".Lhandle_tail:",
                        "\tmovl\t%edx,%ecx",
                        "\tandl    $63&(~7),%ecx",
                        "\tjz \t\t.Lhandle_7",
                        "\tshrl\t$3,%ecx",
                        "\t.p2align 4",
                        ".Lloop_8:",
                        "\tdecl   %ecx",
                        "\tmovq  %rax,(%rdi)",
                        "\tleaq  8(%rdi),%rdi",
                        "\tjnz    .Lloop_8",
                        "",
                        ".Lhandle_7:",
                        "\tandl\t$7,%edx",
                        "\tjz      .Lende",
                        "\t.p2align 4",
                        ".Lloop_1:",
                        "\tdecl    %edx",
                        "\tmovb \t%al,(%rdi)",
                        "\tleaq\t1(%rdi),%rdi",
                        "\tjnz     .Lloop_1",
                        "",
                        ".Lende:",
                        "\tmovq\t%r10,%rax",
                        "\tret",
                        "",
                        ".Lbad_alignment:",
                        "\tcmpq $7,%rdx",
                        "\tjbe\t.Lhandle_7",
                        "\tmovq %rax,(%rdi)\t/* unaligned store */",
                        "\tmovq $8,%r8",
                        "\tsubq %r9,%r8",
                        "\taddq %r8,%rdi",
                        "\tsubq %r8,%rdx",
                        "\tjmp .Lafter_bad_alignment",
                        ".Lfinal:",
                        "SYM_FUNC_END(memset_orig)"
                    ],
                    "start": 71,
                    "highlight": 77
                }
            ],
            "ins_idx": 18,
            "addr": "0xffffffff81aed761"
        },
        "48": {
            "name": "+0x3",
            "parent_idx": 47,
            "source_line": [
                {
                    "file": "arch/x86/lib/memset_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/lib/memset_64.S?id=ca7e1fd1026c#n75",
                    "code": [
                        "SYM_FUNC_START_LOCAL(memset_orig)",
                        "\tmovq %rdi,%r10",
                        "",
                        "\t/* expand byte value  */",
                        "\tmovzbl %sil,%ecx",
                        "\tmovabs $0x0101010101010101,%rax",
                        "\timulq  %rcx,%rax",
                        "",
                        "\t/* align dst */",
                        "\tmovl  %edi,%r9d",
                        "\tandl  $7,%r9d",
                        "\tjnz  .Lbad_alignment",
                        ".Lafter_bad_alignment:",
                        "",
                        "\tmovq  %rdx,%rcx",
                        "\tshrq  $6,%rcx",
                        "\tjz\t .Lhandle_tail",
                        "",
                        "\t.p2align 4",
                        ".Lloop_64:",
                        "\tdecq  %rcx",
                        "\tmovq  %rax,(%rdi)",
                        "\tmovq  %rax,8(%rdi)",
                        "\tmovq  %rax,16(%rdi)",
                        "\tmovq  %rax,24(%rdi)",
                        "\tmovq  %rax,32(%rdi)",
                        "\tmovq  %rax,40(%rdi)",
                        "\tmovq  %rax,48(%rdi)",
                        "\tmovq  %rax,56(%rdi)",
                        "\tleaq  64(%rdi),%rdi",
                        "\tjnz    .Lloop_64",
                        "",
                        "\t/* Handle tail in loops. The loops should be faster than hard",
                        "\t   to predict jump tables. */",
                        "\t.p2align 4",
                        ".Lhandle_tail:",
                        "\tmovl\t%edx,%ecx",
                        "\tandl    $63&(~7),%ecx",
                        "\tjz \t\t.Lhandle_7",
                        "\tshrl\t$3,%ecx",
                        "\t.p2align 4",
                        ".Lloop_8:",
                        "\tdecl   %ecx",
                        "\tmovq  %rax,(%rdi)",
                        "\tleaq  8(%rdi),%rdi",
                        "\tjnz    .Lloop_8",
                        "",
                        ".Lhandle_7:",
                        "\tandl\t$7,%edx",
                        "\tjz      .Lende",
                        "\t.p2align 4",
                        ".Lloop_1:",
                        "\tdecl    %edx",
                        "\tmovb \t%al,(%rdi)",
                        "\tleaq\t1(%rdi),%rdi",
                        "\tjnz     .Lloop_1",
                        "",
                        ".Lende:",
                        "\tmovq\t%r10,%rax",
                        "\tret",
                        "",
                        ".Lbad_alignment:",
                        "\tcmpq $7,%rdx",
                        "\tjbe\t.Lhandle_7",
                        "\tmovq %rax,(%rdi)\t/* unaligned store */",
                        "\tmovq $8,%r8",
                        "\tsubq %r9,%r8",
                        "\taddq %r8,%rdi",
                        "\tsubq %r8,%rdx",
                        "\tjmp .Lafter_bad_alignment",
                        ".Lfinal:",
                        "SYM_FUNC_END(memset_orig)"
                    ],
                    "start": 71,
                    "highlight": 75
                }
            ],
            "ins_idx": 26,
            "addr": "0xffffffff81aed753"
        },
        "45": {
            "name": "+0x58",
            "parent_idx": 41,
            "source_line": [
                {
                    "file": "./include/net/sock.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/net/sock.h?id=ca7e1fd1026c#n1048",
                    "code": [
                        "/*",
                        " * caches using SLAB_TYPESAFE_BY_RCU should let .next pointer from nulls nodes",
                        " * un-modified. Special care is taken when initializing object to zero.",
                        " */",
                        "static inline void sk_prot_clear_nulls(struct sock *sk, int size)",
                        "{",
                        "\tif (offsetof(struct sock, sk_node.next) != 0)",
                        "\t\tmemset(sk, 0, offsetof(struct sock, sk_node.next));",
                        "\tmemset(&sk->sk_node.pprev, 0,",
                        "\t       size - offsetof(struct sock, sk_node.pprev));",
                        "}"
                    ],
                    "start": 1040,
                    "highlight": 1048
                },
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=ca7e1fd1026c#n1601",
                    "code": [
                        "static struct sock *sk_prot_alloc(struct proto *prot, gfp_t priority,",
                        "\t\tint family)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tstruct kmem_cache *slab;",
                        "",
                        "\tslab = prot->slab;",
                        "\tif (slab != NULL) {",
                        "\t\tsk = kmem_cache_alloc(slab, priority & ~__GFP_ZERO);",
                        "\t\tif (!sk)",
                        "\t\t\treturn sk;",
                        "\t\tif (want_init_on_alloc(priority))",
                        "\t\t\tsk_prot_clear_nulls(sk, prot->obj_size);",
                        "\t} else",
                        "\t\tsk = kmalloc(prot->obj_size, priority);",
                        "",
                        "\tif (sk != NULL) {",
                        "\t\tif (security_sk_alloc(sk, family, priority))",
                        "\t\t\tgoto out_free;",
                        "",
                        "\t\tif (!try_module_get(prot->owner))",
                        "\t\t\tgoto out_free_sec;",
                        "\t\tsk_tx_queue_clear(sk);",
                        "\t}",
                        "",
                        "\treturn sk;",
                        "",
                        "out_free_sec:",
                        "\tsecurity_sk_free(sk);",
                        "out_free:",
                        "\tif (slab != NULL)",
                        "\t\tkmem_cache_free(slab, sk);",
                        "\telse",
                        "\t\tkfree(sk);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 1589,
                    "highlight": 1601
                }
            ],
            "ins_idx": 32,
            "addr": "0xffffffff818651a8"
        }
    },
    "ins": {
        "3": {
            "name": "jmp rax",
            "desc": "Invalid Code Pointer",
            "call_idx": 408,
            "inputs": [
                711
            ],
            "outputs": [
                712
            ]
        },
        "6": {
            "name": "mov rax, qword ptr [rbx + 0x4a0]",
            "desc": "",
            "call_idx": 406,
            "inputs": [
                708,
                709
            ],
            "outputs": [
                710
            ]
        },
        "10": {
            "name": "mov qword ptr [rdi + 0x30], rax",
            "desc": "",
            "call_idx": 67,
            "inputs": [
                96,
                97
            ],
            "outputs": [
                98
            ]
        },
        "18": {
            "name": "imul rax, rcx",
            "desc": "",
            "call_idx": 50,
            "inputs": [
                61,
                62
            ],
            "outputs": [
                63
            ]
        },
        "26": {
            "name": "movzx ecx, sil",
            "desc": "",
            "call_idx": 48,
            "inputs": [
                58
            ],
            "outputs": [
                59
            ]
        },
        "32": {
            "name": "xor esi, esi",
            "desc": "Code pointer source CONST 0x0",
            "call_idx": 45,
            "inputs": [
                53,
                54
            ],
            "outputs": [
                55
            ]
        }
    },
    "data": {
        "711": {
            "name": "RAX",
            "ins_idx": 3,
            "value": "0x0",
            "sources": []
        },
        "712": {
            "name": "RIP",
            "ins_idx": 3,
            "value": "0x0",
            "sources": []
        },
        "708": {
            "name": "RBX",
            "ins_idx": 6,
            "value": "0xffff888235518000",
            "sources": []
        },
        "709": {
            "name": "[0xffff8882355184a0]",
            "ins_idx": 6,
            "value": "0x0",
            "sources": []
        },
        "710": {
            "name": "RAX",
            "ins_idx": 6,
            "value": "0x0",
            "sources": [
                711
            ]
        },
        "96": {
            "name": "RDI",
            "ins_idx": 10,
            "value": "0xffff888235518470",
            "sources": []
        },
        "97": {
            "name": "RAX",
            "ins_idx": 10,
            "value": "0x0",
            "sources": []
        },
        "98": {
            "name": "[0xffff8882355184a0]",
            "ins_idx": 10,
            "value": "0x0",
            "sources": [
                709
            ]
        },
        "61": {
            "name": "RCX",
            "ins_idx": 18,
            "value": "0x0",
            "sources": []
        },
        "62": {
            "name": "RAX",
            "ins_idx": 18,
            "value": "0x101010101010101",
            "sources": []
        },
        "63": {
            "name": "RAX",
            "ins_idx": 18,
            "value": "0x0",
            "sources": [
                97
            ]
        },
        "58": {
            "name": "RSI",
            "ins_idx": 26,
            "value": "0x0",
            "sources": []
        },
        "59": {
            "name": "RCX",
            "ins_idx": 26,
            "value": "0x0",
            "sources": [
                61
            ]
        },
        "53": {
            "name": "RSI",
            "ins_idx": 32,
            "value": "0x0",
            "sources": []
        },
        "54": {
            "name": "RSI",
            "ins_idx": 32,
            "value": "0x0",
            "sources": []
        },
        "55": {
            "name": "RSI",
            "ins_idx": 32,
            "value": "0x0",
            "sources": [
                58
            ]
        }
    },
    "chain": {
        "3": [
            6
        ],
        "6": [
            10
        ],
        "10": [
            18
        ],
        "18": [
            26
        ],
        "26": [
            32
        ]
    }
}