{
    "report": "https://syzkaller.appspot.com/bug?id=f56bbe6668873ee245986bbd23312b895fa5a50a",
    "title": "general protection fault in qrtr_endpoint_post",
    "call": {
        "94": {
            "name": "+0x38",
            "parent_idx": 87,
            "source_line": [
                {
                    "file": "net/qrtr/qrtr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/qrtr/qrtr.c?id=7ae77150d94d#n440",
                    "code": [
                        "/**",
                        " * qrtr_endpoint_post() - post incoming data",
                        " * @ep: endpoint handle",
                        " * @data: data pointer",
                        " * @len: size of data in bytes",
                        " *",
                        " * Return: 0 on success; negative error code on failure",
                        " */",
                        "int qrtr_endpoint_post(struct qrtr_endpoint *ep, const void *data, size_t len)",
                        "{",
                        "\tstruct qrtr_node *node = ep->node;",
                        "\tconst struct qrtr_hdr_v1 *v1;",
                        "\tconst struct qrtr_hdr_v2 *v2;",
                        "\tstruct qrtr_sock *ipc;",
                        "\tstruct sk_buff *skb;",
                        "\tstruct qrtr_cb *cb;",
                        "\tunsigned int size;",
                        "\tunsigned int ver;",
                        "\tsize_t hdrlen;",
                        "",
                        "\tif (len & 3)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tskb = netdev_alloc_skb(NULL, len);",
                        "\tif (!skb)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tcb = (struct qrtr_cb *)skb->cb;",
                        "",
                        "\t/* Version field in v1 is little endian, so this works for both cases */",
                        "\tver = *(u8*)data;",
                        "",
                        "\tswitch (ver) {",
                        "\tcase QRTR_PROTO_VER_1:",
                        "\t\tv1 = data;",
                        "\t\thdrlen = sizeof(*v1);",
                        "",
                        "\t\tcb->type = le32_to_cpu(v1->type);",
                        "\t\tcb->src_node = le32_to_cpu(v1->src_node_id);",
                        "\t\tcb->src_port = le32_to_cpu(v1->src_port_id);",
                        "\t\tcb->confirm_rx = !!v1->confirm_rx;",
                        "\t\tcb->dst_node = le32_to_cpu(v1->dst_node_id);",
                        "\t\tcb->dst_port = le32_to_cpu(v1->dst_port_id);",
                        "",
                        "\t\tsize = le32_to_cpu(v1->size);",
                        "\t\tbreak;",
                        "\tcase QRTR_PROTO_VER_2:",
                        "\t\tv2 = data;",
                        "\t\thdrlen = sizeof(*v2) + v2->optlen;",
                        "",
                        "\t\tcb->type = v2->type;",
                        "\t\tcb->confirm_rx = !!(v2->flags & QRTR_FLAGS_CONFIRM_RX);",
                        "\t\tcb->src_node = le16_to_cpu(v2->src_node_id);",
                        "\t\tcb->src_port = le16_to_cpu(v2->src_port_id);",
                        "\t\tcb->dst_node = le16_to_cpu(v2->dst_node_id);",
                        "\t\tcb->dst_port = le16_to_cpu(v2->dst_port_id);",
                        "",
                        "\t\tif (cb->src_port == (u16)QRTR_PORT_CTRL)",
                        "\t\t\tcb->src_port = QRTR_PORT_CTRL;",
                        "\t\tif (cb->dst_port == (u16)QRTR_PORT_CTRL)",
                        "\t\t\tcb->dst_port = QRTR_PORT_CTRL;",
                        "",
                        "\t\tsize = le32_to_cpu(v2->size);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tpr_err(\"qrtr: Invalid version %d\\n\", ver);",
                        "\t\tgoto err;",
                        "\t}",
                        "",
                        "\tif (len != ALIGN(size, 4) + hdrlen)",
                        "\t\tgoto err;",
                        "",
                        "\tif (cb->dst_port != QRTR_PORT_CTRL && cb->type != QRTR_TYPE_DATA &&",
                        "\t    cb->type != QRTR_TYPE_RESUME_TX)",
                        "\t\tgoto err;",
                        "",
                        "\tskb_put_data(skb, data + hdrlen, size);",
                        "",
                        "\tqrtr_node_assign(node, cb->src_node);",
                        "",
                        "\tif (cb->type == QRTR_TYPE_RESUME_TX) {",
                        "\t\tqrtr_tx_resume(node, skb);",
                        "\t} else {",
                        "\t\tipc = qrtr_port_lookup(cb->dst_port);",
                        "\t\tif (!ipc)",
                        "\t\t\tgoto err;",
                        "",
                        "\t\tif (sock_queue_rcv_skb(&ipc->sk, skb))",
                        "\t\t\tgoto err;",
                        "",
                        "\t\tqrtr_port_put(ipc);",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "",
                        "err:",
                        "\tkfree_skb(skb);",
                        "\treturn -EINVAL;",
                        "",
                        "}"
                    ],
                    "start": 410,
                    "highlight": 440
                }
            ],
            "ins_idx": 1,
            "addr": "0xffffffff81b2d018"
        },
        "87": {
            "name": "qrtr_endpoint_post",
            "parent_idx": 75,
            "source_line": [
                {
                    "file": "net/qrtr/tun.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/qrtr/tun.c?id=7ae77150d94d#n92",
                    "code": [
                        "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)",
                        "{",
                        "\tstruct file *filp = iocb->ki_filp;",
                        "\tstruct qrtr_tun *tun = filp->private_data;",
                        "\tsize_t len = iov_iter_count(from);",
                        "\tssize_t ret;",
                        "\tvoid *kbuf;",
                        "",
                        "\tkbuf = kzalloc(len, GFP_KERNEL);",
                        "\tif (!kbuf)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tif (!copy_from_iter_full(kbuf, len, from)) {",
                        "\t\tkfree(kbuf);",
                        "\t\treturn -EFAULT;",
                        "\t}",
                        "",
                        "\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);",
                        "",
                        "\tkfree(kbuf);",
                        "\treturn ret < 0 ? ret : len;",
                        "}"
                    ],
                    "start": 75,
                    "highlight": 92
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b2f120"
        },
        "75": {
            "name": "qrtr_tun_write_iter(indirect)",
            "parent_idx": 67,
            "source_line": [
                {
                    "file": "./include/linux/fs.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/fs.h?id=7ae77150d94d#n1917",
                    "code": [
                        "static inline ssize_t call_write_iter(struct file *file, struct kiocb *kio,",
                        "\t\t\t\t      struct iov_iter *iter)",
                        "{",
                        "\treturn file->f_op->write_iter(kio, iter);",
                        "}"
                    ],
                    "start": 1914,
                    "highlight": 1917
                },
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=7ae77150d94d#n484",
                    "code": [
                        "static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)",
                        "{",
                        "\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };",
                        "\tstruct kiocb kiocb;",
                        "\tstruct iov_iter iter;",
                        "\tssize_t ret;",
                        "",
                        "\tinit_sync_kiocb(&kiocb, filp);",
                        "\tkiocb.ki_pos = (ppos ? *ppos : 0);",
                        "\tiov_iter_init(&iter, WRITE, &iov, 1, len);",
                        "",
                        "\tret = call_write_iter(filp, &kiocb, &iter);",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\tif (ret > 0 && ppos)",
                        "\t\t*ppos = kiocb.ki_pos;",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 473,
                    "highlight": 484
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811e086f"
        },
        "67": {
            "name": "__vfs_write",
            "parent_idx": 51,
            "source_line": [
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=7ae77150d94d#n559",
                    "code": [
                        "\tret = rw_verify_area(WRITE, file, pos, count);",
                        "\tif (!ret) {",
                        "\t\tif (count > MAX_RW_COUNT)",
                        "\t\t\tcount =  MAX_RW_COUNT;",
                        "\t\tfile_start_write(file);",
                        "\t\tret = __vfs_write(file, buf, count, pos);",
                        "\t\tif (ret > 0) {",
                        "\t\t\tfsnotify_modify(file);",
                        "\t\t\tadd_wchar(current, ret);",
                        "\t\t}",
                        "\t\tinc_syscw(current);",
                        "\t\tfile_end_write(file);",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 554,
                    "highlight": 559
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811e385c"
        },
        "51": {
            "name": "vfs_write",
            "parent_idx": 47,
            "source_line": [
                {
                    "file": "fs/read_write.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/read_write.c?id=7ae77150d94d#n612",
                    "code": [
                        "ssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)",
                        "{",
                        "\tstruct fd f = fdget_pos(fd);",
                        "\tssize_t ret = -EBADF;",
                        "",
                        "\tif (f.file) {",
                        "\t\tloff_t pos, *ppos = file_ppos(f.file);",
                        "\t\tif (ppos) {",
                        "\t\t\tpos = *ppos;",
                        "\t\t\tppos = &pos;",
                        "\t\t}",
                        "\t\tret = vfs_write(f.file, buf, count, ppos);",
                        "\t\tif (ret >= 0 && ppos)",
                        "\t\t\tf.file->f_pos = pos;",
                        "\t\tfdput_pos(f);",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 601,
                    "highlight": 612
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff811e3c55"
        },
        "47": {
            "name": "__x64_sys_write(indirect)",
            "parent_idx": 44,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=7ae77150d94d#n295",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 282,
                    "highlight": 295
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81002829"
        },
        "44": {
            "name": "do_syscall_64",
            "parent_idx": 38,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=7ae77150d94d#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_ON\t\t\t/* return enables interrupts */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "38": {
            "name": "31_syscall_5",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "88": {
            "name": "+0x1a",
            "parent_idx": 87,
            "source_line": [
                {
                    "file": "./include/linux/skbuff.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/skbuff.h?id=7ae77150d94d#n2806",
                    "code": [
                        "/**",
                        " *\tnetdev_alloc_skb - allocate an skbuff for rx on a specific device",
                        " *\t@dev: network device to receive on",
                        " *\t@length: length to allocate",
                        " *",
                        " *\tAllocate a new &sk_buff and assign it a usage count of one. The",
                        " *\tbuffer has unspecified headroom built in. Users should allocate",
                        " *\tthe headroom they think they need without accounting for the",
                        " *\tbuilt in space. The built in space is used for optimisations.",
                        " *",
                        " *\t%NULL is returned if there is no free memory. Although this function",
                        " *\tallocates memory it can be called from an interrupt.",
                        " */",
                        "static inline struct sk_buff *netdev_alloc_skb(struct net_device *dev,",
                        "\t\t\t\t\t       unsigned int length)",
                        "{",
                        "\treturn __netdev_alloc_skb(dev, length, GFP_ATOMIC);",
                        "}"
                    ],
                    "start": 2790,
                    "highlight": 2806
                },
                {
                    "file": "net/qrtr/qrtr.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/qrtr/qrtr.c?id=7ae77150d94d#n433",
                    "code": [
                        "/**",
                        " * qrtr_endpoint_post() - post incoming data",
                        " * @ep: endpoint handle",
                        " * @data: data pointer",
                        " * @len: size of data in bytes",
                        " *",
                        " * Return: 0 on success; negative error code on failure",
                        " */",
                        "int qrtr_endpoint_post(struct qrtr_endpoint *ep, const void *data, size_t len)",
                        "{",
                        "\tstruct qrtr_node *node = ep->node;",
                        "\tconst struct qrtr_hdr_v1 *v1;",
                        "\tconst struct qrtr_hdr_v2 *v2;",
                        "\tstruct qrtr_sock *ipc;",
                        "\tstruct sk_buff *skb;",
                        "\tstruct qrtr_cb *cb;",
                        "\tunsigned int size;",
                        "\tunsigned int ver;",
                        "\tsize_t hdrlen;",
                        "",
                        "\tif (len & 3)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tskb = netdev_alloc_skb(NULL, len);",
                        "\tif (!skb)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tcb = (struct qrtr_cb *)skb->cb;",
                        "",
                        "\t/* Version field in v1 is little endian, so this works for both cases */",
                        "\tver = *(u8*)data;",
                        "",
                        "\tswitch (ver) {",
                        "\tcase QRTR_PROTO_VER_1:",
                        "\t\tv1 = data;",
                        "\t\thdrlen = sizeof(*v1);",
                        "",
                        "\t\tcb->type = le32_to_cpu(v1->type);",
                        "\t\tcb->src_node = le32_to_cpu(v1->src_node_id);",
                        "\t\tcb->src_port = le32_to_cpu(v1->src_port_id);",
                        "\t\tcb->confirm_rx = !!v1->confirm_rx;",
                        "\t\tcb->dst_node = le32_to_cpu(v1->dst_node_id);",
                        "\t\tcb->dst_port = le32_to_cpu(v1->dst_port_id);",
                        "",
                        "\t\tsize = le32_to_cpu(v1->size);",
                        "\t\tbreak;",
                        "\tcase QRTR_PROTO_VER_2:",
                        "\t\tv2 = data;",
                        "\t\thdrlen = sizeof(*v2) + v2->optlen;",
                        "",
                        "\t\tcb->type = v2->type;",
                        "\t\tcb->confirm_rx = !!(v2->flags & QRTR_FLAGS_CONFIRM_RX);",
                        "\t\tcb->src_node = le16_to_cpu(v2->src_node_id);",
                        "\t\tcb->src_port = le16_to_cpu(v2->src_port_id);",
                        "\t\tcb->dst_node = le16_to_cpu(v2->dst_node_id);",
                        "\t\tcb->dst_port = le16_to_cpu(v2->dst_port_id);",
                        "",
                        "\t\tif (cb->src_port == (u16)QRTR_PORT_CTRL)",
                        "\t\t\tcb->src_port = QRTR_PORT_CTRL;",
                        "\t\tif (cb->dst_port == (u16)QRTR_PORT_CTRL)",
                        "\t\t\tcb->dst_port = QRTR_PORT_CTRL;",
                        "",
                        "\t\tsize = le32_to_cpu(v2->size);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tpr_err(\"qrtr: Invalid version %d\\n\", ver);",
                        "\t\tgoto err;",
                        "\t}",
                        "",
                        "\tif (len != ALIGN(size, 4) + hdrlen)",
                        "\t\tgoto err;",
                        "",
                        "\tif (cb->dst_port != QRTR_PORT_CTRL && cb->type != QRTR_TYPE_DATA &&",
                        "\t    cb->type != QRTR_TYPE_RESUME_TX)",
                        "\t\tgoto err;",
                        "",
                        "\tskb_put_data(skb, data + hdrlen, size);",
                        "",
                        "\tqrtr_node_assign(node, cb->src_node);",
                        "",
                        "\tif (cb->type == QRTR_TYPE_RESUME_TX) {",
                        "\t\tqrtr_tx_resume(node, skb);",
                        "\t} else {",
                        "\t\tipc = qrtr_port_lookup(cb->dst_port);",
                        "\t\tif (!ipc)",
                        "\t\t\tgoto err;",
                        "",
                        "\t\tif (sock_queue_rcv_skb(&ipc->sk, skb))",
                        "\t\t\tgoto err;",
                        "",
                        "\t\tqrtr_port_put(ipc);",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "",
                        "err:",
                        "\tkfree_skb(skb);",
                        "\treturn -EINVAL;",
                        "",
                        "}"
                    ],
                    "start": 410,
                    "highlight": 433
                }
            ],
            "ins_idx": 9,
            "addr": "0xffffffff81b2cffa"
        },
        "86": {
            "name": "+0x4a",
            "parent_idx": 75,
            "source_line": [
                {
                    "file": "net/qrtr/tun.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/qrtr/tun.c?id=7ae77150d94d#n92",
                    "code": [
                        "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)",
                        "{",
                        "\tstruct file *filp = iocb->ki_filp;",
                        "\tstruct qrtr_tun *tun = filp->private_data;",
                        "\tsize_t len = iov_iter_count(from);",
                        "\tssize_t ret;",
                        "\tvoid *kbuf;",
                        "",
                        "\tkbuf = kzalloc(len, GFP_KERNEL);",
                        "\tif (!kbuf)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tif (!copy_from_iter_full(kbuf, len, from)) {",
                        "\t\tkfree(kbuf);",
                        "\t\treturn -EFAULT;",
                        "\t}",
                        "",
                        "\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);",
                        "",
                        "\tkfree(kbuf);",
                        "\treturn ret < 0 ? ret : len;",
                        "}"
                    ],
                    "start": 75,
                    "highlight": 92
                }
            ],
            "ins_idx": 11,
            "addr": "0xffffffff81b2f11a"
        },
        "80": {
            "name": "+0x29",
            "parent_idx": 75,
            "source_line": [
                {
                    "file": "net/qrtr/tun.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/qrtr/tun.c?id=7ae77150d94d#n84",
                    "code": [
                        "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)",
                        "{",
                        "\tstruct file *filp = iocb->ki_filp;",
                        "\tstruct qrtr_tun *tun = filp->private_data;",
                        "\tsize_t len = iov_iter_count(from);",
                        "\tssize_t ret;",
                        "\tvoid *kbuf;",
                        "",
                        "\tkbuf = kzalloc(len, GFP_KERNEL);",
                        "\tif (!kbuf)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tif (!copy_from_iter_full(kbuf, len, from)) {",
                        "\t\tkfree(kbuf);",
                        "\t\treturn -EFAULT;",
                        "\t}",
                        "",
                        "\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);",
                        "",
                        "\tkfree(kbuf);",
                        "\treturn ret < 0 ? ret : len;",
                        "}"
                    ],
                    "start": 75,
                    "highlight": 84
                }
            ],
            "ins_idx": 21,
            "addr": "0xffffffff81b2f0f9"
        },
        "79": {
            "name": "+0xf1",
            "parent_idx": 78,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=7ae77150d94d#n3942",
                    "code": [
                        "void *__kmalloc_node(size_t size, gfp_t flags, int node)",
                        "{",
                        "\tstruct kmem_cache *s;",
                        "\tvoid *ret;",
                        "",
                        "\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {",
                        "\t\tret = kmalloc_large_node(size, flags, node);",
                        "",
                        "\t\ttrace_kmalloc_node(_RET_IP_, ret,",
                        "\t\t\t\t   size, PAGE_SIZE << get_order(size),",
                        "\t\t\t\t   flags, node);",
                        "",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\ts = kmalloc_slab(size, flags);",
                        "",
                        "\tif (unlikely(ZERO_OR_NULL_PTR(s)))",
                        "\t\treturn s;",
                        "",
                        "\tret = slab_alloc_node(s, flags, node, _RET_IP_);",
                        "",
                        "\ttrace_kmalloc_node(_RET_IP_, ret, size, s->size, flags, node);",
                        "",
                        "\tret = kasan_kmalloc(s, ret, size, flags);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3933,
                    "highlight": 3942
                }
            ],
            "ins_idx": 24,
            "addr": "0xffffffff811d5621"
        },
        "78": {
            "name": "__kmalloc",
            "parent_idx": 75,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=7ae77150d94d#n560",
                    "code": [
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 555,
                    "highlight": 560
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=7ae77150d94d#n669",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 662,
                    "highlight": 669
                },
                {
                    "file": "net/qrtr/tun.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/qrtr/tun.c?id=7ae77150d94d#n83",
                    "code": [
                        "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)",
                        "{",
                        "\tstruct file *filp = iocb->ki_filp;",
                        "\tstruct qrtr_tun *tun = filp->private_data;",
                        "\tsize_t len = iov_iter_count(from);",
                        "\tssize_t ret;",
                        "\tvoid *kbuf;",
                        "",
                        "\tkbuf = kzalloc(len, GFP_KERNEL);",
                        "\tif (!kbuf)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tif (!copy_from_iter_full(kbuf, len, from)) {",
                        "\t\tkfree(kbuf);",
                        "\t\treturn -EFAULT;",
                        "\t}",
                        "",
                        "\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);",
                        "",
                        "\tkfree(kbuf);",
                        "\treturn ret < 0 ? ret : len;",
                        "}"
                    ],
                    "start": 75,
                    "highlight": 83
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b2f0ef"
        }
    },
    "ins": {
        "1": {
            "name": "movzx eax, byte ptr [rbx]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x10",
            "call_idx": 94,
            "inputs": [
                133,
                134
            ],
            "outputs": [
                135
            ]
        },
        "9": {
            "name": "mov rbx, rsi",
            "desc": "",
            "call_idx": 88,
            "inputs": [
                123
            ],
            "outputs": [
                124
            ]
        },
        "11": {
            "name": "mov rsi, rbp",
            "desc": "",
            "call_idx": 86,
            "inputs": [
                121
            ],
            "outputs": [
                122
            ]
        },
        "21": {
            "name": "mov rbp, rax",
            "desc": "",
            "call_idx": 80,
            "inputs": [
                111
            ],
            "outputs": [
                112
            ]
        },
        "24": {
            "name": "ret ",
            "desc": "Source of base address MEMALLOC 0x10",
            "call_idx": 79,
            "inputs": [],
            "outputs": [
                110
            ]
        }
    },
    "data": {
        "133": {
            "name": "RBX",
            "ins_idx": 1,
            "value": "0x10",
            "sources": []
        },
        "134": {
            "name": "[0x10]",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "135": {
            "name": "RAX",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "123": {
            "name": "RSI",
            "ins_idx": 9,
            "value": "0x10",
            "sources": []
        },
        "124": {
            "name": "RBX",
            "ins_idx": 9,
            "value": "0x10",
            "sources": [
                133
            ]
        },
        "121": {
            "name": "RBP",
            "ins_idx": 11,
            "value": "0x10",
            "sources": []
        },
        "122": {
            "name": "RSI",
            "ins_idx": 11,
            "value": "0x10",
            "sources": [
                123
            ]
        },
        "111": {
            "name": "RAX",
            "ins_idx": 21,
            "value": "0x10",
            "sources": []
        },
        "112": {
            "name": "RBP",
            "ins_idx": 21,
            "value": "0x10",
            "sources": [
                121
            ]
        },
        "110": {
            "name": "RAX",
            "ins_idx": 24,
            "value": "0x10",
            "sources": [
                111
            ]
        }
    },
    "chain": {
        "1": [
            9
        ],
        "9": [
            11
        ],
        "11": [
            21
        ],
        "21": [
            24
        ]
    }
}