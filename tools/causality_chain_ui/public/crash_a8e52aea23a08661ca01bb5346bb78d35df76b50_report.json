{
    "report": "https://syzkaller.appspot.com/bug?id=a8e52aea23a08661ca01bb5346bb78d35df76b50",
    "title": "general protection fault in fq_codel_enqueue",
    "call": {
        "2261": {
            "name": "+0x201",
            "parent_idx": 2243,
            "source_line": [
                {
                    "file": "net/sched/sch_fq_codel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_fq_codel.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n120",
                    "code": [
                        "/* remove one skb from head of slot queue */",
                        "static inline struct sk_buff *dequeue_head(struct fq_codel_flow *flow)",
                        "{",
                        "\tstruct sk_buff *skb = flow->head;",
                        "",
                        "\tflow->head = skb->next;",
                        "\tskb_mark_not_on_list(skb);",
                        "\treturn skb;",
                        "}"
                    ],
                    "start": 115,
                    "highlight": 120
                },
                {
                    "file": "net/sched/sch_fq_codel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_fq_codel.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n168",
                    "code": [
                        "static unsigned int fq_codel_drop(struct Qdisc *sch, unsigned int max_packets,",
                        "\t\t\t\t  struct sk_buff **to_free)",
                        "{",
                        "\tstruct fq_codel_sched_data *q = qdisc_priv(sch);",
                        "\tstruct sk_buff *skb;",
                        "\tunsigned int maxbacklog = 0, idx = 0, i, len;",
                        "\tstruct fq_codel_flow *flow;",
                        "\tunsigned int threshold;",
                        "\tunsigned int mem = 0;",
                        "",
                        "\t/* Queue is full! Find the fat flow and drop packet(s) from it.",
                        "\t * This might sound expensive, but with 1024 flows, we scan",
                        "\t * 4KB of memory, and we dont need to handle a complex tree",
                        "\t * in fast path (packet queue/enqueue) with many cache misses.",
                        "\t * In stress mode, we'll try to drop 64 packets from the flow,",
                        "\t * amortizing this linear lookup to one cache line per drop.",
                        "\t */",
                        "\tfor (i = 0; i < q->flows_cnt; i++) {",
                        "\t\tif (q->backlogs[i] > maxbacklog) {",
                        "\t\t\tmaxbacklog = q->backlogs[i];",
                        "\t\t\tidx = i;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* Our goal is to drop half of this fat flow backlog */",
                        "\tthreshold = maxbacklog >> 1;",
                        "",
                        "\tflow = &q->flows[idx];",
                        "\tlen = 0;",
                        "\ti = 0;",
                        "\tdo {",
                        "\t\tskb = dequeue_head(flow);",
                        "\t\tlen += qdisc_pkt_len(skb);",
                        "\t\tmem += get_codel_cb(skb)->mem_usage;",
                        "\t\t__qdisc_drop(skb, to_free);",
                        "\t} while (++i < max_packets && len < threshold);",
                        "",
                        "\t/* Tell codel to increase its signal strength also */",
                        "\tflow->cvars.count += i;",
                        "\tq->backlogs[idx] -= len;",
                        "\tq->memory_usage -= mem;",
                        "\tsch->qstats.drops += i;",
                        "\tsch->qstats.backlog -= len;",
                        "\tsch->q.qlen -= i;",
                        "\treturn idx;",
                        "}"
                    ],
                    "start": 137,
                    "highlight": 168
                },
                {
                    "file": "net/sched/sch_fq_codel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_fq_codel.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n230",
                    "code": [
                        "static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch,",
                        "\t\t\t    struct sk_buff **to_free)",
                        "{",
                        "\tstruct fq_codel_sched_data *q = qdisc_priv(sch);",
                        "\tunsigned int idx, prev_backlog, prev_qlen;",
                        "\tstruct fq_codel_flow *flow;",
                        "\tint uninitialized_var(ret);",
                        "\tunsigned int pkt_len;",
                        "\tbool memory_limited;",
                        "",
                        "\tidx = fq_codel_classify(skb, sch, &ret);",
                        "\tif (idx == 0) {",
                        "\t\tif (ret & __NET_XMIT_BYPASS)",
                        "\t\t\tqdisc_qstats_drop(sch);",
                        "\t\t__qdisc_drop(skb, to_free);",
                        "\t\treturn ret;",
                        "\t}",
                        "\tidx--;",
                        "",
                        "\tcodel_set_enqueue_time(skb);",
                        "\tflow = &q->flows[idx];",
                        "\tflow_queue_add(flow, skb);",
                        "\tq->backlogs[idx] += qdisc_pkt_len(skb);",
                        "\tqdisc_qstats_backlog_inc(sch, skb);",
                        "",
                        "\tif (list_empty(&flow->flowchain)) {",
                        "\t\tlist_add_tail(&flow->flowchain, &q->new_flows);",
                        "\t\tq->new_flow_count++;",
                        "\t\tflow->deficit = q->quantum;",
                        "\t}",
                        "\tget_codel_cb(skb)->mem_usage = skb->truesize;",
                        "\tq->memory_usage += get_codel_cb(skb)->mem_usage;",
                        "\tmemory_limited = q->memory_usage > q->memory_limit;",
                        "\tif (++sch->q.qlen <= sch->limit && !memory_limited)",
                        "\t\treturn NET_XMIT_SUCCESS;",
                        "",
                        "\tprev_backlog = sch->qstats.backlog;",
                        "\tprev_qlen = sch->q.qlen;",
                        "",
                        "\t/* save this packet length as it might be dropped by fq_codel_drop() */",
                        "\tpkt_len = qdisc_pkt_len(skb);",
                        "\t/* fq_codel_drop() is quite expensive, as it performs a linear search",
                        "\t * in q->backlogs[] to find a fat flow.",
                        "\t * So instead of dropping a single packet, drop half of its backlog",
                        "\t * with a 64 packets limit to not add a too big cpu spike here.",
                        "\t */",
                        "\tret = fq_codel_drop(sch, q->drop_batch_size, to_free);",
                        "",
                        "\tprev_qlen -= sch->q.qlen;",
                        "\tprev_backlog -= sch->qstats.backlog;",
                        "\tq->drop_overlimit += prev_qlen;",
                        "\tif (memory_limited)",
                        "\t\tq->drop_overmemory += prev_qlen;",
                        "",
                        "\t/* As we dropped packet(s), better let upper stack know this.",
                        "\t * If we dropped a packet for this flow, return NET_XMIT_CN,",
                        "\t * but in this case, our parents wont increase their backlogs.",
                        "\t */",
                        "\tif (ret == idx) {",
                        "\t\tqdisc_tree_reduce_backlog(sch, prev_qlen - 1,",
                        "\t\t\t\t\t  prev_backlog - pkt_len);",
                        "\t\treturn NET_XMIT_CN;",
                        "\t}",
                        "\tqdisc_tree_reduce_backlog(sch, prev_qlen, prev_backlog);",
                        "\treturn NET_XMIT_SUCCESS;",
                        "}"
                    ],
                    "start": 184,
                    "highlight": 230
                }
            ],
            "ins_idx": 7,
            "addr": "0xffffffff8190eb81"
        },
        "2243": {
            "name": "fq_codel_enqueue(indirect)",
            "parent_idx": 2229,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n3710",
                    "code": [
                        "static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,",
                        "\t\t\t\t struct net_device *dev,",
                        "\t\t\t\t struct netdev_queue *txq)",
                        "{",
                        "\tspinlock_t *root_lock = qdisc_lock(q);",
                        "\tstruct sk_buff *to_free = NULL;",
                        "\tbool contended;",
                        "\tint rc;",
                        "",
                        "\tqdisc_calculate_pkt_len(skb, q);",
                        "",
                        "\tif (q->flags & TCQ_F_NOLOCK) {",
                        "\t\trc = q->enqueue(skb, q, &to_free) & NET_XMIT_MASK;",
                        "\t\tqdisc_run(q);",
                        "",
                        "\t\tif (unlikely(to_free))",
                        "\t\t\tkfree_skb_list(to_free);",
                        "\t\treturn rc;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Heuristic to force contended enqueues to serialize on a",
                        "\t * separate lock before trying to get qdisc main lock.",
                        "\t * This permits qdisc->running owner to get the lock more",
                        "\t * often and dequeue packets faster.",
                        "\t */",
                        "\tcontended = qdisc_is_running(q);",
                        "\tif (unlikely(contended))",
                        "\t\tspin_lock(&q->busylock);",
                        "",
                        "\tspin_lock(root_lock);",
                        "\tif (unlikely(test_bit(__QDISC_STATE_DEACTIVATED, &q->state))) {",
                        "\t\t__qdisc_drop(skb, &to_free);",
                        "\t\trc = NET_XMIT_DROP;",
                        "\t} else if ((q->flags & TCQ_F_CAN_BYPASS) && !qdisc_qlen(q) &&",
                        "\t\t   qdisc_run_begin(q)) {",
                        "\t\t/*",
                        "\t\t * This is a work-conserving queue; there are no old skbs",
                        "\t\t * waiting to be sent out; and the qdisc is not running -",
                        "\t\t * xmit the skb directly.",
                        "\t\t */",
                        "",
                        "\t\tqdisc_bstats_update(q, skb);",
                        "",
                        "\t\tif (sch_direct_xmit(skb, q, dev, txq, root_lock, true)) {",
                        "\t\t\tif (unlikely(contended)) {",
                        "\t\t\t\tspin_unlock(&q->busylock);",
                        "\t\t\t\tcontended = false;",
                        "\t\t\t}",
                        "\t\t\t__qdisc_run(q);",
                        "\t\t}",
                        "",
                        "\t\tqdisc_run_end(q);",
                        "\t\trc = NET_XMIT_SUCCESS;",
                        "\t} else {",
                        "\t\trc = q->enqueue(skb, q, &to_free) & NET_XMIT_MASK;",
                        "\t\tif (qdisc_run_begin(q)) {",
                        "\t\t\tif (unlikely(contended)) {",
                        "\t\t\t\tspin_unlock(&q->busylock);",
                        "\t\t\t\tcontended = false;",
                        "\t\t\t}",
                        "\t\t\t__qdisc_run(q);",
                        "\t\t\tqdisc_run_end(q);",
                        "\t\t}",
                        "\t}",
                        "\tspin_unlock(root_lock);",
                        "\tif (unlikely(to_free))",
                        "\t\tkfree_skb_list(to_free);",
                        "\tif (unlikely(contended))",
                        "\t\tspin_unlock(&q->busylock);",
                        "\treturn rc;",
                        "}"
                    ],
                    "start": 3655,
                    "highlight": 3710
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n4021",
                    "code": [
                        "/**",
                        " *\t__dev_queue_xmit - transmit a buffer",
                        " *\t@skb: buffer to transmit",
                        " *\t@sb_dev: suboordinate device used for L2 forwarding offload",
                        " *",
                        " *\tQueue a buffer for transmission to a network device. The caller must",
                        " *\thave set the device and priority and built the buffer before calling",
                        " *\tthis function. The function can be called from an interrupt.",
                        " *",
                        " *\tA negative errno code is returned on a failure. A success does not",
                        " *\tguarantee the frame will be transmitted as it may be dropped due",
                        " *\tto congestion or traffic shaping.",
                        " *",
                        " * -----------------------------------------------------------------------------------",
                        " *      I notice this method can also return errors from the queue disciplines,",
                        " *      including NET_XMIT_DROP, which is a positive value.  So, errors can also",
                        " *      be positive.",
                        " *",
                        " *      Regardless of the return value, the skb is consumed, so it is currently",
                        " *      difficult to retry a send to this method.  (You can bump the ref count",
                        " *      before sending to hold a reference for retry if you are careful.)",
                        " *",
                        " *      When calling this method, interrupts MUST be enabled.  This is because",
                        " *      the BH enable code must have IRQs enabled so that it will not deadlock.",
                        " *          --BLG",
                        " */",
                        "static int __dev_queue_xmit(struct sk_buff *skb, struct net_device *sb_dev)",
                        "{",
                        "\tstruct net_device *dev = skb->dev;",
                        "\tstruct netdev_queue *txq;",
                        "\tstruct Qdisc *q;",
                        "\tint rc = -ENOMEM;",
                        "\tbool again = false;",
                        "",
                        "\tskb_reset_mac_header(skb);",
                        "",
                        "\tif (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_SCHED_TSTAMP))",
                        "\t\t__skb_tstamp_tx(skb, NULL, skb->sk, SCM_TSTAMP_SCHED);",
                        "",
                        "\t/* Disable soft irqs for various locks below. Also",
                        "\t * stops preemption for RCU.",
                        "\t */",
                        "\trcu_read_lock_bh();",
                        "",
                        "\tskb_update_prio(skb);",
                        "",
                        "\tqdisc_pkt_len_init(skb);",
                        "#ifdef CONFIG_NET_CLS_ACT",
                        "\tskb->tc_at_ingress = 0;",
                        "# ifdef CONFIG_NET_EGRESS",
                        "\tif (static_branch_unlikely(&egress_needed_key)) {",
                        "\t\tskb = sch_handle_egress(skb, &rc, dev);",
                        "\t\tif (!skb)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "# endif",
                        "#endif",
                        "\t/* If device/qdisc don't need skb->dst, release it right now while",
                        "\t * its hot in this cpu cache.",
                        "\t */",
                        "\tif (dev->priv_flags & IFF_XMIT_DST_RELEASE)",
                        "\t\tskb_dst_drop(skb);",
                        "\telse",
                        "\t\tskb_dst_force(skb);",
                        "",
                        "\ttxq = netdev_core_pick_tx(dev, skb, sb_dev);",
                        "\tq = rcu_dereference_bh(txq->qdisc);",
                        "",
                        "\ttrace_net_dev_queue(skb);",
                        "\tif (q->enqueue) {",
                        "\t\trc = __dev_xmit_skb(skb, q, dev, txq);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\t/* The device has no queue. Common case for software devices:",
                        "\t * loopback, all the sorts of tunnels...",
                        "",
                        "\t * Really, it is unlikely that netif_tx_lock protection is necessary",
                        "\t * here.  (f.e. loopback and IP tunnels are clean ignoring statistics",
                        "\t * counters.)",
                        "\t * However, it is possible, that they rely on protection",
                        "\t * made by us here.",
                        "",
                        "\t * Check this and shot the lock. It is not prone from deadlocks.",
                        "\t *Either shot noqueue qdisc, it is even simpler 8)",
                        "\t */",
                        "\tif (dev->flags & IFF_UP) {",
                        "\t\tint cpu = smp_processor_id(); /* ok because BHs are off */",
                        "",
                        "\t\tif (txq->xmit_lock_owner != cpu) {",
                        "\t\t\tif (dev_xmit_recursion())",
                        "\t\t\t\tgoto recursion_alert;",
                        "",
                        "\t\t\tskb = validate_xmit_skb(skb, dev, &again);",
                        "\t\t\tif (!skb)",
                        "\t\t\t\tgoto out;",
                        "",
                        "\t\t\tHARD_TX_LOCK(dev, txq, cpu);",
                        "",
                        "\t\t\tif (!netif_xmit_stopped(txq)) {",
                        "\t\t\t\tdev_xmit_recursion_inc();",
                        "\t\t\t\tskb = dev_hard_start_xmit(skb, dev, txq, &rc);",
                        "\t\t\t\tdev_xmit_recursion_dec();",
                        "\t\t\t\tif (dev_xmit_complete(rc)) {",
                        "\t\t\t\t\tHARD_TX_UNLOCK(dev, txq);",
                        "\t\t\t\t\tgoto out;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tHARD_TX_UNLOCK(dev, txq);",
                        "\t\t\tnet_crit_ratelimited(\"Virtual device %s asks to queue packet!\\n\",",
                        "\t\t\t\t\t     dev->name);",
                        "\t\t} else {",
                        "\t\t\t/* Recursion is detected! It is possible,",
                        "\t\t\t * unfortunately",
                        "\t\t\t */",
                        "recursion_alert:",
                        "\t\t\tnet_crit_ratelimited(\"Dead loop on virtual device %s, fix it urgently!\\n\",",
                        "\t\t\t\t\t     dev->name);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\trc = -ENETDOWN;",
                        "\trcu_read_unlock_bh();",
                        "",
                        "\tatomic_long_inc(&dev->tx_dropped);",
                        "\tkfree_skb_list(skb);",
                        "\treturn rc;",
                        "out:",
                        "\trcu_read_unlock_bh();",
                        "\treturn rc;",
                        "}"
                    ],
                    "start": 3951,
                    "highlight": 4021
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818c69c4"
        },
        "2229": {
            "name": "__dev_queue_xmit(indirect)",
            "parent_idx": 2186,
            "source_line": [
                {
                    "file": "net/packet/af_packet.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/packet/af_packet.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n2979",
                    "code": [
                        "static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tDECLARE_SOCKADDR(struct sockaddr_ll *, saddr, msg->msg_name);",
                        "\tstruct sk_buff *skb;",
                        "\tstruct net_device *dev;",
                        "\t__be16 proto;",
                        "\tunsigned char *addr = NULL;",
                        "\tint err, reserve = 0;",
                        "\tstruct sockcm_cookie sockc;",
                        "\tstruct virtio_net_hdr vnet_hdr = { 0 };",
                        "\tint offset = 0;",
                        "\tstruct packet_sock *po = pkt_sk(sk);",
                        "\tbool has_vnet_hdr = false;",
                        "\tint hlen, tlen, linear;",
                        "\tint extra_len = 0;",
                        "",
                        "\t/*",
                        "\t *\tGet and verify the address.",
                        "\t */",
                        "",
                        "\tif (likely(saddr == NULL)) {",
                        "\t\tdev\t= packet_cached_dev_get(po);",
                        "\t\tproto\t= po->num;",
                        "\t} else {",
                        "\t\terr = -EINVAL;",
                        "\t\tif (msg->msg_namelen < sizeof(struct sockaddr_ll))",
                        "\t\t\tgoto out;",
                        "\t\tif (msg->msg_namelen < (saddr->sll_halen + offsetof(struct sockaddr_ll, sll_addr)))",
                        "\t\t\tgoto out;",
                        "\t\tproto\t= saddr->sll_protocol;",
                        "\t\tdev = dev_get_by_index(sock_net(sk), saddr->sll_ifindex);",
                        "\t\tif (sock->type == SOCK_DGRAM) {",
                        "\t\t\tif (dev && msg->msg_namelen < dev->addr_len +",
                        "\t\t\t\t   offsetof(struct sockaddr_ll, sll_addr))",
                        "\t\t\t\tgoto out_unlock;",
                        "\t\t\taddr = saddr->sll_addr;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\terr = -ENXIO;",
                        "\tif (unlikely(dev == NULL))",
                        "\t\tgoto out_unlock;",
                        "\terr = -ENETDOWN;",
                        "\tif (unlikely(!(dev->flags & IFF_UP)))",
                        "\t\tgoto out_unlock;",
                        "",
                        "\tsockcm_init(&sockc, sk);",
                        "\tsockc.mark = sk->sk_mark;",
                        "\tif (msg->msg_controllen) {",
                        "\t\terr = sock_cmsg_send(sk, msg, &sockc);",
                        "\t\tif (unlikely(err))",
                        "\t\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\tif (sock->type == SOCK_RAW)",
                        "\t\treserve = dev->hard_header_len;",
                        "\tif (po->has_vnet_hdr) {",
                        "\t\terr = packet_snd_vnet_parse(msg, &len, &vnet_hdr);",
                        "\t\tif (err)",
                        "\t\t\tgoto out_unlock;",
                        "\t\thas_vnet_hdr = true;",
                        "\t}",
                        "",
                        "\tif (unlikely(sock_flag(sk, SOCK_NOFCS))) {",
                        "\t\tif (!netif_supports_nofcs(dev)) {",
                        "\t\t\terr = -EPROTONOSUPPORT;",
                        "\t\t\tgoto out_unlock;",
                        "\t\t}",
                        "\t\textra_len = 4; /* We're doing our own CRC */",
                        "\t}",
                        "",
                        "\terr = -EMSGSIZE;",
                        "\tif (!vnet_hdr.gso_type &&",
                        "\t    (len > dev->mtu + reserve + VLAN_HLEN + extra_len))",
                        "\t\tgoto out_unlock;",
                        "",
                        "\terr = -ENOBUFS;",
                        "\thlen = LL_RESERVED_SPACE(dev);",
                        "\ttlen = dev->needed_tailroom;",
                        "\tlinear = __virtio16_to_cpu(vio_le(), vnet_hdr.hdr_len);",
                        "\tlinear = max(linear, min_t(int, len, dev->hard_header_len));",
                        "\tskb = packet_alloc_skb(sk, hlen + tlen, hlen, len, linear,",
                        "\t\t\t       msg->msg_flags & MSG_DONTWAIT, &err);",
                        "\tif (skb == NULL)",
                        "\t\tgoto out_unlock;",
                        "",
                        "\tskb_reset_network_header(skb);",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (sock->type == SOCK_DGRAM) {",
                        "\t\toffset = dev_hard_header(skb, dev, ntohs(proto), addr, NULL, len);",
                        "\t\tif (unlikely(offset < 0))",
                        "\t\t\tgoto out_free;",
                        "\t} else if (reserve) {",
                        "\t\tskb_reserve(skb, -reserve);",
                        "\t\tif (len < reserve + sizeof(struct ipv6hdr) &&",
                        "\t\t    dev->min_header_len != dev->hard_header_len)",
                        "\t\t\tskb_reset_network_header(skb);",
                        "\t}",
                        "",
                        "\t/* Returns -EFAULT on error */",
                        "\terr = skb_copy_datagram_from_iter(skb, offset, &msg->msg_iter, len);",
                        "\tif (err)",
                        "\t\tgoto out_free;",
                        "",
                        "\tif (sock->type == SOCK_RAW &&",
                        "\t    !dev_validate_header(dev, skb->data, len)) {",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "",
                        "\tskb_setup_tx_timestamp(skb, sockc.tsflags);",
                        "",
                        "\tif (!vnet_hdr.gso_type && (len > dev->mtu + reserve + extra_len) &&",
                        "\t    !packet_extra_vlan_len_allowed(dev, skb)) {",
                        "\t\terr = -EMSGSIZE;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "",
                        "\tskb->protocol = proto;",
                        "\tskb->dev = dev;",
                        "\tskb->priority = sk->sk_priority;",
                        "\tskb->mark = sockc.mark;",
                        "\tskb->tstamp = sockc.transmit_time;",
                        "",
                        "\tif (has_vnet_hdr) {",
                        "\t\terr = virtio_net_hdr_to_skb(skb, &vnet_hdr, vio_le());",
                        "\t\tif (err)",
                        "\t\t\tgoto out_free;",
                        "\t\tlen += sizeof(vnet_hdr);",
                        "\t\tvirtio_net_hdr_set_proto(skb, &vnet_hdr);",
                        "\t}",
                        "",
                        "\tpacket_parse_headers(skb, sock);",
                        "",
                        "\tif (unlikely(extra_len == 4))",
                        "\t\tskb->no_fcs = 1;",
                        "",
                        "\terr = po->xmit(skb);",
                        "\tif (err > 0 && (err = net_xmit_errno(err)) != 0)",
                        "\t\tgoto out_unlock;",
                        "",
                        "\tdev_put(dev);",
                        "",
                        "\treturn len;",
                        "",
                        "out_free:",
                        "\tkfree_skb(skb);",
                        "out_unlock:",
                        "\tif (dev)",
                        "\t\tdev_put(dev);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2840,
                    "highlight": 2979
                },
                {
                    "file": "net/packet/af_packet.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/packet/af_packet.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n3004",
                    "code": [
                        "static int packet_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tstruct packet_sock *po = pkt_sk(sk);",
                        "",
                        "\tif (po->tx_ring.pg_vec)",
                        "\t\treturn tpacket_snd(po, msg);",
                        "\telse",
                        "\t\treturn packet_snd(sock, msg, len);",
                        "}"
                    ],
                    "start": 2996,
                    "highlight": 3004
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81a29c67"
        },
        "2186": {
            "name": "packet_sendmsg(indirect)",
            "parent_idx": 2178,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n652",
                    "code": [
                        "INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t   size_t));",
                        "INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t    size_t));",
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,",
                        "\t\t\t\t     inet_sendmsg, sock, msg,",
                        "\t\t\t\t     msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 646,
                    "highlight": 652
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n672",
                    "code": [
                        "/**",
                        " *\tsock_sendmsg - send a message through @sock",
                        " *\t@sock: socket",
                        " *\t@msg: message to send",
                        " *",
                        " *\tSends @msg through @sock, passing through LSM.",
                        " *\tReturns the number of bytes sent, or an error code.",
                        " */",
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 659,
                    "highlight": 672
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818a22b4"
        },
        "2178": {
            "name": "sock_sendmsg",
            "parent_idx": 2154,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n2000",
                    "code": [
                        "/*",
                        " *\tSend a datagram to a given address. We move the address into kernel",
                        " *\tspace and check the user space data area is readable before invoking",
                        " *\tthe protocol.",
                        " */",
                        "int __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags,",
                        "\t\t struct sockaddr __user *addr,  int addr_len)",
                        "{",
                        "\tstruct socket *sock;",
                        "\tstruct sockaddr_storage address;",
                        "\tint err;",
                        "\tstruct msghdr msg;",
                        "\tstruct iovec iov;",
                        "\tint fput_needed;",
                        "",
                        "\terr = import_single_range(WRITE, buff, len, &iov, &msg.msg_iter);",
                        "\tif (unlikely(err))",
                        "\t\treturn err;",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (!sock)",
                        "\t\tgoto out;",
                        "",
                        "\tmsg.msg_name = NULL;",
                        "\tmsg.msg_control = NULL;",
                        "\tmsg.msg_controllen = 0;",
                        "\tmsg.msg_namelen = 0;",
                        "\tif (addr) {",
                        "\t\terr = move_addr_to_kernel(addr, addr_len, &address);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto out_put;",
                        "\t\tmsg.msg_name = (struct sockaddr *)&address;",
                        "\t\tmsg.msg_namelen = addr_len;",
                        "\t}",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tflags |= MSG_DONTWAIT;",
                        "\tmsg.msg_flags = flags;",
                        "\terr = sock_sendmsg(sock, &msg);",
                        "",
                        "out_put:",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1964,
                    "highlight": 2000
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818a41d4"
        },
        "2154": {
            "name": "__sys_sendto",
            "parent_idx": 2152,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n2012",
                    "code": [
                        "SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,",
                        "\t\tunsigned int, flags, struct sockaddr __user *, addr,",
                        "\t\tint, addr_len)",
                        "{",
                        "\treturn __sys_sendto(fd, buff, len, flags, addr, addr_len);",
                        "}"
                    ],
                    "start": 2008,
                    "highlight": 2012
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n2008",
                    "code": [
                        "/*",
                        " *\tSend a datagram to a given address. We move the address into kernel",
                        " *\tspace and check the user space data area is readable before invoking",
                        " *\tthe protocol.",
                        " */",
                        "int __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags,",
                        "\t\t struct sockaddr __user *addr,  int addr_len)",
                        "{",
                        "\tstruct socket *sock;",
                        "\tstruct sockaddr_storage address;",
                        "\tint err;",
                        "\tstruct msghdr msg;",
                        "\tstruct iovec iov;",
                        "\tint fput_needed;",
                        "",
                        "\terr = import_single_range(WRITE, buff, len, &iov, &msg.msg_iter);",
                        "\tif (unlikely(err))",
                        "\t\treturn err;",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (!sock)",
                        "\t\tgoto out;",
                        "",
                        "\tmsg.msg_name = NULL;",
                        "\tmsg.msg_control = NULL;",
                        "\tmsg.msg_controllen = 0;",
                        "\tmsg.msg_namelen = 0;",
                        "\tif (addr) {",
                        "\t\terr = move_addr_to_kernel(addr, addr_len, &address);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto out_put;",
                        "\t\tmsg.msg_name = (struct sockaddr *)&address;",
                        "\t\tmsg.msg_namelen = addr_len;",
                        "\t}",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tflags |= MSG_DONTWAIT;",
                        "\tmsg.msg_flags = flags;",
                        "\terr = sock_sendmsg(sock, &msg);",
                        "",
                        "out_put:",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}",
                        "",
                        "SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,",
                        "\t\tunsigned int, flags, struct sockaddr __user *, addr,",
                        "\t\tint, addr_len)",
                        "{",
                        "\treturn __sys_sendto(fd, buff, len, flags, addr, addr_len);",
                        "}"
                    ],
                    "start": 1964,
                    "highlight": 2008
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818a425b"
        },
        "2152": {
            "name": "__x64_sys_sendto(indirect)",
            "parent_idx": 2149,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n295",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 282,
                    "highlight": 295
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81002829"
        },
        "2149": {
            "name": "do_syscall_64",
            "parent_idx": 2142,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=c578ddb39e565139897124e74e5a43e56538cb33#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_ON\t\t\t/* return enables interrupts */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "2142": {
            "name": "84_syscall_12",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "2260": {
            "name": "+0x1fb",
            "parent_idx": 2243,
            "source_line": [
                {
                    "file": "net/sched/sch_fq_codel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_fq_codel.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n118",
                    "code": [
                        "/* remove one skb from head of slot queue */",
                        "static inline struct sk_buff *dequeue_head(struct fq_codel_flow *flow)",
                        "{",
                        "\tstruct sk_buff *skb = flow->head;",
                        "",
                        "\tflow->head = skb->next;",
                        "\tskb_mark_not_on_list(skb);",
                        "\treturn skb;",
                        "}"
                    ],
                    "start": 115,
                    "highlight": 118
                },
                {
                    "file": "net/sched/sch_fq_codel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_fq_codel.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n168",
                    "code": [
                        "static unsigned int fq_codel_drop(struct Qdisc *sch, unsigned int max_packets,",
                        "\t\t\t\t  struct sk_buff **to_free)",
                        "{",
                        "\tstruct fq_codel_sched_data *q = qdisc_priv(sch);",
                        "\tstruct sk_buff *skb;",
                        "\tunsigned int maxbacklog = 0, idx = 0, i, len;",
                        "\tstruct fq_codel_flow *flow;",
                        "\tunsigned int threshold;",
                        "\tunsigned int mem = 0;",
                        "",
                        "\t/* Queue is full! Find the fat flow and drop packet(s) from it.",
                        "\t * This might sound expensive, but with 1024 flows, we scan",
                        "\t * 4KB of memory, and we dont need to handle a complex tree",
                        "\t * in fast path (packet queue/enqueue) with many cache misses.",
                        "\t * In stress mode, we'll try to drop 64 packets from the flow,",
                        "\t * amortizing this linear lookup to one cache line per drop.",
                        "\t */",
                        "\tfor (i = 0; i < q->flows_cnt; i++) {",
                        "\t\tif (q->backlogs[i] > maxbacklog) {",
                        "\t\t\tmaxbacklog = q->backlogs[i];",
                        "\t\t\tidx = i;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* Our goal is to drop half of this fat flow backlog */",
                        "\tthreshold = maxbacklog >> 1;",
                        "",
                        "\tflow = &q->flows[idx];",
                        "\tlen = 0;",
                        "\ti = 0;",
                        "\tdo {",
                        "\t\tskb = dequeue_head(flow);",
                        "\t\tlen += qdisc_pkt_len(skb);",
                        "\t\tmem += get_codel_cb(skb)->mem_usage;",
                        "\t\t__qdisc_drop(skb, to_free);",
                        "\t} while (++i < max_packets && len < threshold);",
                        "",
                        "\t/* Tell codel to increase its signal strength also */",
                        "\tflow->cvars.count += i;",
                        "\tq->backlogs[idx] -= len;",
                        "\tq->memory_usage -= mem;",
                        "\tsch->qstats.drops += i;",
                        "\tsch->qstats.backlog -= len;",
                        "\tsch->q.qlen -= i;",
                        "\treturn idx;",
                        "}"
                    ],
                    "start": 137,
                    "highlight": 168
                },
                {
                    "file": "net/sched/sch_fq_codel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_fq_codel.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n230",
                    "code": [
                        "static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch,",
                        "\t\t\t    struct sk_buff **to_free)",
                        "{",
                        "\tstruct fq_codel_sched_data *q = qdisc_priv(sch);",
                        "\tunsigned int idx, prev_backlog, prev_qlen;",
                        "\tstruct fq_codel_flow *flow;",
                        "\tint uninitialized_var(ret);",
                        "\tunsigned int pkt_len;",
                        "\tbool memory_limited;",
                        "",
                        "\tidx = fq_codel_classify(skb, sch, &ret);",
                        "\tif (idx == 0) {",
                        "\t\tif (ret & __NET_XMIT_BYPASS)",
                        "\t\t\tqdisc_qstats_drop(sch);",
                        "\t\t__qdisc_drop(skb, to_free);",
                        "\t\treturn ret;",
                        "\t}",
                        "\tidx--;",
                        "",
                        "\tcodel_set_enqueue_time(skb);",
                        "\tflow = &q->flows[idx];",
                        "\tflow_queue_add(flow, skb);",
                        "\tq->backlogs[idx] += qdisc_pkt_len(skb);",
                        "\tqdisc_qstats_backlog_inc(sch, skb);",
                        "",
                        "\tif (list_empty(&flow->flowchain)) {",
                        "\t\tlist_add_tail(&flow->flowchain, &q->new_flows);",
                        "\t\tq->new_flow_count++;",
                        "\t\tflow->deficit = q->quantum;",
                        "\t}",
                        "\tget_codel_cb(skb)->mem_usage = skb->truesize;",
                        "\tq->memory_usage += get_codel_cb(skb)->mem_usage;",
                        "\tmemory_limited = q->memory_usage > q->memory_limit;",
                        "\tif (++sch->q.qlen <= sch->limit && !memory_limited)",
                        "\t\treturn NET_XMIT_SUCCESS;",
                        "",
                        "\tprev_backlog = sch->qstats.backlog;",
                        "\tprev_qlen = sch->q.qlen;",
                        "",
                        "\t/* save this packet length as it might be dropped by fq_codel_drop() */",
                        "\tpkt_len = qdisc_pkt_len(skb);",
                        "\t/* fq_codel_drop() is quite expensive, as it performs a linear search",
                        "\t * in q->backlogs[] to find a fat flow.",
                        "\t * So instead of dropping a single packet, drop half of its backlog",
                        "\t * with a 64 packets limit to not add a too big cpu spike here.",
                        "\t */",
                        "\tret = fq_codel_drop(sch, q->drop_batch_size, to_free);",
                        "",
                        "\tprev_qlen -= sch->q.qlen;",
                        "\tprev_backlog -= sch->qstats.backlog;",
                        "\tq->drop_overlimit += prev_qlen;",
                        "\tif (memory_limited)",
                        "\t\tq->drop_overmemory += prev_qlen;",
                        "",
                        "\t/* As we dropped packet(s), better let upper stack know this.",
                        "\t * If we dropped a packet for this flow, return NET_XMIT_CN,",
                        "\t * but in this case, our parents wont increase their backlogs.",
                        "\t */",
                        "\tif (ret == idx) {",
                        "\t\tqdisc_tree_reduce_backlog(sch, prev_qlen - 1,",
                        "\t\t\t\t\t  prev_backlog - pkt_len);",
                        "\t\treturn NET_XMIT_CN;",
                        "\t}",
                        "\tqdisc_tree_reduce_backlog(sch, prev_qlen, prev_backlog);",
                        "\treturn NET_XMIT_SUCCESS;",
                        "}"
                    ],
                    "start": 184,
                    "highlight": 230
                }
            ],
            "ins_idx": 20,
            "addr": "0xffffffff8190eb7b"
        },
        "1114": {
            "name": "+0x0",
            "parent_idx": 1113,
            "source_line": [
                {
                    "file": "mm/util.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/util.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n559",
                    "code": [
                        "/**",
                        " * kvmalloc_node - attempt to allocate physically contiguous memory, but upon",
                        " * failure, fall back to non-contiguous (vmalloc) allocation.",
                        " * @size: size of the request.",
                        " * @flags: gfp mask for the allocation - must be compatible (superset) with GFP_KERNEL.",
                        " * @node: numa node to allocate from",
                        " *",
                        " * Uses kmalloc to get the memory but if the allocation fails then falls back",
                        " * to the vmalloc allocator. Use kvfree for freeing the memory.",
                        " *",
                        " * Reclaim modifiers - __GFP_NORETRY and __GFP_NOFAIL are not supported.",
                        " * __GFP_RETRY_MAYFAIL is supported, and it should be used only if kmalloc is",
                        " * preferable to the vmalloc fallback, due to visible performance drawbacks.",
                        " *",
                        " * Please note that any use of gfp flags outside of GFP_KERNEL is careful to not",
                        " * fall back to vmalloc.",
                        " *",
                        " * Return: pointer to the allocated memory of %NULL in case of failure",
                        " */",
                        "void *kvmalloc_node(size_t size, gfp_t flags, int node)",
                        "{",
                        "\tgfp_t kmalloc_flags = flags;",
                        "\tvoid *ret;",
                        "",
                        "\t/*",
                        "\t * vmalloc uses GFP_KERNEL for some internal allocations (e.g page tables)",
                        "\t * so the given set of flags has to be compatible.",
                        "\t */",
                        "\tif ((flags & GFP_KERNEL) != GFP_KERNEL)",
                        "\t\treturn kmalloc_node(size, flags, node);",
                        "",
                        "\t/*",
                        "\t * We want to attempt a large physically contiguous block first because",
                        "\t * it is less likely to fragment multiple larger blocks and therefore",
                        "\t * contribute to a long term fragmentation less than vmalloc fallback.",
                        "\t * However make sure that larger requests are not too disruptive - no",
                        "\t * OOM killer and no allocation failure warnings as we have a fallback.",
                        "\t */",
                        "\tif (size > PAGE_SIZE) {",
                        "\t\tkmalloc_flags |= __GFP_NOWARN;",
                        "",
                        "\t\tif (!(kmalloc_flags & __GFP_RETRY_MAYFAIL))",
                        "\t\t\tkmalloc_flags |= __GFP_NORETRY;",
                        "\t}",
                        "",
                        "\tret = kmalloc_node(size, kmalloc_flags, node);",
                        "",
                        "\t/*",
                        "\t * It doesn't really make sense to fallback to vmalloc for sub page",
                        "\t * requests",
                        "\t */",
                        "\tif (ret || size <= PAGE_SIZE)",
                        "\t\treturn ret;",
                        "",
                        "\treturn __vmalloc_node_flags_caller(size, node, flags,",
                        "\t\t\t__builtin_return_address(0));",
                        "}"
                    ],
                    "start": 529,
                    "highlight": 559
                }
            ],
            "ins_idx": 35,
            "addr": "0xffffffff81188730"
        },
        "1113": {
            "name": "kvmalloc_node",
            "parent_idx": 1088,
            "source_line": [
                {
                    "file": "./include/linux/mm.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/mm.h?id=c578ddb39e565139897124e74e5a43e56538cb33#n757",
                    "code": [
                        "extern void *kvmalloc_node(size_t size, gfp_t flags, int node);",
                        "static inline void *kvmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kvmalloc_node(size, flags, NUMA_NO_NODE);",
                        "}"
                    ],
                    "start": 754,
                    "highlight": 757
                },
                {
                    "file": "./include/linux/mm.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/mm.h?id=c578ddb39e565139897124e74e5a43e56538cb33#n775",
                    "code": [
                        "static inline void *kvmalloc_array(size_t n, size_t size, gfp_t flags)",
                        "{",
                        "\tsize_t bytes;",
                        "",
                        "\tif (unlikely(check_mul_overflow(n, size, &bytes)))",
                        "\t\treturn NULL;",
                        "",
                        "\treturn kvmalloc(bytes, flags);",
                        "}"
                    ],
                    "start": 768,
                    "highlight": 775
                },
                {
                    "file": "./include/linux/mm.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/mm.h?id=c578ddb39e565139897124e74e5a43e56538cb33#n780",
                    "code": [
                        "static inline void *kvcalloc(size_t n, size_t size, gfp_t flags)",
                        "{",
                        "\treturn kvmalloc_array(n, size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 778,
                    "highlight": 780
                },
                {
                    "file": "net/sched/sch_fq_codel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_fq_codel.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n479",
                    "code": [
                        "static int fq_codel_init(struct Qdisc *sch, struct nlattr *opt,",
                        "\t\t\t struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct fq_codel_sched_data *q = qdisc_priv(sch);",
                        "\tint i;",
                        "\tint err;",
                        "",
                        "\tsch->limit = 10*1024;",
                        "\tq->flows_cnt = 1024;",
                        "\tq->memory_limit = 32 << 20; /* 32 MBytes */",
                        "\tq->drop_batch_size = 64;",
                        "\tq->quantum = psched_mtu(qdisc_dev(sch));",
                        "\tINIT_LIST_HEAD(&q->new_flows);",
                        "\tINIT_LIST_HEAD(&q->old_flows);",
                        "\tcodel_params_init(&q->cparams);",
                        "\tcodel_stats_init(&q->cstats);",
                        "\tq->cparams.ecn = true;",
                        "\tq->cparams.mtu = psched_mtu(qdisc_dev(sch));",
                        "",
                        "\tif (opt) {",
                        "\t\terr = fq_codel_change(sch, opt, extack);",
                        "\t\tif (err)",
                        "\t\t\tgoto init_failure;",
                        "\t}",
                        "",
                        "\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);",
                        "\tif (err)",
                        "\t\tgoto init_failure;",
                        "",
                        "\tif (!q->flows) {",
                        "\t\tq->flows = kvcalloc(q->flows_cnt,",
                        "\t\t\t\t    sizeof(struct fq_codel_flow),",
                        "\t\t\t\t    GFP_KERNEL);",
                        "\t\tif (!q->flows) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto init_failure;",
                        "\t\t}",
                        "\t\tq->backlogs = kvcalloc(q->flows_cnt, sizeof(u32), GFP_KERNEL);",
                        "\t\tif (!q->backlogs) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto alloc_failure;",
                        "\t\t}",
                        "\t\tfor (i = 0; i < q->flows_cnt; i++) {",
                        "\t\t\tstruct fq_codel_flow *flow = q->flows + i;",
                        "",
                        "\t\t\tINIT_LIST_HEAD(&flow->flowchain);",
                        "\t\t\tcodel_vars_init(&flow->cvars);",
                        "\t\t}",
                        "\t}",
                        "\tif (sch->limit >= 1)",
                        "\t\tsch->flags |= TCQ_F_CAN_BYPASS;",
                        "\telse",
                        "\t\tsch->flags &= ~TCQ_F_CAN_BYPASS;",
                        "\treturn 0;",
                        "",
                        "alloc_failure:",
                        "\tkvfree(q->flows);",
                        "\tq->flows = NULL;",
                        "init_failure:",
                        "\tq->flows_cnt = 0;",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 449,
                    "highlight": 479
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8190fdb6"
        },
        "1088": {
            "name": "fq_codel_init(indirect)",
            "parent_idx": 1062,
            "source_line": [
                {
                    "file": "net/sched/sch_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_api.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n1244",
                    "code": [
                        "static struct Qdisc *qdisc_create(struct net_device *dev,",
                        "\t\t\t\t  struct netdev_queue *dev_queue,",
                        "\t\t\t\t  struct Qdisc *p, u32 parent, u32 handle,",
                        "\t\t\t\t  struct nlattr **tca, int *errp,",
                        "\t\t\t\t  struct netlink_ext_ack *extack)",
                        "{",
                        "\tint err;",
                        "\tstruct nlattr *kind = tca[TCA_KIND];",
                        "\tstruct Qdisc *sch;",
                        "\tstruct Qdisc_ops *ops;",
                        "\tstruct qdisc_size_table *stab;",
                        "",
                        "\tops = qdisc_lookup_ops(kind);",
                        "#ifdef CONFIG_MODULES",
                        "\tif (ops == NULL && kind != NULL) {",
                        "\t\tchar name[IFNAMSIZ];",
                        "\t\tif (nla_strlcpy(name, kind, IFNAMSIZ) < IFNAMSIZ) {",
                        "\t\t\t/* We dropped the RTNL semaphore in order to",
                        "\t\t\t * perform the module load.  So, even if we",
                        "\t\t\t * succeeded in loading the module we have to",
                        "\t\t\t * tell the caller to replay the request.  We",
                        "\t\t\t * indicate this using -EAGAIN.",
                        "\t\t\t * We replay the request because the device may",
                        "\t\t\t * go away in the mean time.",
                        "\t\t\t */",
                        "\t\t\trtnl_unlock();",
                        "\t\t\trequest_module(\"sch_%s\", name);",
                        "\t\t\trtnl_lock();",
                        "\t\t\tops = qdisc_lookup_ops(kind);",
                        "\t\t\tif (ops != NULL) {",
                        "\t\t\t\t/* We will try again qdisc_lookup_ops,",
                        "\t\t\t\t * so don't keep a reference.",
                        "\t\t\t\t */",
                        "\t\t\t\tmodule_put(ops->owner);",
                        "\t\t\t\terr = -EAGAIN;",
                        "\t\t\t\tgoto err_out;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "#endif",
                        "",
                        "\terr = -ENOENT;",
                        "\tif (!ops) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Specified qdisc not found\");",
                        "\t\tgoto err_out;",
                        "\t}",
                        "",
                        "\tsch = qdisc_alloc(dev_queue, ops, extack);",
                        "\tif (IS_ERR(sch)) {",
                        "\t\terr = PTR_ERR(sch);",
                        "\t\tgoto err_out2;",
                        "\t}",
                        "",
                        "\tsch->parent = parent;",
                        "",
                        "\tif (handle == TC_H_INGRESS) {",
                        "\t\tsch->flags |= TCQ_F_INGRESS;",
                        "\t\thandle = TC_H_MAKE(TC_H_INGRESS, 0);",
                        "\t} else {",
                        "\t\tif (handle == 0) {",
                        "\t\t\thandle = qdisc_alloc_handle(dev);",
                        "\t\t\tif (handle == 0) {",
                        "\t\t\t\tNL_SET_ERR_MSG(extack, \"Maximum number of qdisc handles was exceeded\");",
                        "\t\t\t\terr = -ENOSPC;",
                        "\t\t\t\tgoto err_out3;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (!netif_is_multiqueue(dev))",
                        "\t\t\tsch->flags |= TCQ_F_ONETXQUEUE;",
                        "\t}",
                        "",
                        "\tsch->handle = handle;",
                        "",
                        "\t/* This exist to keep backward compatible with a userspace",
                        "\t * loophole, what allowed userspace to get IFF_NO_QUEUE",
                        "\t * facility on older kernels by setting tx_queue_len=0 (prior",
                        "\t * to qdisc init), and then forgot to reinit tx_queue_len",
                        "\t * before again attaching a qdisc.",
                        "\t */",
                        "\tif ((dev->priv_flags & IFF_NO_QUEUE) && (dev->tx_queue_len == 0)) {",
                        "\t\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;",
                        "\t\tnetdev_info(dev, \"Caught tx_queue_len zero misconfig\\n\");",
                        "\t}",
                        "",
                        "\terr = qdisc_block_indexes_set(sch, tca, extack);",
                        "\tif (err)",
                        "\t\tgoto err_out3;",
                        "",
                        "\tif (ops->init) {",
                        "\t\terr = ops->init(sch, tca[TCA_OPTIONS], extack);",
                        "\t\tif (err != 0)",
                        "\t\t\tgoto err_out5;",
                        "\t}",
                        "",
                        "\tif (tca[TCA_STAB]) {",
                        "\t\tstab = qdisc_get_stab(tca[TCA_STAB], extack);",
                        "\t\tif (IS_ERR(stab)) {",
                        "\t\t\terr = PTR_ERR(stab);",
                        "\t\t\tgoto err_out4;",
                        "\t\t}",
                        "\t\trcu_assign_pointer(sch->stab, stab);",
                        "\t}",
                        "\tif (tca[TCA_RATE]) {",
                        "\t\tseqcount_t *running;",
                        "",
                        "\t\terr = -EOPNOTSUPP;",
                        "\t\tif (sch->flags & TCQ_F_MQROOT) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"Cannot attach rate estimator to a multi-queue root qdisc\");",
                        "\t\t\tgoto err_out4;",
                        "\t\t}",
                        "",
                        "\t\tif (sch->parent != TC_H_ROOT &&",
                        "\t\t    !(sch->flags & TCQ_F_INGRESS) &&",
                        "\t\t    (!p || !(p->flags & TCQ_F_MQROOT)))",
                        "\t\t\trunning = qdisc_root_sleeping_running(sch);",
                        "\t\telse",
                        "\t\t\trunning = &sch->running;",
                        "",
                        "\t\terr = gen_new_estimator(&sch->bstats,",
                        "\t\t\t\t\tsch->cpu_bstats,",
                        "\t\t\t\t\t&sch->rate_est,",
                        "\t\t\t\t\tNULL,",
                        "\t\t\t\t\trunning,",
                        "\t\t\t\t\ttca[TCA_RATE]);",
                        "\t\tif (err) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"Failed to generate new estimator\");",
                        "\t\t\tgoto err_out4;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tqdisc_hash_add(sch, false);",
                        "",
                        "\treturn sch;",
                        "",
                        "err_out5:",
                        "\t/* ops->init() failed, we call ->destroy() like qdisc_create_dflt() */",
                        "\tif (ops->destroy)",
                        "\t\tops->destroy(sch);",
                        "err_out3:",
                        "\tdev_put(dev);",
                        "\tqdisc_free(sch);",
                        "err_out2:",
                        "\tmodule_put(ops->owner);",
                        "err_out:",
                        "\t*errp = err;",
                        "\treturn NULL;",
                        "",
                        "err_out4:",
                        "\t/*",
                        "\t * Any broken qdiscs that would require a ops->reset() here?",
                        "\t * The qdisc was never in action so it shouldn't be necessary.",
                        "\t */",
                        "\tqdisc_put_stab(rtnl_dereference(sch->stab));",
                        "\tif (ops->destroy)",
                        "\t\tops->destroy(sch);",
                        "\tgoto err_out3;",
                        "}"
                    ],
                    "start": 1155,
                    "highlight": 1244
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81903e58"
        },
        "1062": {
            "name": "qdisc_create",
            "parent_idx": 1017,
            "source_line": [
                {
                    "file": "net/sched/sch_api.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_api.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n1659",
                    "code": [
                        "static int tc_modify_qdisc(struct sk_buff *skb, struct nlmsghdr *n,",
                        "\t\t\t   struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct tcmsg *tcm;",
                        "\tstruct nlattr *tca[TCA_MAX + 1];",
                        "\tstruct net_device *dev;",
                        "\tu32 clid;",
                        "\tstruct Qdisc *q, *p;",
                        "\tint err;",
                        "",
                        "\tif (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "replay:",
                        "\t/* Reinit, just in case something touches this. */",
                        "\terr = nlmsg_parse_deprecated(n, sizeof(*tcm), tca, TCA_MAX,",
                        "\t\t\t\t     rtm_tca_policy, extack);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\ttcm = nlmsg_data(n);",
                        "\tclid = tcm->tcm_parent;",
                        "\tq = p = NULL;",
                        "",
                        "\tdev = __dev_get_by_index(net, tcm->tcm_ifindex);",
                        "\tif (!dev)",
                        "\t\treturn -ENODEV;",
                        "",
                        "",
                        "\tif (clid) {",
                        "\t\tif (clid != TC_H_ROOT) {",
                        "\t\t\tif (clid != TC_H_INGRESS) {",
                        "\t\t\t\tp = qdisc_lookup(dev, TC_H_MAJ(clid));",
                        "\t\t\t\tif (!p) {",
                        "\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Failed to find specified qdisc\");",
                        "\t\t\t\t\treturn -ENOENT;",
                        "\t\t\t\t}",
                        "\t\t\t\tq = qdisc_leaf(p, clid);",
                        "\t\t\t} else if (dev_ingress_queue_create(dev)) {",
                        "\t\t\t\tq = dev_ingress_queue(dev)->qdisc_sleeping;",
                        "\t\t\t}",
                        "\t\t} else {",
                        "\t\t\tq = dev->qdisc;",
                        "\t\t}",
                        "",
                        "\t\t/* It may be default qdisc, ignore it */",
                        "\t\tif (q && q->handle == 0)",
                        "\t\t\tq = NULL;",
                        "",
                        "\t\tif (!q || !tcm->tcm_handle || q->handle != tcm->tcm_handle) {",
                        "\t\t\tif (tcm->tcm_handle) {",
                        "\t\t\t\tif (q && !(n->nlmsg_flags & NLM_F_REPLACE)) {",
                        "\t\t\t\t\tNL_SET_ERR_MSG(extack, \"NLM_F_REPLACE needed to override\");",
                        "\t\t\t\t\treturn -EEXIST;",
                        "\t\t\t\t}",
                        "\t\t\t\tif (TC_H_MIN(tcm->tcm_handle)) {",
                        "\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid minor handle\");",
                        "\t\t\t\t\treturn -EINVAL;",
                        "\t\t\t\t}",
                        "\t\t\t\tq = qdisc_lookup(dev, tcm->tcm_handle);",
                        "\t\t\t\tif (!q)",
                        "\t\t\t\t\tgoto create_n_graft;",
                        "\t\t\t\tif (n->nlmsg_flags & NLM_F_EXCL) {",
                        "\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Exclusivity flag on, cannot override\");",
                        "\t\t\t\t\treturn -EEXIST;",
                        "\t\t\t\t}",
                        "\t\t\t\tif (tca[TCA_KIND] &&",
                        "\t\t\t\t    nla_strcmp(tca[TCA_KIND], q->ops->id)) {",
                        "\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid qdisc name\");",
                        "\t\t\t\t\treturn -EINVAL;",
                        "\t\t\t\t}",
                        "\t\t\t\tif (q == p ||",
                        "\t\t\t\t    (p && check_loop(q, p, 0))) {",
                        "\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Qdisc parent/child loop detected\");",
                        "\t\t\t\t\treturn -ELOOP;",
                        "\t\t\t\t}",
                        "\t\t\t\tqdisc_refcount_inc(q);",
                        "\t\t\t\tgoto graft;",
                        "\t\t\t} else {",
                        "\t\t\t\tif (!q)",
                        "\t\t\t\t\tgoto create_n_graft;",
                        "",
                        "\t\t\t\t/* This magic test requires explanation.",
                        "\t\t\t\t *",
                        "\t\t\t\t *   We know, that some child q is already",
                        "\t\t\t\t *   attached to this parent and have choice:",
                        "\t\t\t\t *   either to change it or to create/graft new one.",
                        "\t\t\t\t *",
                        "\t\t\t\t *   1. We are allowed to create/graft only",
                        "\t\t\t\t *   if CREATE and REPLACE flags are set.",
                        "\t\t\t\t *",
                        "\t\t\t\t *   2. If EXCL is set, requestor wanted to say,",
                        "\t\t\t\t *   that qdisc tcm_handle is not expected",
                        "\t\t\t\t *   to exist, so that we choose create/graft too.",
                        "\t\t\t\t *",
                        "\t\t\t\t *   3. The last case is when no flags are set.",
                        "\t\t\t\t *   Alas, it is sort of hole in API, we",
                        "\t\t\t\t *   cannot decide what to do unambiguously.",
                        "\t\t\t\t *   For now we select create/graft, if",
                        "\t\t\t\t *   user gave KIND, which does not match existing.",
                        "\t\t\t\t */",
                        "\t\t\t\tif ((n->nlmsg_flags & NLM_F_CREATE) &&",
                        "\t\t\t\t    (n->nlmsg_flags & NLM_F_REPLACE) &&",
                        "\t\t\t\t    ((n->nlmsg_flags & NLM_F_EXCL) ||",
                        "\t\t\t\t     (tca[TCA_KIND] &&",
                        "\t\t\t\t      nla_strcmp(tca[TCA_KIND], q->ops->id))))",
                        "\t\t\t\t\tgoto create_n_graft;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t} else {",
                        "\t\tif (!tcm->tcm_handle) {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"Handle cannot be zero\");",
                        "\t\t\treturn -EINVAL;",
                        "\t\t}",
                        "\t\tq = qdisc_lookup(dev, tcm->tcm_handle);",
                        "\t}",
                        "",
                        "\t/* Change qdisc parameters */",
                        "\tif (!q) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Specified qdisc not found\");",
                        "\t\treturn -ENOENT;",
                        "\t}",
                        "\tif (n->nlmsg_flags & NLM_F_EXCL) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Exclusivity flag on, cannot modify\");",
                        "\t\treturn -EEXIST;",
                        "\t}",
                        "\tif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], q->ops->id)) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Invalid qdisc name\");",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "\terr = qdisc_change(q, tca, extack);",
                        "\tif (err == 0)",
                        "\t\tqdisc_notify(net, skb, n, clid, NULL, q);",
                        "\treturn err;",
                        "",
                        "create_n_graft:",
                        "\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {",
                        "\t\tNL_SET_ERR_MSG(extack, \"Qdisc not found. To create specify NLM_F_CREATE flag\");",
                        "\t\treturn -ENOENT;",
                        "\t}",
                        "\tif (clid == TC_H_INGRESS) {",
                        "\t\tif (dev_ingress_queue(dev)) {",
                        "\t\t\tq = qdisc_create(dev, dev_ingress_queue(dev), p,",
                        "\t\t\t\t\t tcm->tcm_parent, tcm->tcm_parent,",
                        "\t\t\t\t\t tca, &err, extack);",
                        "\t\t} else {",
                        "\t\t\tNL_SET_ERR_MSG(extack, \"Cannot find ingress queue for specified device\");",
                        "\t\t\terr = -ENOENT;",
                        "\t\t}",
                        "\t} else {",
                        "\t\tstruct netdev_queue *dev_queue;",
                        "",
                        "\t\tif (p && p->ops->cl_ops && p->ops->cl_ops->select_queue)",
                        "\t\t\tdev_queue = p->ops->cl_ops->select_queue(p, tcm);",
                        "\t\telse if (p)",
                        "\t\t\tdev_queue = p->dev_queue;",
                        "\t\telse",
                        "\t\t\tdev_queue = netdev_get_tx_queue(dev, 0);",
                        "",
                        "\t\tq = qdisc_create(dev, dev_queue, p,",
                        "\t\t\t\t tcm->tcm_parent, tcm->tcm_handle,",
                        "\t\t\t\t tca, &err, extack);",
                        "\t}",
                        "\tif (q == NULL) {",
                        "\t\tif (err == -EAGAIN)",
                        "\t\t\tgoto replay;",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "graft:",
                        "\terr = qdisc_graft(dev, p, skb, n, clid, q, NULL, extack);",
                        "\tif (err) {",
                        "\t\tif (q)",
                        "\t\t\tqdisc_put(q);",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 1499,
                    "highlight": 1659
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81904b3b"
        },
        "1017": {
            "name": "tc_modify_qdisc(indirect)",
            "parent_idx": 987,
            "source_line": [
                {
                    "file": "net/core/rtnetlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/rtnetlink.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n5454",
                    "code": [
                        "static int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,",
                        "\t\t\t     struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct net *net = sock_net(skb->sk);",
                        "\tstruct rtnl_link *link;",
                        "\tstruct module *owner;",
                        "\tint err = -EOPNOTSUPP;",
                        "\trtnl_doit_func doit;",
                        "\tunsigned int flags;",
                        "\tint kind;",
                        "\tint family;",
                        "\tint type;",
                        "",
                        "\ttype = nlh->nlmsg_type;",
                        "\tif (type > RTM_MAX)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\ttype -= RTM_BASE;",
                        "",
                        "\t/* All the messages must have at least 1 byte length */",
                        "\tif (nlmsg_len(nlh) < sizeof(struct rtgenmsg))",
                        "\t\treturn 0;",
                        "",
                        "\tfamily = ((struct rtgenmsg *)nlmsg_data(nlh))->rtgen_family;",
                        "\tkind = type&3;",
                        "",
                        "\tif (kind != 2 && !netlink_net_capable(skb, CAP_NET_ADMIN))",
                        "\t\treturn -EPERM;",
                        "",
                        "\trcu_read_lock();",
                        "\tif (kind == 2 && nlh->nlmsg_flags&NLM_F_DUMP) {",
                        "\t\tstruct sock *rtnl;",
                        "\t\trtnl_dumpit_func dumpit;",
                        "\t\tu16 min_dump_alloc = 0;",
                        "",
                        "\t\tlink = rtnl_get_link(family, type);",
                        "\t\tif (!link || !link->dumpit) {",
                        "\t\t\tfamily = PF_UNSPEC;",
                        "\t\t\tlink = rtnl_get_link(family, type);",
                        "\t\t\tif (!link || !link->dumpit)",
                        "\t\t\t\tgoto err_unlock;",
                        "\t\t}",
                        "\t\towner = link->owner;",
                        "\t\tdumpit = link->dumpit;",
                        "",
                        "\t\tif (type == RTM_GETLINK - RTM_BASE)",
                        "\t\t\tmin_dump_alloc = rtnl_calcit(skb, nlh);",
                        "",
                        "\t\terr = 0;",
                        "\t\t/* need to do this before rcu_read_unlock() */",
                        "\t\tif (!try_module_get(owner))",
                        "\t\t\terr = -EPROTONOSUPPORT;",
                        "",
                        "\t\trcu_read_unlock();",
                        "",
                        "\t\trtnl = net->rtnl;",
                        "\t\tif (err == 0) {",
                        "\t\t\tstruct netlink_dump_control c = {",
                        "\t\t\t\t.dump\t\t= dumpit,",
                        "\t\t\t\t.min_dump_alloc\t= min_dump_alloc,",
                        "\t\t\t\t.module\t\t= owner,",
                        "\t\t\t};",
                        "\t\t\terr = netlink_dump_start(rtnl, skb, nlh, &c);",
                        "\t\t\t/* netlink_dump_start() will keep a reference on",
                        "\t\t\t * module if dump is still in progress.",
                        "\t\t\t */",
                        "\t\t\tmodule_put(owner);",
                        "\t\t}",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\tlink = rtnl_get_link(family, type);",
                        "\tif (!link || !link->doit) {",
                        "\t\tfamily = PF_UNSPEC;",
                        "\t\tlink = rtnl_get_link(PF_UNSPEC, type);",
                        "\t\tif (!link || !link->doit)",
                        "\t\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\towner = link->owner;",
                        "\tif (!try_module_get(owner)) {",
                        "\t\terr = -EPROTONOSUPPORT;",
                        "\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\tflags = link->flags;",
                        "\tif (flags & RTNL_FLAG_DOIT_UNLOCKED) {",
                        "\t\tdoit = link->doit;",
                        "\t\trcu_read_unlock();",
                        "\t\tif (doit)",
                        "\t\t\terr = doit(skb, nlh, extack);",
                        "\t\tmodule_put(owner);",
                        "\t\treturn err;",
                        "\t}",
                        "\trcu_read_unlock();",
                        "",
                        "\trtnl_lock();",
                        "\tlink = rtnl_get_link(family, type);",
                        "\tif (link && link->doit)",
                        "\t\terr = link->doit(skb, nlh, extack);",
                        "\trtnl_unlock();",
                        "",
                        "\tmodule_put(owner);",
                        "",
                        "\treturn err;",
                        "",
                        "out_unlock:",
                        "\trcu_read_unlock();",
                        "\treturn err;",
                        "",
                        "err_unlock:",
                        "\trcu_read_unlock();",
                        "\treturn -EOPNOTSUPP;",
                        "}"
                    ],
                    "start": 5355,
                    "highlight": 5454
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818d8756"
        },
        "987": {
            "name": "rtnetlink_rcv_msg(indirect)",
            "parent_idx": 981,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n2469",
                    "code": [
                        "int netlink_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *,",
                        "\t\t\t\t\t\t   struct nlmsghdr *,",
                        "\t\t\t\t\t\t   struct netlink_ext_ack *))",
                        "{",
                        "\tstruct netlink_ext_ack extack;",
                        "\tstruct nlmsghdr *nlh;",
                        "\tint err;",
                        "",
                        "\twhile (skb->len >= nlmsg_total_size(0)) {",
                        "\t\tint msglen;",
                        "",
                        "\t\tmemset(&extack, 0, sizeof(extack));",
                        "\t\tnlh = nlmsg_hdr(skb);",
                        "\t\terr = 0;",
                        "",
                        "\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len)",
                        "\t\t\treturn 0;",
                        "",
                        "\t\t/* Only requests are handled by the kernel */",
                        "\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST))",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\t/* Skip control messages */",
                        "\t\tif (nlh->nlmsg_type < NLMSG_MIN_TYPE)",
                        "\t\t\tgoto ack;",
                        "",
                        "\t\terr = cb(skb, nlh, &extack);",
                        "\t\tif (err == -EINTR)",
                        "\t\t\tgoto skip;",
                        "",
                        "ack:",
                        "\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err)",
                        "\t\t\tnetlink_ack(skb, nlh, err, &extack);",
                        "",
                        "skip:",
                        "\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);",
                        "\t\tif (msglen > skb->len)",
                        "\t\t\tmsglen = skb->len;",
                        "\t\tskb_pull(skb, msglen);",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 2443,
                    "highlight": 2469
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8191517d"
        },
        "981": {
            "name": "netlink_rcv_skb(indirect)",
            "parent_idx": 877,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n1303",
                    "code": [
                        "static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,",
                        "\t\t\t\t  struct sock *ssk)",
                        "{",
                        "\tint ret;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "",
                        "\tret = -ECONNREFUSED;",
                        "\tif (nlk->netlink_rcv != NULL) {",
                        "\t\tret = skb->len;",
                        "\t\tnetlink_skb_set_owner_r(skb, sk);",
                        "\t\tNETLINK_CB(skb).sk = ssk;",
                        "\t\tnetlink_deliver_tap_kernel(sk, ssk, skb);",
                        "\t\tnlk->netlink_rcv(skb);",
                        "\t\tconsume_skb(skb);",
                        "\t} else {",
                        "\t\tkfree_skb(skb);",
                        "\t}",
                        "\tsock_put(sk);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 1291,
                    "highlight": 1303
                },
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n1329",
                    "code": [
                        "int netlink_unicast(struct sock *ssk, struct sk_buff *skb,",
                        "\t\t    u32 portid, int nonblock)",
                        "{",
                        "\tstruct sock *sk;",
                        "\tint err;",
                        "\tlong timeo;",
                        "",
                        "\tskb = netlink_trim(skb, gfp_any());",
                        "",
                        "\ttimeo = sock_sndtimeo(ssk, nonblock);",
                        "retry:",
                        "\tsk = netlink_getsockbyportid(ssk, portid);",
                        "\tif (IS_ERR(sk)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\treturn PTR_ERR(sk);",
                        "\t}",
                        "\tif (netlink_is_kernel(sk))",
                        "\t\treturn netlink_unicast_kernel(sk, skb, ssk);",
                        "",
                        "\tif (sk_filter(sk, skb)) {",
                        "\t\terr = skb->len;",
                        "\t\tkfree_skb(skb);",
                        "\t\tsock_put(sk);",
                        "\t\treturn err;",
                        "\t}",
                        "",
                        "\terr = netlink_attachskb(sk, skb, &timeo, ssk);",
                        "\tif (err == 1)",
                        "\t\tgoto retry;",
                        "\tif (err)",
                        "\t\treturn err;",
                        "",
                        "\treturn netlink_sendskb(sk, skb);",
                        "}"
                    ],
                    "start": 1312,
                    "highlight": 1329
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8191490f"
        },
        "877": {
            "name": "netlink_unicast",
            "parent_idx": 684,
            "source_line": [
                {
                    "file": "net/netlink/af_netlink.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netlink/af_netlink.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n1918",
                    "code": [
                        "static int netlink_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tstruct netlink_sock *nlk = nlk_sk(sk);",
                        "\tDECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);",
                        "\tu32 dst_portid;",
                        "\tu32 dst_group;",
                        "\tstruct sk_buff *skb;",
                        "\tint err;",
                        "\tstruct scm_cookie scm;",
                        "\tu32 netlink_skb_flags = 0;",
                        "",
                        "\tif (msg->msg_flags&MSG_OOB)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\terr = scm_send(sock, msg, &scm, true);",
                        "\tif (err < 0)",
                        "\t\treturn err;",
                        "",
                        "\tif (msg->msg_namelen) {",
                        "\t\terr = -EINVAL;",
                        "\t\tif (msg->msg_namelen < sizeof(struct sockaddr_nl))",
                        "\t\t\tgoto out;",
                        "\t\tif (addr->nl_family != AF_NETLINK)",
                        "\t\t\tgoto out;",
                        "\t\tdst_portid = addr->nl_pid;",
                        "\t\tdst_group = ffs(addr->nl_groups);",
                        "\t\terr =  -EPERM;",
                        "\t\tif ((dst_group || dst_portid) &&",
                        "\t\t    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))",
                        "\t\t\tgoto out;",
                        "\t\tnetlink_skb_flags |= NETLINK_SKB_DST;",
                        "\t} else {",
                        "\t\tdst_portid = nlk->dst_portid;",
                        "\t\tdst_group = nlk->dst_group;",
                        "\t}",
                        "",
                        "\tif (!nlk->bound) {",
                        "\t\terr = netlink_autobind(sock);",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t} else {",
                        "\t\t/* Ensure nlk is hashed and visible. */",
                        "\t\tsmp_rmb();",
                        "\t}",
                        "",
                        "\terr = -EMSGSIZE;",
                        "\tif (len > sk->sk_sndbuf - 32)",
                        "\t\tgoto out;",
                        "\terr = -ENOBUFS;",
                        "\tskb = netlink_alloc_large_skb(len, dst_group);",
                        "\tif (skb == NULL)",
                        "\t\tgoto out;",
                        "",
                        "\tNETLINK_CB(skb).portid\t= nlk->portid;",
                        "\tNETLINK_CB(skb).dst_group = dst_group;",
                        "\tNETLINK_CB(skb).creds\t= scm.creds;",
                        "\tNETLINK_CB(skb).flags\t= netlink_skb_flags;",
                        "",
                        "\terr = -EFAULT;",
                        "\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\terr = security_netlink_send(sk, skb);",
                        "\tif (err) {",
                        "\t\tkfree_skb(skb);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\tif (dst_group) {",
                        "\t\trefcount_inc(&skb->users);",
                        "\t\tnetlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);",
                        "\t}",
                        "\terr = netlink_unicast(sk, skb, dst_portid, msg->msg_flags&MSG_DONTWAIT);",
                        "",
                        "out:",
                        "\tscm_destroy(&scm);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1843,
                    "highlight": 1918
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81914bfb"
        },
        "684": {
            "name": "netlink_sendmsg(indirect)",
            "parent_idx": 669,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n652",
                    "code": [
                        "INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t   size_t));",
                        "INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t    size_t));",
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,",
                        "\t\t\t\t     inet_sendmsg, sock, msg,",
                        "\t\t\t\t     msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 646,
                    "highlight": 652
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n672",
                    "code": [
                        "/**",
                        " *\tsock_sendmsg - send a message through @sock",
                        " *\t@sock: socket",
                        " *\t@msg: message to send",
                        " *",
                        " *\tSends @msg through @sock, passing through LSM.",
                        " *\tReturns the number of bytes sent, or an error code.",
                        " */",
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 659,
                    "highlight": 672
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818a22b4"
        },
        "669": {
            "name": "sock_sendmsg",
            "parent_idx": 664,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n2362",
                    "code": [
                        "static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,",
                        "\t\t\t   unsigned int flags, struct used_address *used_address,",
                        "\t\t\t   unsigned int allowed_msghdr_flags)",
                        "{",
                        "\tunsigned char ctl[sizeof(struct cmsghdr) + 20]",
                        "\t\t\t\t__aligned(sizeof(__kernel_size_t));",
                        "\t/* 20 is size of ipv6_pktinfo */",
                        "\tunsigned char *ctl_buf = ctl;",
                        "\tint ctl_len;",
                        "\tssize_t err;",
                        "",
                        "\terr = -ENOBUFS;",
                        "",
                        "\tif (msg_sys->msg_controllen > INT_MAX)",
                        "\t\tgoto out;",
                        "\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);",
                        "\tctl_len = msg_sys->msg_controllen;",
                        "\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
                        "\t\terr =",
                        "\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,",
                        "\t\t\t\t\t\t     sizeof(ctl));",
                        "\t\tif (err)",
                        "\t\t\tgoto out;",
                        "\t\tctl_buf = msg_sys->msg_control;",
                        "\t\tctl_len = msg_sys->msg_controllen;",
                        "\t} else if (ctl_len) {",
                        "\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=",
                        "\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));",
                        "\t\tif (ctl_len > sizeof(ctl)) {",
                        "\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);",
                        "\t\t\tif (ctl_buf == NULL)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\terr = -EFAULT;",
                        "\t\t/*",
                        "\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.",
                        "\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted",
                        "\t\t * checking falls down on this.",
                        "\t\t */",
                        "\t\tif (copy_from_user(ctl_buf,",
                        "\t\t\t\t   (void __user __force *)msg_sys->msg_control,",
                        "\t\t\t\t   ctl_len))",
                        "\t\t\tgoto out_freectl;",
                        "\t\tmsg_sys->msg_control = ctl_buf;",
                        "\t}",
                        "\tmsg_sys->msg_flags = flags;",
                        "",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;",
                        "\t/*",
                        "\t * If this is sendmmsg() and current destination address is same as",
                        "\t * previously succeeded address, omit asking LSM's decision.",
                        "\t * used_address->name_len is initialized to UINT_MAX so that the first",
                        "\t * destination address never matches.",
                        "\t */",
                        "\tif (used_address && msg_sys->msg_name &&",
                        "\t    used_address->name_len == msg_sys->msg_namelen &&",
                        "\t    !memcmp(&used_address->name, msg_sys->msg_name,",
                        "\t\t    used_address->name_len)) {",
                        "\t\terr = sock_sendmsg_nosec(sock, msg_sys);",
                        "\t\tgoto out_freectl;",
                        "\t}",
                        "\terr = sock_sendmsg(sock, msg_sys);",
                        "\t/*",
                        "\t * If this is sendmmsg() and sending to current destination address was",
                        "\t * successful, remember it.",
                        "\t */",
                        "\tif (used_address && err >= 0) {",
                        "\t\tused_address->name_len = msg_sys->msg_namelen;",
                        "\t\tif (msg_sys->msg_name)",
                        "\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,",
                        "\t\t\t       used_address->name_len);",
                        "\t}",
                        "",
                        "out_freectl:",
                        "\tif (ctl_buf != ctl)",
                        "\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2300,
                    "highlight": 2362
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818a25c9"
        },
        "664": {
            "name": "____sys_sendmsg",
            "parent_idx": 572,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n2416",
                    "code": [
                        "\terr = ____sys_sendmsg(sock, msg_sys, flags, used_address,",
                        "\t\t\t\tallowed_msghdr_flags);",
                        "\tkfree(iov);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2416,
                    "highlight": 2416
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818a4ebb"
        },
        "572": {
            "name": "___sys_sendmsg",
            "parent_idx": 541,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n2449",
                    "code": [
                        "\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);",
                        "",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2449,
                    "highlight": 2449
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff818a4f7f"
        },
        "541": {
            "name": "__x64_sys_sendmsg(indirect)",
            "parent_idx": 538,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n295",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 282,
                    "highlight": 295
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81002829"
        },
        "538": {
            "name": "do_syscall_64",
            "parent_idx": 528,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=c578ddb39e565139897124e74e5a43e56538cb33#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_ON\t\t\t/* return enables interrupts */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "528": {
            "name": "68_syscall_8",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "2259": {
            "name": "+0x1e6",
            "parent_idx": 2243,
            "source_line": [
                {
                    "file": "net/sched/sch_fq_codel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_fq_codel.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n164",
                    "code": [
                        "static unsigned int fq_codel_drop(struct Qdisc *sch, unsigned int max_packets,",
                        "\t\t\t\t  struct sk_buff **to_free)",
                        "{",
                        "\tstruct fq_codel_sched_data *q = qdisc_priv(sch);",
                        "\tstruct sk_buff *skb;",
                        "\tunsigned int maxbacklog = 0, idx = 0, i, len;",
                        "\tstruct fq_codel_flow *flow;",
                        "\tunsigned int threshold;",
                        "\tunsigned int mem = 0;",
                        "",
                        "\t/* Queue is full! Find the fat flow and drop packet(s) from it.",
                        "\t * This might sound expensive, but with 1024 flows, we scan",
                        "\t * 4KB of memory, and we dont need to handle a complex tree",
                        "\t * in fast path (packet queue/enqueue) with many cache misses.",
                        "\t * In stress mode, we'll try to drop 64 packets from the flow,",
                        "\t * amortizing this linear lookup to one cache line per drop.",
                        "\t */",
                        "\tfor (i = 0; i < q->flows_cnt; i++) {",
                        "\t\tif (q->backlogs[i] > maxbacklog) {",
                        "\t\t\tmaxbacklog = q->backlogs[i];",
                        "\t\t\tidx = i;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/* Our goal is to drop half of this fat flow backlog */",
                        "\tthreshold = maxbacklog >> 1;",
                        "",
                        "\tflow = &q->flows[idx];",
                        "\tlen = 0;",
                        "\ti = 0;",
                        "\tdo {",
                        "\t\tskb = dequeue_head(flow);",
                        "\t\tlen += qdisc_pkt_len(skb);",
                        "\t\tmem += get_codel_cb(skb)->mem_usage;",
                        "\t\t__qdisc_drop(skb, to_free);",
                        "\t} while (++i < max_packets && len < threshold);",
                        "",
                        "\t/* Tell codel to increase its signal strength also */",
                        "\tflow->cvars.count += i;",
                        "\tq->backlogs[idx] -= len;",
                        "\tq->memory_usage -= mem;",
                        "\tsch->qstats.drops += i;",
                        "\tsch->qstats.backlog -= len;",
                        "\tsch->q.qlen -= i;",
                        "\treturn idx;",
                        "}"
                    ],
                    "start": 137,
                    "highlight": 164
                },
                {
                    "file": "net/sched/sch_fq_codel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_fq_codel.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n230",
                    "code": [
                        "static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch,",
                        "\t\t\t    struct sk_buff **to_free)",
                        "{",
                        "\tstruct fq_codel_sched_data *q = qdisc_priv(sch);",
                        "\tunsigned int idx, prev_backlog, prev_qlen;",
                        "\tstruct fq_codel_flow *flow;",
                        "\tint uninitialized_var(ret);",
                        "\tunsigned int pkt_len;",
                        "\tbool memory_limited;",
                        "",
                        "\tidx = fq_codel_classify(skb, sch, &ret);",
                        "\tif (idx == 0) {",
                        "\t\tif (ret & __NET_XMIT_BYPASS)",
                        "\t\t\tqdisc_qstats_drop(sch);",
                        "\t\t__qdisc_drop(skb, to_free);",
                        "\t\treturn ret;",
                        "\t}",
                        "\tidx--;",
                        "",
                        "\tcodel_set_enqueue_time(skb);",
                        "\tflow = &q->flows[idx];",
                        "\tflow_queue_add(flow, skb);",
                        "\tq->backlogs[idx] += qdisc_pkt_len(skb);",
                        "\tqdisc_qstats_backlog_inc(sch, skb);",
                        "",
                        "\tif (list_empty(&flow->flowchain)) {",
                        "\t\tlist_add_tail(&flow->flowchain, &q->new_flows);",
                        "\t\tq->new_flow_count++;",
                        "\t\tflow->deficit = q->quantum;",
                        "\t}",
                        "\tget_codel_cb(skb)->mem_usage = skb->truesize;",
                        "\tq->memory_usage += get_codel_cb(skb)->mem_usage;",
                        "\tmemory_limited = q->memory_usage > q->memory_limit;",
                        "\tif (++sch->q.qlen <= sch->limit && !memory_limited)",
                        "\t\treturn NET_XMIT_SUCCESS;",
                        "",
                        "\tprev_backlog = sch->qstats.backlog;",
                        "\tprev_qlen = sch->q.qlen;",
                        "",
                        "\t/* save this packet length as it might be dropped by fq_codel_drop() */",
                        "\tpkt_len = qdisc_pkt_len(skb);",
                        "\t/* fq_codel_drop() is quite expensive, as it performs a linear search",
                        "\t * in q->backlogs[] to find a fat flow.",
                        "\t * So instead of dropping a single packet, drop half of its backlog",
                        "\t * with a 64 packets limit to not add a too big cpu spike here.",
                        "\t */",
                        "\tret = fq_codel_drop(sch, q->drop_batch_size, to_free);",
                        "",
                        "\tprev_qlen -= sch->q.qlen;",
                        "\tprev_backlog -= sch->qstats.backlog;",
                        "\tq->drop_overlimit += prev_qlen;",
                        "\tif (memory_limited)",
                        "\t\tq->drop_overmemory += prev_qlen;",
                        "",
                        "\t/* As we dropped packet(s), better let upper stack know this.",
                        "\t * If we dropped a packet for this flow, return NET_XMIT_CN,",
                        "\t * but in this case, our parents wont increase their backlogs.",
                        "\t */",
                        "\tif (ret == idx) {",
                        "\t\tqdisc_tree_reduce_backlog(sch, prev_qlen - 1,",
                        "\t\t\t\t\t  prev_backlog - pkt_len);",
                        "\t\treturn NET_XMIT_CN;",
                        "\t}",
                        "\tqdisc_tree_reduce_backlog(sch, prev_qlen, prev_backlog);",
                        "\treturn NET_XMIT_SUCCESS;",
                        "}"
                    ],
                    "start": 184,
                    "highlight": 230
                }
            ],
            "ins_idx": 34,
            "addr": "0xffffffff8190eb66"
        },
        "1115": {
            "name": "+0x14b",
            "parent_idx": 1088,
            "source_line": [
                {
                    "file": "net/sched/sch_fq_codel.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_fq_codel.c?id=c578ddb39e565139897124e74e5a43e56538cb33#n479",
                    "code": [
                        "static int fq_codel_init(struct Qdisc *sch, struct nlattr *opt,",
                        "\t\t\t struct netlink_ext_ack *extack)",
                        "{",
                        "\tstruct fq_codel_sched_data *q = qdisc_priv(sch);",
                        "\tint i;",
                        "\tint err;",
                        "",
                        "\tsch->limit = 10*1024;",
                        "\tq->flows_cnt = 1024;",
                        "\tq->memory_limit = 32 << 20; /* 32 MBytes */",
                        "\tq->drop_batch_size = 64;",
                        "\tq->quantum = psched_mtu(qdisc_dev(sch));",
                        "\tINIT_LIST_HEAD(&q->new_flows);",
                        "\tINIT_LIST_HEAD(&q->old_flows);",
                        "\tcodel_params_init(&q->cparams);",
                        "\tcodel_stats_init(&q->cstats);",
                        "\tq->cparams.ecn = true;",
                        "\tq->cparams.mtu = psched_mtu(qdisc_dev(sch));",
                        "",
                        "\tif (opt) {",
                        "\t\terr = fq_codel_change(sch, opt, extack);",
                        "\t\tif (err)",
                        "\t\t\tgoto init_failure;",
                        "\t}",
                        "",
                        "\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);",
                        "\tif (err)",
                        "\t\tgoto init_failure;",
                        "",
                        "\tif (!q->flows) {",
                        "\t\tq->flows = kvcalloc(q->flows_cnt,",
                        "\t\t\t\t    sizeof(struct fq_codel_flow),",
                        "\t\t\t\t    GFP_KERNEL);",
                        "\t\tif (!q->flows) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto init_failure;",
                        "\t\t}",
                        "\t\tq->backlogs = kvcalloc(q->flows_cnt, sizeof(u32), GFP_KERNEL);",
                        "\t\tif (!q->backlogs) {",
                        "\t\t\terr = -ENOMEM;",
                        "\t\t\tgoto alloc_failure;",
                        "\t\t}",
                        "\t\tfor (i = 0; i < q->flows_cnt; i++) {",
                        "\t\t\tstruct fq_codel_flow *flow = q->flows + i;",
                        "",
                        "\t\t\tINIT_LIST_HEAD(&flow->flowchain);",
                        "\t\t\tcodel_vars_init(&flow->cvars);",
                        "\t\t}",
                        "\t}",
                        "\tif (sch->limit >= 1)",
                        "\t\tsch->flags |= TCQ_F_CAN_BYPASS;",
                        "\telse",
                        "\t\tsch->flags &= ~TCQ_F_CAN_BYPASS;",
                        "\treturn 0;",
                        "",
                        "alloc_failure:",
                        "\tkvfree(q->flows);",
                        "\tq->flows = NULL;",
                        "init_failure:",
                        "\tq->flows_cnt = 0;",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 449,
                    "highlight": 479
                }
            ],
            "ins_idx": 54,
            "addr": "0xffffffff8190fdbb"
        }
    },
    "ins": {
        "7": {
            "name": "mov r8, qword ptr [rax]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x0",
            "call_idx": 2261,
            "inputs": [
                4200,
                4201
            ],
            "outputs": [
                4202
            ]
        },
        "20": {
            "name": "mov rax, qword ptr [rdi]",
            "desc": "Heap Use Before Initialization",
            "call_idx": 2260,
            "inputs": [
                4197,
                4198
            ],
            "outputs": [
                4199
            ]
        },
        "35": {
            "name": "push r13",
            "desc": "Source of base address MEMALLOC 0x0",
            "call_idx": 1114,
            "inputs": [],
            "outputs": [
                2119
            ]
        },
        "34": {
            "name": "add rdi, qword ptr [rbp + 0x150]",
            "desc": "",
            "call_idx": 2259,
            "inputs": [
                4193,
                4194,
                4195
            ],
            "outputs": [
                4196
            ]
        },
        "54": {
            "name": "mov qword ptr [rbx + 0x150], rax",
            "desc": "",
            "call_idx": 1115,
            "inputs": [
                2120,
                2121
            ],
            "outputs": [
                2122
            ]
        }
    },
    "data": {
        "4200": {
            "name": "RAX",
            "ins_idx": 7,
            "value": "0x0",
            "sources": []
        },
        "4201": {
            "name": "[0x0]",
            "ins_idx": 7,
            "value": "0x0",
            "sources": []
        },
        "4202": {
            "name": "R8",
            "ins_idx": 7,
            "value": "0x0",
            "sources": []
        },
        "4197": {
            "name": "RDI",
            "ins_idx": 20,
            "value": "0xffff888235900000",
            "sources": []
        },
        "4198": {
            "name": "[0xffff888235900000]",
            "ins_idx": 20,
            "value": "0x0",
            "sources": []
        },
        "4199": {
            "name": "RAX",
            "ins_idx": 20,
            "value": "0x0",
            "sources": [
                4200
            ]
        },
        "2119": {
            "name": "RAX",
            "ins_idx": 35,
            "value": "0xffff888235900000",
            "sources": [
                2121
            ]
        },
        "4193": {
            "name": "RBP",
            "ins_idx": 34,
            "value": "0xffff888234f20800",
            "sources": []
        },
        "4194": {
            "name": "[0xffff888234f20950]",
            "ins_idx": 34,
            "value": "0xffff888235900000",
            "sources": []
        },
        "4195": {
            "name": "RDI",
            "ins_idx": 34,
            "value": "0x0",
            "sources": []
        },
        "4196": {
            "name": "RDI",
            "ins_idx": 34,
            "value": "0xffff888235900000",
            "sources": [
                4197
            ]
        },
        "2120": {
            "name": "RBX",
            "ins_idx": 54,
            "value": "0xffff888234f20800",
            "sources": []
        },
        "2121": {
            "name": "RAX",
            "ins_idx": 54,
            "value": "0xffff888235900000",
            "sources": []
        },
        "2122": {
            "name": "[0xffff888234f20950]",
            "ins_idx": 54,
            "value": "0xffff888235900000",
            "sources": [
                4194
            ]
        }
    },
    "chain": {
        "7": [
            20
        ],
        "20": [
            35,
            34
        ],
        "34": [
            54
        ],
        "54": [
            35
        ]
    }
}