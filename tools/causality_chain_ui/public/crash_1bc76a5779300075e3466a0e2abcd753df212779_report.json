{
    "report": "https://syzkaller.appspot.com/bug?id=1bc76a5779300075e3466a0e2abcd753df212779",
    "title": "KASAN: null-ptr-deref Write in __pm_runtime_resume",
    "call": {
        "566": {
            "name": "+0x21",
            "parent_idx": 564,
            "source_line": [
                {
                    "file": "./arch/x86/include/asm/atomic.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./arch/x86/include/asm/atomic.h?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n95",
                    "code": [
                        "/**",
                        " * arch_atomic_inc - increment atomic variable",
                        " * @v: pointer of type atomic_t",
                        " *",
                        " * Atomically increments @v by 1.",
                        " */",
                        "static __always_inline void arch_atomic_inc(atomic_t *v)",
                        "{",
                        "\tasm volatile(LOCK_PREFIX \"incl %0\"",
                        "\t\t     : \"+m\" (v->counter) :: \"memory\");",
                        "}"
                    ],
                    "start": 87,
                    "highlight": 95
                },
                {
                    "file": "./include/linux/atomic/atomic-instrumented.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/atomic/atomic-instrumented.h?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n182",
                    "code": [
                        "static __always_inline void",
                        "atomic_inc(atomic_t *v)",
                        "{",
                        "\tinstrument_atomic_read_write(v, sizeof(*v));",
                        "\tarch_atomic_inc(v);",
                        "}"
                    ],
                    "start": 178,
                    "highlight": 182
                },
                {
                    "file": "drivers/base/power/runtime.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/power/runtime.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n1105",
                    "code": [
                        "/**",
                        " * __pm_runtime_resume - Entry point for runtime resume operations.",
                        " * @dev: Device to resume.",
                        " * @rpmflags: Flag bits.",
                        " *",
                        " * If the RPM_GET_PUT flag is set, increment the device's usage count.  Then",
                        " * carry out a resume, either synchronous or asynchronous.",
                        " *",
                        " * This routine may be called in atomic context if the RPM_ASYNC flag is set,",
                        " * or if pm_runtime_irq_safe() has been called.",
                        " */",
                        "int __pm_runtime_resume(struct device *dev, int rpmflags)",
                        "{",
                        "\tunsigned long flags;",
                        "\tint retval;",
                        "",
                        "\tmight_sleep_if(!(rpmflags & RPM_ASYNC) && !dev->power.irq_safe &&",
                        "\t\t\tdev->power.runtime_status != RPM_ACTIVE);",
                        "",
                        "\tif (rpmflags & RPM_GET_PUT)",
                        "\t\tatomic_inc(&dev->power.usage_count);",
                        "",
                        "\tspin_lock_irqsave(&dev->power.lock, flags);",
                        "\tretval = rpm_resume(dev, rpmflags);",
                        "\tspin_unlock_irqrestore(&dev->power.lock, flags);",
                        "",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 1085,
                    "highlight": 1105
                }
            ],
            "ins_idx": 1,
            "addr": "0xffffffff816c78f1"
        },
        "564": {
            "name": "__pm_runtime_resume",
            "parent_idx": 561,
            "source_line": [
                {
                    "file": "./include/linux/pm_runtime.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/pm_runtime.h?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n370",
                    "code": [
                        "/**",
                        " * pm_runtime_get - Bump up usage counter and queue up resume of a device.",
                        " * @dev: Target device.",
                        " *",
                        " * Bump up the runtime PM usage counter of @dev and queue up a work item to",
                        " * carry out runtime-resume of it.",
                        " */",
                        "static inline int pm_runtime_get(struct device *dev)",
                        "{",
                        "\treturn __pm_runtime_resume(dev, RPM_GET_PUT | RPM_ASYNC);",
                        "}"
                    ],
                    "start": 361,
                    "highlight": 370
                },
                {
                    "file": "drivers/bluetooth/hci_h5.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_h5.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n590",
                    "code": [
                        "static int h5_recv(struct hci_uart *hu, const void *data, int count)",
                        "{",
                        "\tstruct h5 *h5 = hu->priv;",
                        "\tconst unsigned char *ptr = data;",
                        "",
                        "\tBT_DBG(\"%s pending %zu count %d\", hu->hdev->name, h5->rx_pending,",
                        "\t       count);",
                        "",
                        "\twhile (count > 0) {",
                        "\t\tint processed;",
                        "",
                        "\t\tif (h5->rx_pending > 0) {",
                        "\t\t\tif (*ptr == SLIP_DELIMITER) {",
                        "\t\t\t\tbt_dev_err(hu->hdev, \"Too short H5 packet\");",
                        "\t\t\t\th5_reset_rx(h5);",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "",
                        "\t\t\th5_unslip_one_byte(h5, *ptr);",
                        "",
                        "\t\t\tptr++; count--;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "",
                        "\t\tprocessed = h5->rx_func(hu, *ptr);",
                        "\t\tif (processed < 0)",
                        "\t\t\treturn processed;",
                        "",
                        "\t\tptr += processed;",
                        "\t\tcount -= processed;",
                        "\t}",
                        "",
                        "\tpm_runtime_get(&hu->serdev->dev);",
                        "\tpm_runtime_mark_last_busy(&hu->serdev->dev);",
                        "\tpm_runtime_put_autosuspend(&hu->serdev->dev);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 558,
                    "highlight": 590
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8186005e"
        },
        "561": {
            "name": "h5_recv(indirect)",
            "parent_idx": 552,
            "source_line": [
                {
                    "file": "drivers/bluetooth/hci_ldisc.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_ldisc.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n613",
                    "code": [
                        "/* hci_uart_tty_receive()",
                        " *",
                        " *     Called by tty low level driver when receive data is",
                        " *     available.",
                        " *",
                        " * Arguments:  tty          pointer to tty isntance data",
                        " *             data         pointer to received data",
                        " *             flags        pointer to flags for data",
                        " *             count        count of received data in bytes",
                        " *",
                        " * Return Value:    None",
                        " */",
                        "static void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data,",
                        "\t\t\t\t const char *flags, int count)",
                        "{",
                        "\tstruct hci_uart *hu = tty->disc_data;",
                        "",
                        "\tif (!hu || tty != hu->tty)",
                        "\t\treturn;",
                        "",
                        "\tpercpu_down_read(&hu->proto_lock);",
                        "",
                        "\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags)) {",
                        "\t\tpercpu_up_read(&hu->proto_lock);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* It does not need a lock here as it is already protected by a mutex in",
                        "\t * tty caller",
                        "\t */",
                        "\thu->proto->recv(hu, data, count);",
                        "\tpercpu_up_read(&hu->proto_lock);",
                        "",
                        "\tif (hu->hdev)",
                        "\t\thu->hdev->stat.byte_rx += count;",
                        "",
                        "\ttty_unthrottle(tty);",
                        "}"
                    ],
                    "start": 583,
                    "highlight": 613
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8185e316"
        },
        "552": {
            "name": "hci_uart_tty_receive(indirect)",
            "parent_idx": 526,
            "source_line": [
                {
                    "file": "drivers/tty/tty_io.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_io.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n2310",
                    "code": [
                        "\tif ((current->signal->tty != tty) && !capable(CAP_SYS_ADMIN))",
                        "\t\treturn -EPERM;",
                        "\tif (get_user(ch, p))",
                        "\t\treturn -EFAULT;",
                        "\ttty_audit_tiocsti(tty, ch);",
                        "\tld = tty_ldisc_ref_wait(tty);",
                        "\tif (!ld)",
                        "\t\treturn -EIO;",
                        "\ttty_buffer_lock_exclusive(tty->port);",
                        "\tif (ld->ops->receive_buf)",
                        "\t\tld->ops->receive_buf(tty, &ch, &mbz, 1);",
                        "\ttty_buffer_unlock_exclusive(tty->port);",
                        "\ttty_ldisc_deref(ld);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 2300,
                    "highlight": 2310
                },
                {
                    "file": "drivers/tty/tty_io.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_io.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n2719",
                    "code": [
                        "/*",
                        " * Split this up, as gcc can choke on it otherwise..",
                        " */",
                        "long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tstruct tty_struct *tty = file_tty(file);",
                        "\tstruct tty_struct *real_tty;",
                        "\tvoid __user *p = (void __user *)arg;",
                        "\tint retval;",
                        "\tstruct tty_ldisc *ld;",
                        "",
                        "\tif (tty_paranoia_check(tty, file_inode(file), \"tty_ioctl\"))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\treal_tty = tty_pair_get_tty(tty);",
                        "",
                        "\t/*",
                        "\t * Factor out some common prep work",
                        "\t */",
                        "\tswitch (cmd) {",
                        "\tcase TIOCSETD:",
                        "\tcase TIOCSBRK:",
                        "\tcase TIOCCBRK:",
                        "\tcase TCSBRK:",
                        "\tcase TCSBRKP:",
                        "\t\tretval = tty_check_change(tty);",
                        "\t\tif (retval)",
                        "\t\t\treturn retval;",
                        "\t\tif (cmd != TIOCCBRK) {",
                        "\t\t\ttty_wait_until_sent(tty, 0);",
                        "\t\t\tif (signal_pending(current))",
                        "\t\t\t\treturn -EINTR;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t *\tNow do the stuff.",
                        "\t */",
                        "\tswitch (cmd) {",
                        "\tcase TIOCSTI:",
                        "\t\treturn tiocsti(tty, p);",
                        "\tcase TIOCGWINSZ:",
                        "\t\treturn tiocgwinsz(real_tty, p);",
                        "\tcase TIOCSWINSZ:",
                        "\t\treturn tiocswinsz(real_tty, p);",
                        "\tcase TIOCCONS:",
                        "\t\treturn real_tty != tty ? -EINVAL : tioccons(file);",
                        "\tcase TIOCEXCL:",
                        "\t\tset_bit(TTY_EXCLUSIVE, &tty->flags);",
                        "\t\treturn 0;",
                        "\tcase TIOCNXCL:",
                        "\t\tclear_bit(TTY_EXCLUSIVE, &tty->flags);",
                        "\t\treturn 0;",
                        "\tcase TIOCGEXCL:",
                        "\t{",
                        "\t\tint excl = test_bit(TTY_EXCLUSIVE, &tty->flags);",
                        "",
                        "\t\treturn put_user(excl, (int __user *)p);",
                        "\t}",
                        "\tcase TIOCGETD:",
                        "\t\treturn tiocgetd(tty, p);",
                        "\tcase TIOCSETD:",
                        "\t\treturn tiocsetd(tty, p);",
                        "\tcase TIOCVHANGUP:",
                        "\t\tif (!capable(CAP_SYS_ADMIN))",
                        "\t\t\treturn -EPERM;",
                        "\t\ttty_vhangup(tty);",
                        "\t\treturn 0;",
                        "\tcase TIOCGDEV:",
                        "\t{",
                        "\t\tunsigned int ret = new_encode_dev(tty_devnum(real_tty));",
                        "",
                        "\t\treturn put_user(ret, (unsigned int __user *)p);",
                        "\t}",
                        "\t/*",
                        "\t * Break handling",
                        "\t */",
                        "\tcase TIOCSBRK:\t/* Turn break on, unconditionally */",
                        "\t\tif (tty->ops->break_ctl)",
                        "\t\t\treturn tty->ops->break_ctl(tty, -1);",
                        "\t\treturn 0;",
                        "\tcase TIOCCBRK:\t/* Turn break off, unconditionally */",
                        "\t\tif (tty->ops->break_ctl)",
                        "\t\t\treturn tty->ops->break_ctl(tty, 0);",
                        "\t\treturn 0;",
                        "\tcase TCSBRK:   /* SVID version: non-zero arg --> no break */",
                        "\t\t/* non-zero arg means wait for all output data",
                        "\t\t * to be sent (performed above) but don't send break.",
                        "\t\t * This is used by the tcdrain() termios function.",
                        "\t\t */",
                        "\t\tif (!arg)",
                        "\t\t\treturn send_break(tty, 250);",
                        "\t\treturn 0;",
                        "\tcase TCSBRKP:\t/* support for POSIX tcsendbreak() */",
                        "\t\treturn send_break(tty, arg ? arg*100 : 250);",
                        "",
                        "\tcase TIOCMGET:",
                        "\t\treturn tty_tiocmget(tty, p);",
                        "\tcase TIOCMSET:",
                        "\tcase TIOCMBIC:",
                        "\tcase TIOCMBIS:",
                        "\t\treturn tty_tiocmset(tty, cmd, p);",
                        "\tcase TIOCGICOUNT:",
                        "\t\treturn tty_tiocgicount(tty, p);",
                        "\tcase TCFLSH:",
                        "\t\tswitch (arg) {",
                        "\t\tcase TCIFLUSH:",
                        "\t\tcase TCIOFLUSH:",
                        "\t\t/* flush tty buffer and allow ldisc to process ioctl */",
                        "\t\t\ttty_buffer_flush(tty, NULL);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\tcase TIOCSSERIAL:",
                        "\t\treturn tty_tiocsserial(tty, p);",
                        "\tcase TIOCGSERIAL:",
                        "\t\treturn tty_tiocgserial(tty, p);",
                        "\tcase TIOCGPTPEER:",
                        "\t\t/* Special because the struct file is needed */",
                        "\t\treturn ptm_open_peer(file, tty, (int)arg);",
                        "\tdefault:",
                        "\t\tretval = tty_jobctrl_ioctl(tty, real_tty, file, cmd, arg);",
                        "\t\tif (retval != -ENOIOCTLCMD)",
                        "\t\t\treturn retval;",
                        "\t}",
                        "\tif (tty->ops->ioctl) {",
                        "\t\tretval = tty->ops->ioctl(tty, cmd, arg);",
                        "\t\tif (retval != -ENOIOCTLCMD)",
                        "\t\t\treturn retval;",
                        "\t}",
                        "\tld = tty_ldisc_ref_wait(tty);",
                        "\tif (!ld)",
                        "\t\treturn hung_up_tty_ioctl(file, cmd, arg);",
                        "\tretval = -EINVAL;",
                        "\tif (ld->ops->ioctl) {",
                        "\t\tretval = ld->ops->ioctl(tty, file, cmd, arg);",
                        "\t\tif (retval == -ENOIOCTLCMD)",
                        "\t\t\tretval = -ENOTTY;",
                        "\t}",
                        "\ttty_ldisc_deref(ld);",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 2678,
                    "highlight": 2719
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff814dc371"
        },
        "526": {
            "name": "tty_ioctl(indirect)",
            "parent_idx": 495,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n51",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 33,
                    "highlight": 51
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n874",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 860,
                    "highlight": 874
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n860",
                    "code": [
                        "/*",
                        " * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.",
                        " * It's just a simple helper for sys_ioctl and compat_sys_ioctl.",
                        " *",
                        " * When you add any new common ioctls to the switches above and below,",
                        " * please ensure they have compatible arguments in compat mode.",
                        " */",
                        "static int do_vfs_ioctl(struct file *filp, unsigned int fd,",
                        "\t\t\tunsigned int cmd, unsigned long arg)",
                        "{",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tstruct inode *inode = file_inode(filp);",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIOCLEX:",
                        "\t\tset_close_on_exec(fd, 1);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONCLEX:",
                        "\t\tset_close_on_exec(fd, 0);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONBIO:",
                        "\t\treturn ioctl_fionbio(filp, argp);",
                        "",
                        "\tcase FIOASYNC:",
                        "\t\treturn ioctl_fioasync(fd, filp, argp);",
                        "",
                        "\tcase FIOQSIZE:",
                        "\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||",
                        "\t\t    S_ISLNK(inode->i_mode)) {",
                        "\t\t\tloff_t res = inode_get_bytes(inode);",
                        "\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?",
                        "\t\t\t\t\t    -EFAULT : 0;",
                        "\t\t}",
                        "",
                        "\t\treturn -ENOTTY;",
                        "",
                        "\tcase FIFREEZE:",
                        "\t\treturn ioctl_fsfreeze(filp);",
                        "",
                        "\tcase FITHAW:",
                        "\t\treturn ioctl_fsthaw(filp);",
                        "",
                        "\tcase FS_IOC_FIEMAP:",
                        "\t\treturn ioctl_fiemap(filp, argp);",
                        "",
                        "\tcase FIGETBSZ:",
                        "\t\t/* anon_bdev filesystems may not have a block size */",
                        "\t\tif (!inode->i_sb->s_blocksize)",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
                        "",
                        "\tcase FICLONE:",
                        "\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);",
                        "",
                        "\tcase FICLONERANGE:",
                        "\t\treturn ioctl_file_clone_range(filp, argp);",
                        "",
                        "\tcase FIDEDUPERANGE:",
                        "\t\treturn ioctl_file_dedupe_range(filp, argp);",
                        "",
                        "\tcase FIONREAD:",
                        "\t\tif (!S_ISREG(inode->i_mode))",
                        "\t\t\treturn vfs_ioctl(filp, cmd, arg);",
                        "",
                        "\t\treturn put_user(i_size_read(inode) - filp->f_pos,",
                        "\t\t\t\t(int __user *)argp);",
                        "",
                        "\tcase FS_IOC_GETFLAGS:",
                        "\t\treturn ioctl_getflags(filp, argp);",
                        "",
                        "\tcase FS_IOC_SETFLAGS:",
                        "\t\treturn ioctl_setflags(filp, argp);",
                        "",
                        "\tcase FS_IOC_FSGETXATTR:",
                        "\t\treturn ioctl_fsgetxattr(filp, argp);",
                        "",
                        "\tcase FS_IOC_FSSETXATTR:",
                        "\t\treturn ioctl_fssetxattr(filp, argp);",
                        "",
                        "\tdefault:",
                        "\t\tif (S_ISREG(inode->i_mode))",
                        "\t\t\treturn file_ioctl(filp, cmd, argp);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn -ENOIOCTLCMD;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 769,
                    "highlight": 860
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81208f49"
        },
        "495": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 492,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n50",
                    "code": [
                        "static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)",
                        "{",
                        "\t/*",
                        "\t * Convert negative numbers to very high and thus out of range",
                        "\t * numbers for comparisons.",
                        "\t */",
                        "\tunsigned int unr = nr;",
                        "",
                        "\tif (likely(unr < NR_syscalls)) {",
                        "\t\tunr = array_index_nospec(unr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[unr](regs);",
                        "\t\treturn true;",
                        "\t}",
                        "\treturn false;",
                        "}"
                    ],
                    "start": 40,
                    "highlight": 50
                },
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n80",
                    "code": [
                        "__visible noinstr void do_syscall_64(struct pt_regs *regs, int nr)",
                        "{",
                        "\tadd_random_kstack_offset();",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "",
                        "\tif (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {",
                        "\t\t/* Invalid system call, but still a system call. */",
                        "\t\tregs->ax = __x64_sys_ni_syscall(regs);",
                        "\t}",
                        "",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 73,
                    "highlight": 80
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c24b3e"
        },
        "492": {
            "name": "do_syscall_64",
            "parent_idx": 485,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n113",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rsp, %rdi",
                        "\t/* Sign extend the lower 32bit as syscall numbers are treated as int */",
                        "\tmovslq\t%eax, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t * In the Xen PV case we must use iret anyway.",
                        "\t */",
                        "",
                        "\tALTERNATIVE \"\", \"jmp\tswapgs_restore_regs_and_return_to_usermode\", \\",
                        "\t\tX86_FEATURE_XENPV",
                        "",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tswapgs",
                        "\tsysretq",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 87,
                    "highlight": 113
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e00077"
        },
        "485": {
            "name": "10_syscall_7",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "565": {
            "name": "+0xd",
            "parent_idx": 564,
            "source_line": [
                {
                    "file": "drivers/base/power/runtime.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/base/power/runtime.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n1097",
                    "code": [
                        "/**",
                        " * __pm_runtime_resume - Entry point for runtime resume operations.",
                        " * @dev: Device to resume.",
                        " * @rpmflags: Flag bits.",
                        " *",
                        " * If the RPM_GET_PUT flag is set, increment the device's usage count.  Then",
                        " * carry out a resume, either synchronous or asynchronous.",
                        " *",
                        " * This routine may be called in atomic context if the RPM_ASYNC flag is set,",
                        " * or if pm_runtime_irq_safe() has been called.",
                        " */",
                        "int __pm_runtime_resume(struct device *dev, int rpmflags)",
                        "{",
                        "\tunsigned long flags;",
                        "\tint retval;",
                        "",
                        "\tmight_sleep_if(!(rpmflags & RPM_ASYNC) && !dev->power.irq_safe &&",
                        "\t\t\tdev->power.runtime_status != RPM_ACTIVE);",
                        "",
                        "\tif (rpmflags & RPM_GET_PUT)",
                        "\t\tatomic_inc(&dev->power.usage_count);",
                        "",
                        "\tspin_lock_irqsave(&dev->power.lock, flags);",
                        "\tretval = rpm_resume(dev, rpmflags);",
                        "\tspin_unlock_irqrestore(&dev->power.lock, flags);",
                        "",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 1085,
                    "highlight": 1097
                }
            ],
            "ins_idx": 7,
            "addr": "0xffffffff816c78dd"
        },
        "563": {
            "name": "+0xf5",
            "parent_idx": 561,
            "source_line": [
                {
                    "file": "./include/linux/pm_runtime.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/pm_runtime.h?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n370",
                    "code": [
                        "/**",
                        " * pm_runtime_get - Bump up usage counter and queue up resume of a device.",
                        " * @dev: Target device.",
                        " *",
                        " * Bump up the runtime PM usage counter of @dev and queue up a work item to",
                        " * carry out runtime-resume of it.",
                        " */",
                        "static inline int pm_runtime_get(struct device *dev)",
                        "{",
                        "\treturn __pm_runtime_resume(dev, RPM_GET_PUT | RPM_ASYNC);",
                        "}"
                    ],
                    "start": 361,
                    "highlight": 370
                },
                {
                    "file": "drivers/bluetooth/hci_h5.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_h5.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n590",
                    "code": [
                        "static int h5_recv(struct hci_uart *hu, const void *data, int count)",
                        "{",
                        "\tstruct h5 *h5 = hu->priv;",
                        "\tconst unsigned char *ptr = data;",
                        "",
                        "\tBT_DBG(\"%s pending %zu count %d\", hu->hdev->name, h5->rx_pending,",
                        "\t       count);",
                        "",
                        "\twhile (count > 0) {",
                        "\t\tint processed;",
                        "",
                        "\t\tif (h5->rx_pending > 0) {",
                        "\t\t\tif (*ptr == SLIP_DELIMITER) {",
                        "\t\t\t\tbt_dev_err(hu->hdev, \"Too short H5 packet\");",
                        "\t\t\t\th5_reset_rx(h5);",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "",
                        "\t\t\th5_unslip_one_byte(h5, *ptr);",
                        "",
                        "\t\t\tptr++; count--;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "",
                        "\t\tprocessed = h5->rx_func(hu, *ptr);",
                        "\t\tif (processed < 0)",
                        "\t\t\treturn processed;",
                        "",
                        "\t\tptr += processed;",
                        "\t\tcount -= processed;",
                        "\t}",
                        "",
                        "\tpm_runtime_get(&hu->serdev->dev);",
                        "\tpm_runtime_mark_last_busy(&hu->serdev->dev);",
                        "\tpm_runtime_put_autosuspend(&hu->serdev->dev);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 558,
                    "highlight": 590
                }
            ],
            "ins_idx": 13,
            "addr": "0xffffffff81860055"
        },
        "465": {
            "name": "+0x0",
            "parent_idx": 464,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n2993",
                    "code": [
                        "#ifdef CONFIG_TRACING",
                        "void *kmem_cache_alloc_trace(struct kmem_cache *s, gfp_t gfpflags, size_t size)",
                        "{",
                        "\tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_, size);",
                        "\ttrace_kmalloc(_RET_IP_, ret, size, s->size, gfpflags);",
                        "\tret = kasan_kmalloc(s, ret, size, gfpflags);",
                        "\treturn ret;",
                        "}",
                        "EXPORT_SYMBOL(kmem_cache_alloc_trace);",
                        "#endif",
                        "",
                        "#ifdef CONFIG_NUMA",
                        "void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)",
                        "{",
                        "\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_, s->object_size);",
                        "",
                        "\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,",
                        "\t\t\t\t    s->object_size, s->size, gfpflags, node);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2981,
                    "highlight": 2993
                }
            ],
            "ins_idx": 21,
            "addr": "0xffffffff811e6900"
        },
        "464": {
            "name": "kmem_cache_alloc_trace",
            "parent_idx": 461,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n591",
                    "code": [
                        "/**",
                        " * kmalloc - allocate memory",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate.",
                        " *",
                        " * kmalloc is the normal method of allocating memory",
                        " * for objects smaller than page size in the kernel.",
                        " *",
                        " * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN",
                        " * bytes. For @size of power of two bytes, the alignment is also guaranteed",
                        " * to be at least to the size.",
                        " *",
                        " * The @flags argument may be one of the GFP flags defined at",
                        " * include/linux/gfp.h and described at",
                        " * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`",
                        " *",
                        " * The recommended usage of the @flags is described at",
                        " * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`",
                        " *",
                        " * Below is a brief outline of the most useful GFP flags",
                        " *",
                        " * %GFP_KERNEL",
                        " *\tAllocate normal kernel ram. May sleep.",
                        " *",
                        " * %GFP_NOWAIT",
                        " *\tAllocation will not sleep.",
                        " *",
                        " * %GFP_ATOMIC",
                        " *\tAllocation will not sleep.  May use emergency pools.",
                        " *",
                        " * %GFP_HIGHUSER",
                        " *\tAllocate memory from high memory on behalf of user.",
                        " *",
                        " * Also it is possible to set different flags by OR'ing",
                        " * in one or more of the following additional @flags:",
                        " *",
                        " * %__GFP_HIGH",
                        " *\tThis allocation has high priority and may use emergency pools.",
                        " *",
                        " * %__GFP_NOFAIL",
                        " *\tIndicate that this allocation is in no way allowed to fail",
                        " *\t(think twice before using).",
                        " *",
                        " * %__GFP_NORETRY",
                        " *\tIf memory is not immediately available,",
                        " *\tthen give up at once.",
                        " *",
                        " * %__GFP_NOWARN",
                        " *\tIf allocation fails, don't issue any warnings.",
                        " *",
                        " * %__GFP_RETRY_MAYFAIL",
                        " *\tTry really hard to succeed the allocation but fail",
                        " *\teventually.",
                        " */",
                        "static __always_inline void *kmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\tif (__builtin_constant_p(size)) {",
                        "#ifndef CONFIG_SLOB",
                        "\t\tunsigned int index;",
                        "#endif",
                        "\t\tif (size > KMALLOC_MAX_CACHE_SIZE)",
                        "\t\t\treturn kmalloc_large(size, flags);",
                        "#ifndef CONFIG_SLOB",
                        "\t\tindex = kmalloc_index(size);",
                        "",
                        "\t\tif (!index)",
                        "\t\t\treturn ZERO_SIZE_PTR;",
                        "",
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 523,
                    "highlight": 591
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n721",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 714,
                    "highlight": 721
                },
                {
                    "file": "drivers/bluetooth/hci_ldisc.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_ldisc.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n488",
                    "code": [
                        "/* ------ LDISC part ------ */",
                        "/* hci_uart_tty_open",
                        " *",
                        " *     Called when line discipline changed to HCI_UART.",
                        " *",
                        " * Arguments:",
                        " *     tty    pointer to tty info structure",
                        " * Return Value:",
                        " *     0 if success, otherwise error code",
                        " */",
                        "static int hci_uart_tty_open(struct tty_struct *tty)",
                        "{",
                        "\tstruct hci_uart *hu;",
                        "",
                        "\tBT_DBG(\"tty %p\", tty);",
                        "",
                        "\t/* Error if the tty has no write op instead of leaving an exploitable",
                        "\t * hole",
                        "\t */",
                        "\tif (tty->ops->write == NULL)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\thu = kzalloc(sizeof(struct hci_uart), GFP_KERNEL);",
                        "\tif (!hu) {",
                        "\t\tBT_ERR(\"Can't allocate control structure\");",
                        "\t\treturn -ENFILE;",
                        "\t}",
                        "",
                        "\ttty->disc_data = hu;",
                        "\thu->tty = tty;",
                        "\ttty->receive_room = 65536;",
                        "",
                        "\t/* disable alignment support by default */",
                        "\thu->alignment = 1;",
                        "\thu->padding = 0;",
                        "",
                        "\tINIT_WORK(&hu->init_ready, hci_uart_init_work);",
                        "\tINIT_WORK(&hu->write_work, hci_uart_write_work);",
                        "",
                        "\tpercpu_init_rwsem(&hu->proto_lock);",
                        "",
                        "\t/* Flush any pending characters in the driver */",
                        "\ttty_driver_flush_buffer(tty);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 466,
                    "highlight": 488
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8185da84"
        },
        "461": {
            "name": "hci_uart_tty_open(indirect)",
            "parent_idx": 458,
            "source_line": [
                {
                    "file": "drivers/tty/tty_ldisc.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_ldisc.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n449",
                    "code": [
                        "static int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)",
                        "{",
                        "\tWARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &tty->flags));",
                        "\tif (ld->ops->open) {",
                        "\t\tint ret;",
                        "\t\t/* BTM here locks versus a hangup event */",
                        "\t\tret = ld->ops->open(tty);",
                        "\t\tif (ret)",
                        "\t\t\tclear_bit(TTY_LDISC_OPEN, &tty->flags);",
                        "",
                        "\t\ttty_ldisc_debug(tty, \"%p: opened\\n\", ld);",
                        "\t\treturn ret;",
                        "\t}",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 443,
                    "highlight": 449
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff814e2c11"
        },
        "458": {
            "name": "tty_ldisc_open",
            "parent_idx": 413,
            "source_line": [
                {
                    "file": "drivers/tty/tty_ldisc.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_ldisc.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n579",
                    "code": [
                        "int tty_set_ldisc(struct tty_struct *tty, int disc)",
                        "{",
                        "\tint retval;",
                        "\tstruct tty_ldisc *old_ldisc, *new_ldisc;",
                        "",
                        "\tnew_ldisc = tty_ldisc_get(tty, disc);",
                        "\tif (IS_ERR(new_ldisc))",
                        "\t\treturn PTR_ERR(new_ldisc);",
                        "",
                        "\ttty_lock(tty);",
                        "\tretval = tty_ldisc_lock(tty, 5 * HZ);",
                        "\tif (retval)",
                        "\t\tgoto err;",
                        "",
                        "\tif (!tty->ldisc) {",
                        "\t\tretval = -EIO;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\t/* Check the no-op case */",
                        "\tif (tty->ldisc->ops->num == disc)",
                        "\t\tgoto out;",
                        "",
                        "\tif (test_bit(TTY_HUPPED, &tty->flags)) {",
                        "\t\t/* We were raced by hangup */",
                        "\t\tretval = -EIO;",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\told_ldisc = tty->ldisc;",
                        "",
                        "\t/* Shutdown the old discipline. */",
                        "\ttty_ldisc_close(tty, old_ldisc);",
                        "",
                        "\t/* Now set up the new line discipline. */",
                        "\ttty->ldisc = new_ldisc;",
                        "\ttty_set_termios_ldisc(tty, disc);",
                        "",
                        "\tretval = tty_ldisc_open(tty, new_ldisc);",
                        "\tif (retval < 0) {",
                        "\t\t/* Back to the old one or N_TTY if we can't */",
                        "\t\ttty_ldisc_put(new_ldisc);",
                        "\t\ttty_ldisc_restore(tty, old_ldisc);",
                        "\t}",
                        "",
                        "\tif (tty->ldisc->ops->num != old_ldisc->ops->num && tty->ops->set_ldisc) {",
                        "\t\tdown_read(&tty->termios_rwsem);",
                        "\t\ttty->ops->set_ldisc(tty);",
                        "\t\tup_read(&tty->termios_rwsem);",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * At this point we hold a reference to the new ldisc and a",
                        "\t * reference to the old ldisc, or we hold two references to",
                        "\t * the old ldisc (if it was restored as part of error cleanup",
                        "\t * above). In either case, releasing a single reference from",
                        "\t * the old ldisc is correct.",
                        "\t */",
                        "\tnew_ldisc = old_ldisc;",
                        "out:",
                        "\ttty_ldisc_unlock(tty);",
                        "",
                        "\t/*",
                        "\t * Restart the work queue in case no characters kick it off. Safe if",
                        "\t * already running",
                        "\t */",
                        "\ttty_buffer_restart_work(tty->port);",
                        "err:",
                        "\ttty_ldisc_put(new_ldisc);\t/* drop the extra reference */",
                        "\ttty_unlock(tty);",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 541,
                    "highlight": 579
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff814e327b"
        },
        "413": {
            "name": "tty_set_ldisc",
            "parent_idx": 404,
            "source_line": [
                {
                    "file": "drivers/tty/tty_io.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_io.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n2455",
                    "code": [
                        "static int tiocsetd(struct tty_struct *tty, int __user *p)",
                        "{",
                        "\tint disc;",
                        "\tint ret;",
                        "",
                        "\tif (get_user(disc, p))",
                        "\t\treturn -EFAULT;",
                        "",
                        "\tret = tty_set_ldisc(tty, disc);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2447,
                    "highlight": 2455
                },
                {
                    "file": "drivers/tty/tty_io.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/tty_io.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n2741",
                    "code": [
                        "/*",
                        " * Split this up, as gcc can choke on it otherwise..",
                        " */",
                        "long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tstruct tty_struct *tty = file_tty(file);",
                        "\tstruct tty_struct *real_tty;",
                        "\tvoid __user *p = (void __user *)arg;",
                        "\tint retval;",
                        "\tstruct tty_ldisc *ld;",
                        "",
                        "\tif (tty_paranoia_check(tty, file_inode(file), \"tty_ioctl\"))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\treal_tty = tty_pair_get_tty(tty);",
                        "",
                        "\t/*",
                        "\t * Factor out some common prep work",
                        "\t */",
                        "\tswitch (cmd) {",
                        "\tcase TIOCSETD:",
                        "\tcase TIOCSBRK:",
                        "\tcase TIOCCBRK:",
                        "\tcase TCSBRK:",
                        "\tcase TCSBRKP:",
                        "\t\tretval = tty_check_change(tty);",
                        "\t\tif (retval)",
                        "\t\t\treturn retval;",
                        "\t\tif (cmd != TIOCCBRK) {",
                        "\t\t\ttty_wait_until_sent(tty, 0);",
                        "\t\t\tif (signal_pending(current))",
                        "\t\t\t\treturn -EINTR;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t *\tNow do the stuff.",
                        "\t */",
                        "\tswitch (cmd) {",
                        "\tcase TIOCSTI:",
                        "\t\treturn tiocsti(tty, p);",
                        "\tcase TIOCGWINSZ:",
                        "\t\treturn tiocgwinsz(real_tty, p);",
                        "\tcase TIOCSWINSZ:",
                        "\t\treturn tiocswinsz(real_tty, p);",
                        "\tcase TIOCCONS:",
                        "\t\treturn real_tty != tty ? -EINVAL : tioccons(file);",
                        "\tcase TIOCEXCL:",
                        "\t\tset_bit(TTY_EXCLUSIVE, &tty->flags);",
                        "\t\treturn 0;",
                        "\tcase TIOCNXCL:",
                        "\t\tclear_bit(TTY_EXCLUSIVE, &tty->flags);",
                        "\t\treturn 0;",
                        "\tcase TIOCGEXCL:",
                        "\t{",
                        "\t\tint excl = test_bit(TTY_EXCLUSIVE, &tty->flags);",
                        "",
                        "\t\treturn put_user(excl, (int __user *)p);",
                        "\t}",
                        "\tcase TIOCGETD:",
                        "\t\treturn tiocgetd(tty, p);",
                        "\tcase TIOCSETD:",
                        "\t\treturn tiocsetd(tty, p);",
                        "\tcase TIOCVHANGUP:",
                        "\t\tif (!capable(CAP_SYS_ADMIN))",
                        "\t\t\treturn -EPERM;",
                        "\t\ttty_vhangup(tty);",
                        "\t\treturn 0;",
                        "\tcase TIOCGDEV:",
                        "\t{",
                        "\t\tunsigned int ret = new_encode_dev(tty_devnum(real_tty));",
                        "",
                        "\t\treturn put_user(ret, (unsigned int __user *)p);",
                        "\t}",
                        "\t/*",
                        "\t * Break handling",
                        "\t */",
                        "\tcase TIOCSBRK:\t/* Turn break on, unconditionally */",
                        "\t\tif (tty->ops->break_ctl)",
                        "\t\t\treturn tty->ops->break_ctl(tty, -1);",
                        "\t\treturn 0;",
                        "\tcase TIOCCBRK:\t/* Turn break off, unconditionally */",
                        "\t\tif (tty->ops->break_ctl)",
                        "\t\t\treturn tty->ops->break_ctl(tty, 0);",
                        "\t\treturn 0;",
                        "\tcase TCSBRK:   /* SVID version: non-zero arg --> no break */",
                        "\t\t/* non-zero arg means wait for all output data",
                        "\t\t * to be sent (performed above) but don't send break.",
                        "\t\t * This is used by the tcdrain() termios function.",
                        "\t\t */",
                        "\t\tif (!arg)",
                        "\t\t\treturn send_break(tty, 250);",
                        "\t\treturn 0;",
                        "\tcase TCSBRKP:\t/* support for POSIX tcsendbreak() */",
                        "\t\treturn send_break(tty, arg ? arg*100 : 250);",
                        "",
                        "\tcase TIOCMGET:",
                        "\t\treturn tty_tiocmget(tty, p);",
                        "\tcase TIOCMSET:",
                        "\tcase TIOCMBIC:",
                        "\tcase TIOCMBIS:",
                        "\t\treturn tty_tiocmset(tty, cmd, p);",
                        "\tcase TIOCGICOUNT:",
                        "\t\treturn tty_tiocgicount(tty, p);",
                        "\tcase TCFLSH:",
                        "\t\tswitch (arg) {",
                        "\t\tcase TCIFLUSH:",
                        "\t\tcase TCIOFLUSH:",
                        "\t\t/* flush tty buffer and allow ldisc to process ioctl */",
                        "\t\t\ttty_buffer_flush(tty, NULL);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tbreak;",
                        "\tcase TIOCSSERIAL:",
                        "\t\treturn tty_tiocsserial(tty, p);",
                        "\tcase TIOCGSERIAL:",
                        "\t\treturn tty_tiocgserial(tty, p);",
                        "\tcase TIOCGPTPEER:",
                        "\t\t/* Special because the struct file is needed */",
                        "\t\treturn ptm_open_peer(file, tty, (int)arg);",
                        "\tdefault:",
                        "\t\tretval = tty_jobctrl_ioctl(tty, real_tty, file, cmd, arg);",
                        "\t\tif (retval != -ENOIOCTLCMD)",
                        "\t\t\treturn retval;",
                        "\t}",
                        "\tif (tty->ops->ioctl) {",
                        "\t\tretval = tty->ops->ioctl(tty, cmd, arg);",
                        "\t\tif (retval != -ENOIOCTLCMD)",
                        "\t\t\treturn retval;",
                        "\t}",
                        "\tld = tty_ldisc_ref_wait(tty);",
                        "\tif (!ld)",
                        "\t\treturn hung_up_tty_ioctl(file, cmd, arg);",
                        "\tretval = -EINVAL;",
                        "\tif (ld->ops->ioctl) {",
                        "\t\tretval = ld->ops->ioctl(tty, file, cmd, arg);",
                        "\t\tif (retval == -ENOIOCTLCMD)",
                        "\t\t\tretval = -ENOTTY;",
                        "\t}",
                        "\ttty_ldisc_deref(ld);",
                        "\treturn retval;",
                        "}"
                    ],
                    "start": 2678,
                    "highlight": 2741
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff814dc435"
        },
        "404": {
            "name": "tty_ioctl(indirect)",
            "parent_idx": 373,
            "source_line": [
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n51",
                    "code": [
                        "/**",
                        " * vfs_ioctl - call filesystem specific ioctl methods",
                        " * @filp:\topen file to invoke ioctl method on",
                        " * @cmd:\tioctl command to execute",
                        " * @arg:\tcommand-specific argument for ioctl",
                        " *",
                        " * Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise",
                        " * returns -ENOTTY.",
                        " *",
                        " * Returns 0 on success, -errno on error.",
                        " */",
                        "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
                        "{",
                        "\tint error = -ENOTTY;",
                        "",
                        "\tif (!filp->f_op->unlocked_ioctl)",
                        "\t\tgoto out;",
                        "",
                        "\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = -ENOTTY;",
                        " out:",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 33,
                    "highlight": 51
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n874",
                    "code": [
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 860,
                    "highlight": 874
                },
                {
                    "file": "fs/ioctl.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ioctl.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n860",
                    "code": [
                        "/*",
                        " * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.",
                        " * It's just a simple helper for sys_ioctl and compat_sys_ioctl.",
                        " *",
                        " * When you add any new common ioctls to the switches above and below,",
                        " * please ensure they have compatible arguments in compat mode.",
                        " */",
                        "static int do_vfs_ioctl(struct file *filp, unsigned int fd,",
                        "\t\t\tunsigned int cmd, unsigned long arg)",
                        "{",
                        "\tvoid __user *argp = (void __user *)arg;",
                        "\tstruct inode *inode = file_inode(filp);",
                        "",
                        "\tswitch (cmd) {",
                        "\tcase FIOCLEX:",
                        "\t\tset_close_on_exec(fd, 1);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONCLEX:",
                        "\t\tset_close_on_exec(fd, 0);",
                        "\t\treturn 0;",
                        "",
                        "\tcase FIONBIO:",
                        "\t\treturn ioctl_fionbio(filp, argp);",
                        "",
                        "\tcase FIOASYNC:",
                        "\t\treturn ioctl_fioasync(fd, filp, argp);",
                        "",
                        "\tcase FIOQSIZE:",
                        "\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||",
                        "\t\t    S_ISLNK(inode->i_mode)) {",
                        "\t\t\tloff_t res = inode_get_bytes(inode);",
                        "\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?",
                        "\t\t\t\t\t    -EFAULT : 0;",
                        "\t\t}",
                        "",
                        "\t\treturn -ENOTTY;",
                        "",
                        "\tcase FIFREEZE:",
                        "\t\treturn ioctl_fsfreeze(filp);",
                        "",
                        "\tcase FITHAW:",
                        "\t\treturn ioctl_fsthaw(filp);",
                        "",
                        "\tcase FS_IOC_FIEMAP:",
                        "\t\treturn ioctl_fiemap(filp, argp);",
                        "",
                        "\tcase FIGETBSZ:",
                        "\t\t/* anon_bdev filesystems may not have a block size */",
                        "\t\tif (!inode->i_sb->s_blocksize)",
                        "\t\t\treturn -EINVAL;",
                        "",
                        "\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
                        "",
                        "\tcase FICLONE:",
                        "\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);",
                        "",
                        "\tcase FICLONERANGE:",
                        "\t\treturn ioctl_file_clone_range(filp, argp);",
                        "",
                        "\tcase FIDEDUPERANGE:",
                        "\t\treturn ioctl_file_dedupe_range(filp, argp);",
                        "",
                        "\tcase FIONREAD:",
                        "\t\tif (!S_ISREG(inode->i_mode))",
                        "\t\t\treturn vfs_ioctl(filp, cmd, arg);",
                        "",
                        "\t\treturn put_user(i_size_read(inode) - filp->f_pos,",
                        "\t\t\t\t(int __user *)argp);",
                        "",
                        "\tcase FS_IOC_GETFLAGS:",
                        "\t\treturn ioctl_getflags(filp, argp);",
                        "",
                        "\tcase FS_IOC_SETFLAGS:",
                        "\t\treturn ioctl_setflags(filp, argp);",
                        "",
                        "\tcase FS_IOC_FSGETXATTR:",
                        "\t\treturn ioctl_fsgetxattr(filp, argp);",
                        "",
                        "\tcase FS_IOC_FSSETXATTR:",
                        "\t\treturn ioctl_fssetxattr(filp, argp);",
                        "",
                        "\tdefault:",
                        "\t\tif (S_ISREG(inode->i_mode))",
                        "\t\t\treturn file_ioctl(filp, cmd, argp);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\treturn -ENOIOCTLCMD;",
                        "}",
                        "",
                        "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)",
                        "{",
                        "\tstruct fd f = fdget(fd);",
                        "\tint error;",
                        "",
                        "\tif (!f.file)",
                        "\t\treturn -EBADF;",
                        "",
                        "\terror = security_file_ioctl(f.file, cmd, arg);",
                        "\tif (error)",
                        "\t\tgoto out;",
                        "",
                        "\terror = do_vfs_ioctl(f.file, fd, cmd, arg);",
                        "\tif (error == -ENOIOCTLCMD)",
                        "\t\terror = vfs_ioctl(f.file, cmd, arg);",
                        "",
                        "out:",
                        "\tfdput(f);",
                        "\treturn error;",
                        "}"
                    ],
                    "start": 769,
                    "highlight": 860
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81208f49"
        },
        "373": {
            "name": "__x64_sys_ioctl(indirect)",
            "parent_idx": 370,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n50",
                    "code": [
                        "static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)",
                        "{",
                        "\t/*",
                        "\t * Convert negative numbers to very high and thus out of range",
                        "\t * numbers for comparisons.",
                        "\t */",
                        "\tunsigned int unr = nr;",
                        "",
                        "\tif (likely(unr < NR_syscalls)) {",
                        "\t\tunr = array_index_nospec(unr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[unr](regs);",
                        "\t\treturn true;",
                        "\t}",
                        "\treturn false;",
                        "}"
                    ],
                    "start": 40,
                    "highlight": 50
                },
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n80",
                    "code": [
                        "__visible noinstr void do_syscall_64(struct pt_regs *regs, int nr)",
                        "{",
                        "\tadd_random_kstack_offset();",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "",
                        "\tif (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {",
                        "\t\t/* Invalid system call, but still a system call. */",
                        "\t\tregs->ax = __x64_sys_ni_syscall(regs);",
                        "\t}",
                        "",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 73,
                    "highlight": 80
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c24b3e"
        },
        "370": {
            "name": "do_syscall_64",
            "parent_idx": 363,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n113",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rsp, %rdi",
                        "\t/* Sign extend the lower 32bit as syscall numbers are treated as int */",
                        "\tmovslq\t%eax, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t * In the Xen PV case we must use iret anyway.",
                        "\t */",
                        "",
                        "\tALTERNATIVE \"\", \"jmp\tswapgs_restore_regs_and_return_to_usermode\", \\",
                        "\t\tX86_FEATURE_XENPV",
                        "",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tswapgs",
                        "\tsysretq",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 87,
                    "highlight": 113
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e00077"
        },
        "363": {
            "name": "6_syscall_5",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "562": {
            "name": "+0xd",
            "parent_idx": 561,
            "source_line": [
                {
                    "file": "drivers/bluetooth/hci_h5.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_h5.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n559",
                    "code": [
                        "static int h5_recv(struct hci_uart *hu, const void *data, int count)",
                        "{",
                        "\tstruct h5 *h5 = hu->priv;",
                        "\tconst unsigned char *ptr = data;",
                        "",
                        "\tBT_DBG(\"%s pending %zu count %d\", hu->hdev->name, h5->rx_pending,",
                        "\t       count);",
                        "",
                        "\twhile (count > 0) {",
                        "\t\tint processed;",
                        "",
                        "\t\tif (h5->rx_pending > 0) {",
                        "\t\t\tif (*ptr == SLIP_DELIMITER) {",
                        "\t\t\t\tbt_dev_err(hu->hdev, \"Too short H5 packet\");",
                        "\t\t\t\th5_reset_rx(h5);",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "",
                        "\t\t\th5_unslip_one_byte(h5, *ptr);",
                        "",
                        "\t\t\tptr++; count--;",
                        "\t\t\tcontinue;",
                        "\t\t}",
                        "",
                        "\t\tprocessed = h5->rx_func(hu, *ptr);",
                        "\t\tif (processed < 0)",
                        "\t\t\treturn processed;",
                        "",
                        "\t\tptr += processed;",
                        "\t\tcount -= processed;",
                        "\t}",
                        "",
                        "\tpm_runtime_get(&hu->serdev->dev);",
                        "\tpm_runtime_mark_last_busy(&hu->serdev->dev);",
                        "\tpm_runtime_put_autosuspend(&hu->serdev->dev);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 558,
                    "highlight": 559
                }
            ],
            "ins_idx": 20,
            "addr": "0xffffffff8185ff6d"
        },
        "560": {
            "name": "+0x4f",
            "parent_idx": 552,
            "source_line": [
                {
                    "file": "drivers/bluetooth/hci_ldisc.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_ldisc.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n613",
                    "code": [
                        "/* hci_uart_tty_receive()",
                        " *",
                        " *     Called by tty low level driver when receive data is",
                        " *     available.",
                        " *",
                        " * Arguments:  tty          pointer to tty isntance data",
                        " *             data         pointer to received data",
                        " *             flags        pointer to flags for data",
                        " *             count        count of received data in bytes",
                        " *",
                        " * Return Value:    None",
                        " */",
                        "static void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data,",
                        "\t\t\t\t const char *flags, int count)",
                        "{",
                        "\tstruct hci_uart *hu = tty->disc_data;",
                        "",
                        "\tif (!hu || tty != hu->tty)",
                        "\t\treturn;",
                        "",
                        "\tpercpu_down_read(&hu->proto_lock);",
                        "",
                        "\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags)) {",
                        "\t\tpercpu_up_read(&hu->proto_lock);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* It does not need a lock here as it is already protected by a mutex in",
                        "\t * tty caller",
                        "\t */",
                        "\thu->proto->recv(hu, data, count);",
                        "\tpercpu_up_read(&hu->proto_lock);",
                        "",
                        "\tif (hu->hdev)",
                        "\t\thu->hdev->stat.byte_rx += count;",
                        "",
                        "\ttty_unthrottle(tty);",
                        "}"
                    ],
                    "start": 583,
                    "highlight": 613
                }
            ],
            "ins_idx": 27,
            "addr": "0xffffffff8185e30f"
        },
        "553": {
            "name": "+0x6",
            "parent_idx": 552,
            "source_line": [
                {
                    "file": "drivers/bluetooth/hci_ldisc.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_ldisc.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n598",
                    "code": [
                        "/* hci_uart_tty_receive()",
                        " *",
                        " *     Called by tty low level driver when receive data is",
                        " *     available.",
                        " *",
                        " * Arguments:  tty          pointer to tty isntance data",
                        " *             data         pointer to received data",
                        " *             flags        pointer to flags for data",
                        " *             count        count of received data in bytes",
                        " *",
                        " * Return Value:    None",
                        " */",
                        "static void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data,",
                        "\t\t\t\t const char *flags, int count)",
                        "{",
                        "\tstruct hci_uart *hu = tty->disc_data;",
                        "",
                        "\tif (!hu || tty != hu->tty)",
                        "\t\treturn;",
                        "",
                        "\tpercpu_down_read(&hu->proto_lock);",
                        "",
                        "\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags)) {",
                        "\t\tpercpu_up_read(&hu->proto_lock);",
                        "\t\treturn;",
                        "\t}",
                        "",
                        "\t/* It does not need a lock here as it is already protected by a mutex in",
                        "\t * tty caller",
                        "\t */",
                        "\thu->proto->recv(hu, data, count);",
                        "\tpercpu_up_read(&hu->proto_lock);",
                        "",
                        "\tif (hu->hdev)",
                        "\t\thu->hdev->stat.byte_rx += count;",
                        "",
                        "\ttty_unthrottle(tty);",
                        "}"
                    ],
                    "start": 583,
                    "highlight": 598
                }
            ],
            "ins_idx": 53,
            "addr": "0xffffffff8185e2c6"
        },
        "466": {
            "name": "+0x6a",
            "parent_idx": 461,
            "source_line": [
                {
                    "file": "drivers/bluetooth/hci_ldisc.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/bluetooth/hci_ldisc.c?id=835d31d319d9c8c4eb6cac074643360ba0ecab10#n494",
                    "code": [
                        "/* ------ LDISC part ------ */",
                        "/* hci_uart_tty_open",
                        " *",
                        " *     Called when line discipline changed to HCI_UART.",
                        " *",
                        " * Arguments:",
                        " *     tty    pointer to tty info structure",
                        " * Return Value:",
                        " *     0 if success, otherwise error code",
                        " */",
                        "static int hci_uart_tty_open(struct tty_struct *tty)",
                        "{",
                        "\tstruct hci_uart *hu;",
                        "",
                        "\tBT_DBG(\"tty %p\", tty);",
                        "",
                        "\t/* Error if the tty has no write op instead of leaving an exploitable",
                        "\t * hole",
                        "\t */",
                        "\tif (tty->ops->write == NULL)",
                        "\t\treturn -EOPNOTSUPP;",
                        "",
                        "\thu = kzalloc(sizeof(struct hci_uart), GFP_KERNEL);",
                        "\tif (!hu) {",
                        "\t\tBT_ERR(\"Can't allocate control structure\");",
                        "\t\treturn -ENFILE;",
                        "\t}",
                        "",
                        "\ttty->disc_data = hu;",
                        "\thu->tty = tty;",
                        "\ttty->receive_room = 65536;",
                        "",
                        "\t/* disable alignment support by default */",
                        "\thu->alignment = 1;",
                        "\thu->padding = 0;",
                        "",
                        "\tINIT_WORK(&hu->init_ready, hci_uart_init_work);",
                        "\tINIT_WORK(&hu->write_work, hci_uart_write_work);",
                        "",
                        "\tpercpu_init_rwsem(&hu->proto_lock);",
                        "",
                        "\t/* Flush any pending characters in the driver */",
                        "\ttty_driver_flush_buffer(tty);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 466,
                    "highlight": 494
                }
            ],
            "ins_idx": 65,
            "addr": "0xffffffff8185daca"
        }
    },
    "ins": {
        "1": {
            "name": "inc dword ptr d",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x1b0\nInvalid Base Address 0x1b0",
            "call_idx": 566,
            "inputs": [
                921,
                922
            ],
            "outputs": [
                923
            ]
        },
        "7": {
            "name": "mov rbp, rdi",
            "desc": "",
            "call_idx": 565,
            "inputs": [
                919
            ],
            "outputs": [
                920
            ]
        },
        "13": {
            "name": "mov rdi, qword ptr [rbp + 8]",
            "desc": "Heap Use Before Initialization",
            "call_idx": 563,
            "inputs": [
                916,
                917
            ],
            "outputs": [
                918
            ]
        },
        "21": {
            "name": "push r15",
            "desc": "Source of base address MEMALLOC 0x0",
            "call_idx": 465,
            "inputs": [],
            "outputs": [
                754
            ]
        },
        "20": {
            "name": "mov rbp, rdi",
            "desc": "",
            "call_idx": 562,
            "inputs": [
                914
            ],
            "outputs": [
                915
            ]
        },
        "27": {
            "name": "mov rdi, rbx",
            "desc": "",
            "call_idx": 560,
            "inputs": [
                912
            ],
            "outputs": [
                913
            ]
        },
        "53": {
            "name": "mov rbx, qword ptr [rdi + 0x250]",
            "desc": "",
            "call_idx": 553,
            "inputs": [
                901,
                902
            ],
            "outputs": [
                903
            ]
        },
        "65": {
            "name": "mov qword ptr [rbp + 0x250], rax",
            "desc": "",
            "call_idx": 466,
            "inputs": [
                755,
                756
            ],
            "outputs": [
                757
            ]
        }
    },
    "data": {
        "921": {
            "name": "RBP",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "922": {
            "name": "[0x1b0]",
            "ins_idx": 1,
            "value": "0x0",
            "sources": []
        },
        "923": {
            "name": "[0x1b0]",
            "ins_idx": 1,
            "value": "0x1",
            "sources": []
        },
        "919": {
            "name": "RDI",
            "ins_idx": 7,
            "value": "0x0",
            "sources": []
        },
        "920": {
            "name": "RBP",
            "ins_idx": 7,
            "value": "0x0",
            "sources": [
                921
            ]
        },
        "916": {
            "name": "RBP",
            "ins_idx": 13,
            "value": "0xffff8881010e2100",
            "sources": []
        },
        "917": {
            "name": "[0xffff8881010e2108]",
            "ins_idx": 13,
            "value": "0x0",
            "sources": []
        },
        "918": {
            "name": "RDI",
            "ins_idx": 13,
            "value": "0x0",
            "sources": [
                919
            ]
        },
        "754": {
            "name": "RAX",
            "ins_idx": 21,
            "value": "0xffff8881010e2100",
            "sources": [
                756
            ]
        },
        "914": {
            "name": "RDI",
            "ins_idx": 20,
            "value": "0xffff8881010e2100",
            "sources": []
        },
        "915": {
            "name": "RBP",
            "ins_idx": 20,
            "value": "0xffff8881010e2100",
            "sources": [
                916
            ]
        },
        "912": {
            "name": "RBX",
            "ins_idx": 27,
            "value": "0xffff8881010e2100",
            "sources": []
        },
        "913": {
            "name": "RDI",
            "ins_idx": 27,
            "value": "0xffff8881010e2100",
            "sources": [
                914
            ]
        },
        "901": {
            "name": "RDI",
            "ins_idx": 53,
            "value": "0xffff888100189000",
            "sources": []
        },
        "902": {
            "name": "[0xffff888100189250]",
            "ins_idx": 53,
            "value": "0xffff8881010e2100",
            "sources": []
        },
        "903": {
            "name": "RBX",
            "ins_idx": 53,
            "value": "0xffff8881010e2100",
            "sources": [
                912
            ]
        },
        "755": {
            "name": "RBP",
            "ins_idx": 65,
            "value": "0xffff888100189000",
            "sources": []
        },
        "756": {
            "name": "RAX",
            "ins_idx": 65,
            "value": "0xffff8881010e2100",
            "sources": []
        },
        "757": {
            "name": "[0xffff888100189250]",
            "ins_idx": 65,
            "value": "0xffff8881010e2100",
            "sources": [
                902
            ]
        }
    },
    "chain": {
        "1": [
            7
        ],
        "7": [
            13
        ],
        "13": [
            21,
            20
        ],
        "20": [
            27
        ],
        "27": [
            53
        ],
        "53": [
            65
        ],
        "65": [
            21
        ]
    }
}