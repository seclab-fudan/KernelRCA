{
    "report": "https://syzkaller.appspot.com/bug?id=57c3bc1b0045898f8c53719fd5f994ca7f9dc1db",
    "title": "general protection fault in __io_file_supports_nowait",
    "call": {
        "1253": {
            "name": "+0x0",
            "parent_idx": 1252,
            "source_line": [
                {
                    "file": "./include/linux/fs.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/fs.h?id=b91db6a0b52e#n1344",
                    "code": [
                        "static inline struct inode *file_inode(const struct file *f)",
                        "{",
                        "\treturn f->f_inode;",
                        "}"
                    ],
                    "start": 1342,
                    "highlight": 1344
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n2785",
                    "code": [
                        "/*",
                        " * If we tracked the file through the SCM inflight mechanism, we could support",
                        " * any file. For now, just ensure that anything potentially problematic is done",
                        " * inline.",
                        " */",
                        "static bool __io_file_supports_nowait(struct file *file, int rw)",
                        "{",
                        "\tumode_t mode = file_inode(file)->i_mode;",
                        "",
                        "\tif (S_ISBLK(mode)) {",
                        "\t\tif (IS_ENABLED(CONFIG_BLOCK) &&",
                        "\t\t    io_bdev_nowait(I_BDEV(file->f_mapping->host)))",
                        "\t\t\treturn true;",
                        "\t\treturn false;",
                        "\t}",
                        "\tif (S_ISSOCK(mode))",
                        "\t\treturn true;",
                        "\tif (S_ISREG(mode)) {",
                        "\t\tif (IS_ENABLED(CONFIG_BLOCK) &&",
                        "\t\t    io_bdev_nowait(file->f_inode->i_sb->s_bdev) &&",
                        "\t\t    file->f_op != &io_uring_fops)",
                        "\t\t\treturn true;",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\t/* any ->read/write should understand O_NONBLOCK */",
                        "\tif (file->f_flags & O_NONBLOCK)",
                        "\t\treturn true;",
                        "",
                        "\tif (!(file->f_mode & FMODE_NOWAIT))",
                        "\t\treturn false;",
                        "",
                        "\tif (rw == READ)",
                        "\t\treturn file->f_op->read_iter != NULL;",
                        "",
                        "\treturn file->f_op->write_iter != NULL;",
                        "}"
                    ],
                    "start": 2778,
                    "highlight": 2785
                }
            ],
            "ins_idx": 8,
            "addr": "0xffffffff8124b390"
        },
        "1252": {
            "name": "__io_file_supports_nowait",
            "parent_idx": 1243,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n2823",
                    "code": [
                        "\treturn __io_file_supports_nowait(req->file, rw);",
                        "}"
                    ],
                    "start": 2823,
                    "highlight": 2823
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n2816",
                    "code": [
                        "static bool io_file_supports_nowait(struct io_kiocb *req, int rw)",
                        "{",
                        "\tif (rw == READ && (req->flags & REQ_F_NOWAIT_READ))",
                        "\t\treturn true;",
                        "\telse if (rw == WRITE && (req->flags & REQ_F_NOWAIT_WRITE))",
                        "\t\treturn true;",
                        "",
                        "\treturn __io_file_supports_nowait(req->file, rw);",
                        "}"
                    ],
                    "start": 2816,
                    "highlight": 2816
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n3440",
                    "code": [
                        "static int io_read(struct io_kiocb *req, unsigned int issue_flags)",
                        "{",
                        "\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;",
                        "\tstruct kiocb *kiocb = &req->rw.kiocb;",
                        "\tstruct iov_iter __iter, *iter = &__iter;",
                        "\tstruct io_async_rw *rw = req->async_data;",
                        "\tssize_t io_size, ret, ret2;",
                        "\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;",
                        "",
                        "\tif (rw) {",
                        "\t\titer = &rw->iter;",
                        "\t\tiovec = NULL;",
                        "\t} else {",
                        "\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);",
                        "\t\tif (ret < 0)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "\tio_size = iov_iter_count(iter);",
                        "\treq->result = io_size;",
                        "",
                        "\t/* Ensure we clear previously set non-block flag */",
                        "\tif (!force_nonblock)",
                        "\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;",
                        "\telse",
                        "\t\tkiocb->ki_flags |= IOCB_NOWAIT;",
                        "",
                        "\t/* If the file doesn't support async, just async punt */",
                        "\tif (force_nonblock && !io_file_supports_nowait(req, READ)) {",
                        "\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);",
                        "\t\treturn ret ?: -EAGAIN;",
                        "\t}",
                        "",
                        "\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);",
                        "\tif (unlikely(ret)) {",
                        "\t\tkfree(iovec);",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\tret = io_iter_do_read(req, iter);",
                        "",
                        "\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {",
                        "\t\treq->flags &= ~REQ_F_REISSUE;",
                        "\t\t/* IOPOLL retry should happen for io-wq threads */",
                        "\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))",
                        "\t\t\tgoto done;",
                        "\t\t/* no retry on NONBLOCK nor RWF_NOWAIT */",
                        "\t\tif (req->flags & REQ_F_NOWAIT)",
                        "\t\t\tgoto done;",
                        "\t\t/* some cases will consume bytes even on error returns */",
                        "\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));",
                        "\t\tret = 0;",
                        "\t} else if (ret == -EIOCBQUEUED) {",
                        "\t\tgoto out_free;",
                        "\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||",
                        "\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {",
                        "\t\t/* read all, failed, already did sync or don't want to retry */",
                        "\t\tgoto done;",
                        "\t}",
                        "",
                        "\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);",
                        "\tif (ret2)",
                        "\t\treturn ret2;",
                        "",
                        "\tiovec = NULL;",
                        "\trw = req->async_data;",
                        "\t/* now use our persistent iterator, if we aren't already */",
                        "\titer = &rw->iter;",
                        "",
                        "\tdo {",
                        "\t\tio_size -= ret;",
                        "\t\trw->bytes_done += ret;",
                        "\t\t/* if we can retry, do so with the callbacks armed */",
                        "\t\tif (!io_rw_should_retry(req)) {",
                        "\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;",
                        "\t\t\treturn -EAGAIN;",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * Now retry read with the IOCB_WAITQ parts set in the iocb. If",
                        "\t\t * we get -EIOCBQUEUED, then we'll get a notification when the",
                        "\t\t * desired page gets unlocked. We can also get a partial read",
                        "\t\t * here, and if we do, then just retry at the new offset.",
                        "\t\t */",
                        "\t\tret = io_iter_do_read(req, iter);",
                        "\t\tif (ret == -EIOCBQUEUED)",
                        "\t\t\treturn 0;",
                        "\t\t/* we got some bytes, but not all. retry. */",
                        "\t\tkiocb->ki_flags &= ~IOCB_WAITQ;",
                        "\t} while (ret > 0 && ret < io_size);",
                        "done:",
                        "\tkiocb_done(kiocb, ret, issue_flags);",
                        "out_free:",
                        "\t/* it's faster to check here then delegate to kfree */",
                        "\tif (iovec)",
                        "\t\tkfree(iovec);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 3413,
                    "highlight": 3440
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812577d3"
        },
        "1243": {
            "name": "io_read",
            "parent_idx": 1240,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n6558",
                    "code": [
                        "static int io_issue_sqe(struct io_kiocb *req, unsigned int issue_flags)",
                        "{",
                        "\tstruct io_ring_ctx *ctx = req->ctx;",
                        "\tconst struct cred *creds = NULL;",
                        "\tint ret;",
                        "",
                        "\tif ((req->flags & REQ_F_CREDS) && req->creds != current_cred())",
                        "\t\tcreds = override_creds(req->creds);",
                        "",
                        "\tswitch (req->opcode) {",
                        "\tcase IORING_OP_NOP:",
                        "\t\tret = io_nop(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_READV:",
                        "\tcase IORING_OP_READ_FIXED:",
                        "\tcase IORING_OP_READ:",
                        "\t\tret = io_read(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_WRITEV:",
                        "\tcase IORING_OP_WRITE_FIXED:",
                        "\tcase IORING_OP_WRITE:",
                        "\t\tret = io_write(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_FSYNC:",
                        "\t\tret = io_fsync(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_POLL_ADD:",
                        "\t\tret = io_poll_add(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_POLL_REMOVE:",
                        "\t\tret = io_poll_update(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_SYNC_FILE_RANGE:",
                        "\t\tret = io_sync_file_range(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_SENDMSG:",
                        "\t\tret = io_sendmsg(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_SEND:",
                        "\t\tret = io_send(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_RECVMSG:",
                        "\t\tret = io_recvmsg(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_RECV:",
                        "\t\tret = io_recv(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_TIMEOUT:",
                        "\t\tret = io_timeout(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_TIMEOUT_REMOVE:",
                        "\t\tret = io_timeout_remove(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_ACCEPT:",
                        "\t\tret = io_accept(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_CONNECT:",
                        "\t\tret = io_connect(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_ASYNC_CANCEL:",
                        "\t\tret = io_async_cancel(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_FALLOCATE:",
                        "\t\tret = io_fallocate(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_OPENAT:",
                        "\t\tret = io_openat(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_CLOSE:",
                        "\t\tret = io_close(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_FILES_UPDATE:",
                        "\t\tret = io_files_update(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_STATX:",
                        "\t\tret = io_statx(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_FADVISE:",
                        "\t\tret = io_fadvise(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_MADVISE:",
                        "\t\tret = io_madvise(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_OPENAT2:",
                        "\t\tret = io_openat2(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_EPOLL_CTL:",
                        "\t\tret = io_epoll_ctl(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_SPLICE:",
                        "\t\tret = io_splice(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_PROVIDE_BUFFERS:",
                        "\t\tret = io_provide_buffers(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_REMOVE_BUFFERS:",
                        "\t\tret = io_remove_buffers(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_TEE:",
                        "\t\tret = io_tee(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_SHUTDOWN:",
                        "\t\tret = io_shutdown(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_RENAMEAT:",
                        "\t\tret = io_renameat(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_UNLINKAT:",
                        "\t\tret = io_unlinkat(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_MKDIRAT:",
                        "\t\tret = io_mkdirat(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_SYMLINKAT:",
                        "\t\tret = io_symlinkat(req, issue_flags);",
                        "\t\tbreak;",
                        "\tcase IORING_OP_LINKAT:",
                        "\t\tret = io_linkat(req, issue_flags);",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\tret = -EINVAL;",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\tif (creds)",
                        "\t\trevert_creds(creds);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\t/* If the op doesn't have a file, we're not polling for it */",
                        "\tif ((ctx->flags & IORING_SETUP_IOPOLL) && req->file)",
                        "\t\tio_iopoll_req_issued(req);",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 6542,
                    "highlight": 6558
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81258910"
        },
        "1240": {
            "name": "io_issue_sqe",
            "parent_idx": 1235,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n6864",
                    "code": [
                        "static void __io_queue_sqe(struct io_kiocb *req)",
                        "\t__must_hold(&req->ctx->uring_lock)",
                        "{",
                        "\tstruct io_kiocb *linked_timeout;",
                        "\tint ret;",
                        "",
                        "issue_sqe:",
                        "\tret = io_issue_sqe(req, IO_URING_F_NONBLOCK|IO_URING_F_COMPLETE_DEFER);",
                        "",
                        "\t/*",
                        "\t * We async punt it if the file wasn't marked NOWAIT, or if the file",
                        "\t * doesn't support non-blocking read/write attempts",
                        "\t */",
                        "\tif (likely(!ret)) {",
                        "\t\tif (req->flags & REQ_F_COMPLETE_INLINE) {",
                        "\t\t\tstruct io_ring_ctx *ctx = req->ctx;",
                        "\t\t\tstruct io_submit_state *state = &ctx->submit_state;",
                        "",
                        "\t\t\tstate->compl_reqs[state->compl_nr++] = req;",
                        "\t\t\tif (state->compl_nr == ARRAY_SIZE(state->compl_reqs))",
                        "\t\t\t\tio_submit_flush_completions(ctx);",
                        "\t\t\treturn;",
                        "\t\t}",
                        "",
                        "\t\tlinked_timeout = io_prep_linked_timeout(req);",
                        "\t\tif (linked_timeout)",
                        "\t\t\tio_queue_linked_timeout(linked_timeout);",
                        "\t} else if (ret == -EAGAIN && !(req->flags & REQ_F_NOWAIT)) {",
                        "\t\tlinked_timeout = io_prep_linked_timeout(req);",
                        "",
                        "\t\tswitch (io_arm_poll_handler(req)) {",
                        "\t\tcase IO_APOLL_READY:",
                        "\t\t\tif (linked_timeout)",
                        "\t\t\t\tio_unprep_linked_timeout(req);",
                        "\t\t\tgoto issue_sqe;",
                        "\t\tcase IO_APOLL_ABORTED:",
                        "\t\t\t/*",
                        "\t\t\t * Queued up for async execution, worker will release",
                        "\t\t\t * submit reference when the iocb is actually submitted.",
                        "\t\t\t */",
                        "\t\t\tio_queue_async_work(req, NULL);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "",
                        "\t\tif (linked_timeout)",
                        "\t\t\tio_queue_linked_timeout(linked_timeout);",
                        "\t} else {",
                        "\t\tio_req_complete_failed(req, ret);",
                        "\t}",
                        "}"
                    ],
                    "start": 6857,
                    "highlight": 6864
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812595c7"
        },
        "1235": {
            "name": "io_req_task_submit(indirect)",
            "parent_idx": 1229,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n2143",
                    "code": [
                        "static void tctx_task_work(struct callback_head *cb)",
                        "{",
                        "\tbool locked = false;",
                        "\tstruct io_ring_ctx *ctx = NULL;",
                        "\tstruct io_uring_task *tctx = container_of(cb, struct io_uring_task,",
                        "\t\t\t\t\t\t  task_work);",
                        "",
                        "\twhile (1) {",
                        "\t\tstruct io_wq_work_node *node;",
                        "",
                        "\t\tspin_lock_irq(&tctx->task_lock);",
                        "\t\tnode = tctx->task_list.first;",
                        "\t\tINIT_WQ_LIST(&tctx->task_list);",
                        "\t\tif (!node)",
                        "\t\t\ttctx->task_running = false;",
                        "\t\tspin_unlock_irq(&tctx->task_lock);",
                        "\t\tif (!node)",
                        "\t\t\tbreak;",
                        "",
                        "\t\tdo {",
                        "\t\t\tstruct io_wq_work_node *next = node->next;",
                        "\t\t\tstruct io_kiocb *req = container_of(node, struct io_kiocb,",
                        "\t\t\t\t\t\t\t    io_task_work.node);",
                        "",
                        "\t\t\tif (req->ctx != ctx) {",
                        "\t\t\t\tctx_flush_and_put(ctx, &locked);",
                        "\t\t\t\tctx = req->ctx;",
                        "\t\t\t\t/* if not contended, grab and improve batching */",
                        "\t\t\t\tlocked = mutex_trylock(&ctx->uring_lock);",
                        "\t\t\t\tpercpu_ref_get(&ctx->refs);",
                        "\t\t\t}",
                        "\t\t\treq->io_task_work.func(req, &locked);",
                        "\t\t\tnode = next;",
                        "\t\t} while (node);",
                        "",
                        "\t\tcond_resched();",
                        "\t}",
                        "",
                        "\tctx_flush_and_put(ctx, &locked);",
                        "}"
                    ],
                    "start": 2112,
                    "highlight": 2143
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81255022"
        },
        "1229": {
            "name": "tctx_task_work(indirect)",
            "parent_idx": 1225,
            "source_line": [
                {
                    "file": "kernel/task_work.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/task_work.c?id=b91db6a0b52e#n164",
                    "code": [
                        "/**",
                        " * task_work_run - execute the works added by task_work_add()",
                        " *",
                        " * Flush the pending works. Should be used by the core kernel code.",
                        " * Called before the task returns to the user-mode or stops, or when",
                        " * it exits. In the latter case task_work_add() can no longer add the",
                        " * new work after task_work_run() returns.",
                        " */",
                        "void task_work_run(void)",
                        "{",
                        "\tstruct task_struct *task = current;",
                        "\tstruct callback_head *work, *head, *next;",
                        "",
                        "\tfor (;;) {",
                        "\t\t/*",
                        "\t\t * work->func() can do task_work_add(), do not set",
                        "\t\t * work_exited unless the list is empty.",
                        "\t\t */",
                        "\t\tdo {",
                        "\t\t\thead = NULL;",
                        "\t\t\twork = READ_ONCE(task->task_works);",
                        "\t\t\tif (!work) {",
                        "\t\t\t\tif (task->flags & PF_EXITING)",
                        "\t\t\t\t\thead = &work_exited;",
                        "\t\t\t\telse",
                        "\t\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t} while (cmpxchg(&task->task_works, work, head) != work);",
                        "",
                        "\t\tif (!work)",
                        "\t\t\tbreak;",
                        "\t\t/*",
                        "\t\t * Synchronize with task_work_cancel(). It can not remove",
                        "\t\t * the first entry == work, cmpxchg(task_works) must fail.",
                        "\t\t * But it can remove another entry from the ->next list.",
                        "\t\t */",
                        "\t\traw_spin_lock_irq(&task->pi_lock);",
                        "\t\traw_spin_unlock_irq(&task->pi_lock);",
                        "",
                        "\t\tdo {",
                        "\t\t\tnext = work->next;",
                        "\t\t\twork->func(work);",
                        "\t\t\twork = next;",
                        "\t\t\tcond_resched();",
                        "\t\t} while (work);",
                        "\t}",
                        "}"
                    ],
                    "start": 123,
                    "highlight": 164
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff810883a2"
        },
        "1225": {
            "name": "task_work_run",
            "parent_idx": 1224,
            "source_line": [
                {
                    "file": "./include/linux/tracehook.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/tracehook.h?id=b91db6a0b52e#n212",
                    "code": [
                        "/*",
                        " * called by exit_to_user_mode_loop() if ti_work & _TIF_NOTIFY_SIGNAL. This",
                        " * is currently used by TWA_SIGNAL based task_work, which requires breaking",
                        " * wait loops to ensure that task_work is noticed and run.",
                        " */",
                        "static inline void tracehook_notify_signal(void)",
                        "{",
                        "\tclear_thread_flag(TIF_NOTIFY_SIGNAL);",
                        "\tsmp_mb__after_atomic();",
                        "\tif (current->task_works)",
                        "\t\ttask_work_run();",
                        "}"
                    ],
                    "start": 202,
                    "highlight": 212
                },
                {
                    "file": "kernel/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/entry/common.c?id=b91db6a0b52e#n146",
                    "code": [
                        "static void handle_signal_work(struct pt_regs *regs, unsigned long ti_work)",
                        "{",
                        "\tif (ti_work & _TIF_NOTIFY_SIGNAL)",
                        "\t\ttracehook_notify_signal();",
                        "",
                        "\tarch_do_signal_or_restart(regs, ti_work & _TIF_SIGPENDING);",
                        "}"
                    ],
                    "start": 143,
                    "highlight": 146
                },
                {
                    "file": "kernel/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/entry/common.c?id=b91db6a0b52e#n172",
                    "code": [
                        "static unsigned long exit_to_user_mode_loop(struct pt_regs *regs,",
                        "\t\t\t\t\t    unsigned long ti_work)",
                        "{",
                        "\t/*",
                        "\t * Before returning to user space ensure that all pending work",
                        "\t * items have been completed.",
                        "\t */",
                        "\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {",
                        "",
                        "\t\tlocal_irq_enable_exit_to_user(ti_work);",
                        "",
                        "\t\tif (ti_work & _TIF_NEED_RESCHED)",
                        "\t\t\tschedule();",
                        "",
                        "\t\tif (ti_work & _TIF_UPROBE)",
                        "\t\t\tuprobe_notify_resume(regs);",
                        "",
                        "\t\tif (ti_work & _TIF_PATCH_PENDING)",
                        "\t\t\tklp_update_patch_state(current);",
                        "",
                        "\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))",
                        "\t\t\thandle_signal_work(regs, ti_work);",
                        "",
                        "\t\tif (ti_work & _TIF_NOTIFY_RESUME) {",
                        "\t\t\ttracehook_notify_resume(regs);",
                        "\t\t\trseq_handle_notify_resume(NULL, regs);",
                        "\t\t}",
                        "",
                        "\t\t/* Architecture specific TIF work */",
                        "\t\tarch_exit_to_user_mode_work(regs, ti_work);",
                        "",
                        "\t\t/*",
                        "\t\t * Disable interrupts and reevaluate the work flags as they",
                        "\t\t * might have changed while interrupts and preemption was",
                        "\t\t * enabled above.",
                        "\t\t */",
                        "\t\tlocal_irq_disable_exit_to_user();",
                        "",
                        "\t\t/* Check if any of the above work has queued a deferred wakeup */",
                        "\t\ttick_nohz_user_enter_prepare();",
                        "",
                        "\t\tti_work = READ_ONCE(current_thread_info()->flags);",
                        "\t}",
                        "",
                        "\t/* Return the latest work state for arch_exit_to_user_mode() */",
                        "\treturn ti_work;",
                        "}"
                    ],
                    "start": 151,
                    "highlight": 172
                },
                {
                    "file": "kernel/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/entry/common.c?id=b91db6a0b52e#n209",
                    "code": [
                        "static void exit_to_user_mode_prepare(struct pt_regs *regs)",
                        "{",
                        "\tunsigned long ti_work = READ_ONCE(current_thread_info()->flags);",
                        "",
                        "\tlockdep_assert_irqs_disabled();",
                        "",
                        "\t/* Flush pending rcuog wakeup before the last need_resched() check */",
                        "\ttick_nohz_user_enter_prepare();",
                        "",
                        "\tif (unlikely(ti_work & EXIT_TO_USER_MODE_WORK))",
                        "\t\tti_work = exit_to_user_mode_loop(regs, ti_work);",
                        "",
                        "\tarch_exit_to_user_mode_prepare(regs, ti_work);",
                        "",
                        "\t/* Ensure that the address limit is intact and no locks are held */",
                        "\taddr_limit_user_check();",
                        "\tkmap_assert_nomap();",
                        "\tlockdep_assert_irqs_disabled();",
                        "\tlockdep_sys_exit();",
                        "}"
                    ],
                    "start": 199,
                    "highlight": 209
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff810dcdad"
        },
        "1224": {
            "name": "exit_to_user_mode_prepare",
            "parent_idx": 1223,
            "source_line": [
                {
                    "file": "kernel/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/entry/common.c?id=b91db6a0b52e#n291",
                    "code": [
                        "static __always_inline void __syscall_exit_to_user_mode_work(struct pt_regs *regs)",
                        "{",
                        "\tsyscall_exit_to_user_mode_prepare(regs);",
                        "\tlocal_irq_disable_exit_to_user();",
                        "\texit_to_user_mode_prepare(regs);",
                        "}"
                    ],
                    "start": 287,
                    "highlight": 291
                },
                {
                    "file": "kernel/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/entry/common.c?id=b91db6a0b52e#n302",
                    "code": [
                        "__visible noinstr void syscall_exit_to_user_mode(struct pt_regs *regs)",
                        "{",
                        "\tinstrumentation_begin();",
                        "\t__syscall_exit_to_user_mode_work(regs);",
                        "\tinstrumentation_end();",
                        "\t__exit_to_user_mode();",
                        "}"
                    ],
                    "start": 299,
                    "highlight": 302
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81bcc6e8"
        },
        "1223": {
            "name": "syscall_exit_to_user_mode",
            "parent_idx": 1145,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=b91db6a0b52e#n86",
                    "code": [
                        "__visible noinstr void do_syscall_64(struct pt_regs *regs, int nr)",
                        "{",
                        "\tadd_random_kstack_offset();",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "",
                        "\tif (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {",
                        "\t\t/* Invalid system call, but still a system call. */",
                        "\t\tregs->ax = __x64_sys_ni_syscall(regs);",
                        "\t}",
                        "",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 73,
                    "highlight": 86
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81bc93eb"
        },
        "1145": {
            "name": "do_syscall_64",
            "parent_idx": 1138,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=b91db6a0b52e#n113",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rsp, %rdi",
                        "\t/* Sign extend the lower 32bit as syscall numbers are treated as int */",
                        "\tmovslq\t%eax, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t * In the Xen PV case we must use iret anyway.",
                        "\t */",
                        "",
                        "\tALTERNATIVE \"\", \"jmp\tswapgs_restore_regs_and_return_to_usermode\", \\",
                        "\t\tX86_FEATURE_XENPV",
                        "",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tswapgs",
                        "\tsysretq",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 87,
                    "highlight": 113
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "1138": {
            "name": "25_syscall_7",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1251": {
            "name": "+0x170",
            "parent_idx": 1243,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n2823",
                    "code": [
                        "\treturn __io_file_supports_nowait(req->file, rw);",
                        "}"
                    ],
                    "start": 2823,
                    "highlight": 2823
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n2816",
                    "code": [
                        "static bool io_file_supports_nowait(struct io_kiocb *req, int rw)",
                        "{",
                        "\tif (rw == READ && (req->flags & REQ_F_NOWAIT_READ))",
                        "\t\treturn true;",
                        "\telse if (rw == WRITE && (req->flags & REQ_F_NOWAIT_WRITE))",
                        "\t\treturn true;",
                        "",
                        "\treturn __io_file_supports_nowait(req->file, rw);",
                        "}"
                    ],
                    "start": 2816,
                    "highlight": 2816
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n3440",
                    "code": [
                        "static int io_read(struct io_kiocb *req, unsigned int issue_flags)",
                        "{",
                        "\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;",
                        "\tstruct kiocb *kiocb = &req->rw.kiocb;",
                        "\tstruct iov_iter __iter, *iter = &__iter;",
                        "\tstruct io_async_rw *rw = req->async_data;",
                        "\tssize_t io_size, ret, ret2;",
                        "\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;",
                        "",
                        "\tif (rw) {",
                        "\t\titer = &rw->iter;",
                        "\t\tiovec = NULL;",
                        "\t} else {",
                        "\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);",
                        "\t\tif (ret < 0)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "\tio_size = iov_iter_count(iter);",
                        "\treq->result = io_size;",
                        "",
                        "\t/* Ensure we clear previously set non-block flag */",
                        "\tif (!force_nonblock)",
                        "\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;",
                        "\telse",
                        "\t\tkiocb->ki_flags |= IOCB_NOWAIT;",
                        "",
                        "\t/* If the file doesn't support async, just async punt */",
                        "\tif (force_nonblock && !io_file_supports_nowait(req, READ)) {",
                        "\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);",
                        "\t\treturn ret ?: -EAGAIN;",
                        "\t}",
                        "",
                        "\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);",
                        "\tif (unlikely(ret)) {",
                        "\t\tkfree(iovec);",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\tret = io_iter_do_read(req, iter);",
                        "",
                        "\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {",
                        "\t\treq->flags &= ~REQ_F_REISSUE;",
                        "\t\t/* IOPOLL retry should happen for io-wq threads */",
                        "\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))",
                        "\t\t\tgoto done;",
                        "\t\t/* no retry on NONBLOCK nor RWF_NOWAIT */",
                        "\t\tif (req->flags & REQ_F_NOWAIT)",
                        "\t\t\tgoto done;",
                        "\t\t/* some cases will consume bytes even on error returns */",
                        "\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));",
                        "\t\tret = 0;",
                        "\t} else if (ret == -EIOCBQUEUED) {",
                        "\t\tgoto out_free;",
                        "\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||",
                        "\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {",
                        "\t\t/* read all, failed, already did sync or don't want to retry */",
                        "\t\tgoto done;",
                        "\t}",
                        "",
                        "\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);",
                        "\tif (ret2)",
                        "\t\treturn ret2;",
                        "",
                        "\tiovec = NULL;",
                        "\trw = req->async_data;",
                        "\t/* now use our persistent iterator, if we aren't already */",
                        "\titer = &rw->iter;",
                        "",
                        "\tdo {",
                        "\t\tio_size -= ret;",
                        "\t\trw->bytes_done += ret;",
                        "\t\t/* if we can retry, do so with the callbacks armed */",
                        "\t\tif (!io_rw_should_retry(req)) {",
                        "\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;",
                        "\t\t\treturn -EAGAIN;",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * Now retry read with the IOCB_WAITQ parts set in the iocb. If",
                        "\t\t * we get -EIOCBQUEUED, then we'll get a notification when the",
                        "\t\t * desired page gets unlocked. We can also get a partial read",
                        "\t\t * here, and if we do, then just retry at the new offset.",
                        "\t\t */",
                        "\t\tret = io_iter_do_read(req, iter);",
                        "\t\tif (ret == -EIOCBQUEUED)",
                        "\t\t\treturn 0;",
                        "\t\t/* we got some bytes, but not all. retry. */",
                        "\t\tkiocb->ki_flags &= ~IOCB_WAITQ;",
                        "\t} while (ret > 0 && ret < io_size);",
                        "done:",
                        "\tkiocb_done(kiocb, ret, issue_flags);",
                        "out_free:",
                        "\t/* it's faster to check here then delegate to kfree */",
                        "\tif (iovec)",
                        "\t\tkfree(iovec);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 3413,
                    "highlight": 3440
                }
            ],
            "ins_idx": 17,
            "addr": "0xffffffff812577d0"
        },
        "1250": {
            "name": "+0x61",
            "parent_idx": 1243,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n3435",
                    "code": [
                        "static int io_read(struct io_kiocb *req, unsigned int issue_flags)",
                        "{",
                        "\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;",
                        "\tstruct kiocb *kiocb = &req->rw.kiocb;",
                        "\tstruct iov_iter __iter, *iter = &__iter;",
                        "\tstruct io_async_rw *rw = req->async_data;",
                        "\tssize_t io_size, ret, ret2;",
                        "\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;",
                        "",
                        "\tif (rw) {",
                        "\t\titer = &rw->iter;",
                        "\t\tiovec = NULL;",
                        "\t} else {",
                        "\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);",
                        "\t\tif (ret < 0)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "\tio_size = iov_iter_count(iter);",
                        "\treq->result = io_size;",
                        "",
                        "\t/* Ensure we clear previously set non-block flag */",
                        "\tif (!force_nonblock)",
                        "\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;",
                        "\telse",
                        "\t\tkiocb->ki_flags |= IOCB_NOWAIT;",
                        "",
                        "\t/* If the file doesn't support async, just async punt */",
                        "\tif (force_nonblock && !io_file_supports_nowait(req, READ)) {",
                        "\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);",
                        "\t\treturn ret ?: -EAGAIN;",
                        "\t}",
                        "",
                        "\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);",
                        "\tif (unlikely(ret)) {",
                        "\t\tkfree(iovec);",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\tret = io_iter_do_read(req, iter);",
                        "",
                        "\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {",
                        "\t\treq->flags &= ~REQ_F_REISSUE;",
                        "\t\t/* IOPOLL retry should happen for io-wq threads */",
                        "\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))",
                        "\t\t\tgoto done;",
                        "\t\t/* no retry on NONBLOCK nor RWF_NOWAIT */",
                        "\t\tif (req->flags & REQ_F_NOWAIT)",
                        "\t\t\tgoto done;",
                        "\t\t/* some cases will consume bytes even on error returns */",
                        "\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));",
                        "\t\tret = 0;",
                        "\t} else if (ret == -EIOCBQUEUED) {",
                        "\t\tgoto out_free;",
                        "\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||",
                        "\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {",
                        "\t\t/* read all, failed, already did sync or don't want to retry */",
                        "\t\tgoto done;",
                        "\t}",
                        "",
                        "\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);",
                        "\tif (ret2)",
                        "\t\treturn ret2;",
                        "",
                        "\tiovec = NULL;",
                        "\trw = req->async_data;",
                        "\t/* now use our persistent iterator, if we aren't already */",
                        "\titer = &rw->iter;",
                        "",
                        "\tdo {",
                        "\t\tio_size -= ret;",
                        "\t\trw->bytes_done += ret;",
                        "\t\t/* if we can retry, do so with the callbacks armed */",
                        "\t\tif (!io_rw_should_retry(req)) {",
                        "\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;",
                        "\t\t\treturn -EAGAIN;",
                        "\t\t}",
                        "",
                        "\t\t/*",
                        "\t\t * Now retry read with the IOCB_WAITQ parts set in the iocb. If",
                        "\t\t * we get -EIOCBQUEUED, then we'll get a notification when the",
                        "\t\t * desired page gets unlocked. We can also get a partial read",
                        "\t\t * here, and if we do, then just retry at the new offset.",
                        "\t\t */",
                        "\t\tret = io_iter_do_read(req, iter);",
                        "\t\tif (ret == -EIOCBQUEUED)",
                        "\t\t\treturn 0;",
                        "\t\t/* we got some bytes, but not all. retry. */",
                        "\t\tkiocb->ki_flags &= ~IOCB_WAITQ;",
                        "\t} while (ret > 0 && ret < io_size);",
                        "done:",
                        "\tkiocb_done(kiocb, ret, issue_flags);",
                        "out_free:",
                        "\t/* it's faster to check here then delegate to kfree */",
                        "\tif (iovec)",
                        "\t\tkfree(iovec);",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 3413,
                    "highlight": 3435
                }
            ],
            "ins_idx": 26,
            "addr": "0xffffffff812576c1"
        },
        "1198": {
            "name": "+0x141",
            "parent_idx": 1175,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n6967",
                    "code": [
                        "static int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb *req,",
                        "\t\t       const struct io_uring_sqe *sqe)",
                        "\t__must_hold(&ctx->uring_lock)",
                        "{",
                        "\tstruct io_submit_state *state;",
                        "\tunsigned int sqe_flags;",
                        "\tint personality, ret = 0;",
                        "",
                        "\t/* req is partially pre-initialised, see io_preinit_req() */",
                        "\treq->opcode = READ_ONCE(sqe->opcode);",
                        "\t/* same numerical values with corresponding REQ_F_*, safe to copy */",
                        "\treq->flags = sqe_flags = READ_ONCE(sqe->flags);",
                        "\treq->user_data = READ_ONCE(sqe->user_data);",
                        "\treq->file = NULL;",
                        "\treq->fixed_rsrc_refs = NULL;",
                        "\treq->task = current;",
                        "",
                        "\t/* enforce forwards compatibility on users */",
                        "\tif (unlikely(sqe_flags & ~SQE_VALID_FLAGS))",
                        "\t\treturn -EINVAL;",
                        "\tif (unlikely(req->opcode >= IORING_OP_LAST))",
                        "\t\treturn -EINVAL;",
                        "\tif (!io_check_restriction(ctx, req, sqe_flags))",
                        "\t\treturn -EACCES;",
                        "",
                        "\tif ((sqe_flags & IOSQE_BUFFER_SELECT) &&",
                        "\t    !io_op_defs[req->opcode].buffer_select)",
                        "\t\treturn -EOPNOTSUPP;",
                        "\tif (unlikely(sqe_flags & IOSQE_IO_DRAIN))",
                        "\t\tctx->drain_active = true;",
                        "",
                        "\tpersonality = READ_ONCE(sqe->personality);",
                        "\tif (personality) {",
                        "\t\treq->creds = xa_load(&ctx->personalities, personality);",
                        "\t\tif (!req->creds)",
                        "\t\t\treturn -EINVAL;",
                        "\t\tget_cred(req->creds);",
                        "\t\treq->flags |= REQ_F_CREDS;",
                        "\t}",
                        "\tstate = &ctx->submit_state;",
                        "",
                        "\t/*",
                        "\t * Plug now if we have more than 1 IO left after this, and the target",
                        "\t * is potentially a read/write to block based storage.",
                        "\t */",
                        "\tif (!state->plug_started && state->ios_left > 1 &&",
                        "\t    io_op_defs[req->opcode].plug) {",
                        "\t\tblk_start_plug(&state->plug);",
                        "\t\tstate->plug_started = true;",
                        "\t}",
                        "",
                        "\tif (io_op_defs[req->opcode].needs_file) {",
                        "\t\treq->file = io_file_get(ctx, req, READ_ONCE(sqe->fd),",
                        "\t\t\t\t\t(sqe_flags & IOSQE_FIXED_FILE));",
                        "\t\tif (unlikely(!req->file))",
                        "\t\t\tret = -EBADF;",
                        "\t}",
                        "",
                        "\tstate->ios_left--;",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 6954,
                    "highlight": 6967
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n7023",
                    "code": [
                        "static int io_submit_sqe(struct io_ring_ctx *ctx, struct io_kiocb *req,",
                        "\t\t\t const struct io_uring_sqe *sqe)",
                        "\t__must_hold(&ctx->uring_lock)",
                        "{",
                        "\tstruct io_submit_link *link = &ctx->submit_state.link;",
                        "\tint ret;",
                        "",
                        "\tret = io_init_req(ctx, req, sqe);",
                        "\tif (unlikely(ret)) {",
                        "fail_req:",
                        "\t\t/* fail even hard links since we don't submit */",
                        "\t\tif (link->head) {",
                        "\t\t\t/*",
                        "\t\t\t * we can judge a link req is failed or cancelled by if",
                        "\t\t\t * REQ_F_FAIL is set, but the head is an exception since",
                        "\t\t\t * it may be set REQ_F_FAIL because of other req's failure",
                        "\t\t\t * so let's leverage req->result to distinguish if a head",
                        "\t\t\t * is set REQ_F_FAIL because of its failure or other req's",
                        "\t\t\t * failure so that we can set the correct ret code for it.",
                        "\t\t\t * init result here to avoid affecting the normal path.",
                        "\t\t\t */",
                        "\t\t\tif (!(link->head->flags & REQ_F_FAIL))",
                        "\t\t\t\treq_fail_link_node(link->head, -ECANCELED);",
                        "\t\t} else if (!(req->flags & (REQ_F_LINK | REQ_F_HARDLINK))) {",
                        "\t\t\t/*",
                        "\t\t\t * the current req is a normal req, we should return",
                        "\t\t\t * error and thus break the submittion loop.",
                        "\t\t\t */",
                        "\t\t\tio_req_complete_failed(req, ret);",
                        "\t\t\treturn ret;",
                        "\t\t}",
                        "\t\treq_fail_link_node(req, ret);",
                        "\t} else {",
                        "\t\tret = io_req_prep(req, sqe);",
                        "\t\tif (unlikely(ret))",
                        "\t\t\tgoto fail_req;",
                        "\t}",
                        "",
                        "\t/* don't need @sqe from now on */",
                        "\ttrace_io_uring_submit_sqe(ctx, req, req->opcode, req->user_data,",
                        "\t\t\t\t  req->flags, true,",
                        "\t\t\t\t  ctx->flags & IORING_SETUP_SQPOLL);",
                        "",
                        "\t/*",
                        "\t * If we already have a head request, queue this one for async",
                        "\t * submittal once the head completes. If we don't have a head but",
                        "\t * IOSQE_IO_LINK is set in the sqe, start a new head. This one will be",
                        "\t * submitted sync once the chain is complete. If none of those",
                        "\t * conditions are true (normal request), then just queue it.",
                        "\t */",
                        "\tif (link->head) {",
                        "\t\tstruct io_kiocb *head = link->head;",
                        "",
                        "\t\tif (!(req->flags & REQ_F_FAIL)) {",
                        "\t\t\tret = io_req_prep_async(req);",
                        "\t\t\tif (unlikely(ret)) {",
                        "\t\t\t\treq_fail_link_node(req, ret);",
                        "\t\t\t\tif (!(head->flags & REQ_F_FAIL))",
                        "\t\t\t\t\treq_fail_link_node(head, -ECANCELED);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\ttrace_io_uring_link(ctx, req, head);",
                        "\t\tlink->last->link = req;",
                        "\t\tlink->last = req;",
                        "",
                        "\t\t/* last request of a link, enqueue the link */",
                        "\t\tif (!(req->flags & (REQ_F_LINK | REQ_F_HARDLINK))) {",
                        "\t\t\tlink->head = NULL;",
                        "\t\t\tio_queue_sqe(head);",
                        "\t\t}",
                        "\t} else {",
                        "\t\tif (req->flags & (REQ_F_LINK | REQ_F_HARDLINK)) {",
                        "\t\t\tlink->head = req;",
                        "\t\t\tlink->last = req;",
                        "\t\t} else {",
                        "\t\t\tio_queue_sqe(req);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 7016,
                    "highlight": 7023
                },
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n7197",
                    "code": [
                        "static int io_submit_sqes(struct io_ring_ctx *ctx, unsigned int nr)",
                        "\t__must_hold(&ctx->uring_lock)",
                        "{",
                        "\tint submitted = 0;",
                        "",
                        "\t/* make sure SQ entry isn't read before tail */",
                        "\tnr = min3(nr, ctx->sq_entries, io_sqring_entries(ctx));",
                        "\tif (!percpu_ref_tryget_many(&ctx->refs, nr))",
                        "\t\treturn -EAGAIN;",
                        "\tio_get_task_refs(nr);",
                        "",
                        "\tio_submit_state_start(&ctx->submit_state, nr);",
                        "\twhile (submitted < nr) {",
                        "\t\tconst struct io_uring_sqe *sqe;",
                        "\t\tstruct io_kiocb *req;",
                        "",
                        "\t\treq = io_alloc_req(ctx);",
                        "\t\tif (unlikely(!req)) {",
                        "\t\t\tif (!submitted)",
                        "\t\t\t\tsubmitted = -EAGAIN;",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tsqe = io_get_sqe(ctx);",
                        "\t\tif (unlikely(!sqe)) {",
                        "\t\t\tlist_add(&req->inflight_entry, &ctx->submit_state.free_list);",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\t/* will complete beyond this point, count as submitted */",
                        "\t\tsubmitted++;",
                        "\t\tif (io_submit_sqe(ctx, req, sqe))",
                        "\t\t\tbreak;",
                        "\t}",
                        "",
                        "\tif (unlikely(submitted != nr)) {",
                        "\t\tint ref_used = (submitted == -EAGAIN) ? 0 : submitted;",
                        "\t\tint unused = nr - ref_used;",
                        "",
                        "\t\tcurrent->io_uring->cached_refs += unused;",
                        "\t\tpercpu_ref_put_many(&ctx->refs, unused);",
                        "\t}",
                        "",
                        "\tio_submit_state_end(&ctx->submit_state, ctx);",
                        "\t /* Commit SQ ring head once we've consumed and submitted all SQEs */",
                        "\tio_commit_sqring(ctx);",
                        "",
                        "\treturn submitted;",
                        "}"
                    ],
                    "start": 7168,
                    "highlight": 7197
                }
            ],
            "ins_idx": 35,
            "addr": "0xffffffff81259c61"
        },
        "1175": {
            "name": "io_submit_sqes",
            "parent_idx": 1148,
            "source_line": [
                {
                    "file": "fs/io_uring.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/io_uring.c?id=b91db6a0b52e#n9839",
                    "code": [
                        "SYSCALL_DEFINE6(io_uring_enter, unsigned int, fd, u32, to_submit,",
                        "\t\tu32, min_complete, u32, flags, const void __user *, argp,",
                        "\t\tsize_t, argsz)",
                        "{",
                        "\tstruct io_ring_ctx *ctx;",
                        "\tint submitted = 0;",
                        "\tstruct fd f;",
                        "\tlong ret;",
                        "",
                        "\tio_run_task_work();",
                        "",
                        "\tif (unlikely(flags & ~(IORING_ENTER_GETEVENTS | IORING_ENTER_SQ_WAKEUP |",
                        "\t\t\t       IORING_ENTER_SQ_WAIT | IORING_ENTER_EXT_ARG)))",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tf = fdget(fd);",
                        "\tif (unlikely(!f.file))",
                        "\t\treturn -EBADF;",
                        "",
                        "\tret = -EOPNOTSUPP;",
                        "\tif (unlikely(f.file->f_op != &io_uring_fops))",
                        "\t\tgoto out_fput;",
                        "",
                        "\tret = -ENXIO;",
                        "\tctx = f.file->private_data;",
                        "\tif (unlikely(!percpu_ref_tryget(&ctx->refs)))",
                        "\t\tgoto out_fput;",
                        "",
                        "\tret = -EBADFD;",
                        "\tif (unlikely(ctx->flags & IORING_SETUP_R_DISABLED))",
                        "\t\tgoto out;",
                        "",
                        "\t/*",
                        "\t * For SQ polling, the thread will do all submissions and completions.",
                        "\t * Just return the requested submit count, and wake the thread if",
                        "\t * we were asked to.",
                        "\t */",
                        "\tret = 0;",
                        "\tif (ctx->flags & IORING_SETUP_SQPOLL) {",
                        "\t\tio_cqring_overflow_flush(ctx);",
                        "",
                        "\t\tif (unlikely(ctx->sq_data->thread == NULL)) {",
                        "\t\t\tret = -EOWNERDEAD;",
                        "\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tif (flags & IORING_ENTER_SQ_WAKEUP)",
                        "\t\t\twake_up(&ctx->sq_data->wait);",
                        "\t\tif (flags & IORING_ENTER_SQ_WAIT) {",
                        "\t\t\tret = io_sqpoll_wait_sq(ctx);",
                        "\t\t\tif (ret)",
                        "\t\t\t\tgoto out;",
                        "\t\t}",
                        "\t\tsubmitted = to_submit;",
                        "\t} else if (to_submit) {",
                        "\t\tret = io_uring_add_tctx_node(ctx);",
                        "\t\tif (unlikely(ret))",
                        "\t\t\tgoto out;",
                        "\t\tmutex_lock(&ctx->uring_lock);",
                        "\t\tsubmitted = io_submit_sqes(ctx, to_submit);",
                        "\t\tmutex_unlock(&ctx->uring_lock);",
                        "",
                        "\t\tif (submitted != to_submit)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "\tif (flags & IORING_ENTER_GETEVENTS) {",
                        "\t\tconst sigset_t __user *sig;",
                        "\t\tstruct __kernel_timespec __user *ts;",
                        "",
                        "\t\tret = io_get_ext_arg(flags, argp, &argsz, &ts, &sig);",
                        "\t\tif (unlikely(ret))",
                        "\t\t\tgoto out;",
                        "",
                        "\t\tmin_complete = min(min_complete, ctx->cq_entries);",
                        "",
                        "\t\t/*",
                        "\t\t * When SETUP_IOPOLL and SETUP_SQPOLL are both enabled, user",
                        "\t\t * space applications don't need to do io completion events",
                        "\t\t * polling again, they can rely on io_sq_thread to do polling",
                        "\t\t * work, which can reduce cpu usage and uring_lock contention.",
                        "\t\t */",
                        "\t\tif (ctx->flags & IORING_SETUP_IOPOLL &&",
                        "\t\t    !(ctx->flags & IORING_SETUP_SQPOLL)) {",
                        "\t\t\tret = io_iopoll_check(ctx, min_complete);",
                        "\t\t} else {",
                        "\t\t\tret = io_cqring_wait(ctx, min_complete, sig, argsz, ts);",
                        "\t\t}",
                        "\t}",
                        "",
                        "out:",
                        "\tpercpu_ref_put(&ctx->refs);",
                        "out_fput:",
                        "\tfdput(f);",
                        "\treturn submitted ? submitted : ret;",
                        "}"
                    ],
                    "start": 9781,
                    "highlight": 9839
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8125b8ad"
        },
        "1148": {
            "name": "__x64_sys_io_uring_enter(indirect)",
            "parent_idx": 1145,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=b91db6a0b52e#n50",
                    "code": [
                        "static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)",
                        "{",
                        "\t/*",
                        "\t * Convert negative numbers to very high and thus out of range",
                        "\t * numbers for comparisons.",
                        "\t */",
                        "\tunsigned int unr = nr;",
                        "",
                        "\tif (likely(unr < NR_syscalls)) {",
                        "\t\tunr = array_index_nospec(unr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[unr](regs);",
                        "\t\treturn true;",
                        "\t}",
                        "\treturn false;",
                        "}"
                    ],
                    "start": 40,
                    "highlight": 50
                },
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=b91db6a0b52e#n80",
                    "code": [
                        "__visible noinstr void do_syscall_64(struct pt_regs *regs, int nr)",
                        "{",
                        "\tadd_random_kstack_offset();",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "",
                        "\tif (!do_syscall_x64(regs, nr) && !do_syscall_x32(regs, nr) && nr != -1) {",
                        "\t\t/* Invalid system call, but still a system call. */",
                        "\t\tregs->ax = __x64_sys_ni_syscall(regs);",
                        "\t}",
                        "",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 73,
                    "highlight": 80
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81bc93de"
        }
    },
    "ins": {
        "8": {
            "name": "mov rdx, qword ptr [rdi + 0x20]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x20",
            "call_idx": 1253,
            "inputs": [
                2618,
                2619
            ],
            "outputs": [
                2620
            ]
        },
        "17": {
            "name": "mov rdi, r8",
            "desc": "",
            "call_idx": 1251,
            "inputs": [
                2616
            ],
            "outputs": [
                2617
            ]
        },
        "26": {
            "name": "mov r8, qword ptr [r15]",
            "desc": "",
            "call_idx": 1250,
            "inputs": [
                2613,
                2614
            ],
            "outputs": [
                2615
            ]
        },
        "35": {
            "name": "mov qword ptr [r14], 0",
            "desc": "Source of base address CONST 0x0",
            "call_idx": 1198,
            "inputs": [
                2516
            ],
            "outputs": [
                2517
            ]
        }
    },
    "data": {
        "2618": {
            "name": "RDI",
            "ins_idx": 8,
            "value": "0x0",
            "sources": []
        },
        "2619": {
            "name": "[0x20]",
            "ins_idx": 8,
            "value": "0x0",
            "sources": []
        },
        "2620": {
            "name": "RDX",
            "ins_idx": 8,
            "value": "0x0",
            "sources": []
        },
        "2616": {
            "name": "R8",
            "ins_idx": 17,
            "value": "0x0",
            "sources": []
        },
        "2617": {
            "name": "RDI",
            "ins_idx": 17,
            "value": "0x0",
            "sources": [
                2618
            ]
        },
        "2613": {
            "name": "R15",
            "ins_idx": 26,
            "value": "0xffff888101add700",
            "sources": []
        },
        "2614": {
            "name": "[0xffff888101add700]",
            "ins_idx": 26,
            "value": "0x0",
            "sources": []
        },
        "2615": {
            "name": "R8",
            "ins_idx": 26,
            "value": "0x0",
            "sources": [
                2616
            ]
        },
        "2516": {
            "name": "R14",
            "ins_idx": 35,
            "value": "0xffff888101add700",
            "sources": []
        },
        "2517": {
            "name": "[0xffff888101add700]",
            "ins_idx": 35,
            "value": "0x0",
            "sources": [
                2614
            ]
        }
    },
    "chain": {
        "8": [
            17
        ],
        "17": [
            26
        ],
        "26": [
            35
        ]
    }
}