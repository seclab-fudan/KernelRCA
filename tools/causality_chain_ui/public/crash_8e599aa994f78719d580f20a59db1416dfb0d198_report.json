{
    "report": "https://syzkaller.appspot.com/bug?id=8e599aa994f78719d580f20a59db1416dfb0d198",
    "title": "general protection fault in jffs2_parse_param",
    "call": {
        "753": {
            "name": "+0x50",
            "parent_idx": 744,
            "source_line": [
                {
                    "file": "fs/jffs2/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jffs2/super.c?id=325d0eab4f31#n206",
                    "code": [
                        "static int jffs2_parse_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tstruct fs_parse_result result;",
                        "\tstruct jffs2_sb_info *c = fc->s_fs_info;",
                        "\tint opt;",
                        "",
                        "\topt = fs_parse(fc, jffs2_fs_parameters, param, &result);",
                        "\tif (opt < 0)",
                        "\t\treturn opt;",
                        "",
                        "\tswitch (opt) {",
                        "\tcase Opt_override_compr:",
                        "\t\tc->mount_opts.compr = result.uint_32;",
                        "\t\tc->mount_opts.override_compr = true;",
                        "\t\tbreak;",
                        "\tcase Opt_rp_size:",
                        "\t\tif (result.uint_32 > UINT_MAX / 1024)",
                        "\t\t\treturn invalf(fc, \"jffs2: rp_size unrepresentable\");",
                        "\t\topt = result.uint_32 * 1024;",
                        "\t\tif (opt > c->mtd->size)",
                        "\t\t\treturn invalf(fc, \"jffs2: Too large reserve pool specified, max is %llu KB\",",
                        "\t\t\t\t      c->mtd->size / 1024);",
                        "\t\tc->mount_opts.rp_size = opt;",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 187,
                    "highlight": 206
                }
            ],
            "ins_idx": 11,
            "addr": "0xffffffff8136a170"
        },
        "744": {
            "name": "jffs2_parse_param(indirect)",
            "parent_idx": 723,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=325d0eab4f31#n117",
                    "code": [
                        "/**",
                        " * vfs_parse_fs_param - Add a single parameter to a superblock config",
                        " * @fc: The filesystem context to modify",
                        " * @param: The parameter",
                        " *",
                        " * A single mount option in string form is applied to the filesystem context",
                        " * being set up.  Certain standard options (for example \"ro\") are translated",
                        " * into flag bits without going to the filesystem.  The active security module",
                        " * is allowed to observe and poach options.  Any other options are passed over",
                        " * to the filesystem to parse.",
                        " *",
                        " * This may be called multiple times for a context.",
                        " *",
                        " * Returns 0 on success and a negative error code on failure.  In the event of",
                        " * failure, supplementary error information may have been set.",
                        " */",
                        "int vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tif (!param->key)",
                        "\t\treturn invalf(fc, \"Unnamed parameter\\n\");",
                        "",
                        "\tret = vfs_parse_sb_flag(fc, param->key);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\treturn ret;",
                        "",
                        "\tret = security_fs_context_parse_param(fc, param);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\t/* Param belongs to the LSM or is disallowed by the LSM; so",
                        "\t\t * don't pass to the FS.",
                        "\t\t */",
                        "\t\treturn ret;",
                        "",
                        "\tif (fc->ops->parse_param) {",
                        "\t\tret = fc->ops->parse_param(fc, param);",
                        "\t\tif (ret != -ENOPARAM)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "",
                        "\t/* If the filesystem doesn't take any arguments, give it the",
                        "\t * default handling of source.",
                        "\t */",
                        "\tif (strcmp(param->key, \"source\") == 0) {",
                        "\t\tif (param->type != fs_value_is_string)",
                        "\t\t\treturn invalf(fc, \"VFS: Non-string source\");",
                        "\t\tif (fc->source)",
                        "\t\t\treturn invalf(fc, \"VFS: Multiple sources\");",
                        "\t\tfc->source = param->string;",
                        "\t\tparam->string = NULL;",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\treturn invalf(fc, \"%s: Unknown parameter '%s'\",",
                        "\t\t      fc->fs_type->name, param->key);",
                        "}"
                    ],
                    "start": 82,
                    "highlight": 117
                },
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=325d0eab4f31#n98",
                    "code": [
                        "/**",
                        " * vfs_parse_fs_param - Add a single parameter to a superblock config",
                        " * @fc: The filesystem context to modify",
                        " * @param: The parameter",
                        " *",
                        " * A single mount option in string form is applied to the filesystem context",
                        " * being set up.  Certain standard options (for example \"ro\") are translated",
                        " * into flag bits without going to the filesystem.  The active security module",
                        " * is allowed to observe and poach options.  Any other options are passed over",
                        " * to the filesystem to parse.",
                        " *",
                        " * This may be called multiple times for a context.",
                        " *",
                        " * Returns 0 on success and a negative error code on failure.  In the event of",
                        " * failure, supplementary error information may have been set.",
                        " */",
                        "int vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tif (!param->key)",
                        "\t\treturn invalf(fc, \"Unnamed parameter\\n\");",
                        "",
                        "\tret = vfs_parse_sb_flag(fc, param->key);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\treturn ret;",
                        "",
                        "\tret = security_fs_context_parse_param(fc, param);",
                        "\tif (ret != -ENOPARAM)",
                        "\t\t/* Param belongs to the LSM or is disallowed by the LSM; so",
                        "\t\t * don't pass to the FS.",
                        "\t\t */",
                        "\t\treturn ret;",
                        "",
                        "\tif (fc->ops->parse_param) {",
                        "\t\tret = fc->ops->parse_param(fc, param);",
                        "\t\tif (ret != -ENOPARAM)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "",
                        "\t/* If the filesystem doesn't take any arguments, give it the",
                        "\t * default handling of source.",
                        "\t */",
                        "\tif (strcmp(param->key, \"source\") == 0) {",
                        "\t\tif (param->type != fs_value_is_string)",
                        "\t\t\treturn invalf(fc, \"VFS: Non-string source\");",
                        "\t\tif (fc->source)",
                        "\t\t\treturn invalf(fc, \"VFS: Multiple sources\");",
                        "\t\tfc->source = param->string;",
                        "\t\tparam->string = NULL;",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\treturn invalf(fc, \"%s: Unknown parameter '%s'\",",
                        "\t\t      fc->fs_type->name, param->key);",
                        "}"
                    ],
                    "start": 82,
                    "highlight": 98
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81223b9e"
        },
        "723": {
            "name": "vfs_parse_fs_param",
            "parent_idx": 715,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=325d0eab4f31#n161",
                    "code": [
                        "/**",
                        " * vfs_parse_fs_string - Convenience function to just parse a string.",
                        " */",
                        "int vfs_parse_fs_string(struct fs_context *fc, const char *key,",
                        "\t\t\tconst char *value, size_t v_size)",
                        "{",
                        "\tint ret;",
                        "",
                        "\tstruct fs_parameter param = {",
                        "\t\t.key\t= key,",
                        "\t\t.type\t= fs_value_is_flag,",
                        "\t\t.size\t= v_size,",
                        "\t};",
                        "",
                        "\tif (value) {",
                        "\t\tparam.string = kmemdup_nul(value, v_size, GFP_KERNEL);",
                        "\t\tif (!param.string)",
                        "\t\t\treturn -ENOMEM;",
                        "\t\tparam.type = fs_value_is_string;",
                        "\t}",
                        "",
                        "\tret = vfs_parse_fs_param(fc, &param);",
                        "\tkfree(param.string);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 140,
                    "highlight": 161
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81223ced"
        },
        "715": {
            "name": "vfs_parse_fs_string",
            "parent_idx": 706,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=325d0eab4f31#n201",
                    "code": [
                        "/**",
                        " * generic_parse_monolithic - Parse key[=val][,key[=val]]* mount data",
                        " * @ctx: The superblock configuration to fill in.",
                        " * @data: The data to parse",
                        " *",
                        " * Parse a blob of data that's in key[=val][,key[=val]]* form.  This can be",
                        " * called from the ->monolithic_mount_data() fs_context operation.",
                        " *",
                        " * Returns 0 on success or the error returned by the ->parse_option() fs_context",
                        " * operation on failure.",
                        " */",
                        "int generic_parse_monolithic(struct fs_context *fc, void *data)",
                        "{",
                        "\tchar *options = data, *key;",
                        "\tint ret = 0;",
                        "",
                        "\tif (!options)",
                        "\t\treturn 0;",
                        "",
                        "\tret = security_sb_eat_lsm_opts(options, &fc->security);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "",
                        "\twhile ((key = strsep(&options, \",\")) != NULL) {",
                        "\t\tif (*key) {",
                        "\t\t\tsize_t v_len = 0;",
                        "\t\t\tchar *value = strchr(key, '=');",
                        "",
                        "\t\t\tif (value) {",
                        "\t\t\t\tif (value == key)",
                        "\t\t\t\t\tcontinue;",
                        "\t\t\t\t*value++ = 0;",
                        "\t\t\t\tv_len = strlen(value);",
                        "\t\t\t}",
                        "\t\t\tret = vfs_parse_fs_string(fc, key, value, v_len);",
                        "\t\t\tif (ret < 0)",
                        "\t\t\t\tbreak;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 167,
                    "highlight": 201
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81223db9"
        },
        "706": {
            "name": "parse_monolithic_mount_data",
            "parent_idx": 684,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=325d0eab4f31#n2871",
                    "code": [
                        "/*",
                        " * create a new mount for userspace and request it to be added into the",
                        " * namespace's tree",
                        " */",
                        "static int do_new_mount(struct path *path, const char *fstype, int sb_flags,",
                        "\t\t\tint mnt_flags, const char *name, void *data)",
                        "{",
                        "\tstruct file_system_type *type;",
                        "\tstruct fs_context *fc;",
                        "\tconst char *subtype = NULL;",
                        "\tint err = 0;",
                        "",
                        "\tif (!fstype)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\ttype = get_fs_type(fstype);",
                        "\tif (!type)",
                        "\t\treturn -ENODEV;",
                        "",
                        "\tif (type->fs_flags & FS_HAS_SUBTYPE) {",
                        "\t\tsubtype = strchr(fstype, '.');",
                        "\t\tif (subtype) {",
                        "\t\t\tsubtype++;",
                        "\t\t\tif (!*subtype) {",
                        "\t\t\t\tput_filesystem(type);",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tfc = fs_context_for_mount(type, sb_flags);",
                        "\tput_filesystem(type);",
                        "\tif (IS_ERR(fc))",
                        "\t\treturn PTR_ERR(fc);",
                        "",
                        "\tif (subtype)",
                        "\t\terr = vfs_parse_fs_string(fc, \"subtype\",",
                        "\t\t\t\t\t  subtype, strlen(subtype));",
                        "\tif (!err && name)",
                        "\t\terr = vfs_parse_fs_string(fc, \"source\", name, strlen(name));",
                        "\tif (!err)",
                        "\t\terr = parse_monolithic_mount_data(fc, data);",
                        "\tif (!err && !mount_capable(fc))",
                        "\t\terr = -EPERM;",
                        "\tif (!err)",
                        "\t\terr = vfs_get_tree(fc);",
                        "\tif (!err)",
                        "\t\terr = do_new_mount_fc(fc, path, mnt_flags);",
                        "",
                        "\tput_fs_context(fc);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2830,
                    "highlight": 2871
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=325d0eab4f31#n3192",
                    "code": [
                        "/*",
                        " * Flags is a 32-bit value that allows up to 31 non-fs dependent flags to",
                        " * be given to the mount() call (ie: read-only, no-dev, no-suid etc).",
                        " *",
                        " * data is a (void *) that can point to any structure up to",
                        " * PAGE_SIZE-1 bytes, which can contain arbitrary fs-dependent",
                        " * information (or be NULL).",
                        " *",
                        " * Pre-0.97 versions of mount() didn't have a flags word.",
                        " * When the flags word was introduced its top half was required",
                        " * to have the magic value 0xC0ED, and this remained so until 2.4.0-test9.",
                        " * Therefore, if this magic number is present, it carries no information",
                        " * and must be discarded.",
                        " */",
                        "int path_mount(const char *dev_name, struct path *path,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tunsigned int mnt_flags = 0, sb_flags;",
                        "\tint ret;",
                        "",
                        "\t/* Discard magic */",
                        "\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)",
                        "\t\tflags &= ~MS_MGC_MSK;",
                        "",
                        "\t/* Basic sanity checks */",
                        "\tif (data_page)",
                        "\t\t((char *)data_page)[PAGE_SIZE - 1] = 0;",
                        "",
                        "\tif (flags & MS_NOUSER)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tret = security_sb_mount(dev_name, path, type_page, flags, data_page);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tif (!may_mount())",
                        "\t\treturn -EPERM;",
                        "\tif ((flags & SB_MANDLOCK) && !may_mandlock())",
                        "\t\treturn -EPERM;",
                        "",
                        "\t/* Default to relatime unless overriden */",
                        "\tif (!(flags & MS_NOATIME))",
                        "\t\tmnt_flags |= MNT_RELATIME;",
                        "",
                        "\t/* Separate the per-mountpoint flags */",
                        "\tif (flags & MS_NOSUID)",
                        "\t\tmnt_flags |= MNT_NOSUID;",
                        "\tif (flags & MS_NODEV)",
                        "\t\tmnt_flags |= MNT_NODEV;",
                        "\tif (flags & MS_NOEXEC)",
                        "\t\tmnt_flags |= MNT_NOEXEC;",
                        "\tif (flags & MS_NOATIME)",
                        "\t\tmnt_flags |= MNT_NOATIME;",
                        "\tif (flags & MS_NODIRATIME)",
                        "\t\tmnt_flags |= MNT_NODIRATIME;",
                        "\tif (flags & MS_STRICTATIME)",
                        "\t\tmnt_flags &= ~(MNT_RELATIME | MNT_NOATIME);",
                        "\tif (flags & MS_RDONLY)",
                        "\t\tmnt_flags |= MNT_READONLY;",
                        "",
                        "\t/* The default atime for remount is preservation */",
                        "\tif ((flags & MS_REMOUNT) &&",
                        "\t    ((flags & (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |",
                        "\t\t       MS_STRICTATIME)) == 0)) {",
                        "\t\tmnt_flags &= ~MNT_ATIME_MASK;",
                        "\t\tmnt_flags |= path->mnt->mnt_flags & MNT_ATIME_MASK;",
                        "\t}",
                        "",
                        "\tsb_flags = flags & (SB_RDONLY |",
                        "\t\t\t    SB_SYNCHRONOUS |",
                        "\t\t\t    SB_MANDLOCK |",
                        "\t\t\t    SB_DIRSYNC |",
                        "\t\t\t    SB_SILENT |",
                        "\t\t\t    SB_POSIXACL |",
                        "\t\t\t    SB_LAZYTIME |",
                        "\t\t\t    SB_I_VERSION);",
                        "",
                        "\tif ((flags & (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND))",
                        "\t\treturn do_reconfigure_mnt(path, mnt_flags);",
                        "\tif (flags & MS_REMOUNT)",
                        "\t\treturn do_remount(path, flags, sb_flags, mnt_flags, data_page);",
                        "\tif (flags & MS_BIND)",
                        "\t\treturn do_loopback(path, dev_name, flags & MS_REC);",
                        "\tif (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))",
                        "\t\treturn do_change_type(path, flags);",
                        "\tif (flags & MS_MOVE)",
                        "\t\treturn do_move_mount_old(path, dev_name);",
                        "",
                        "\treturn do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,",
                        "\t\t\t    data_page);",
                        "}"
                    ],
                    "start": 3105,
                    "highlight": 3192
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff812100ce"
        },
        "684": {
            "name": "path_mount",
            "parent_idx": 665,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=325d0eab4f31#n3205",
                    "code": [
                        "long do_mount(const char *dev_name, const char __user *dir_name,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tstruct path path;",
                        "\tint ret;",
                        "",
                        "\tret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &path);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tret = path_mount(dev_name, &path, type_page, flags, data_page);",
                        "\tpath_put(&path);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3196,
                    "highlight": 3205
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=325d0eab4f31#n3413",
                    "code": [
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3390,
                    "highlight": 3413
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=325d0eab4f31#n3390",
                    "code": [
                        "struct dentry *mount_subtree(struct vfsmount *m, const char *name)",
                        "{",
                        "\tstruct mount *mnt = real_mount(m);",
                        "\tstruct mnt_namespace *ns;",
                        "\tstruct super_block *s;",
                        "\tstruct path path;",
                        "\tint err;",
                        "",
                        "\tns = alloc_mnt_ns(&init_user_ns, true);",
                        "\tif (IS_ERR(ns)) {",
                        "\t\tmntput(m);",
                        "\t\treturn ERR_CAST(ns);",
                        "\t}",
                        "\tmnt->mnt_ns = ns;",
                        "\tns->root = mnt;",
                        "\tns->mounts++;",
                        "\tlist_add(&mnt->mnt_list, &ns->list);",
                        "",
                        "\terr = vfs_path_lookup(m->mnt_root, m,",
                        "\t\t\tname, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);",
                        "",
                        "\tput_mnt_ns(ns);",
                        "",
                        "\tif (err)",
                        "\t\treturn ERR_PTR(err);",
                        "",
                        "\t/* trade a vfsmount reference for active sb one */",
                        "\ts = path.mnt->mnt_sb;",
                        "\tatomic_inc(&s->s_active);",
                        "\tmntput(path.mnt);",
                        "\t/* lock the sucker */",
                        "\tdown_write(&s->s_umount);",
                        "\t/* ... and return the root of (sub)tree on it */",
                        "\treturn path.dentry;",
                        "}",
                        "EXPORT_SYMBOL(mount_subtree);",
                        "",
                        "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,",
                        "\t\tchar __user *, type, unsigned long, flags, void __user *, data)",
                        "{",
                        "\tint ret;",
                        "\tchar *kernel_type;",
                        "\tchar *kernel_dev;",
                        "\tvoid *options;",
                        "",
                        "\tkernel_type = copy_mount_string(type);",
                        "\tret = PTR_ERR(kernel_type);",
                        "\tif (IS_ERR(kernel_type))",
                        "\t\tgoto out_type;",
                        "",
                        "\tkernel_dev = copy_mount_string(dev_name);",
                        "\tret = PTR_ERR(kernel_dev);",
                        "\tif (IS_ERR(kernel_dev))",
                        "\t\tgoto out_dev;",
                        "",
                        "\toptions = copy_mount_options(data);",
                        "\tret = PTR_ERR(options);",
                        "\tif (IS_ERR(options))",
                        "\t\tgoto out_data;",
                        "",
                        "\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);",
                        "",
                        "\tkfree(options);",
                        "out_data:",
                        "\tkfree(kernel_dev);",
                        "out_dev:",
                        "\tkfree(kernel_type);",
                        "out_type:",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 3353,
                    "highlight": 3390
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81210959"
        },
        "665": {
            "name": "__x64_sys_mount(indirect)",
            "parent_idx": 664,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=325d0eab4f31#n46",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tnr = syscall_enter_from_user_mode(regs, nr);",
                        "",
                        "\tinstrumentation_begin();",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "\tinstrumentation_end();",
                        "\tsyscall_exit_to_user_mode(regs);",
                        "}"
                    ],
                    "start": 38,
                    "highlight": 46
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81b6b5ee"
        },
        "664": {
            "name": "do_syscall_64",
            "parent_idx": 663,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=325d0eab4f31#n118",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "\tUNWIND_HINT_EMPTY",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 95,
                    "highlight": 118
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81c00077"
        },
        "663": {
            "name": "89_syscall_5",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "752": {
            "name": "+0x49",
            "parent_idx": 744,
            "source_line": [
                {
                    "file": "fs/jffs2/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jffs2/super.c?id=325d0eab4f31#n206",
                    "code": [
                        "static int jffs2_parse_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tstruct fs_parse_result result;",
                        "\tstruct jffs2_sb_info *c = fc->s_fs_info;",
                        "\tint opt;",
                        "",
                        "\topt = fs_parse(fc, jffs2_fs_parameters, param, &result);",
                        "\tif (opt < 0)",
                        "\t\treturn opt;",
                        "",
                        "\tswitch (opt) {",
                        "\tcase Opt_override_compr:",
                        "\t\tc->mount_opts.compr = result.uint_32;",
                        "\t\tc->mount_opts.override_compr = true;",
                        "\t\tbreak;",
                        "\tcase Opt_rp_size:",
                        "\t\tif (result.uint_32 > UINT_MAX / 1024)",
                        "\t\t\treturn invalf(fc, \"jffs2: rp_size unrepresentable\");",
                        "\t\topt = result.uint_32 * 1024;",
                        "\t\tif (opt > c->mtd->size)",
                        "\t\t\treturn invalf(fc, \"jffs2: Too large reserve pool specified, max is %llu KB\",",
                        "\t\t\t\t      c->mtd->size / 1024);",
                        "\t\tc->mount_opts.rp_size = opt;",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 187,
                    "highlight": 206
                }
            ],
            "ins_idx": 28,
            "addr": "0xffffffff8136a169"
        },
        "701": {
            "name": "+0x0",
            "parent_idx": 700,
            "source_line": [
                {
                    "file": "mm/slub.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/slub.c?id=325d0eab4f31#n2926",
                    "code": [
                        "#ifdef CONFIG_TRACING",
                        "void *kmem_cache_alloc_trace(struct kmem_cache *s, gfp_t gfpflags, size_t size)",
                        "{",
                        "\tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_);",
                        "\ttrace_kmalloc(_RET_IP_, ret, size, s->size, gfpflags);",
                        "\tret = kasan_kmalloc(s, ret, size, gfpflags);",
                        "\treturn ret;",
                        "}",
                        "EXPORT_SYMBOL(kmem_cache_alloc_trace);",
                        "#endif",
                        "",
                        "#ifdef CONFIG_NUMA",
                        "void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)",
                        "{",
                        "\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);",
                        "",
                        "\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,",
                        "\t\t\t\t    s->object_size, s->size, gfpflags, node);",
                        "",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 2914,
                    "highlight": 2926
                }
            ],
            "ins_idx": 47,
            "addr": "0xffffffff811db920"
        },
        "700": {
            "name": "kmem_cache_alloc_trace",
            "parent_idx": 697,
            "source_line": [
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=325d0eab4f31#n554",
                    "code": [
                        "/**",
                        " * kmalloc - allocate memory",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate.",
                        " *",
                        " * kmalloc is the normal method of allocating memory",
                        " * for objects smaller than page size in the kernel.",
                        " *",
                        " * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN",
                        " * bytes. For @size of power of two bytes, the alignment is also guaranteed",
                        " * to be at least to the size.",
                        " *",
                        " * The @flags argument may be one of the GFP flags defined at",
                        " * include/linux/gfp.h and described at",
                        " * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`",
                        " *",
                        " * The recommended usage of the @flags is described at",
                        " * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`",
                        " *",
                        " * Below is a brief outline of the most useful GFP flags",
                        " *",
                        " * %GFP_KERNEL",
                        " *\tAllocate normal kernel ram. May sleep.",
                        " *",
                        " * %GFP_NOWAIT",
                        " *\tAllocation will not sleep.",
                        " *",
                        " * %GFP_ATOMIC",
                        " *\tAllocation will not sleep.  May use emergency pools.",
                        " *",
                        " * %GFP_HIGHUSER",
                        " *\tAllocate memory from high memory on behalf of user.",
                        " *",
                        " * Also it is possible to set different flags by OR'ing",
                        " * in one or more of the following additional @flags:",
                        " *",
                        " * %__GFP_HIGH",
                        " *\tThis allocation has high priority and may use emergency pools.",
                        " *",
                        " * %__GFP_NOFAIL",
                        " *\tIndicate that this allocation is in no way allowed to fail",
                        " *\t(think twice before using).",
                        " *",
                        " * %__GFP_NORETRY",
                        " *\tIf memory is not immediately available,",
                        " *\tthen give up at once.",
                        " *",
                        " * %__GFP_NOWARN",
                        " *\tIf allocation fails, don't issue any warnings.",
                        " *",
                        " * %__GFP_RETRY_MAYFAIL",
                        " *\tTry really hard to succeed the allocation but fail",
                        " *\teventually.",
                        " */",
                        "static __always_inline void *kmalloc(size_t size, gfp_t flags)",
                        "{",
                        "\tif (__builtin_constant_p(size)) {",
                        "#ifndef CONFIG_SLOB",
                        "\t\tunsigned int index;",
                        "#endif",
                        "\t\tif (size > KMALLOC_MAX_CACHE_SIZE)",
                        "\t\t\treturn kmalloc_large(size, flags);",
                        "#ifndef CONFIG_SLOB",
                        "\t\tindex = kmalloc_index(size);",
                        "",
                        "\t\tif (!index)",
                        "\t\t\treturn ZERO_SIZE_PTR;",
                        "",
                        "\t\treturn kmem_cache_alloc_trace(",
                        "\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],",
                        "\t\t\t\tflags, size);",
                        "#endif",
                        "\t}",
                        "\treturn __kmalloc(size, flags);",
                        "}"
                    ],
                    "start": 486,
                    "highlight": 554
                },
                {
                    "file": "./include/linux/slab.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/slab.h?id=325d0eab4f31#n666",
                    "code": [
                        "/**",
                        " * kzalloc - allocate memory. The memory is set to zero.",
                        " * @size: how many bytes of memory are required.",
                        " * @flags: the type of memory to allocate (see kmalloc).",
                        " */",
                        "static inline void *kzalloc(size_t size, gfp_t flags)",
                        "{",
                        "\treturn kmalloc(size, flags | __GFP_ZERO);",
                        "}"
                    ],
                    "start": 659,
                    "highlight": 666
                },
                {
                    "file": "fs/jffs2/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jffs2/super.c?id=325d0eab4f31#n292",
                    "code": [
                        "static int jffs2_init_fs_context(struct fs_context *fc)",
                        "{",
                        "\tstruct jffs2_sb_info *ctx;",
                        "",
                        "\tctx = kzalloc(sizeof(struct jffs2_sb_info), GFP_KERNEL);",
                        "\tif (!ctx)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tfc->s_fs_info = ctx;",
                        "\tfc->ops = &jffs2_context_ops;",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 288,
                    "highlight": 292
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8136a265"
        },
        "697": {
            "name": "jffs2_init_fs_context(indirect)",
            "parent_idx": 685,
            "source_line": [
                {
                    "file": "fs/fs_context.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_context.c?id=325d0eab4f31#n267",
                    "code": [
                        "/**",
                        " * alloc_fs_context - Create a filesystem context.",
                        " * @fs_type: The filesystem type.",
                        " * @reference: The dentry from which this one derives (or NULL)",
                        " * @sb_flags: Filesystem/superblock flags (SB_*)",
                        " * @sb_flags_mask: Applicable members of @sb_flags",
                        " * @purpose: The purpose that this configuration shall be used for.",
                        " *",
                        " * Open a filesystem and create a mount context.  The mount context is",
                        " * initialised with the supplied flags and, if a submount/automount from",
                        " * another superblock (referred to by @reference) is supplied, may have",
                        " * parameters such as namespaces copied across from that superblock.",
                        " */",
                        "static struct fs_context *alloc_fs_context(struct file_system_type *fs_type,",
                        "\t\t\t\t      struct dentry *reference,",
                        "\t\t\t\t      unsigned int sb_flags,",
                        "\t\t\t\t      unsigned int sb_flags_mask,",
                        "\t\t\t\t      enum fs_context_purpose purpose)",
                        "{",
                        "\tint (*init_fs_context)(struct fs_context *);",
                        "\tstruct fs_context *fc;",
                        "\tint ret = -ENOMEM;",
                        "",
                        "\tfc = kzalloc(sizeof(struct fs_context), GFP_KERNEL);",
                        "\tif (!fc)",
                        "\t\treturn ERR_PTR(-ENOMEM);",
                        "",
                        "\tfc->purpose\t= purpose;",
                        "\tfc->sb_flags\t= sb_flags;",
                        "\tfc->sb_flags_mask = sb_flags_mask;",
                        "\tfc->fs_type\t= get_filesystem(fs_type);",
                        "\tfc->cred\t= get_current_cred();",
                        "\tfc->net_ns\t= get_net(current->nsproxy->net_ns);",
                        "\tfc->log.prefix\t= fs_type->name;",
                        "",
                        "\tmutex_init(&fc->uapi_mutex);",
                        "",
                        "\tswitch (purpose) {",
                        "\tcase FS_CONTEXT_FOR_MOUNT:",
                        "\t\tfc->user_ns = get_user_ns(fc->cred->user_ns);",
                        "\t\tbreak;",
                        "\tcase FS_CONTEXT_FOR_SUBMOUNT:",
                        "\t\tfc->user_ns = get_user_ns(reference->d_sb->s_user_ns);",
                        "\t\tbreak;",
                        "\tcase FS_CONTEXT_FOR_RECONFIGURE:",
                        "\t\tatomic_inc(&reference->d_sb->s_active);",
                        "\t\tfc->user_ns = get_user_ns(reference->d_sb->s_user_ns);",
                        "\t\tfc->root = dget(reference);",
                        "\t\tbreak;",
                        "\t}",
                        "",
                        "\t/* TODO: Make all filesystems support this unconditionally */",
                        "\tinit_fs_context = fc->fs_type->init_fs_context;",
                        "\tif (!init_fs_context)",
                        "\t\tinit_fs_context = legacy_init_fs_context;",
                        "",
                        "\tret = init_fs_context(fc);",
                        "\tif (ret < 0)",
                        "\t\tgoto err_fc;",
                        "\tfc->need_free = true;",
                        "\treturn fc;",
                        "",
                        "err_fc:",
                        "\tput_fs_context(fc);",
                        "\treturn ERR_PTR(ret);",
                        "}"
                    ],
                    "start": 211,
                    "highlight": 267
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81224224"
        },
        "685": {
            "name": "fs_context_for_mount",
            "parent_idx": 684,
            "source_line": [
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=325d0eab4f31#n2860",
                    "code": [
                        "/*",
                        " * create a new mount for userspace and request it to be added into the",
                        " * namespace's tree",
                        " */",
                        "static int do_new_mount(struct path *path, const char *fstype, int sb_flags,",
                        "\t\t\tint mnt_flags, const char *name, void *data)",
                        "{",
                        "\tstruct file_system_type *type;",
                        "\tstruct fs_context *fc;",
                        "\tconst char *subtype = NULL;",
                        "\tint err = 0;",
                        "",
                        "\tif (!fstype)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\ttype = get_fs_type(fstype);",
                        "\tif (!type)",
                        "\t\treturn -ENODEV;",
                        "",
                        "\tif (type->fs_flags & FS_HAS_SUBTYPE) {",
                        "\t\tsubtype = strchr(fstype, '.');",
                        "\t\tif (subtype) {",
                        "\t\t\tsubtype++;",
                        "\t\t\tif (!*subtype) {",
                        "\t\t\t\tput_filesystem(type);",
                        "\t\t\t\treturn -EINVAL;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tfc = fs_context_for_mount(type, sb_flags);",
                        "\tput_filesystem(type);",
                        "\tif (IS_ERR(fc))",
                        "\t\treturn PTR_ERR(fc);",
                        "",
                        "\tif (subtype)",
                        "\t\terr = vfs_parse_fs_string(fc, \"subtype\",",
                        "\t\t\t\t\t  subtype, strlen(subtype));",
                        "\tif (!err && name)",
                        "\t\terr = vfs_parse_fs_string(fc, \"source\", name, strlen(name));",
                        "\tif (!err)",
                        "\t\terr = parse_monolithic_mount_data(fc, data);",
                        "\tif (!err && !mount_capable(fc))",
                        "\t\terr = -EPERM;",
                        "\tif (!err)",
                        "\t\terr = vfs_get_tree(fc);",
                        "\tif (!err)",
                        "\t\terr = do_new_mount_fc(fc, path, mnt_flags);",
                        "",
                        "\tput_fs_context(fc);",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2830,
                    "highlight": 2860
                },
                {
                    "file": "fs/namespace.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/namespace.c?id=325d0eab4f31#n3192",
                    "code": [
                        "/*",
                        " * Flags is a 32-bit value that allows up to 31 non-fs dependent flags to",
                        " * be given to the mount() call (ie: read-only, no-dev, no-suid etc).",
                        " *",
                        " * data is a (void *) that can point to any structure up to",
                        " * PAGE_SIZE-1 bytes, which can contain arbitrary fs-dependent",
                        " * information (or be NULL).",
                        " *",
                        " * Pre-0.97 versions of mount() didn't have a flags word.",
                        " * When the flags word was introduced its top half was required",
                        " * to have the magic value 0xC0ED, and this remained so until 2.4.0-test9.",
                        " * Therefore, if this magic number is present, it carries no information",
                        " * and must be discarded.",
                        " */",
                        "int path_mount(const char *dev_name, struct path *path,",
                        "\t\tconst char *type_page, unsigned long flags, void *data_page)",
                        "{",
                        "\tunsigned int mnt_flags = 0, sb_flags;",
                        "\tint ret;",
                        "",
                        "\t/* Discard magic */",
                        "\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)",
                        "\t\tflags &= ~MS_MGC_MSK;",
                        "",
                        "\t/* Basic sanity checks */",
                        "\tif (data_page)",
                        "\t\t((char *)data_page)[PAGE_SIZE - 1] = 0;",
                        "",
                        "\tif (flags & MS_NOUSER)",
                        "\t\treturn -EINVAL;",
                        "",
                        "\tret = security_sb_mount(dev_name, path, type_page, flags, data_page);",
                        "\tif (ret)",
                        "\t\treturn ret;",
                        "\tif (!may_mount())",
                        "\t\treturn -EPERM;",
                        "\tif ((flags & SB_MANDLOCK) && !may_mandlock())",
                        "\t\treturn -EPERM;",
                        "",
                        "\t/* Default to relatime unless overriden */",
                        "\tif (!(flags & MS_NOATIME))",
                        "\t\tmnt_flags |= MNT_RELATIME;",
                        "",
                        "\t/* Separate the per-mountpoint flags */",
                        "\tif (flags & MS_NOSUID)",
                        "\t\tmnt_flags |= MNT_NOSUID;",
                        "\tif (flags & MS_NODEV)",
                        "\t\tmnt_flags |= MNT_NODEV;",
                        "\tif (flags & MS_NOEXEC)",
                        "\t\tmnt_flags |= MNT_NOEXEC;",
                        "\tif (flags & MS_NOATIME)",
                        "\t\tmnt_flags |= MNT_NOATIME;",
                        "\tif (flags & MS_NODIRATIME)",
                        "\t\tmnt_flags |= MNT_NODIRATIME;",
                        "\tif (flags & MS_STRICTATIME)",
                        "\t\tmnt_flags &= ~(MNT_RELATIME | MNT_NOATIME);",
                        "\tif (flags & MS_RDONLY)",
                        "\t\tmnt_flags |= MNT_READONLY;",
                        "",
                        "\t/* The default atime for remount is preservation */",
                        "\tif ((flags & MS_REMOUNT) &&",
                        "\t    ((flags & (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |",
                        "\t\t       MS_STRICTATIME)) == 0)) {",
                        "\t\tmnt_flags &= ~MNT_ATIME_MASK;",
                        "\t\tmnt_flags |= path->mnt->mnt_flags & MNT_ATIME_MASK;",
                        "\t}",
                        "",
                        "\tsb_flags = flags & (SB_RDONLY |",
                        "\t\t\t    SB_SYNCHRONOUS |",
                        "\t\t\t    SB_MANDLOCK |",
                        "\t\t\t    SB_DIRSYNC |",
                        "\t\t\t    SB_SILENT |",
                        "\t\t\t    SB_POSIXACL |",
                        "\t\t\t    SB_LAZYTIME |",
                        "\t\t\t    SB_I_VERSION);",
                        "",
                        "\tif ((flags & (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND))",
                        "\t\treturn do_reconfigure_mnt(path, mnt_flags);",
                        "\tif (flags & MS_REMOUNT)",
                        "\t\treturn do_remount(path, flags, sb_flags, mnt_flags, data_page);",
                        "\tif (flags & MS_BIND)",
                        "\t\treturn do_loopback(path, dev_name, flags & MS_REC);",
                        "\tif (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))",
                        "\t\treturn do_change_type(path, flags);",
                        "\tif (flags & MS_MOVE)",
                        "\t\treturn do_move_mount_old(path, dev_name);",
                        "",
                        "\treturn do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,",
                        "\t\t\t    data_page);",
                        "}"
                    ],
                    "start": 3105,
                    "highlight": 3192
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8121027e"
        },
        "751": {
            "name": "+0xab",
            "parent_idx": 747,
            "source_line": [
                {
                    "file": "fs/fs_parser.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_parser.c?id=325d0eab4f31#n133",
                    "code": [
                        "/*",
                        " * fs_parse - Parse a filesystem configuration parameter",
                        " * @fc: The filesystem context to log errors through.",
                        " * @desc: The parameter description to use.",
                        " * @param: The parameter.",
                        " * @result: Where to place the result of the parse",
                        " *",
                        " * Parse a filesystem configuration parameter and attempt a conversion for a",
                        " * simple parameter for which this is requested.  If successful, the determined",
                        " * parameter ID is placed into @result->key, the desired type is indicated in",
                        " * @result->t and any converted value is placed into an appropriate member of",
                        " * the union in @result.",
                        " *",
                        " * The function returns the parameter number if the parameter was matched,",
                        " * -ENOPARAM if it wasn't matched and @desc->ignore_unknown indicated that",
                        " * unknown parameters are okay and -EINVAL if there was a conversion issue or",
                        " * the parameter wasn't recognised and unknowns aren't okay.",
                        " */",
                        "int __fs_parse(struct p_log *log,",
                        "\t     const struct fs_parameter_spec *desc,",
                        "\t     struct fs_parameter *param,",
                        "\t     struct fs_parse_result *result)",
                        "{",
                        "\tconst struct fs_parameter_spec *p;",
                        "",
                        "\tresult->uint_64 = 0;",
                        "",
                        "\tp = fs_lookup_key(desc, param, &result->negated);",
                        "\tif (!p)",
                        "\t\treturn -ENOPARAM;",
                        "",
                        "\tif (p->flags & fs_param_deprecated)",
                        "\t\twarn_plog(log, \"Deprecated parameter '%s'\", param->key);",
                        "",
                        "\t/* Try to turn the type we were given into the type desired by the",
                        "\t * parameter and give an error if we can't.",
                        "\t */",
                        "\tif (is_flag(p)) {",
                        "\t\tif (param->type != fs_value_is_flag)",
                        "\t\t\treturn inval_plog(log, \"Unexpected value for '%s'\",",
                        "\t\t\t\t      param->key);",
                        "\t\tresult->boolean = !result->negated;",
                        "\t} else  {",
                        "\t\tint ret = p->type(log, p, param, result);",
                        "\t\tif (ret)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "\treturn p->opt;",
                        "}"
                    ],
                    "start": 85,
                    "highlight": 133
                }
            ],
            "ins_idx": 46,
            "addr": "0xffffffff8122469b"
        },
        "747": {
            "name": "__fs_parse",
            "parent_idx": 744,
            "source_line": [
                {
                    "file": "./include/linux/fs_parser.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/fs_parser.h?id=325d0eab4f31#n73",
                    "code": [
                        "static inline int fs_parse(struct fs_context *fc,",
                        "\t     const struct fs_parameter_spec *desc,",
                        "\t     struct fs_parameter *param,",
                        "\t     struct fs_parse_result *result)",
                        "{",
                        "\treturn __fs_parse(&fc->log, desc, param, result);",
                        "}"
                    ],
                    "start": 68,
                    "highlight": 73
                },
                {
                    "file": "fs/jffs2/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jffs2/super.c?id=325d0eab4f31#n193",
                    "code": [
                        "static int jffs2_parse_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tstruct fs_parse_result result;",
                        "\tstruct jffs2_sb_info *c = fc->s_fs_info;",
                        "\tint opt;",
                        "",
                        "\topt = fs_parse(fc, jffs2_fs_parameters, param, &result);",
                        "\tif (opt < 0)",
                        "\t\treturn opt;",
                        "",
                        "\tswitch (opt) {",
                        "\tcase Opt_override_compr:",
                        "\t\tc->mount_opts.compr = result.uint_32;",
                        "\t\tc->mount_opts.override_compr = true;",
                        "\t\tbreak;",
                        "\tcase Opt_rp_size:",
                        "\t\tif (result.uint_32 > UINT_MAX / 1024)",
                        "\t\t\treturn invalf(fc, \"jffs2: rp_size unrepresentable\");",
                        "\t\topt = result.uint_32 * 1024;",
                        "\t\tif (opt > c->mtd->size)",
                        "\t\t\treturn invalf(fc, \"jffs2: Too large reserve pool specified, max is %llu KB\",",
                        "\t\t\t\t      c->mtd->size / 1024);",
                        "\t\tc->mount_opts.rp_size = opt;",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 187,
                    "highlight": 193
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff8136a14e"
        },
        "749": {
            "name": "+0x8",
            "parent_idx": 747,
            "source_line": [
                {
                    "file": "fs/fs_parser.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/fs_parser.c?id=325d0eab4f31#n107",
                    "code": [
                        "/*",
                        " * fs_parse - Parse a filesystem configuration parameter",
                        " * @fc: The filesystem context to log errors through.",
                        " * @desc: The parameter description to use.",
                        " * @param: The parameter.",
                        " * @result: Where to place the result of the parse",
                        " *",
                        " * Parse a filesystem configuration parameter and attempt a conversion for a",
                        " * simple parameter for which this is requested.  If successful, the determined",
                        " * parameter ID is placed into @result->key, the desired type is indicated in",
                        " * @result->t and any converted value is placed into an appropriate member of",
                        " * the union in @result.",
                        " *",
                        " * The function returns the parameter number if the parameter was matched,",
                        " * -ENOPARAM if it wasn't matched and @desc->ignore_unknown indicated that",
                        " * unknown parameters are okay and -EINVAL if there was a conversion issue or",
                        " * the parameter wasn't recognised and unknowns aren't okay.",
                        " */",
                        "int __fs_parse(struct p_log *log,",
                        "\t     const struct fs_parameter_spec *desc,",
                        "\t     struct fs_parameter *param,",
                        "\t     struct fs_parse_result *result)",
                        "{",
                        "\tconst struct fs_parameter_spec *p;",
                        "",
                        "\tresult->uint_64 = 0;",
                        "",
                        "\tp = fs_lookup_key(desc, param, &result->negated);",
                        "\tif (!p)",
                        "\t\treturn -ENOPARAM;",
                        "",
                        "\tif (p->flags & fs_param_deprecated)",
                        "\t\twarn_plog(log, \"Deprecated parameter '%s'\", param->key);",
                        "",
                        "\t/* Try to turn the type we were given into the type desired by the",
                        "\t * parameter and give an error if we can't.",
                        "\t */",
                        "\tif (is_flag(p)) {",
                        "\t\tif (param->type != fs_value_is_flag)",
                        "\t\t\treturn inval_plog(log, \"Unexpected value for '%s'\",",
                        "\t\t\t\t      param->key);",
                        "\t\tresult->boolean = !result->negated;",
                        "\t} else  {",
                        "\t\tint ret = p->type(log, p, param, result);",
                        "\t\tif (ret)",
                        "\t\t\treturn ret;",
                        "\t}",
                        "\treturn p->opt;",
                        "}"
                    ],
                    "start": 85,
                    "highlight": 107
                }
            ],
            "ins_idx": 69,
            "addr": "0xffffffff812245f8"
        },
        "746": {
            "name": "+0x17",
            "parent_idx": 744,
            "source_line": [
                {
                    "file": "fs/jffs2/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jffs2/super.c?id=325d0eab4f31#n190",
                    "code": [
                        "static int jffs2_parse_param(struct fs_context *fc, struct fs_parameter *param)",
                        "{",
                        "\tstruct fs_parse_result result;",
                        "\tstruct jffs2_sb_info *c = fc->s_fs_info;",
                        "\tint opt;",
                        "",
                        "\topt = fs_parse(fc, jffs2_fs_parameters, param, &result);",
                        "\tif (opt < 0)",
                        "\t\treturn opt;",
                        "",
                        "\tswitch (opt) {",
                        "\tcase Opt_override_compr:",
                        "\t\tc->mount_opts.compr = result.uint_32;",
                        "\t\tc->mount_opts.override_compr = true;",
                        "\t\tbreak;",
                        "\tcase Opt_rp_size:",
                        "\t\tif (result.uint_32 > UINT_MAX / 1024)",
                        "\t\t\treturn invalf(fc, \"jffs2: rp_size unrepresentable\");",
                        "\t\topt = result.uint_32 * 1024;",
                        "\t\tif (opt > c->mtd->size)",
                        "\t\t\treturn invalf(fc, \"jffs2: Too large reserve pool specified, max is %llu KB\",",
                        "\t\t\t\t      c->mtd->size / 1024);",
                        "\t\tc->mount_opts.rp_size = opt;",
                        "\t\tbreak;",
                        "\tdefault:",
                        "\t\treturn -EINVAL;",
                        "\t}",
                        "",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 187,
                    "highlight": 190
                }
            ],
            "ins_idx": 96,
            "addr": "0xffffffff8136a137"
        },
        "702": {
            "name": "+0x1f",
            "parent_idx": 697,
            "source_line": [
                {
                    "file": "fs/jffs2/super.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/jffs2/super.c?id=325d0eab4f31#n296",
                    "code": [
                        "static int jffs2_init_fs_context(struct fs_context *fc)",
                        "{",
                        "\tstruct jffs2_sb_info *ctx;",
                        "",
                        "\tctx = kzalloc(sizeof(struct jffs2_sb_info), GFP_KERNEL);",
                        "\tif (!ctx)",
                        "\t\treturn -ENOMEM;",
                        "",
                        "\tfc->s_fs_info = ctx;",
                        "\tfc->ops = &jffs2_context_ops;",
                        "\treturn 0;",
                        "}"
                    ],
                    "start": 288,
                    "highlight": 296
                }
            ],
            "ins_idx": 124,
            "addr": "0xffffffff8136a26f"
        }
    },
    "ins": {
        "11": {
            "name": "mov r8, qword ptr [rdx + 8]",
            "desc": "Invalid Memory Access\nInvalid Base Address 0x8",
            "call_idx": 753,
            "inputs": [
                1149,
                1150
            ],
            "outputs": [
                1151
            ]
        },
        "28": {
            "name": "mov rdx, qword ptr [rbp]",
            "desc": "Heap Use Before Initialization",
            "call_idx": 752,
            "inputs": [
                1146,
                1147
            ],
            "outputs": [
                1148
            ]
        },
        "47": {
            "name": "push r15",
            "desc": "Source of base address MEMALLOC 0x0",
            "call_idx": 701,
            "inputs": [],
            "outputs": [
                1071
            ]
        },
        "46": {
            "name": "pop rbp",
            "desc": "",
            "call_idx": 751,
            "inputs": [
                1143,
                1144
            ],
            "outputs": [
                1145
            ]
        },
        "69": {
            "name": "push rbp",
            "desc": "",
            "call_idx": 749,
            "inputs": [
                1139,
                1140
            ],
            "outputs": [
                1141
            ]
        },
        "96": {
            "name": "mov rbp, qword ptr [rdi + 0x20]",
            "desc": "",
            "call_idx": 746,
            "inputs": [
                1135,
                1136
            ],
            "outputs": [
                1137
            ]
        },
        "124": {
            "name": "mov qword ptr [rbx + 0x80], rax",
            "desc": "",
            "call_idx": 702,
            "inputs": [
                1072,
                1073
            ],
            "outputs": [
                1074
            ]
        }
    },
    "data": {
        "1149": {
            "name": "RDX",
            "ins_idx": 11,
            "value": "0x0",
            "sources": []
        },
        "1150": {
            "name": "[0x8]",
            "ins_idx": 11,
            "value": "0x0",
            "sources": []
        },
        "1151": {
            "name": "R8",
            "ins_idx": 11,
            "value": "0x0",
            "sources": []
        },
        "1146": {
            "name": "RBP",
            "ins_idx": 28,
            "value": "0xffff88823629c000",
            "sources": []
        },
        "1147": {
            "name": "[0xffff88823629c000]",
            "ins_idx": 28,
            "value": "0x0",
            "sources": []
        },
        "1148": {
            "name": "RDX",
            "ins_idx": 28,
            "value": "0x0",
            "sources": [
                1149
            ]
        },
        "1071": {
            "name": "RAX",
            "ins_idx": 47,
            "value": "0xffff88823629c000",
            "sources": [
                1073
            ]
        },
        "1143": {
            "name": "RSP",
            "ins_idx": 46,
            "value": "0xffffc900002abda8",
            "sources": []
        },
        "1144": {
            "name": "[0xffffc900002abda8]",
            "ins_idx": 46,
            "value": "0xffff88823629c000",
            "sources": []
        },
        "1145": {
            "name": "RBP",
            "ins_idx": 46,
            "value": "0xffff88823629c000",
            "sources": [
                1146
            ]
        },
        "1139": {
            "name": "RSP",
            "ins_idx": 69,
            "value": "0xffffc900002abdb0",
            "sources": []
        },
        "1140": {
            "name": "RBP",
            "ins_idx": 69,
            "value": "0xffff88823629c000",
            "sources": []
        },
        "1141": {
            "name": "[0xffffc900002abda8]",
            "ins_idx": 69,
            "value": "0xffff88823629c000",
            "sources": [
                1144
            ]
        },
        "1135": {
            "name": "RDI",
            "ins_idx": 96,
            "value": "0xffff8882363f01e0",
            "sources": []
        },
        "1136": {
            "name": "[0xffff8882363f0200]",
            "ins_idx": 96,
            "value": "0xffff88823629c000",
            "sources": []
        },
        "1137": {
            "name": "RBP",
            "ins_idx": 96,
            "value": "0xffff88823629c000",
            "sources": [
                1140
            ]
        },
        "1072": {
            "name": "RBX",
            "ins_idx": 124,
            "value": "0xffff8882363f0180",
            "sources": []
        },
        "1073": {
            "name": "RAX",
            "ins_idx": 124,
            "value": "0xffff88823629c000",
            "sources": []
        },
        "1074": {
            "name": "[0xffff8882363f0200]",
            "ins_idx": 124,
            "value": "0xffff88823629c000",
            "sources": [
                1136
            ]
        }
    },
    "chain": {
        "11": [
            28
        ],
        "28": [
            47,
            46
        ],
        "46": [
            69
        ],
        "69": [
            96
        ],
        "96": [
            124
        ],
        "124": [
            47
        ]
    }
}