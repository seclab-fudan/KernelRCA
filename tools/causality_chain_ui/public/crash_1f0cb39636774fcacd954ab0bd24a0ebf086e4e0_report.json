{
    "report": "https://syzkaller.appspot.com/bug?id=1f0cb39636774fcacd954ab0bd24a0ebf086e4e0",
    "title": "KASAN: slab-out-of-bounds Read in skb_gso_transport_seglen",
    "call": {
        "13005": {
            "name": "+0xf0",
            "parent_idx": 13000,
            "source_line": [
                {
                    "file": "./include/linux/tcp.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/tcp.h?id=50cc09c18985eacbbd666acfd7be2391394733f5#n31",
                    "code": [
                        "static inline unsigned int __tcp_hdrlen(const struct tcphdr *th)",
                        "{",
                        "\treturn th->doff * 4;",
                        "}"
                    ],
                    "start": 29,
                    "highlight": 31
                },
                {
                    "file": "./include/linux/tcp.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/tcp.h?id=50cc09c18985eacbbd666acfd7be2391394733f5#n36",
                    "code": [
                        "static inline unsigned int tcp_hdrlen(const struct sk_buff *skb)",
                        "{",
                        "\treturn __tcp_hdrlen(tcp_hdr(skb));",
                        "}"
                    ],
                    "start": 34,
                    "highlight": 36
                },
                {
                    "file": "net/core/skbuff.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/skbuff.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n5266",
                    "code": [
                        "/**",
                        " * skb_gso_transport_seglen - Return length of individual segments of a gso packet",
                        " *",
                        " * @skb: GSO skb",
                        " *",
                        " * skb_gso_transport_seglen is used to determine the real size of the",
                        " * individual segments, including Layer4 headers (TCP/UDP).",
                        " *",
                        " * The MAC/L2 or network (IP, IPv6) headers are not accounted for.",
                        " */",
                        "static unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)",
                        "{",
                        "\tconst struct skb_shared_info *shinfo = skb_shinfo(skb);",
                        "\tunsigned int thlen = 0;",
                        "",
                        "\tif (skb->encapsulation) {",
                        "\t\tthlen = skb_inner_transport_header(skb) -",
                        "\t\t\tskb_transport_header(skb);",
                        "",
                        "\t\tif (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))",
                        "\t\t\tthlen += inner_tcp_hdrlen(skb);",
                        "\t} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {",
                        "\t\tthlen = tcp_hdrlen(skb);",
                        "\t} else if (unlikely(skb_is_gso_sctp(skb))) {",
                        "\t\tthlen = sizeof(struct sctphdr);",
                        "\t} else if (shinfo->gso_type & SKB_GSO_UDP_L4) {",
                        "\t\tthlen = sizeof(struct udphdr);",
                        "\t}",
                        "\t/* UFO sets gso_size to the size of the fragmentation",
                        "\t * payload, i.e. the size of the L4 (UDP) header is already",
                        "\t * accounted for.",
                        "\t */",
                        "\treturn thlen + shinfo->gso_size;",
                        "}"
                    ],
                    "start": 5244,
                    "highlight": 5266
                }
            ],
            "ins_idx": 138,
            "addr": "0xffffffff81e11550"
        },
        "13000": {
            "name": "skb_gso_transport_seglen",
            "parent_idx": 12997,
            "source_line": [
                {
                    "file": "net/core/skbuff.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/skbuff.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n5310",
                    "code": [
                        "/**",
                        " * skb_gso_mac_seglen - Return length of individual segments of a gso packet",
                        " *",
                        " * @skb: GSO skb",
                        " *",
                        " * skb_gso_mac_seglen is used to determine the real size of the",
                        " * individual segments, including MAC/L2, Layer3 (IP, IPv6) and L4",
                        " * headers (TCP/UDP).",
                        " */",
                        "static unsigned int skb_gso_mac_seglen(const struct sk_buff *skb)",
                        "{",
                        "\tunsigned int hdr_len = skb_transport_header(skb) - skb_mac_header(skb);",
                        "",
                        "\treturn hdr_len + skb_gso_transport_seglen(skb);",
                        "}"
                    ],
                    "start": 5297,
                    "highlight": 5310
                },
                {
                    "file": "net/core/skbuff.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/skbuff.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n5381",
                    "code": [
                        "/**",
                        " * skb_gso_validate_mac_len - Will a split GSO skb fit in a given length?",
                        " *",
                        " * @skb: GSO skb",
                        " * @len: length to validate against",
                        " *",
                        " * skb_gso_validate_mac_len validates if a given skb will fit a wanted",
                        " * length once split, including L2, L3 and L4 headers and the payload.",
                        " */",
                        "bool skb_gso_validate_mac_len(const struct sk_buff *skb, unsigned int len)",
                        "{",
                        "\treturn skb_gso_size_check(skb, skb_gso_mac_seglen(skb), len);",
                        "}"
                    ],
                    "start": 5370,
                    "highlight": 5381
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e1266e"
        },
        "12997": {
            "name": "skb_gso_validate_mac_len",
            "parent_idx": 12994,
            "source_line": [
                {
                    "file": "net/sched/sch_tbf.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/sched/sch_tbf.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n233",
                    "code": [
                        "static int tbf_enqueue(struct sk_buff *skb, struct Qdisc *sch,",
                        "\t\t       struct sk_buff **to_free)",
                        "{",
                        "\tstruct tbf_sched_data *q = qdisc_priv(sch);",
                        "\tunsigned int len = qdisc_pkt_len(skb);",
                        "\tint ret;",
                        "",
                        "\tif (qdisc_pkt_len(skb) > q->max_size) {",
                        "\t\tif (skb_is_gso(skb) &&",
                        "\t\t    skb_gso_validate_mac_len(skb, q->max_size))",
                        "\t\t\treturn tbf_segment(skb, sch, to_free);",
                        "\t\treturn qdisc_drop(skb, sch, to_free);",
                        "\t}",
                        "\tret = qdisc_enqueue(skb, q->qdisc, to_free);",
                        "\tif (ret != NET_XMIT_SUCCESS) {",
                        "\t\tif (net_xmit_drop_count(ret))",
                        "\t\t\tqdisc_qstats_drop(sch);",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\tsch->qstats.backlog += len;",
                        "\tsch->q.qlen++;",
                        "\treturn NET_XMIT_SUCCESS;",
                        "}"
                    ],
                    "start": 224,
                    "highlight": 233
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81ebbee8"
        },
        "12994": {
            "name": "tbf_enqueue(indirect)",
            "parent_idx": 12976,
            "source_line": [
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n3710",
                    "code": [
                        "static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,",
                        "\t\t\t\t struct net_device *dev,",
                        "\t\t\t\t struct netdev_queue *txq)",
                        "{",
                        "\tspinlock_t *root_lock = qdisc_lock(q);",
                        "\tstruct sk_buff *to_free = NULL;",
                        "\tbool contended;",
                        "\tint rc;",
                        "",
                        "\tqdisc_calculate_pkt_len(skb, q);",
                        "",
                        "\tif (q->flags & TCQ_F_NOLOCK) {",
                        "\t\trc = q->enqueue(skb, q, &to_free) & NET_XMIT_MASK;",
                        "\t\tqdisc_run(q);",
                        "",
                        "\t\tif (unlikely(to_free))",
                        "\t\t\tkfree_skb_list(to_free);",
                        "\t\treturn rc;",
                        "\t}",
                        "",
                        "\t/*",
                        "\t * Heuristic to force contended enqueues to serialize on a",
                        "\t * separate lock before trying to get qdisc main lock.",
                        "\t * This permits qdisc->running owner to get the lock more",
                        "\t * often and dequeue packets faster.",
                        "\t */",
                        "\tcontended = qdisc_is_running(q);",
                        "\tif (unlikely(contended))",
                        "\t\tspin_lock(&q->busylock);",
                        "",
                        "\tspin_lock(root_lock);",
                        "\tif (unlikely(test_bit(__QDISC_STATE_DEACTIVATED, &q->state))) {",
                        "\t\t__qdisc_drop(skb, &to_free);",
                        "\t\trc = NET_XMIT_DROP;",
                        "\t} else if ((q->flags & TCQ_F_CAN_BYPASS) && !qdisc_qlen(q) &&",
                        "\t\t   qdisc_run_begin(q)) {",
                        "\t\t/*",
                        "\t\t * This is a work-conserving queue; there are no old skbs",
                        "\t\t * waiting to be sent out; and the qdisc is not running -",
                        "\t\t * xmit the skb directly.",
                        "\t\t */",
                        "",
                        "\t\tqdisc_bstats_update(q, skb);",
                        "",
                        "\t\tif (sch_direct_xmit(skb, q, dev, txq, root_lock, true)) {",
                        "\t\t\tif (unlikely(contended)) {",
                        "\t\t\t\tspin_unlock(&q->busylock);",
                        "\t\t\t\tcontended = false;",
                        "\t\t\t}",
                        "\t\t\t__qdisc_run(q);",
                        "\t\t}",
                        "",
                        "\t\tqdisc_run_end(q);",
                        "\t\trc = NET_XMIT_SUCCESS;",
                        "\t} else {",
                        "\t\trc = q->enqueue(skb, q, &to_free) & NET_XMIT_MASK;",
                        "\t\tif (qdisc_run_begin(q)) {",
                        "\t\t\tif (unlikely(contended)) {",
                        "\t\t\t\tspin_unlock(&q->busylock);",
                        "\t\t\t\tcontended = false;",
                        "\t\t\t}",
                        "\t\t\t__qdisc_run(q);",
                        "\t\t\tqdisc_run_end(q);",
                        "\t\t}",
                        "\t}",
                        "\tspin_unlock(root_lock);",
                        "\tif (unlikely(to_free))",
                        "\t\tkfree_skb_list(to_free);",
                        "\tif (unlikely(contended))",
                        "\t\tspin_unlock(&q->busylock);",
                        "\treturn rc;",
                        "}"
                    ],
                    "start": 3655,
                    "highlight": 3710
                },
                {
                    "file": "net/core/dev.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/dev.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n4021",
                    "code": [
                        "/**",
                        " *\t__dev_queue_xmit - transmit a buffer",
                        " *\t@skb: buffer to transmit",
                        " *\t@sb_dev: suboordinate device used for L2 forwarding offload",
                        " *",
                        " *\tQueue a buffer for transmission to a network device. The caller must",
                        " *\thave set the device and priority and built the buffer before calling",
                        " *\tthis function. The function can be called from an interrupt.",
                        " *",
                        " *\tA negative errno code is returned on a failure. A success does not",
                        " *\tguarantee the frame will be transmitted as it may be dropped due",
                        " *\tto congestion or traffic shaping.",
                        " *",
                        " * -----------------------------------------------------------------------------------",
                        " *      I notice this method can also return errors from the queue disciplines,",
                        " *      including NET_XMIT_DROP, which is a positive value.  So, errors can also",
                        " *      be positive.",
                        " *",
                        " *      Regardless of the return value, the skb is consumed, so it is currently",
                        " *      difficult to retry a send to this method.  (You can bump the ref count",
                        " *      before sending to hold a reference for retry if you are careful.)",
                        " *",
                        " *      When calling this method, interrupts MUST be enabled.  This is because",
                        " *      the BH enable code must have IRQs enabled so that it will not deadlock.",
                        " *          --BLG",
                        " */",
                        "static int __dev_queue_xmit(struct sk_buff *skb, struct net_device *sb_dev)",
                        "{",
                        "\tstruct net_device *dev = skb->dev;",
                        "\tstruct netdev_queue *txq;",
                        "\tstruct Qdisc *q;",
                        "\tint rc = -ENOMEM;",
                        "\tbool again = false;",
                        "",
                        "\tskb_reset_mac_header(skb);",
                        "",
                        "\tif (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_SCHED_TSTAMP))",
                        "\t\t__skb_tstamp_tx(skb, NULL, skb->sk, SCM_TSTAMP_SCHED);",
                        "",
                        "\t/* Disable soft irqs for various locks below. Also",
                        "\t * stops preemption for RCU.",
                        "\t */",
                        "\trcu_read_lock_bh();",
                        "",
                        "\tskb_update_prio(skb);",
                        "",
                        "\tqdisc_pkt_len_init(skb);",
                        "#ifdef CONFIG_NET_CLS_ACT",
                        "\tskb->tc_at_ingress = 0;",
                        "# ifdef CONFIG_NET_EGRESS",
                        "\tif (static_branch_unlikely(&egress_needed_key)) {",
                        "\t\tskb = sch_handle_egress(skb, &rc, dev);",
                        "\t\tif (!skb)",
                        "\t\t\tgoto out;",
                        "\t}",
                        "# endif",
                        "#endif",
                        "\t/* If device/qdisc don't need skb->dst, release it right now while",
                        "\t * its hot in this cpu cache.",
                        "\t */",
                        "\tif (dev->priv_flags & IFF_XMIT_DST_RELEASE)",
                        "\t\tskb_dst_drop(skb);",
                        "\telse",
                        "\t\tskb_dst_force(skb);",
                        "",
                        "\ttxq = netdev_core_pick_tx(dev, skb, sb_dev);",
                        "\tq = rcu_dereference_bh(txq->qdisc);",
                        "",
                        "\ttrace_net_dev_queue(skb);",
                        "\tif (q->enqueue) {",
                        "\t\trc = __dev_xmit_skb(skb, q, dev, txq);",
                        "\t\tgoto out;",
                        "\t}",
                        "",
                        "\t/* The device has no queue. Common case for software devices:",
                        "\t * loopback, all the sorts of tunnels...",
                        "",
                        "\t * Really, it is unlikely that netif_tx_lock protection is necessary",
                        "\t * here.  (f.e. loopback and IP tunnels are clean ignoring statistics",
                        "\t * counters.)",
                        "\t * However, it is possible, that they rely on protection",
                        "\t * made by us here.",
                        "",
                        "\t * Check this and shot the lock. It is not prone from deadlocks.",
                        "\t *Either shot noqueue qdisc, it is even simpler 8)",
                        "\t */",
                        "\tif (dev->flags & IFF_UP) {",
                        "\t\tint cpu = smp_processor_id(); /* ok because BHs are off */",
                        "",
                        "\t\tif (txq->xmit_lock_owner != cpu) {",
                        "\t\t\tif (dev_xmit_recursion())",
                        "\t\t\t\tgoto recursion_alert;",
                        "",
                        "\t\t\tskb = validate_xmit_skb(skb, dev, &again);",
                        "\t\t\tif (!skb)",
                        "\t\t\t\tgoto out;",
                        "",
                        "\t\t\tHARD_TX_LOCK(dev, txq, cpu);",
                        "",
                        "\t\t\tif (!netif_xmit_stopped(txq)) {",
                        "\t\t\t\tdev_xmit_recursion_inc();",
                        "\t\t\t\tskb = dev_hard_start_xmit(skb, dev, txq, &rc);",
                        "\t\t\t\tdev_xmit_recursion_dec();",
                        "\t\t\t\tif (dev_xmit_complete(rc)) {",
                        "\t\t\t\t\tHARD_TX_UNLOCK(dev, txq);",
                        "\t\t\t\t\tgoto out;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tHARD_TX_UNLOCK(dev, txq);",
                        "\t\t\tnet_crit_ratelimited(\"Virtual device %s asks to queue packet!\\n\",",
                        "\t\t\t\t\t     dev->name);",
                        "\t\t} else {",
                        "\t\t\t/* Recursion is detected! It is possible,",
                        "\t\t\t * unfortunately",
                        "\t\t\t */",
                        "recursion_alert:",
                        "\t\t\tnet_crit_ratelimited(\"Dead loop on virtual device %s, fix it urgently!\\n\",",
                        "\t\t\t\t\t     dev->name);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\trc = -ENETDOWN;",
                        "\trcu_read_unlock_bh();",
                        "",
                        "\tatomic_long_inc(&dev->tx_dropped);",
                        "\tkfree_skb_list(skb);",
                        "\treturn rc;",
                        "out:",
                        "\trcu_read_unlock_bh();",
                        "\treturn rc;",
                        "}"
                    ],
                    "start": 3951,
                    "highlight": 4021
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e4116f"
        },
        "12976": {
            "name": "__dev_queue_xmit(indirect)",
            "parent_idx": 11208,
            "source_line": [
                {
                    "file": "net/packet/af_packet.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/packet/af_packet.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n2979",
                    "code": [
                        "static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tDECLARE_SOCKADDR(struct sockaddr_ll *, saddr, msg->msg_name);",
                        "\tstruct sk_buff *skb;",
                        "\tstruct net_device *dev;",
                        "\t__be16 proto;",
                        "\tunsigned char *addr = NULL;",
                        "\tint err, reserve = 0;",
                        "\tstruct sockcm_cookie sockc;",
                        "\tstruct virtio_net_hdr vnet_hdr = { 0 };",
                        "\tint offset = 0;",
                        "\tstruct packet_sock *po = pkt_sk(sk);",
                        "\tbool has_vnet_hdr = false;",
                        "\tint hlen, tlen, linear;",
                        "\tint extra_len = 0;",
                        "",
                        "\t/*",
                        "\t *\tGet and verify the address.",
                        "\t */",
                        "",
                        "\tif (likely(saddr == NULL)) {",
                        "\t\tdev\t= packet_cached_dev_get(po);",
                        "\t\tproto\t= po->num;",
                        "\t} else {",
                        "\t\terr = -EINVAL;",
                        "\t\tif (msg->msg_namelen < sizeof(struct sockaddr_ll))",
                        "\t\t\tgoto out;",
                        "\t\tif (msg->msg_namelen < (saddr->sll_halen + offsetof(struct sockaddr_ll, sll_addr)))",
                        "\t\t\tgoto out;",
                        "\t\tproto\t= saddr->sll_protocol;",
                        "\t\tdev = dev_get_by_index(sock_net(sk), saddr->sll_ifindex);",
                        "\t\tif (sock->type == SOCK_DGRAM) {",
                        "\t\t\tif (dev && msg->msg_namelen < dev->addr_len +",
                        "\t\t\t\t   offsetof(struct sockaddr_ll, sll_addr))",
                        "\t\t\t\tgoto out_unlock;",
                        "\t\t\taddr = saddr->sll_addr;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\terr = -ENXIO;",
                        "\tif (unlikely(dev == NULL))",
                        "\t\tgoto out_unlock;",
                        "\terr = -ENETDOWN;",
                        "\tif (unlikely(!(dev->flags & IFF_UP)))",
                        "\t\tgoto out_unlock;",
                        "",
                        "\tsockcm_init(&sockc, sk);",
                        "\tsockc.mark = sk->sk_mark;",
                        "\tif (msg->msg_controllen) {",
                        "\t\terr = sock_cmsg_send(sk, msg, &sockc);",
                        "\t\tif (unlikely(err))",
                        "\t\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\tif (sock->type == SOCK_RAW)",
                        "\t\treserve = dev->hard_header_len;",
                        "\tif (po->has_vnet_hdr) {",
                        "\t\terr = packet_snd_vnet_parse(msg, &len, &vnet_hdr);",
                        "\t\tif (err)",
                        "\t\t\tgoto out_unlock;",
                        "\t\thas_vnet_hdr = true;",
                        "\t}",
                        "",
                        "\tif (unlikely(sock_flag(sk, SOCK_NOFCS))) {",
                        "\t\tif (!netif_supports_nofcs(dev)) {",
                        "\t\t\terr = -EPROTONOSUPPORT;",
                        "\t\t\tgoto out_unlock;",
                        "\t\t}",
                        "\t\textra_len = 4; /* We're doing our own CRC */",
                        "\t}",
                        "",
                        "\terr = -EMSGSIZE;",
                        "\tif (!vnet_hdr.gso_type &&",
                        "\t    (len > dev->mtu + reserve + VLAN_HLEN + extra_len))",
                        "\t\tgoto out_unlock;",
                        "",
                        "\terr = -ENOBUFS;",
                        "\thlen = LL_RESERVED_SPACE(dev);",
                        "\ttlen = dev->needed_tailroom;",
                        "\tlinear = __virtio16_to_cpu(vio_le(), vnet_hdr.hdr_len);",
                        "\tlinear = max(linear, min_t(int, len, dev->hard_header_len));",
                        "\tskb = packet_alloc_skb(sk, hlen + tlen, hlen, len, linear,",
                        "\t\t\t       msg->msg_flags & MSG_DONTWAIT, &err);",
                        "\tif (skb == NULL)",
                        "\t\tgoto out_unlock;",
                        "",
                        "\tskb_reset_network_header(skb);",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (sock->type == SOCK_DGRAM) {",
                        "\t\toffset = dev_hard_header(skb, dev, ntohs(proto), addr, NULL, len);",
                        "\t\tif (unlikely(offset < 0))",
                        "\t\t\tgoto out_free;",
                        "\t} else if (reserve) {",
                        "\t\tskb_reserve(skb, -reserve);",
                        "\t\tif (len < reserve + sizeof(struct ipv6hdr) &&",
                        "\t\t    dev->min_header_len != dev->hard_header_len)",
                        "\t\t\tskb_reset_network_header(skb);",
                        "\t}",
                        "",
                        "\t/* Returns -EFAULT on error */",
                        "\terr = skb_copy_datagram_from_iter(skb, offset, &msg->msg_iter, len);",
                        "\tif (err)",
                        "\t\tgoto out_free;",
                        "",
                        "\tif (sock->type == SOCK_RAW &&",
                        "\t    !dev_validate_header(dev, skb->data, len)) {",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "",
                        "\tskb_setup_tx_timestamp(skb, sockc.tsflags);",
                        "",
                        "\tif (!vnet_hdr.gso_type && (len > dev->mtu + reserve + extra_len) &&",
                        "\t    !packet_extra_vlan_len_allowed(dev, skb)) {",
                        "\t\terr = -EMSGSIZE;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "",
                        "\tskb->protocol = proto;",
                        "\tskb->dev = dev;",
                        "\tskb->priority = sk->sk_priority;",
                        "\tskb->mark = sockc.mark;",
                        "\tskb->tstamp = sockc.transmit_time;",
                        "",
                        "\tif (has_vnet_hdr) {",
                        "\t\terr = virtio_net_hdr_to_skb(skb, &vnet_hdr, vio_le());",
                        "\t\tif (err)",
                        "\t\t\tgoto out_free;",
                        "\t\tlen += sizeof(vnet_hdr);",
                        "\t\tvirtio_net_hdr_set_proto(skb, &vnet_hdr);",
                        "\t}",
                        "",
                        "\tpacket_parse_headers(skb, sock);",
                        "",
                        "\tif (unlikely(extra_len == 4))",
                        "\t\tskb->no_fcs = 1;",
                        "",
                        "\terr = po->xmit(skb);",
                        "\tif (err > 0 && (err = net_xmit_errno(err)) != 0)",
                        "\t\tgoto out_unlock;",
                        "",
                        "\tdev_put(dev);",
                        "",
                        "\treturn len;",
                        "",
                        "out_free:",
                        "\tkfree_skb(skb);",
                        "out_unlock:",
                        "\tif (dev)",
                        "\t\tdev_put(dev);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2840,
                    "highlight": 2979
                },
                {
                    "file": "net/packet/af_packet.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/packet/af_packet.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n3004",
                    "code": [
                        "static int packet_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tstruct packet_sock *po = pkt_sk(sk);",
                        "",
                        "\tif (po->tx_ring.pg_vec)",
                        "\t\treturn tpacket_snd(po, msg);",
                        "\telse",
                        "\t\treturn packet_snd(sock, msg, len);",
                        "}"
                    ],
                    "start": 2996,
                    "highlight": 3004
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff820a10af"
        },
        "11208": {
            "name": "packet_sendmsg(indirect)",
            "parent_idx": 11193,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n652",
                    "code": [
                        "INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t   size_t));",
                        "INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *,",
                        "\t\t\t\t\t    size_t));",
                        "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,",
                        "\t\t\t\t     inet_sendmsg, sock, msg,",
                        "\t\t\t\t     msg_data_left(msg));",
                        "\tBUG_ON(ret == -EIOCBQUEUED);",
                        "\treturn ret;",
                        "}"
                    ],
                    "start": 646,
                    "highlight": 652
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n672",
                    "code": [
                        "/**",
                        " *\tsock_sendmsg - send a message through @sock",
                        " *\t@sock: socket",
                        " *\t@msg: message to send",
                        " *",
                        " *\tSends @msg through @sock, passing through LSM.",
                        " *\tReturns the number of bytes sent, or an error code.",
                        " */",
                        "int sock_sendmsg(struct socket *sock, struct msghdr *msg)",
                        "{",
                        "\tint err = security_socket_sendmsg(sock, msg,",
                        "\t\t\t\t\t  msg_data_left(msg));",
                        "",
                        "\treturn err ?: sock_sendmsg_nosec(sock, msg);",
                        "}"
                    ],
                    "start": 659,
                    "highlight": 672
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e0198c"
        },
        "11193": {
            "name": "sock_sendmsg",
            "parent_idx": 11147,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n2000",
                    "code": [
                        "/*",
                        " *\tSend a datagram to a given address. We move the address into kernel",
                        " *\tspace and check the user space data area is readable before invoking",
                        " *\tthe protocol.",
                        " */",
                        "int __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags,",
                        "\t\t struct sockaddr __user *addr,  int addr_len)",
                        "{",
                        "\tstruct socket *sock;",
                        "\tstruct sockaddr_storage address;",
                        "\tint err;",
                        "\tstruct msghdr msg;",
                        "\tstruct iovec iov;",
                        "\tint fput_needed;",
                        "",
                        "\terr = import_single_range(WRITE, buff, len, &iov, &msg.msg_iter);",
                        "\tif (unlikely(err))",
                        "\t\treturn err;",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (!sock)",
                        "\t\tgoto out;",
                        "",
                        "\tmsg.msg_name = NULL;",
                        "\tmsg.msg_control = NULL;",
                        "\tmsg.msg_controllen = 0;",
                        "\tmsg.msg_namelen = 0;",
                        "\tif (addr) {",
                        "\t\terr = move_addr_to_kernel(addr, addr_len, &address);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto out_put;",
                        "\t\tmsg.msg_name = (struct sockaddr *)&address;",
                        "\t\tmsg.msg_namelen = addr_len;",
                        "\t}",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tflags |= MSG_DONTWAIT;",
                        "\tmsg.msg_flags = flags;",
                        "\terr = sock_sendmsg(sock, &msg);",
                        "",
                        "out_put:",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 1964,
                    "highlight": 2000
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e04aba"
        },
        "11147": {
            "name": "__sys_sendto",
            "parent_idx": 11140,
            "source_line": [
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n2012",
                    "code": [
                        "SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,",
                        "\t\tunsigned int, flags, struct sockaddr __user *, addr,",
                        "\t\tint, addr_len)",
                        "{",
                        "\treturn __sys_sendto(fd, buff, len, flags, addr, addr_len);",
                        "}"
                    ],
                    "start": 2008,
                    "highlight": 2012
                },
                {
                    "file": "net/socket.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/socket.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n2008",
                    "code": [
                        "/*",
                        " *\tSend a datagram to a given address. We move the address into kernel",
                        " *\tspace and check the user space data area is readable before invoking",
                        " *\tthe protocol.",
                        " */",
                        "int __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags,",
                        "\t\t struct sockaddr __user *addr,  int addr_len)",
                        "{",
                        "\tstruct socket *sock;",
                        "\tstruct sockaddr_storage address;",
                        "\tint err;",
                        "\tstruct msghdr msg;",
                        "\tstruct iovec iov;",
                        "\tint fput_needed;",
                        "",
                        "\terr = import_single_range(WRITE, buff, len, &iov, &msg.msg_iter);",
                        "\tif (unlikely(err))",
                        "\t\treturn err;",
                        "\tsock = sockfd_lookup_light(fd, &err, &fput_needed);",
                        "\tif (!sock)",
                        "\t\tgoto out;",
                        "",
                        "\tmsg.msg_name = NULL;",
                        "\tmsg.msg_control = NULL;",
                        "\tmsg.msg_controllen = 0;",
                        "\tmsg.msg_namelen = 0;",
                        "\tif (addr) {",
                        "\t\terr = move_addr_to_kernel(addr, addr_len, &address);",
                        "\t\tif (err < 0)",
                        "\t\t\tgoto out_put;",
                        "\t\tmsg.msg_name = (struct sockaddr *)&address;",
                        "\t\tmsg.msg_namelen = addr_len;",
                        "\t}",
                        "\tif (sock->file->f_flags & O_NONBLOCK)",
                        "\t\tflags |= MSG_DONTWAIT;",
                        "\tmsg.msg_flags = flags;",
                        "\terr = sock_sendmsg(sock, &msg);",
                        "",
                        "out_put:",
                        "\tfput_light(sock->file, fput_needed);",
                        "out:",
                        "\treturn err;",
                        "}",
                        "",
                        "SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,",
                        "\t\tunsigned int, flags, struct sockaddr __user *, addr,",
                        "\t\tint, addr_len)",
                        "{",
                        "\treturn __sys_sendto(fd, buff, len, flags, addr, addr_len);",
                        "}"
                    ],
                    "start": 1964,
                    "highlight": 2008
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e04bca"
        },
        "11140": {
            "name": "__x64_sys_sendto(indirect)",
            "parent_idx": 11137,
            "source_line": [
                {
                    "file": "arch/x86/entry/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/common.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n295",
                    "code": [
                        "#ifdef CONFIG_X86_64",
                        "__visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)",
                        "{",
                        "\tstruct thread_info *ti;",
                        "",
                        "\tenter_from_user_mode();",
                        "\tlocal_irq_enable();",
                        "\tti = current_thread_info();",
                        "\tif (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY)",
                        "\t\tnr = syscall_trace_enter(regs);",
                        "",
                        "\tif (likely(nr < NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr, NR_syscalls);",
                        "\t\tregs->ax = sys_call_table[nr](regs);",
                        "#ifdef CONFIG_X86_X32_ABI",
                        "\t} else if (likely((nr & __X32_SYSCALL_BIT) &&",
                        "\t\t\t  (nr & ~__X32_SYSCALL_BIT) < X32_NR_syscalls)) {",
                        "\t\tnr = array_index_nospec(nr & ~__X32_SYSCALL_BIT,",
                        "\t\t\t\t\tX32_NR_syscalls);",
                        "\t\tregs->ax = x32_sys_call_table[nr](regs);",
                        "#endif",
                        "\t}",
                        "",
                        "\tsyscall_return_slowpath(regs);",
                        "}"
                    ],
                    "start": 282,
                    "highlight": 295
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81003f95"
        },
        "11137": {
            "name": "do_syscall_64",
            "parent_idx": 11124,
            "source_line": [
                {
                    "file": "arch/x86/entry/entry_64.S",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/entry/entry_64.S?id=50cc09c18985eacbbd666acfd7be2391394733f5#n175",
                    "code": [
                        "SYM_CODE_START(entry_SYSCALL_64)",
                        "\tUNWIND_HINT_EMPTY",
                        "\t/*",
                        "\t * Interrupts are off on entry.",
                        "\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,",
                        "\t * it is too small to ever cause noticeable irq latency.",
                        "\t */",
                        "",
                        "\tswapgs",
                        "\t/* tss.sp2 is scratch space. */",
                        "\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)",
                        "\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp",
                        "\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp",
                        "",
                        "\t/* Construct struct pt_regs on stack */",
                        "\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */",
                        "\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */",
                        "\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */",
                        "\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */",
                        "\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */",
                        "SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)",
                        "\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */",
                        "",
                        "\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS",
                        "",
                        "\tTRACE_IRQS_OFF",
                        "",
                        "\t/* IRQs are off. */",
                        "\tmovq\t%rax, %rdi",
                        "\tmovq\t%rsp, %rsi",
                        "\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */",
                        "",
                        "\tTRACE_IRQS_ON\t\t\t/* return enables interrupts */",
                        "",
                        "\t/*",
                        "\t * Try to use SYSRET instead of IRET if we're returning to",
                        "\t * a completely clean 64-bit userspace context.  If we're not,",
                        "\t * go to the slow exit path.",
                        "\t */",
                        "\tmovq\tRCX(%rsp), %rcx",
                        "\tmovq\tRIP(%rsp), %r11",
                        "",
                        "\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP",
                        "\t * in kernel space.  This essentially lets the user take over",
                        "\t * the kernel, since userspace controls RSP.",
                        "\t *",
                        "\t * If width of \"canonical tail\" ever becomes variable, this will need",
                        "\t * to be updated to remain correct on both old and new CPUs.",
                        "\t *",
                        "\t * Change top bits to match most significant bit (47th or 56th bit",
                        "\t * depending on paging mode) in the address.",
                        "\t */",
                        "#ifdef CONFIG_X86_5LEVEL",
                        "\tALTERNATIVE \"shl $(64 - 48), %rcx; sar $(64 - 48), %rcx\", \\",
                        "\t\t\"shl $(64 - 57), %rcx; sar $(64 - 57), %rcx\", X86_FEATURE_LA57",
                        "#else",
                        "\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx",
                        "#endif",
                        "",
                        "\t/* If this changed %rcx, it was not canonical */",
                        "\tcmpq\t%rcx, %r11",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\tmovq\tR11(%rsp), %r11",
                        "\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot",
                        "\t * restore RF properly. If the slowpath sets it for whatever reason, we",
                        "\t * need to restore it correctly.",
                        "\t *",
                        "\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a",
                        "\t * trap from userspace immediately after SYSRET.  This would cause an",
                        "\t * infinite loop whenever #DB happens with register state that satisfies",
                        "\t * the opportunistic SYSRET conditions.  For example, single-stepping",
                        "\t * this user code:",
                        "\t *",
                        "\t *           movq\t$stuck_here, %rcx",
                        "\t *           pushfq",
                        "\t *           popq %r11",
                        "\t *   stuck_here:",
                        "\t *",
                        "\t * would never get past 'stuck_here'.",
                        "\t */",
                        "\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11",
                        "\tjnz\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/* nothing to check for RSP */",
                        "",
                        "\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */",
                        "\tjne\tswapgs_restore_regs_and_return_to_usermode",
                        "",
                        "\t/*",
                        "\t * We win! This label is here just for ease of understanding",
                        "\t * perf profiles. Nothing jumps here.",
                        "\t */",
                        "syscall_return_via_sysret:",
                        "\t/* rcx and r11 are already restored (see code above) */",
                        "\tUNWIND_HINT_EMPTY",
                        "\tPOP_REGS pop_rdi=0 skip_r11rcx=1",
                        "",
                        "\t/*",
                        "\t * Now all regs are restored except RSP and RDI.",
                        "\t * Save old stack pointer and switch to trampoline stack.",
                        "\t */",
                        "\tmovq\t%rsp, %rdi",
                        "\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp",
                        "",
                        "\tpushq\tRSP-RDI(%rdi)\t/* RSP */",
                        "\tpushq\t(%rdi)\t\t/* RDI */",
                        "",
                        "\t/*",
                        "\t * We are on the trampoline stack.  All regs except RDI are live.",
                        "\t * We can do future final exit work right here.",
                        "\t */",
                        "\tSTACKLEAK_ERASE_NOCLOBBER",
                        "",
                        "\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi",
                        "",
                        "\tpopq\t%rdi",
                        "\tpopq\t%rsp",
                        "\tUSERGS_SYSRET64",
                        "SYM_CODE_END(entry_SYSCALL_64)"
                    ],
                    "start": 145,
                    "highlight": 175
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff82400077"
        },
        "11124": {
            "name": "598_syscall_12",
            "parent_idx": 1,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "1": {
            "name": "PoC",
            "parent_idx": 0,
            "source_line": [],
            "ins_idx": 0,
            "addr": "0x0"
        },
        "13004": {
            "name": "+0xe3",
            "parent_idx": 13000,
            "source_line": [
                {
                    "file": "./include/linux/skbuff.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/skbuff.h?id=50cc09c18985eacbbd666acfd7be2391394733f5#n2511",
                    "code": [
                        "static inline unsigned char *skb_transport_header(const struct sk_buff *skb)",
                        "{",
                        "\treturn skb->head + skb->transport_header;",
                        "}"
                    ],
                    "start": 2509,
                    "highlight": 2511
                },
                {
                    "file": "./include/linux/tcp.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/tcp.h?id=50cc09c18985eacbbd666acfd7be2391394733f5#n26",
                    "code": [
                        "static inline struct tcphdr *tcp_hdr(const struct sk_buff *skb)",
                        "{",
                        "\treturn (struct tcphdr *)skb_transport_header(skb);",
                        "}"
                    ],
                    "start": 24,
                    "highlight": 26
                },
                {
                    "file": "./include/linux/tcp.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/tcp.h?id=50cc09c18985eacbbd666acfd7be2391394733f5#n36",
                    "code": [
                        "static inline unsigned int tcp_hdrlen(const struct sk_buff *skb)",
                        "{",
                        "\treturn __tcp_hdrlen(tcp_hdr(skb));",
                        "}"
                    ],
                    "start": 34,
                    "highlight": 36
                },
                {
                    "file": "net/core/skbuff.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/skbuff.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n5266",
                    "code": [
                        "/**",
                        " * skb_gso_transport_seglen - Return length of individual segments of a gso packet",
                        " *",
                        " * @skb: GSO skb",
                        " *",
                        " * skb_gso_transport_seglen is used to determine the real size of the",
                        " * individual segments, including Layer4 headers (TCP/UDP).",
                        " *",
                        " * The MAC/L2 or network (IP, IPv6) headers are not accounted for.",
                        " */",
                        "static unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)",
                        "{",
                        "\tconst struct skb_shared_info *shinfo = skb_shinfo(skb);",
                        "\tunsigned int thlen = 0;",
                        "",
                        "\tif (skb->encapsulation) {",
                        "\t\tthlen = skb_inner_transport_header(skb) -",
                        "\t\t\tskb_transport_header(skb);",
                        "",
                        "\t\tif (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))",
                        "\t\t\tthlen += inner_tcp_hdrlen(skb);",
                        "\t} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {",
                        "\t\tthlen = tcp_hdrlen(skb);",
                        "\t} else if (unlikely(skb_is_gso_sctp(skb))) {",
                        "\t\tthlen = sizeof(struct sctphdr);",
                        "\t} else if (shinfo->gso_type & SKB_GSO_UDP_L4) {",
                        "\t\tthlen = sizeof(struct udphdr);",
                        "\t}",
                        "\t/* UFO sets gso_size to the size of the fragmentation",
                        "\t * payload, i.e. the size of the L4 (UDP) header is already",
                        "\t * accounted for.",
                        "\t */",
                        "\treturn thlen + shinfo->gso_size;",
                        "}"
                    ],
                    "start": 5244,
                    "highlight": 5266
                }
            ],
            "ins_idx": 280,
            "addr": "0xffffffff81e11543"
        },
        "13002": {
            "name": "+0x1e",
            "parent_idx": 13000,
            "source_line": [
                {
                    "file": "./include/linux/skbuff.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/skbuff.h?id=50cc09c18985eacbbd666acfd7be2391394733f5#n1417",
                    "code": [
                        "#ifdef NET_SKBUFF_DATA_USES_OFFSET",
                        "static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)",
                        "{",
                        "\treturn skb->head + skb->end;",
                        "}"
                    ],
                    "start": 1414,
                    "highlight": 1417
                },
                {
                    "file": "net/core/skbuff.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/skbuff.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n5256",
                    "code": [
                        "/**",
                        " * skb_gso_transport_seglen - Return length of individual segments of a gso packet",
                        " *",
                        " * @skb: GSO skb",
                        " *",
                        " * skb_gso_transport_seglen is used to determine the real size of the",
                        " * individual segments, including Layer4 headers (TCP/UDP).",
                        " *",
                        " * The MAC/L2 or network (IP, IPv6) headers are not accounted for.",
                        " */",
                        "static unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)",
                        "{",
                        "\tconst struct skb_shared_info *shinfo = skb_shinfo(skb);",
                        "\tunsigned int thlen = 0;",
                        "",
                        "\tif (skb->encapsulation) {",
                        "\t\tthlen = skb_inner_transport_header(skb) -",
                        "\t\t\tskb_transport_header(skb);",
                        "",
                        "\t\tif (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))",
                        "\t\t\tthlen += inner_tcp_hdrlen(skb);",
                        "\t} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {",
                        "\t\tthlen = tcp_hdrlen(skb);",
                        "\t} else if (unlikely(skb_is_gso_sctp(skb))) {",
                        "\t\tthlen = sizeof(struct sctphdr);",
                        "\t} else if (shinfo->gso_type & SKB_GSO_UDP_L4) {",
                        "\t\tthlen = sizeof(struct udphdr);",
                        "\t}",
                        "\t/* UFO sets gso_size to the size of the fragmentation",
                        "\t * payload, i.e. the size of the L4 (UDP) header is already",
                        "\t * accounted for.",
                        "\t */",
                        "\treturn thlen + shinfo->gso_size;",
                        "}"
                    ],
                    "start": 5244,
                    "highlight": 5256
                }
            ],
            "ins_idx": 422,
            "addr": "0xffffffff81e1147e"
        },
        "11371": {
            "name": "+0x15c",
            "parent_idx": 11315,
            "source_line": [
                {
                    "file": "net/core/skbuff.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/skbuff.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n230",
                    "code": [
                        "/**",
                        " *\t__alloc_skb\t-\tallocate a network buffer",
                        " *\t@size: size to allocate",
                        " *\t@gfp_mask: allocation mask",
                        " *\t@flags: If SKB_ALLOC_FCLONE is set, allocate from fclone cache",
                        " *\t\tinstead of head cache and allocate a cloned (child) skb.",
                        " *\t\tIf SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for",
                        " *\t\tallocations in case the data is required for writeback",
                        " *\t@node: numa node to allocate memory on",
                        " *",
                        " *\tAllocate a new &sk_buff. The returned buffer has no headroom and a",
                        " *\ttail room of at least size bytes. The object has a reference count",
                        " *\tof one. The return is the buffer. On a failure the return is %NULL.",
                        " *",
                        " *\tBuffers may only be allocated from interrupts using a @gfp_mask of",
                        " *\t%GFP_ATOMIC.",
                        " */",
                        "struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,",
                        "\t\t\t    int flags, int node)",
                        "{",
                        "\tstruct kmem_cache *cache;",
                        "\tstruct skb_shared_info *shinfo;",
                        "\tstruct sk_buff *skb;",
                        "\tu8 *data;",
                        "\tbool pfmemalloc;",
                        "",
                        "\tcache = (flags & SKB_ALLOC_FCLONE)",
                        "\t\t? skbuff_fclone_cache : skbuff_head_cache;",
                        "",
                        "\tif (sk_memalloc_socks() && (flags & SKB_ALLOC_RX))",
                        "\t\tgfp_mask |= __GFP_MEMALLOC;",
                        "",
                        "\t/* Get the HEAD */",
                        "\tskb = kmem_cache_alloc_node(cache, gfp_mask & ~__GFP_DMA, node);",
                        "\tif (!skb)",
                        "\t\tgoto out;",
                        "\tprefetchw(skb);",
                        "",
                        "\t/* We do our best to align skb_shared_info on a separate cache",
                        "\t * line. It usually works because kmalloc(X > SMP_CACHE_BYTES) gives",
                        "\t * aligned memory blocks, unless SLUB/SLAB debug is enabled.",
                        "\t * Both skb->head and skb_shared_info are cache line aligned.",
                        "\t */",
                        "\tsize = SKB_DATA_ALIGN(size);",
                        "\tsize += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));",
                        "\tdata = kmalloc_reserve(size, gfp_mask, node, &pfmemalloc);",
                        "\tif (!data)",
                        "\t\tgoto nodata;",
                        "\t/* kmalloc(size) might give us more room than requested.",
                        "\t * Put skb_shared_info exactly at the end of allocated zone,",
                        "\t * to allow max possible filling before reallocation.",
                        "\t */",
                        "\tsize = SKB_WITH_OVERHEAD(ksize(data));",
                        "\tprefetchw(data + size);",
                        "",
                        "\t/*",
                        "\t * Only clear those fields we need to clear, not those that we will",
                        "\t * actually initialise below. Hence, don't put any more fields after",
                        "\t * the tail pointer in struct sk_buff!",
                        "\t */",
                        "\tmemset(skb, 0, offsetof(struct sk_buff, tail));",
                        "\t/* Account for allocated memory : skb + skb->head */",
                        "\tskb->truesize = SKB_TRUESIZE(size);",
                        "\tskb->pfmemalloc = pfmemalloc;",
                        "\trefcount_set(&skb->users, 1);",
                        "\tskb->head = data;",
                        "\tskb->data = data;",
                        "\tskb_reset_tail_pointer(skb);",
                        "\tskb->end = skb->tail + size;",
                        "\tskb->mac_header = (typeof(skb->mac_header))~0U;",
                        "\tskb->transport_header = (typeof(skb->transport_header))~0U;",
                        "",
                        "\t/* make sure we initialize shinfo sequentially */",
                        "\tshinfo = skb_shinfo(skb);",
                        "\tmemset(shinfo, 0, offsetof(struct skb_shared_info, dataref));",
                        "\tatomic_set(&shinfo->dataref, 1);",
                        "",
                        "\tif (flags & SKB_ALLOC_FCLONE) {",
                        "\t\tstruct sk_buff_fclones *fclones;",
                        "",
                        "\t\tfclones = container_of(skb, struct sk_buff_fclones, skb1);",
                        "",
                        "\t\tskb->fclone = SKB_FCLONE_ORIG;",
                        "\t\trefcount_set(&fclones->fclone_ref, 1);",
                        "",
                        "\t\tfclones->skb2.fclone = SKB_FCLONE_CLONE;",
                        "\t}",
                        "out:",
                        "\treturn skb;",
                        "nodata:",
                        "\tkmem_cache_free(cache, skb);",
                        "\tskb = NULL;",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 165,
                    "highlight": 230
                }
            ],
            "ins_idx": 631,
            "addr": "0xffffffff81e14c2c"
        },
        "11315": {
            "name": "__alloc_skb",
            "parent_idx": 11310,
            "source_line": [
                {
                    "file": "./include/linux/skbuff.h",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/./include/linux/skbuff.h?id=50cc09c18985eacbbd666acfd7be2391394733f5#n1083",
                    "code": [
                        "/**",
                        " * alloc_skb - allocate a network buffer",
                        " * @size: size to allocate",
                        " * @priority: allocation mask",
                        " *",
                        " * This function is a convenient wrapper around __alloc_skb().",
                        " */",
                        "static inline struct sk_buff *alloc_skb(unsigned int size,",
                        "\t\t\t\t\tgfp_t priority)",
                        "{",
                        "\treturn __alloc_skb(size, priority, 0, NUMA_NO_NODE);",
                        "}"
                    ],
                    "start": 1073,
                    "highlight": 1083
                },
                {
                    "file": "net/core/skbuff.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/skbuff.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n5772",
                    "code": [
                        "/**",
                        " * alloc_skb_with_frags - allocate skb with page frags",
                        " *",
                        " * @header_len: size of linear part",
                        " * @data_len: needed length in frags",
                        " * @max_page_order: max page order desired.",
                        " * @errcode: pointer to error code if any",
                        " * @gfp_mask: allocation mask",
                        " *",
                        " * This can be used to allocate a paged skb, given a maximal order for frags.",
                        " */",
                        "struct sk_buff *alloc_skb_with_frags(unsigned long header_len,",
                        "\t\t\t\t     unsigned long data_len,",
                        "\t\t\t\t     int max_page_order,",
                        "\t\t\t\t     int *errcode,",
                        "\t\t\t\t     gfp_t gfp_mask)",
                        "{",
                        "\tint npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;",
                        "\tunsigned long chunk;",
                        "\tstruct sk_buff *skb;",
                        "\tstruct page *page;",
                        "\tint i;",
                        "",
                        "\t*errcode = -EMSGSIZE;",
                        "\t/* Note this test could be relaxed, if we succeed to allocate",
                        "\t * high order pages...",
                        "\t */",
                        "\tif (npages > MAX_SKB_FRAGS)",
                        "\t\treturn NULL;",
                        "",
                        "\t*errcode = -ENOBUFS;",
                        "\tskb = alloc_skb(header_len, gfp_mask);",
                        "\tif (!skb)",
                        "\t\treturn NULL;",
                        "",
                        "\tskb->truesize += npages << PAGE_SHIFT;",
                        "",
                        "\tfor (i = 0; npages > 0; i++) {",
                        "\t\tint order = max_page_order;",
                        "",
                        "\t\twhile (order) {",
                        "\t\t\tif (npages >= 1 << order) {",
                        "\t\t\t\tpage = alloc_pages((gfp_mask & ~__GFP_DIRECT_RECLAIM) |",
                        "\t\t\t\t\t\t   __GFP_COMP |",
                        "\t\t\t\t\t\t   __GFP_NOWARN,",
                        "\t\t\t\t\t\t   order);",
                        "\t\t\t\tif (page)",
                        "\t\t\t\t\tgoto fill_page;",
                        "\t\t\t\t/* Do not retry other high order allocations */",
                        "\t\t\t\torder = 1;",
                        "\t\t\t\tmax_page_order = 0;",
                        "\t\t\t}",
                        "\t\t\torder--;",
                        "\t\t}",
                        "\t\tpage = alloc_page(gfp_mask);",
                        "\t\tif (!page)",
                        "\t\t\tgoto failure;",
                        "fill_page:",
                        "\t\tchunk = min_t(unsigned long, data_len,",
                        "\t\t\t      PAGE_SIZE << order);",
                        "\t\tskb_fill_page_desc(skb, i, page, 0, chunk);",
                        "\t\tdata_len -= chunk;",
                        "\t\tnpages -= 1 << order;",
                        "\t}",
                        "\treturn skb;",
                        "",
                        "failure:",
                        "\tkfree_skb(skb);",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 5741,
                    "highlight": 5772
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e19404"
        },
        "11310": {
            "name": "alloc_skb_with_frags",
            "parent_idx": 11301,
            "source_line": [
                {
                    "file": "net/core/sock.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/sock.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n2265",
                    "code": [
                        "struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,",
                        "\t\t\t\t     unsigned long data_len, int noblock,",
                        "\t\t\t\t     int *errcode, int max_page_order)",
                        "{",
                        "\tstruct sk_buff *skb;",
                        "\tlong timeo;",
                        "\tint err;",
                        "",
                        "\ttimeo = sock_sndtimeo(sk, noblock);",
                        "\tfor (;;) {",
                        "\t\terr = sock_error(sk);",
                        "\t\tif (err != 0)",
                        "\t\t\tgoto failure;",
                        "",
                        "\t\terr = -EPIPE;",
                        "\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)",
                        "\t\t\tgoto failure;",
                        "",
                        "\t\tif (sk_wmem_alloc_get(sk) < READ_ONCE(sk->sk_sndbuf))",
                        "\t\t\tbreak;",
                        "",
                        "\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);",
                        "\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);",
                        "\t\terr = -EAGAIN;",
                        "\t\tif (!timeo)",
                        "\t\t\tgoto failure;",
                        "\t\tif (signal_pending(current))",
                        "\t\t\tgoto interrupted;",
                        "\t\ttimeo = sock_wait_for_wmem(sk, timeo);",
                        "\t}",
                        "\tskb = alloc_skb_with_frags(header_len, data_len, max_page_order,",
                        "\t\t\t\t   errcode, sk->sk_allocation);",
                        "\tif (skb)",
                        "\t\tskb_set_owner_w(skb, sk);",
                        "\treturn skb;",
                        "",
                        "interrupted:",
                        "\terr = sock_intr_errno(timeo);",
                        "failure:",
                        "\t*errcode = err;",
                        "\treturn NULL;",
                        "}"
                    ],
                    "start": 2235,
                    "highlight": 2265
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e0aded"
        },
        "11301": {
            "name": "sock_alloc_send_pskb",
            "parent_idx": 11208,
            "source_line": [
                {
                    "file": "net/packet/af_packet.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/packet/af_packet.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n2827",
                    "code": [
                        "static struct sk_buff *packet_alloc_skb(struct sock *sk, size_t prepad,",
                        "\t\t\t\t        size_t reserve, size_t len,",
                        "\t\t\t\t        size_t linear, int noblock,",
                        "\t\t\t\t        int *err)",
                        "{",
                        "\tstruct sk_buff *skb;",
                        "",
                        "\t/* Under a page?  Don't bother with paged skb. */",
                        "\tif (prepad + len < PAGE_SIZE || !linear)",
                        "\t\tlinear = len;",
                        "",
                        "\tskb = sock_alloc_send_pskb(sk, prepad + linear, len - linear, noblock,",
                        "\t\t\t\t   err, 0);",
                        "\tif (!skb)",
                        "\t\treturn NULL;",
                        "",
                        "\tskb_reserve(skb, reserve);",
                        "\tskb_put(skb, linear);",
                        "\tskb->data_len = len - linear;",
                        "\tskb->len += len - linear;",
                        "",
                        "\treturn skb;",
                        "}"
                    ],
                    "start": 2816,
                    "highlight": 2827
                },
                {
                    "file": "net/packet/af_packet.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/packet/af_packet.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n2922",
                    "code": [
                        "static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tDECLARE_SOCKADDR(struct sockaddr_ll *, saddr, msg->msg_name);",
                        "\tstruct sk_buff *skb;",
                        "\tstruct net_device *dev;",
                        "\t__be16 proto;",
                        "\tunsigned char *addr = NULL;",
                        "\tint err, reserve = 0;",
                        "\tstruct sockcm_cookie sockc;",
                        "\tstruct virtio_net_hdr vnet_hdr = { 0 };",
                        "\tint offset = 0;",
                        "\tstruct packet_sock *po = pkt_sk(sk);",
                        "\tbool has_vnet_hdr = false;",
                        "\tint hlen, tlen, linear;",
                        "\tint extra_len = 0;",
                        "",
                        "\t/*",
                        "\t *\tGet and verify the address.",
                        "\t */",
                        "",
                        "\tif (likely(saddr == NULL)) {",
                        "\t\tdev\t= packet_cached_dev_get(po);",
                        "\t\tproto\t= po->num;",
                        "\t} else {",
                        "\t\terr = -EINVAL;",
                        "\t\tif (msg->msg_namelen < sizeof(struct sockaddr_ll))",
                        "\t\t\tgoto out;",
                        "\t\tif (msg->msg_namelen < (saddr->sll_halen + offsetof(struct sockaddr_ll, sll_addr)))",
                        "\t\t\tgoto out;",
                        "\t\tproto\t= saddr->sll_protocol;",
                        "\t\tdev = dev_get_by_index(sock_net(sk), saddr->sll_ifindex);",
                        "\t\tif (sock->type == SOCK_DGRAM) {",
                        "\t\t\tif (dev && msg->msg_namelen < dev->addr_len +",
                        "\t\t\t\t   offsetof(struct sockaddr_ll, sll_addr))",
                        "\t\t\t\tgoto out_unlock;",
                        "\t\t\taddr = saddr->sll_addr;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\terr = -ENXIO;",
                        "\tif (unlikely(dev == NULL))",
                        "\t\tgoto out_unlock;",
                        "\terr = -ENETDOWN;",
                        "\tif (unlikely(!(dev->flags & IFF_UP)))",
                        "\t\tgoto out_unlock;",
                        "",
                        "\tsockcm_init(&sockc, sk);",
                        "\tsockc.mark = sk->sk_mark;",
                        "\tif (msg->msg_controllen) {",
                        "\t\terr = sock_cmsg_send(sk, msg, &sockc);",
                        "\t\tif (unlikely(err))",
                        "\t\t\tgoto out_unlock;",
                        "\t}",
                        "",
                        "\tif (sock->type == SOCK_RAW)",
                        "\t\treserve = dev->hard_header_len;",
                        "\tif (po->has_vnet_hdr) {",
                        "\t\terr = packet_snd_vnet_parse(msg, &len, &vnet_hdr);",
                        "\t\tif (err)",
                        "\t\t\tgoto out_unlock;",
                        "\t\thas_vnet_hdr = true;",
                        "\t}",
                        "",
                        "\tif (unlikely(sock_flag(sk, SOCK_NOFCS))) {",
                        "\t\tif (!netif_supports_nofcs(dev)) {",
                        "\t\t\terr = -EPROTONOSUPPORT;",
                        "\t\t\tgoto out_unlock;",
                        "\t\t}",
                        "\t\textra_len = 4; /* We're doing our own CRC */",
                        "\t}",
                        "",
                        "\terr = -EMSGSIZE;",
                        "\tif (!vnet_hdr.gso_type &&",
                        "\t    (len > dev->mtu + reserve + VLAN_HLEN + extra_len))",
                        "\t\tgoto out_unlock;",
                        "",
                        "\terr = -ENOBUFS;",
                        "\thlen = LL_RESERVED_SPACE(dev);",
                        "\ttlen = dev->needed_tailroom;",
                        "\tlinear = __virtio16_to_cpu(vio_le(), vnet_hdr.hdr_len);",
                        "\tlinear = max(linear, min_t(int, len, dev->hard_header_len));",
                        "\tskb = packet_alloc_skb(sk, hlen + tlen, hlen, len, linear,",
                        "\t\t\t       msg->msg_flags & MSG_DONTWAIT, &err);",
                        "\tif (skb == NULL)",
                        "\t\tgoto out_unlock;",
                        "",
                        "\tskb_reset_network_header(skb);",
                        "",
                        "\terr = -EINVAL;",
                        "\tif (sock->type == SOCK_DGRAM) {",
                        "\t\toffset = dev_hard_header(skb, dev, ntohs(proto), addr, NULL, len);",
                        "\t\tif (unlikely(offset < 0))",
                        "\t\t\tgoto out_free;",
                        "\t} else if (reserve) {",
                        "\t\tskb_reserve(skb, -reserve);",
                        "\t\tif (len < reserve + sizeof(struct ipv6hdr) &&",
                        "\t\t    dev->min_header_len != dev->hard_header_len)",
                        "\t\t\tskb_reset_network_header(skb);",
                        "\t}",
                        "",
                        "\t/* Returns -EFAULT on error */",
                        "\terr = skb_copy_datagram_from_iter(skb, offset, &msg->msg_iter, len);",
                        "\tif (err)",
                        "\t\tgoto out_free;",
                        "",
                        "\tif (sock->type == SOCK_RAW &&",
                        "\t    !dev_validate_header(dev, skb->data, len)) {",
                        "\t\terr = -EINVAL;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "",
                        "\tskb_setup_tx_timestamp(skb, sockc.tsflags);",
                        "",
                        "\tif (!vnet_hdr.gso_type && (len > dev->mtu + reserve + extra_len) &&",
                        "\t    !packet_extra_vlan_len_allowed(dev, skb)) {",
                        "\t\terr = -EMSGSIZE;",
                        "\t\tgoto out_free;",
                        "\t}",
                        "",
                        "\tskb->protocol = proto;",
                        "\tskb->dev = dev;",
                        "\tskb->priority = sk->sk_priority;",
                        "\tskb->mark = sockc.mark;",
                        "\tskb->tstamp = sockc.transmit_time;",
                        "",
                        "\tif (has_vnet_hdr) {",
                        "\t\terr = virtio_net_hdr_to_skb(skb, &vnet_hdr, vio_le());",
                        "\t\tif (err)",
                        "\t\t\tgoto out_free;",
                        "\t\tlen += sizeof(vnet_hdr);",
                        "\t\tvirtio_net_hdr_set_proto(skb, &vnet_hdr);",
                        "\t}",
                        "",
                        "\tpacket_parse_headers(skb, sock);",
                        "",
                        "\tif (unlikely(extra_len == 4))",
                        "\t\tskb->no_fcs = 1;",
                        "",
                        "\terr = po->xmit(skb);",
                        "\tif (err > 0 && (err = net_xmit_errno(err)) != 0)",
                        "\t\tgoto out_unlock;",
                        "",
                        "\tdev_put(dev);",
                        "",
                        "\treturn len;",
                        "",
                        "out_free:",
                        "\tkfree_skb(skb);",
                        "out_unlock:",
                        "\tif (dev)",
                        "\t\tdev_put(dev);",
                        "out:",
                        "\treturn err;",
                        "}"
                    ],
                    "start": 2840,
                    "highlight": 2922
                },
                {
                    "file": "net/packet/af_packet.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/packet/af_packet.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n3004",
                    "code": [
                        "static int packet_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)",
                        "{",
                        "\tstruct sock *sk = sock->sk;",
                        "\tstruct packet_sock *po = pkt_sk(sk);",
                        "",
                        "\tif (po->tx_ring.pg_vec)",
                        "\t\treturn tpacket_snd(po, msg);",
                        "\telse",
                        "\t\treturn packet_snd(sock, msg, len);",
                        "}"
                    ],
                    "start": 2996,
                    "highlight": 3004
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff820a0b08"
        },
        "11326": {
            "name": "+0xa3",
            "parent_idx": 11315,
            "source_line": [
                {
                    "file": "net/core/skbuff.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/skbuff.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n142",
                    "code": [
                        "static void *__kmalloc_reserve(size_t size, gfp_t flags, int node,",
                        "\t\t\t       unsigned long ip, bool *pfmemalloc)",
                        "{",
                        "\tvoid *obj;",
                        "\tbool ret_pfmemalloc = false;",
                        "",
                        "\t/*",
                        "\t * Try a regular allocation, when that fails and we're not entitled",
                        "\t * to the reserves, fail.",
                        "\t */",
                        "\tobj = kmalloc_node_track_caller(size,",
                        "\t\t\t\t\tflags | __GFP_NOMEMALLOC | __GFP_NOWARN,",
                        "\t\t\t\t\tnode);",
                        "\tif (obj || !(gfp_pfmemalloc_allowed(flags)))",
                        "\t\tgoto out;",
                        "",
                        "\t/* Try again but now we are using pfmemalloc reserves */",
                        "\tret_pfmemalloc = true;",
                        "\tobj = kmalloc_node_track_caller(size, flags, node);",
                        "",
                        "out:",
                        "\tif (pfmemalloc)",
                        "\t\t*pfmemalloc = ret_pfmemalloc;",
                        "",
                        "\treturn obj;",
                        "}"
                    ],
                    "start": 132,
                    "highlight": 142
                },
                {
                    "file": "net/core/skbuff.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/skbuff.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n210",
                    "code": [
                        "/**",
                        " *\t__alloc_skb\t-\tallocate a network buffer",
                        " *\t@size: size to allocate",
                        " *\t@gfp_mask: allocation mask",
                        " *\t@flags: If SKB_ALLOC_FCLONE is set, allocate from fclone cache",
                        " *\t\tinstead of head cache and allocate a cloned (child) skb.",
                        " *\t\tIf SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for",
                        " *\t\tallocations in case the data is required for writeback",
                        " *\t@node: numa node to allocate memory on",
                        " *",
                        " *\tAllocate a new &sk_buff. The returned buffer has no headroom and a",
                        " *\ttail room of at least size bytes. The object has a reference count",
                        " *\tof one. The return is the buffer. On a failure the return is %NULL.",
                        " *",
                        " *\tBuffers may only be allocated from interrupts using a @gfp_mask of",
                        " *\t%GFP_ATOMIC.",
                        " */",
                        "struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,",
                        "\t\t\t    int flags, int node)",
                        "{",
                        "\tstruct kmem_cache *cache;",
                        "\tstruct skb_shared_info *shinfo;",
                        "\tstruct sk_buff *skb;",
                        "\tu8 *data;",
                        "\tbool pfmemalloc;",
                        "",
                        "\tcache = (flags & SKB_ALLOC_FCLONE)",
                        "\t\t? skbuff_fclone_cache : skbuff_head_cache;",
                        "",
                        "\tif (sk_memalloc_socks() && (flags & SKB_ALLOC_RX))",
                        "\t\tgfp_mask |= __GFP_MEMALLOC;",
                        "",
                        "\t/* Get the HEAD */",
                        "\tskb = kmem_cache_alloc_node(cache, gfp_mask & ~__GFP_DMA, node);",
                        "\tif (!skb)",
                        "\t\tgoto out;",
                        "\tprefetchw(skb);",
                        "",
                        "\t/* We do our best to align skb_shared_info on a separate cache",
                        "\t * line. It usually works because kmalloc(X > SMP_CACHE_BYTES) gives",
                        "\t * aligned memory blocks, unless SLUB/SLAB debug is enabled.",
                        "\t * Both skb->head and skb_shared_info are cache line aligned.",
                        "\t */",
                        "\tsize = SKB_DATA_ALIGN(size);",
                        "\tsize += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));",
                        "\tdata = kmalloc_reserve(size, gfp_mask, node, &pfmemalloc);",
                        "\tif (!data)",
                        "\t\tgoto nodata;",
                        "\t/* kmalloc(size) might give us more room than requested.",
                        "\t * Put skb_shared_info exactly at the end of allocated zone,",
                        "\t * to allow max possible filling before reallocation.",
                        "\t */",
                        "\tsize = SKB_WITH_OVERHEAD(ksize(data));",
                        "\tprefetchw(data + size);",
                        "",
                        "\t/*",
                        "\t * Only clear those fields we need to clear, not those that we will",
                        "\t * actually initialise below. Hence, don't put any more fields after",
                        "\t * the tail pointer in struct sk_buff!",
                        "\t */",
                        "\tmemset(skb, 0, offsetof(struct sk_buff, tail));",
                        "\t/* Account for allocated memory : skb + skb->head */",
                        "\tskb->truesize = SKB_TRUESIZE(size);",
                        "\tskb->pfmemalloc = pfmemalloc;",
                        "\trefcount_set(&skb->users, 1);",
                        "\tskb->head = data;",
                        "\tskb->data = data;",
                        "\tskb_reset_tail_pointer(skb);",
                        "\tskb->end = skb->tail + size;",
                        "\tskb->mac_header = (typeof(skb->mac_header))~0U;",
                        "\tskb->transport_header = (typeof(skb->transport_header))~0U;",
                        "",
                        "\t/* make sure we initialize shinfo sequentially */",
                        "\tshinfo = skb_shinfo(skb);",
                        "\tmemset(shinfo, 0, offsetof(struct skb_shared_info, dataref));",
                        "\tatomic_set(&shinfo->dataref, 1);",
                        "",
                        "\tif (flags & SKB_ALLOC_FCLONE) {",
                        "\t\tstruct sk_buff_fclones *fclones;",
                        "",
                        "\t\tfclones = container_of(skb, struct sk_buff_fclones, skb1);",
                        "",
                        "\t\tskb->fclone = SKB_FCLONE_ORIG;",
                        "\t\trefcount_set(&fclones->fclone_ref, 1);",
                        "",
                        "\t\tfclones->skb2.fclone = SKB_FCLONE_CLONE;",
                        "\t}",
                        "out:",
                        "\treturn skb;",
                        "nodata:",
                        "\tkmem_cache_free(cache, skb);",
                        "\tskb = NULL;",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 165,
                    "highlight": 210
                }
            ],
            "ins_idx": 906,
            "addr": "0xffffffff81e14b73"
        },
        "11325": {
            "name": "+0x3b",
            "parent_idx": 11324,
            "source_line": [
                {
                    "file": "mm/kasan/common.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/kasan/common.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n52",
                    "code": [
                        "static inline depot_stack_handle_t save_stack(gfp_t flags)",
                        "{",
                        "\tunsigned long entries[KASAN_STACK_DEPTH];",
                        "\tunsigned int nr_entries;",
                        "",
                        "\tnr_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 0);",
                        "\tnr_entries = filter_irq_stacks(entries, nr_entries);",
                        "\treturn stack_depot_save(entries, nr_entries, flags);",
                        "}"
                    ],
                    "start": 44,
                    "highlight": 52
                }
            ],
            "ins_idx": 1313,
            "addr": "0xffffffff8130234b"
        },
        "11324": {
            "name": "__kmalloc_node_track_caller",
            "parent_idx": 11315,
            "source_line": [
                {
                    "file": "net/core/skbuff.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/skbuff.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n142",
                    "code": [
                        "static void *__kmalloc_reserve(size_t size, gfp_t flags, int node,",
                        "\t\t\t       unsigned long ip, bool *pfmemalloc)",
                        "{",
                        "\tvoid *obj;",
                        "\tbool ret_pfmemalloc = false;",
                        "",
                        "\t/*",
                        "\t * Try a regular allocation, when that fails and we're not entitled",
                        "\t * to the reserves, fail.",
                        "\t */",
                        "\tobj = kmalloc_node_track_caller(size,",
                        "\t\t\t\t\tflags | __GFP_NOMEMALLOC | __GFP_NOWARN,",
                        "\t\t\t\t\tnode);",
                        "\tif (obj || !(gfp_pfmemalloc_allowed(flags)))",
                        "\t\tgoto out;",
                        "",
                        "\t/* Try again but now we are using pfmemalloc reserves */",
                        "\tret_pfmemalloc = true;",
                        "\tobj = kmalloc_node_track_caller(size, flags, node);",
                        "",
                        "out:",
                        "\tif (pfmemalloc)",
                        "\t\t*pfmemalloc = ret_pfmemalloc;",
                        "",
                        "\treturn obj;",
                        "}"
                    ],
                    "start": 132,
                    "highlight": 142
                },
                {
                    "file": "net/core/skbuff.c",
                    "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/net/core/skbuff.c?id=50cc09c18985eacbbd666acfd7be2391394733f5#n210",
                    "code": [
                        "/**",
                        " *\t__alloc_skb\t-\tallocate a network buffer",
                        " *\t@size: size to allocate",
                        " *\t@gfp_mask: allocation mask",
                        " *\t@flags: If SKB_ALLOC_FCLONE is set, allocate from fclone cache",
                        " *\t\tinstead of head cache and allocate a cloned (child) skb.",
                        " *\t\tIf SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for",
                        " *\t\tallocations in case the data is required for writeback",
                        " *\t@node: numa node to allocate memory on",
                        " *",
                        " *\tAllocate a new &sk_buff. The returned buffer has no headroom and a",
                        " *\ttail room of at least size bytes. The object has a reference count",
                        " *\tof one. The return is the buffer. On a failure the return is %NULL.",
                        " *",
                        " *\tBuffers may only be allocated from interrupts using a @gfp_mask of",
                        " *\t%GFP_ATOMIC.",
                        " */",
                        "struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,",
                        "\t\t\t    int flags, int node)",
                        "{",
                        "\tstruct kmem_cache *cache;",
                        "\tstruct skb_shared_info *shinfo;",
                        "\tstruct sk_buff *skb;",
                        "\tu8 *data;",
                        "\tbool pfmemalloc;",
                        "",
                        "\tcache = (flags & SKB_ALLOC_FCLONE)",
                        "\t\t? skbuff_fclone_cache : skbuff_head_cache;",
                        "",
                        "\tif (sk_memalloc_socks() && (flags & SKB_ALLOC_RX))",
                        "\t\tgfp_mask |= __GFP_MEMALLOC;",
                        "",
                        "\t/* Get the HEAD */",
                        "\tskb = kmem_cache_alloc_node(cache, gfp_mask & ~__GFP_DMA, node);",
                        "\tif (!skb)",
                        "\t\tgoto out;",
                        "\tprefetchw(skb);",
                        "",
                        "\t/* We do our best to align skb_shared_info on a separate cache",
                        "\t * line. It usually works because kmalloc(X > SMP_CACHE_BYTES) gives",
                        "\t * aligned memory blocks, unless SLUB/SLAB debug is enabled.",
                        "\t * Both skb->head and skb_shared_info are cache line aligned.",
                        "\t */",
                        "\tsize = SKB_DATA_ALIGN(size);",
                        "\tsize += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));",
                        "\tdata = kmalloc_reserve(size, gfp_mask, node, &pfmemalloc);",
                        "\tif (!data)",
                        "\t\tgoto nodata;",
                        "\t/* kmalloc(size) might give us more room than requested.",
                        "\t * Put skb_shared_info exactly at the end of allocated zone,",
                        "\t * to allow max possible filling before reallocation.",
                        "\t */",
                        "\tsize = SKB_WITH_OVERHEAD(ksize(data));",
                        "\tprefetchw(data + size);",
                        "",
                        "\t/*",
                        "\t * Only clear those fields we need to clear, not those that we will",
                        "\t * actually initialise below. Hence, don't put any more fields after",
                        "\t * the tail pointer in struct sk_buff!",
                        "\t */",
                        "\tmemset(skb, 0, offsetof(struct sk_buff, tail));",
                        "\t/* Account for allocated memory : skb + skb->head */",
                        "\tskb->truesize = SKB_TRUESIZE(size);",
                        "\tskb->pfmemalloc = pfmemalloc;",
                        "\trefcount_set(&skb->users, 1);",
                        "\tskb->head = data;",
                        "\tskb->data = data;",
                        "\tskb_reset_tail_pointer(skb);",
                        "\tskb->end = skb->tail + size;",
                        "\tskb->mac_header = (typeof(skb->mac_header))~0U;",
                        "\tskb->transport_header = (typeof(skb->transport_header))~0U;",
                        "",
                        "\t/* make sure we initialize shinfo sequentially */",
                        "\tshinfo = skb_shinfo(skb);",
                        "\tmemset(shinfo, 0, offsetof(struct skb_shared_info, dataref));",
                        "\tatomic_set(&shinfo->dataref, 1);",
                        "",
                        "\tif (flags & SKB_ALLOC_FCLONE) {",
                        "\t\tstruct sk_buff_fclones *fclones;",
                        "",
                        "\t\tfclones = container_of(skb, struct sk_buff_fclones, skb1);",
                        "",
                        "\t\tskb->fclone = SKB_FCLONE_ORIG;",
                        "\t\trefcount_set(&fclones->fclone_ref, 1);",
                        "",
                        "\t\tfclones->skb2.fclone = SKB_FCLONE_CLONE;",
                        "\t}",
                        "out:",
                        "\treturn skb;",
                        "nodata:",
                        "\tkmem_cache_free(cache, skb);",
                        "\tskb = NULL;",
                        "\tgoto out;",
                        "}"
                    ],
                    "start": 165,
                    "highlight": 210
                }
            ],
            "ins_idx": 0,
            "addr": "0xffffffff81e14b6b"
        }
    },
    "ins": {
        "138": {
            "name": "movzx ebx, byte ptr [r12 + 0xc]",
            "desc": "Invalid Memory Access\nOut of Bound Access.",
            "call_idx": 13005,
            "inputs": [
                22917,
                22918
            ],
            "outputs": [
                22919
            ]
        },
        "280": {
            "name": "add r12, rax",
            "desc": "",
            "call_idx": 13004,
            "inputs": [
                22914,
                22915
            ],
            "outputs": [
                22916
            ]
        },
        "422": {
            "name": "mov r12, qword ptr [rbx + 0xc0]",
            "desc": "",
            "call_idx": 13002,
            "inputs": [
                22908,
                22909
            ],
            "outputs": [
                22910
            ]
        },
        "631": {
            "name": "mov qword ptr [r12 + 0xc0], rbx",
            "desc": "",
            "call_idx": 11371,
            "inputs": [
                19162,
                19163
            ],
            "outputs": [
                19164
            ]
        },
        "906": {
            "name": "mov rbx, rax",
            "desc": "",
            "call_idx": 11326,
            "inputs": [
                19069
            ],
            "outputs": [
                19070
            ]
        },
        "1313": {
            "name": "ret ",
            "desc": "",
            "call_idx": 11325,
            "inputs": [],
            "outputs": [
                19068
            ]
        }
    },
    "data": {
        "22917": {
            "name": "R12",
            "ins_idx": 138,
            "value": "0xffff8881e2f18a50",
            "sources": []
        },
        "22918": {
            "name": "[0xffff8881e2f18a5c]",
            "ins_idx": 138,
            "value": "0x0",
            "sources": []
        },
        "22919": {
            "name": "RBX",
            "ins_idx": 138,
            "value": "0x0",
            "sources": []
        },
        "22914": {
            "name": "R12",
            "ins_idx": 280,
            "value": "0xffff8881e2f18800",
            "sources": []
        },
        "22915": {
            "name": "RAX",
            "ins_idx": 280,
            "value": "0x250",
            "sources": []
        },
        "22916": {
            "name": "R12",
            "ins_idx": 280,
            "value": "0xffff8881e2f18a50",
            "sources": [
                22917
            ]
        },
        "22908": {
            "name": "RBX",
            "ins_idx": 422,
            "value": "0xffff8881e3584180",
            "sources": []
        },
        "22909": {
            "name": "[0xffff8881e3584240]",
            "ins_idx": 422,
            "value": "0xffff8881e2f18800",
            "sources": []
        },
        "22910": {
            "name": "R12",
            "ins_idx": 422,
            "value": "0xffff8881e2f18800",
            "sources": [
                22914
            ]
        },
        "19162": {
            "name": "R12",
            "ins_idx": 631,
            "value": "0xffff8881e3584180",
            "sources": []
        },
        "19163": {
            "name": "RBX",
            "ins_idx": 631,
            "value": "0xffff8881e2f18800",
            "sources": []
        },
        "19164": {
            "name": "[0xffff8881e3584240]",
            "ins_idx": 631,
            "value": "0xffff8881e2f18800",
            "sources": [
                22909
            ]
        },
        "19069": {
            "name": "RAX",
            "ins_idx": 906,
            "value": "0xffff8881e2f18800",
            "sources": []
        },
        "19070": {
            "name": "RBX",
            "ins_idx": 906,
            "value": "0xffff8881e2f18800",
            "sources": [
                19163
            ]
        },
        "19068": {
            "name": "RAX",
            "ins_idx": 1313,
            "value": "0xffff8881e2f18800",
            "sources": [
                19069
            ]
        }
    },
    "chain": {
        "138": [
            280
        ],
        "280": [
            422
        ],
        "422": [
            631
        ],
        "631": [
            906
        ],
        "906": [
            1313
        ]
    }
}